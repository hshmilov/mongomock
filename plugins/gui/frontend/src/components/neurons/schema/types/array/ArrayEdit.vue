<template>
  <div class="x-array-edit">
    <template v-if="!isStringList">
      <h4
        v-if="schema.title"
        :id="schema.name"
        :title="schema.description || ''"
        class="array-header"
      >{{ schema.title }}</h4>
      <div
        v-for="(item, index) in shownSchemaItems"
        :key="item.name"
        class="item"
      >
        <x-type-wrap
          :name="item.name"
          :type="item.type"
          :title="item.title"
          :description="item.description"
          :required="item.required"
          :expand="!isFileList"
        >
          <component
            :is="item.type"
            ref="itemChild"
            :value="data[item.name]"
            :schema="item"
            :api-upload="apiUpload"
            :read-only="readOnly"
            @input="(value) => dataChanged(value, item.name)"
            @validate="onValidate"
            @remove-validate="onRemoveValidate"
          />
        </x-type-wrap>
        <x-button
          v-if="!isOrderedObject"
          link
          @click.prevent="removeItem(index)"
        >x</x-button>
      </div>
      <x-button
        v-if="!isOrderedObject"
        light
        @click.prevent="addNewItem"
      >+</x-button>
    </template>
    <template v-else-if="isStringList && schema.items.enum">
      <label>{{ schema.title }}</label>
      <v-combobox
        v-model="data"
        :items="schema.items.enum"
        :return-object="false"
        :menu-props="{
          closeOnClick: true
        }"
        :placeholder="placeholder"
        item-text="title"
        item-value="name"
        multiple
        dense
        clearable
      >
        <template #selection="{ item }">
          <v-chip small>{{ getItemTitle(item) }}</v-chip>
        </template>
      </v-combobox>
    </template>
    <template v-else>
      <label>{{ schema.title }}</label>
      <x-list-input
        v-model="data"
        :id="schema.name"
        :format="formatStringItem"
        :error-items="invalidStringItems"
        :class="{'error-border': !stringListValid}"
        @focusout.native="() => validateStringList()"
        :readOnly="readOnly"
      />
    </template>
  </div>
</template>

<script>
  import xTypeWrap from './TypeWrap.vue'
  import string from '../string/StringEdit.vue'
  import number from '../numerical/NumberEdit.vue'
  import integer from '../numerical/IntegerEdit.vue'
  import bool from '../boolean/BooleanEdit.vue'
  import file from './FileEdit.vue'
  import range from '../string/RangeEdit.vue'
  import xButton from '../../../../axons/inputs/Button.vue'
  import xListInput from '../../../../axons/inputs/ListInput.vue'
  import { validateEmail } from '../../../../../constants/validations'
  import XVaultEdit from '../string/VaultEdit.vue'

  import arrayMixin from '../../../../../mixins/array'

  export default {
    name: 'Array',
    components: {
      xTypeWrap, string, number, integer, bool, file, range, xButton, xListInput, XVaultEdit
    },
    mixins: [arrayMixin],
    props: {
      readOnly: {
        type: Boolean,
        default: false
      },
      placeholder: {
        type: String,
        default: 'Select...'
      },
      useVault: {
        type: Boolean,
        default: false
      },
    },
    data () {
      return {
        needsValidation: false,
        stringListValid: true
      }
    },
    computed: {
      isStringList () {
        if (this.isOrderedObject) return false
        return this.schema.items.type === 'string'
      },
      isFileList () {
        if (this.isOrderedObject) return false
        return this.schema.items.type === 'file'
      },
      invalidStringItems() {
        if (!this.isStringList) return []
        return this.data.filter(item => {
          if (this.schema.items.format === 'email') {
            return !validateEmail(item)
          }
          return false
        })
      },
      stringListError() {
        if (this.invalidStringItems.length) {
          return `'${this.schema.title}' items are not all properly formed`
        } else if (this.data.length === 0 && this.schema.required) {
          return `'${this.schema.title}' is required`
        }
        return ''
      }
    },
    watch: {
      isHidden () {
        /*
            Change of hidden, means some fields may appear or disappear.
            Therefore, the new children should be re-validated but the DOM has not updated yet
         */
        this.needsValidation = true
      },
      stringListError () {
        this.validateStringList()
      }
    },
    mounted () {
      this.validate(true)
      // When loaded, update data with default values, as defined
      let updateData = false
      this.schemaItems.forEach(item => {
        if (item.type === 'array') {
          // An array, no need to handle recursively
          return
        }
        if (this.data[item.name] !== undefined && this.data[item.name] !== null && !this.schema.useVault) {
          // Value exists, no need to process
          return
        }
        if (item.type === 'bool') {
          this.data[item.name] = false
          updateData = true
        }
        if (item.format && item.format === "password" && this.schema.useVault){
          item.type = 'XVaultEdit'
        }
        if (!item.default) {
          // Nothing defined to set
          return
        }

        this.data[item.name] = item.default
        updateData = true
      })
      if (updateData) {
        this.data = { ...this.data }
      }
    },
    updated () {
      if (this.needsValidation) {
        // Here the new children (after change of hidden) are updated in the DOM
        this.validate(true, true)
        this.needsValidation = false
      }
    },
    methods: {
      dataChanged(value, itemName) {
        if (Array.isArray(this.data) && typeof itemName === 'number') {
          this.data = this.data.map((item, index) => index === itemName? value : item)
        } else {
          this.data = {...this.data, [itemName]: value}
        }
      },
      onValidate (validity) {
        this.$emit('validate', validity)
      },
      onRemoveValidate (validity) {
        this.$emit('remove-validate', validity);
      },
      validate (silent, checkHiddenFields=false) {
        // If the user reverted his choice and decided not to fill a certain group of options,
        // We go through each of the children fields and make sure to invalidate them.
        // In other words, once the option sub fields is invisible again, we have to make them valid
        // since they are no longer relevant for validation.
        if(checkHiddenFields
           && this.schema.items[0].name === 'enabled'
           && this.data[this.schema.items[0].name] === false
           && this.schema.items.length > 1) {
          this.$emit('remove-validate', this.schema.items.slice(1).map((item) => {
            return ({ name: item.name });
          }));
          return;
        }

        if (this.isStringList) {
          this.validateStringList(silent)
        } else if (this.$refs.itemChild) {
          this.$refs.itemChild.forEach(item => item.validate(silent))
        }
      },
      addNewItem () {
        if (!this.schema.items.items) {
          this.data = [...this.data, null]
        } else {
          this.data = [...this.data,
            this.schema.items.items.reduce((map, field) => {
              map[field.name] = field.default || null
              return map
            }, {})
          ]
        }
      },
      removeItem (index) {
        this.data.splice(index, 1)
      },
      formatStringItem(item) {
        if (this.schema.items.format === 'email') {
          let emailMatch = item.match(new RegExp('.*?\s?<(\.*?)>'))
          if (emailMatch && emailMatch.length > 1) {
            return emailMatch[1]
          }
        }
        return item
      },
      validateStringList(silent) {
        let valid = this.stringListError === ''
        this.stringListValid = valid || silent
        this.$emit('validate', {
          name: this.schema.name,
          valid,
          error: this.stringListValid? '': this.stringListError
        })
      },
      getItemTitle (name) {
        const item = this.schema.items.enum.find(item => item.name === name)
        return item ? item.title : ''
      }
    }
  }
</script>

<style lang="scss">
  .x-array-edit {
    .array-header {
      margin-bottom: 0;
      display: inline-block;
      min-width: 200px;
    }

    .item {
      display: flex;
      align-items: flex-end;

      .index {
        display: inline-block;
        vertical-align: top;
      }

      .x-button {
        &.link {
          text-align: right;
        }
        &.light {
          margin-top: 8px;
          display: block;
        }
      }
    }

    .object {

      input, select, textarea {
        width: 100%;
      }

      .upload-file {
        margin-top: 8px;
      }
    }

    .v-select.v-autocomplete {
      input {
        border-style: none;
      }
    }
  }
</style>