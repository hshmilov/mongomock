// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bandicoot/internal"
	"fmt"
	"io"
	"net"
	"strconv"
	"time"

	"github.com/satori/go.uuid"
)

type AdapterData interface {
	IsAdapterData()
}

type Aggregate interface {
	IsAggregate()
}

type Filter interface {
	IsFilter()
}

// Enum filter expression for AccessType
type AccessTypeComparator struct {
	// eq comparison operator
	Eq *AccessType ` json:"eq"`
	// neq comparison operator
	Neq *AccessType ` json:"neq"`
	// in comparison operator
	In []*AccessType ` json:"in"`
	// not_in comparison operator
	NotIn []*AccessType ` json:"not_in"`
}

type ActiveDirectoryData struct {
	// AD Common Name (CN)
	AdCn *string ` json:"ad_cn"`
	// AD objectSid
	AdSid *string ` json:"ad_sid"`
	// AD objectGUID
	AdGUID *string ` json:"ad_guid"`
	// AD name
	AdName *string ` json:"ad_name"`
	// AD SAMAccountName
	AdSAMAccountName *string ` json:"ad_sam_account_name"`
	// AD User Principal Name
	AdUserPrincipalName *string ` json:"ad_user_principal_name"`
	// AD displayName
	AdDisplayName *string ` json:"ad_display_name"`
	// AD distinguishedName
	AdDistinguishedName *string ` json:"ad_distinguished_name"`
	// AD canonicalName
	AdCanonicalName *string ` json:"ad_canonical_name"`
	// AD accountExpires
	AdAccountExpires *internal.Epoch ` json:"ad_account_expires"`
	// AD objectClass
	AdObjectClass []*string ` json:"ad_object_class"`
	// AD objectCategory
	AdObjectCategory *string ` json:"ad_object_category"`
	// AD Organizational Unit
	AdOrganizationalUnit []*string ` json:"ad_organizational_unit"`
	// AD lastLogoff
	AdLastLogoff *time.Time ` json:"ad_last_logoff"`
	// AD lastLogon
	AdLastLogon *time.Time ` json:"ad_last_logon"`
	// AD lastLogonTimestamp
	AdLastLogonTimestamp *time.Time ` json:"ad_last_logon_timestamp"`
	// AD badPasswordTime
	AdBadPasswordTime *time.Time ` json:"ad_bad_password_time"`
	// AD badPwdCount
	AdBadPwdCount *int ` json:"ad_bad_pwd_count"`
	// AD managedBy
	AdManagedBy *string ` json:"ad_managed_by"`
	// AD pwdLastSet
	AdPasswordLastSet *time.Time ` json:"ad_password_last_set"`
	// AD Primary group ID
	AdPrimaryGroupID *int ` json:"ad_primary_group_id"`
	// AD Primary group ID
	AdPrimaryGroupDn *string ` json:"ad_primary_group_dn"`
	// AD memberOf
	AdMemberOf []*string ` json:"ad_member_of"`
	// AD memberOf (nested full list)
	AdMemberOfFull []*string ` json:"ad_member_of_full"`
	// AD uSNChanged
	AdUsnChanged *int ` json:"ad_usn_changed"`
	// AD uSNCreated
	AdUsnCreated *int ` json:"ad_usn_created"`
	// AD whenChanged
	AdWhenChanged *time.Time ` json:"ad_when_changed"`
	// AD whenCreated
	AdWhenCreated *time.Time ` json:"ad_when_created"`
	// AD isCriticalSystemObject
	AdIsCriticalSystemObject *bool ` json:"ad_is_critical_system_object"`
	// AD msDS-AllowedToDelegateTo
	AdMsdsAllowedToDelegateTo []*string ` json:"ad_msds_allowed_to_delegate_to"`
	// AD Password Must Change
	AdPwdMustChange *bool ` json:"ad_pwd_must_change"`
	// AD Resultant Password Settings Object
	AdMsdsResultantPso *string ` json:"ad_msds_resultant_pso"`
}

func (ActiveDirectoryData) IsAdapterData() {}

type Adapter struct {
	ID         string    ` json:"id"`
	Name       *string   ` json:"name"`
	Properties []*string ` json:"properties"`
}

// Adapter device is a single enitity returned from that adapter
type AdapterDevice struct {
	// Unique id of adapter device
	ID uuid.UUID ` json:"id"`
	// Cycle adapter device was fetched
	FetchCycle int ` json:"fetch_cycle"`
	// Idadas of adapter that fetched this device
	AdapterID string   ` json:"adapter_id"`
	Adapter   *Adapter ` json:"adapter"`
	// Name of adapter that fetched this advice
	AdapterName *string ` json:"adapter_name"`
	// Correlated device id
	DeviceID uuid.UUID ` json:"device_id"`
	// Unique data returned by adapter on this device
	AdapterData AdapterData ` json:"adapter_data"`
	// Data returned by this adapter as a json mappping
	Data map[string]interface{} ` json:"data"`
	// Time adapter was requested to fetch device by axonius
	FetchTime *internal.Epoch ` json:"fetch_time"`
	// hostname of device
	Hostname *string ` json:"hostname"`
	// name given to device by the adapter
	Name *string ` json:"name"`
	// Last time device was seen by adapter in Unix time
	LastSeen *internal.Epoch ` json:"last_seen"`
	OsID     uuid.UUID       ` json:"os_id"`
	// Operating system adapter device is running on
	Os *OperatingSystem ` json:"os"`
	// Pertty id given to adapter device when axonius created it
	PrettyID   *string            ` json:"pretty_id"`
	Tags       []*Tag             ` json:"tags"`
	Interfaces []NetworkInterface ` json:"interfaces"`
	// List of uses who last used the device
	LastUsedUsers []*string ` json:"last_used_users"`
	// Name of domain this adapter device belongs too
	Domain *string ` json:"domain"`
	// Whether this adapter device is part of the domain
	PartOfDomain *bool ` json:"part_of_domain"`
	// Users known by this device
	DeviceUsers []*AdapterDeviceUser ` json:"device_users"`
	// local admins known by this device
	LocalAdmins []*AdapterDeviceAdmin ` json:"local_admins"`
	// Firewall rules defined on this adapter device
	FirewallRules []*FirewallRule ` json:"firewall_rules"`
	// Software installed on this device
	InstalledSoftware []*InstalledSoftware ` json:"installed_software"`
	AgentVersion      *string              ` json:"agent_version"`
	AgentStatus       *string              ` json:"agent_status"`
	AgentName         *string              ` json:"agent_name"`
	Model             *string              ` json:"model"`
	Manufacturer      *string              ` json:"manufacturer"`
	Serial            *string              ` json:"serial"`
	Family            *string              ` json:"family"`
	BiosVersion       *string              ` json:"bios_version"`
	BiosSerial        *string              ` json:"bios_serial"`
	// Returns aggregate of tags
	TagsAggregate []TagsAggregate ` json:"tags_aggregate"`
	// Returns aggregate of interfaces
	InterfacesAggregate []InterfacesAggregate ` json:"interfaces_aggregate"`
	// Returns aggregate of firewallRules
	FirewallRulesAggregate []FirewallRulesAggregate ` json:"firewall_rules_aggregate"`
	// Returns aggregate of installedSoftware
	InstalledSoftwareAggregate []InstalledSoftwareAggregate ` json:"installed_software_aggregate"`
}

type AdapterDeviceAdmin struct {
	Name *string    ` json:"name"`
	Type *AdminType ` json:"type"`
}

// User known by an adapter device
type AdapterDeviceUser struct {
	DeviceID       *uuid.UUID      ` json:"device_id"`
	Sid            *string         ` json:"sid"`
	Username       *string         ` json:"username"`
	LastUseDate    *internal.Epoch ` json:"last_use_date"`
	IsLocal        *bool           ` json:"is_local"`
	IsDisabled     *bool           ` json:"is_disabled"`
	IsAdmin        *bool           ` json:"is_admin"`
	UserDepartment *bool           ` json:"user_department"`
	PasswordMaxAge *int            ` json:"password_max_age"`
	Interpreter    *string         ` json:"interpreter"`
}

type AdapterUser struct {
	// Unique id of adapter device
	ID uuid.UUID ` json:"id"`
	// Cycle adapter device was fetched
	FetchCycle int ` json:"fetch_cycle"`
	// Id of adapter that fetched this device
	AdapterID string   ` json:"adapter_id"`
	Adapter   *Adapter ` json:"adapter"`
	// Name of adapter that fetched this advice
	AdapterName *string ` json:"adapter_name"`
	// Correlated device id
	UserID uuid.UUID ` json:"user_id"`
	// Unique data returned by adapter on this device
	AdapterData AdapterData ` json:"adapter_data"`
	// Data returned by this adapter as a json mappping
	Data map[string]interface{} ` json:"data"`
	// Time adapter was requested to fetch device by axonius
	FetchTime *internal.Epoch ` json:"fetch_time"`
	// Last time device was seen by adapter in Unix time
	LastSeen *internal.Epoch ` json:"last_seen"`
	// Username
	Username    *string ` json:"username"`
	DisplayName *string ` json:"display_name"`
	Description *string ` json:"description"`
	Domain      *string ` json:"domain"`
	UserSid     *string ` json:"user_sid"`
	// User first name
	FirstName *string ` json:"first_name"`
	// User last name
	LastName *string ` json:"last_name"`
	// User email account
	Mail *string ` json:"mail"`
	// User account has admin privileges
	Admin *bool ` json:"admin"`
	// User entity is local
	Local *bool ` json:"local"`
	// User account is a delegated admin
	DelegatedAdmin *bool ` json:"delegated_admin"`
	// User account has multi-factor authentication enforced
	MfaEnforced *bool ` json:"mfa_enforced"`
	// User account is enrollled in multi-factor authenticaton
	MfaEnrolled *bool ` json:"mfa_enrolled"`
	// User account is suspended
	Suspended *bool ` json:"suspended"`
	// User account has been locked
	Locked *bool ` json:"locked"`
	// User account has been disabled
	Disabled *bool ` json:"disabled"`
}

// Enum filter expression for AdminType
type AdminTypeComparator struct {
	// eq comparison operator
	Eq *AdminType ` json:"eq"`
	// neq comparison operator
	Neq *AdminType ` json:"neq"`
	// in comparison operator
	In []*AdminType ` json:"in"`
	// not_in comparison operator
	NotIn []*AdminType ` json:"not_in"`
}

// Enum filter expression for Architecture
type ArchitectureComparator struct {
	// eq comparison operator
	Eq *Architecture ` json:"eq"`
	// neq comparison operator
	Neq *Architecture ` json:"neq"`
	// in comparison operator
	In []*Architecture ` json:"in"`
	// not_in comparison operator
	NotIn []*Architecture ` json:"not_in"`
}

type BooleanComparator struct {
	Exists *bool ` json:"exists"`
	Eq     *bool ` json:"eq"`
	Neq    *bool ` json:"neq"`
}

type CPU struct {
	ID          int     ` json:"id"`
	Name        string  ` json:"name"`
	Manfacturer *string ` json:"manfacturer"`
	Bitness     *int    ` json:"bitness"`
	Family      *string ` json:"family"`
	// Core count of CPU
	Cores        *int     ` json:"cores"`
	CoresThreads *int     ` json:"cores_threads"`
	Ghz          *float64 ` json:"ghz"`
}

type CrowdStrikeData struct {
	ExternalIP         *string    ` json:"external_ip"`
	Groups             []*CsGroup ` json:"groups"`
	PreventionPolicy   *CsPolicy  ` json:"prevention_policy"`
	SensorUpdatePolicy *CsGroup   ` json:"sensor_update_policy"`
	CsAgentVersion     *string    ` json:"cs_agent_version"`
	// Returns aggregate of groups
	GroupsAggregate []GroupsAggregate ` json:"groups_aggregate"`
}

func (CrowdStrikeData) IsAdapterData() {}

type CylanceData struct {
	IsSafe          *string             ` json:"is_safe"`
	DeviceState     *CylanceDeviceState ` json:"device_state"`
	PolicyID        *string             ` json:"policy_id"`
	PolicyName      *string             ` json:"policy_name"`
	PoliciesDetails []*string           ` json:"policies_details"`
	TenantTag       *string             ` json:"tenant_tag"`
	ZoneNames       []*string           ` json:"zone_names"`
	AgentVersion    *string             ` json:"agent_version"`
}

func (CylanceData) IsAdapterData() {}

// Enum filter expression for CylanceDeviceState
type CylanceDeviceStateComparator struct {
	// eq comparison operator
	Eq *CylanceDeviceState ` json:"eq"`
	// neq comparison operator
	Neq *CylanceDeviceState ` json:"neq"`
	// in comparison operator
	In []*CylanceDeviceState ` json:"in"`
	// not_in comparison operator
	NotIn []*CylanceDeviceState ` json:"not_in"`
}

// Device aggregates one or more adapter device that were correlated
type Device struct {
	// Unique ID of correlated device
	ID uuid.UUID ` json:"id"`
	// Fetch cycle this device was collected
	FetchCycle int ` json:"fetch_cycle"`
	// Count of adapters that are correlated to this device
	AdapterCount int ` json:"adapter_count"`
	// Names of adapters that are correlated to this device
	AdapterNames []string ` json:"adapter_names"`
	// Unique hostnames given to device by all adapters
	Hostnames []string ` json:"hostnames"`
	// Last time device was seen by one of the adapters
	LastSeen *internal.Epoch ` json:"last_seen"`
	// Adapter devices that are correlated to this device
	AdapterDevices []AdapterDevice ` json:"adapter_devices"`
	// Unique set of network interfaces collected by all adapter devices
	Interfaces []NetworkInterface ` json:"interfaces"`
	// Unique set tags given to all adapter devices
	Tags []Tag ` json:"tags"`
	// Allows transformation of queried data to API v1
	CompatabilityAPI map[string]interface{} ` json:"compatability_api"`
	// Returns aggregate of adapterDevices
	AdapterDevicesAggregate []AdapterDevicesAggregate ` json:"adapter_devices_aggregate"`
	// Returns aggregate of interfaces
	InterfacesAggregate []InterfacesAggregate ` json:"interfaces_aggregate"`
	// Returns aggregate of tags
	TagsAggregate []TagsAggregate ` json:"tags_aggregate"`
}

// Enum filter expression for Direction
type DirectionComparator struct {
	// eq comparison operator
	Eq *Direction ` json:"eq"`
	// neq comparison operator
	Neq *Direction ` json:"neq"`
	// in comparison operator
	In []*Direction ` json:"in"`
	// not_in comparison operator
	NotIn []*Direction ` json:"not_in"`
}

type EpochArrayComparator struct {
	Exists *bool             ` json:"exists"`
	Eq     []*internal.Epoch ` json:"eq"`
	Neq    []*internal.Epoch ` json:"neq"`
}

type EpochComparator struct {
	Exists *bool           ` json:"exists"`
	Eq     *internal.Epoch ` json:"eq"`
	Neq    *internal.Epoch ` json:"neq"`
	Lte    *internal.Epoch ` json:"lte"`
	Lt     *internal.Epoch ` json:"lt"`
	Gte    *internal.Epoch ` json:"gte"`
	Gt     *internal.Epoch ` json:"gt"`
	Days   *int            ` json:"days"`
}

type FirewallRule struct {
	Name      *string     ` json:"name"`
	Source    *string     ` json:"source"`
	Type      *AccessType ` json:"type"`
	Direction *Direction  ` json:"direction"`
	Target    *string     ` json:"target"`
	Protocol  *string     ` json:"protocol"`
	SrcPort   *int        ` json:"src_port"`
	DstPort   *int        ` json:"dst_port"`
}

type FloatArrayComparator struct {
	Exists      *bool      ` json:"exists"`
	Eq          []*float64 ` json:"eq"`
	Neq         []*float64 ` json:"neq"`
	Contains    []*float64 ` json:"contains"`
	ContainedBy []*float64 ` json:"contained_by"`
	Overlap     []*float64 ` json:"overlap"`
	Size        *int       ` json:"size"`
}

type FloatComparator struct {
	Exists *bool    ` json:"exists"`
	Eq     *float64 ` json:"eq"`
	Neq    *float64 ` json:"neq"`
	Lte    *float64 ` json:"lte"`
	Lt     *float64 ` json:"lt"`
	Gte    *float64 ` json:"gte"`
	Gt     *float64 ` json:"gt"`
}

type GCETagsAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	GCETags  []*GceTags             ` json:"gce_tags"`
}

type GceTags struct {
	GceKey   *string ` json:"gce_key"`
	GceValue *string ` json:"gce_value"`
}

type GoogleCloudData struct {
	ID      *string    ` json:"id"`
	Size    *string    ` json:"size"`
	Image   *string    ` json:"image"`
	GCETags []*GceTags ` json:"gce_tags"`
	// Returns aggregate of GCETags
	GCETagsAggregate []GCETagsAggregate ` json:"gce_tags_aggregate"`
}

type IPArrayComparator struct {
	Exists      *bool      ` json:"exists"`
	Eq          []*net.IP  ` json:"eq"`
	Neq         []*net.IP  ` json:"neq"`
	Contains    []*net.IP  ` json:"contains"`
	ContainedBy []*net.IP  ` json:"contained_by"`
	Overlap     []*net.IP  ` json:"overlap"`
	Size        *int       ` json:"size"`
	InSubnet    *net.IPNet ` json:"in_subnet"`
	IPFamily    *IPFamily  ` json:"ip_family"`
}

type IPComparator struct {
	Exists *bool   ` json:"exists"`
	Eq     *net.IP ` json:"eq"`
	Neq    *net.IP ` json:"neq"`
}

type InstalledSoftware struct {
	// Software Name
	Name *string ` json:"name"`
	// Software Version
	Version      *string       ` json:"version"`
	Architecture *Architecture ` json:"architecture"`
	Description  *string       ` json:"description"`
	// Software Vendor
	Vendor    *string ` json:"vendor"`
	Publisher *string ` json:"publisher"`
	CveCount  *int    ` json:"cve_count"`
	SwLicense *string ` json:"sw_license"`
	Path      *string ` json:"path"`
}

type IntArrayComparator struct {
	Exists      *bool  ` json:"exists"`
	Eq          []*int ` json:"eq"`
	Neq         []*int ` json:"neq"`
	Contains    []*int ` json:"contains"`
	ContainedBy []*int ` json:"contained_by"`
	Overlap     []*int ` json:"overlap"`
	Size        *int   ` json:"size"`
}

type IntComparator struct {
	Exists *bool  ` json:"exists"`
	Eq     *int   ` json:"eq"`
	Neq    *int   ` json:"neq"`
	Lte    *int   ` json:"lte"`
	Lt     *int   ` json:"lt"`
	Gte    *int   ` json:"gte"`
	Gt     *int   ` json:"gt"`
	In     []*int ` json:"in"`
	NotIn  []*int ` json:"not_in"`
}

type MacArrayComparator struct {
	Exists      *bool     ` json:"exists"`
	Eq          []*string ` json:"eq"`
	Neq         []*string ` json:"neq"`
	Contains    []*string ` json:"contains"`
	ContainedBy []*string ` json:"contained_by"`
	Overlap     []*string ` json:"overlap"`
	Size        *string   ` json:"size"`
}

type MacComparator struct {
	Exists *bool   ` json:"exists"`
	Eq     *string ` json:"eq"`
	Neq    *string ` json:"neq"`
}

// Network interface is a system's interface between two pieces of equipment or protocol layers in a computer network.
type NetworkInterface struct {
	DeviceID *uuid.UUID ` json:"device_id"`
	MacAddr  *string    ` json:"mac_addr"`
	IPAddrs  []net.IP   ` json:"ip_addrs"`
}

type ObjectFilter struct {
	Name        string   ` json:"name"`
	DisplayName string   ` json:"display_name"`
	Type        string   ` json:"type"`
	Description *string  ` json:"description"`
	Filters     []Filter ` json:"filters"`
}

func (ObjectFilter) IsFilter() {}

// Operating System is the system installed on an adapter device
type OperatingSystem struct {
	ID            uuid.UUID       ` json:"id"`
	Type          *string         ` json:"type"`
	Distribution  *string         ` json:"distribution"`
	Architecture  *int            ` json:"architecture"`
	ServicePack   *string         ` json:"service_pack"`
	InstallDate   *internal.Epoch ` json:"install_date"`
	KernelVersion *string         ` json:"kernel_version"`
	CodeName      *string         ` json:"code_name"`
	Major         *int            ` json:"major"`
	Minor         *int            ` json:"minor"`
	Build         *string         ` json:"build"`
	RawName       *string         ` json:"raw_name"`
}

type Operator struct {
	Name          string  ` json:"name"`
	Type          string  ` json:"type"`
	DisplayName   string  ` json:"display_name"`
	Description   *string ` json:"description"`
	FormatDisplay *string ` json:"format_display"`
}

func (Operator) IsFilter() {}

type ScalarFilter struct {
	Name        string      ` json:"name"`
	DisplayName string      ` json:"display_name"`
	Description *string     ` json:"description"`
	Type        string      ` json:"type"`
	Operators   []*Operator ` json:"operators"`
}

func (ScalarFilter) IsFilter() {}

type Storage struct {
	DeviceID uuid.UUID ` json:"device_id"`
	// Path
	Path string ` json:"path"`
	// Device Name
	Name string ` json:"name"`
	// Size (GB)
	TotalSize float64 ` json:"total_size"`
	// Size (GB)
	FreeSize float64 ` json:"free_size"`
	// Whether drive is encrypted or not
	IsEncrypted bool ` json:"is_encrypted"`
	// Descirption of device
	Description *string ` json:"description"`
}

type StringArrayComparator struct {
	Exists        *bool     ` json:"exists"`
	Eq            []*string ` json:"eq"`
	Neq           []*string ` json:"neq"`
	Contains      []*string ` json:"contains"`
	ContainedBy   []*string ` json:"contained_by"`
	Overlap       []*string ` json:"overlap"`
	NoOverlap     []*string ` json:"no_overlap"`
	Size          *int      ` json:"size"`
	ContainsRegex *string   ` json:"contains_regex"`
}

type StringComparator struct {
	Exists   *bool     ` json:"exists"`
	Eq       *string   ` json:"eq"`
	Neq      *string   ` json:"neq"`
	In       []*string ` json:"in"`
	NotIn    []*string ` json:"not_in"`
	Like     *string   ` json:"like"`
	Ilike    *string   ` json:"ilike"`
	NotLike  *string   ` json:"not_like"`
	NotIlike *string   ` json:"not_ilike"`
	Suffix   *string   ` json:"suffix"`
	Prefix   *string   ` json:"prefix"`
}

type Tag struct {
	Name    string ` json:"name"`
	Creator string ` json:"creator"`
	Level   string ` json:"level"`
}

type UUIDArrayComparator struct {
	Exists      *bool        ` json:"exists"`
	Eq          []*uuid.UUID ` json:"eq"`
	Neq         []*uuid.UUID ` json:"neq"`
	Contains    []*uuid.UUID ` json:"contains"`
	ContainedBy []*uuid.UUID ` json:"contained_by"`
	Overlap     []*uuid.UUID ` json:"overlap"`
	Size        *int         ` json:"size"`
}

type UUIDComparator struct {
	Exists *bool        ` json:"exists"`
	Eq     *uuid.UUID   ` json:"eq"`
	Neq    *uuid.UUID   ` json:"neq"`
	In     []*uuid.UUID ` json:"in"`
	NotIn  []*uuid.UUID ` json:"not_in"`
}

type UnionFilter struct {
	Name        string          ` json:"name"`
	DisplayName string          ` json:"display_name"`
	Type        string          ` json:"type"`
	Description *string         ` json:"description"`
	Objects     []*ObjectFilter ` json:"objects"`
}

func (UnionFilter) IsFilter() {}

type User struct {
	ID               uuid.UUID              ` json:"id"`
	FetchCycle       int                    ` json:"fetch_cycle"`
	AdapterCount     int                    ` json:"adapter_count"`
	AdapterNames     []string               ` json:"adapter_names"`
	Usernames        []string               ` json:"usernames"`
	LastSeen         *internal.Epoch        ` json:"last_seen"`
	AdapterUsers     []AdapterUser          ` json:"adapter_users"`
	CompatabilityAPI map[string]interface{} ` json:"compatability_api"`
	// Returns aggregate of adapterUsers
	AdapterUsersAggregate []AdapterUsersAggregate ` json:"adapter_users_aggregate"`
}

type AdapterDevicesAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	// Adapter devices that are correlated to this device
	AdapterDevices []*AdapterDevice ` json:"adapter_devices"`
}

type AdapterUsersAggregate struct {
	Group        []string               ` json:"group"`
	Distinct     []string               ` json:"distinct"`
	Count        *int                   ` json:"count"`
	Sum          map[string]interface{} ` json:"sum"`
	Avg          map[string]interface{} ` json:"avg"`
	Min          map[string]interface{} ` json:"min"`
	Max          map[string]interface{} ` json:"max"`
	AdapterUsers []*AdapterUser         ` json:"adapter_users"`
}

// Boolean filter expression for Adapter
type AdapterBoolExp struct {
	// filter by id
	ID *StringComparator ` json:"id"`
	// filter by name
	Name *StringComparator ` json:"name"`
	// filter by properties
	Properties *StringArrayComparator ` json:"properties"`
	And        []AdapterBoolExp       ` json:"and"`
	Or         []AdapterBoolExp       ` json:"or"`
	Not        []AdapterBoolExp       ` json:"not"`
}

// Boolean filter expression for AdapterData
type AdapterDataBoolExp struct {
	// filter by adCn
	AdCn *StringComparator ` json:"ad_cn"`
	// filter by adSid
	AdSid *StringComparator ` json:"ad_sid"`
	// filter by adGuid
	AdGUID *StringComparator ` json:"ad_guid"`
	// filter by adName
	AdName *StringComparator ` json:"ad_name"`
	// filter by adSAMAccountName
	AdSAMAccountName *StringComparator ` json:"ad_sam_account_name"`
	// filter by adUserPrincipalName
	AdUserPrincipalName *StringComparator ` json:"ad_user_principal_name"`
	// filter by adDisplayName
	AdDisplayName *StringComparator ` json:"ad_display_name"`
	// filter by adDistinguishedName
	AdDistinguishedName *StringComparator ` json:"ad_distinguished_name"`
	// filter by adCanonicalName
	AdCanonicalName *StringComparator ` json:"ad_canonical_name"`
	// filter by adAccountExpires
	AdAccountExpires *EpochComparator ` json:"ad_account_expires"`
	// filter by adObjectClass
	AdObjectClass *StringArrayComparator ` json:"ad_object_class"`
	// filter by adObjectCategory
	AdObjectCategory *StringComparator ` json:"ad_object_category"`
	// filter by adOrganizationalUnit
	AdOrganizationalUnit *StringArrayComparator ` json:"ad_organizational_unit"`
	// filter by ad_bad_pwd_count
	AdBadPwdCount *IntComparator ` json:"ad_bad_pwd_count"`
	// filter by adManagedBy
	AdManagedBy *StringComparator ` json:"ad_managed_by"`
	// filter by adPrimaryGroupId
	AdPrimaryGroupID *IntComparator ` json:"ad_primary_group_id"`
	// filter by adPrimaryGroupDn
	AdPrimaryGroupDn *StringComparator ` json:"ad_primary_group_dn"`
	// filter by adMemberOf
	AdMemberOf *StringArrayComparator ` json:"ad_member_of"`
	// filter by adMemberOfFull
	AdMemberOfFull *StringArrayComparator ` json:"ad_member_of_full"`
	// filter by adUsnChanged
	AdUsnChanged *IntComparator ` json:"ad_usn_changed"`
	// filter by adUsnCreated
	AdUsnCreated *IntComparator ` json:"ad_usn_created"`
	// filter by adIsCriticalSystemObject
	AdIsCriticalSystemObject *BooleanComparator ` json:"ad_is_critical_system_object"`
	// filter by adMsdsAllowedToDelegateTo
	AdMsdsAllowedToDelegateTo *StringArrayComparator ` json:"ad_msds_allowed_to_delegate_to"`
	// filter by adPwdMustChange
	AdPwdMustChange *BooleanComparator ` json:"ad_pwd_must_change"`
	// filter by adMsdsResultantPso
	AdMsdsResultantPso *StringComparator ` json:"ad_msds_resultant_pso"`
	// filter by isSafe
	IsSafe *StringComparator ` json:"is_safe"`
	// filter by deviceState
	DeviceState *CylanceDeviceStateComparator ` json:"device_state"`
	// filter by policyId
	PolicyID *StringComparator ` json:"policy_id"`
	// filter by policyName
	PolicyName *StringComparator ` json:"policy_name"`
	// filter by policiesDetails
	PoliciesDetails *StringArrayComparator ` json:"policies_details"`
	// filter by tenantTag
	TenantTag *StringComparator ` json:"tenant_tag"`
	// filter by zoneNames
	ZoneNames *StringArrayComparator ` json:"zone_names"`
	// filter by agentVersion
	AgentVersion *StringComparator ` json:"agent_version"`
	// filter by externalIp
	ExternalIP *StringComparator ` json:"external_ip"`
	// filter by groups
	Groups *CsGroupBoolExp ` json:"groups"`
	// filter by preventionPolicy
	PreventionPolicy *CsPolicyBoolExp ` json:"prevention_policy"`
	// filter by sensorUpdatePolicy
	SensorUpdatePolicy *CsGroupBoolExp ` json:"sensor_update_policy"`
	// filter by csAgentVersion
	CsAgentVersion *StringComparator    ` json:"cs_agent_version"`
	And            []AdapterDataBoolExp ` json:"and"`
	Or             []AdapterDataBoolExp ` json:"or"`
	Not            []AdapterDataBoolExp ` json:"not"`
}

// Boolean filter expression for AdapterDeviceAdmin
type AdapterDeviceAdminBoolExp struct {
	// filter by name
	Name *StringComparator ` json:"name"`
	// filter by type
	Type *AdminTypeComparator        ` json:"type"`
	And  []AdapterDeviceAdminBoolExp ` json:"and"`
	Or   []AdapterDeviceAdminBoolExp ` json:"or"`
	Not  []AdapterDeviceAdminBoolExp ` json:"not"`
}

// Boolean filter expression for AdapterDevice
type AdapterDeviceBoolExp struct {
	// filter by id
	ID *UUIDComparator ` json:"id"`
	// filter by fetchCycle
	FetchCycle *IntComparator ` json:"fetch_cycle"`
	// filter by adapterId
	AdapterID *StringComparator ` json:"adapter_id"`
	// filter by adapter
	Adapter *AdapterBoolExp ` json:"adapter"`
	// filter by adapterName
	AdapterName *StringComparator ` json:"adapter_name"`
	// filter by deviceId
	DeviceID *UUIDComparator ` json:"device_id"`
	// filter by adapterData
	AdapterData *AdapterDataBoolExp ` json:"adapter_data"`
	// filter by fetchTime
	FetchTime *EpochComparator ` json:"fetch_time"`
	// filter by hostname
	Hostname *StringComparator ` json:"hostname"`
	// filter by name
	Name *StringComparator ` json:"name"`
	// filter by lastSeen
	LastSeen *EpochComparator ` json:"last_seen"`
	// filter by osId
	OsID *UUIDComparator ` json:"os_id"`
	// filter by os
	Os *OperatingSystemBoolExp ` json:"os"`
	// filter by prettyId
	PrettyID *StringComparator ` json:"pretty_id"`
	// filter by tags
	Tags *TagBoolExp ` json:"tags"`
	// filter by interfaces
	Interfaces *NetworkInterfaceBoolExp ` json:"interfaces"`
	// filter by lastUsedUsers
	LastUsedUsers *StringArrayComparator ` json:"last_used_users"`
	// filter by domain
	Domain *StringComparator ` json:"domain"`
	// filter by partOfDomain
	PartOfDomain *BooleanComparator ` json:"part_of_domain"`
	// filter by deviceUsers
	DeviceUsers *AdapterDeviceUserBoolExp ` json:"device_users"`
	// filter by localAdmins
	LocalAdmins *AdapterDeviceAdminBoolExp ` json:"local_admins"`
	// filter by firewallRules
	FirewallRules *FirewallRuleBoolExp ` json:"firewall_rules"`
	// filter by installedSoftware
	InstalledSoftware *InstalledSoftwareBoolExp ` json:"installed_software"`
	// filter by agentVersion
	AgentVersion *StringComparator ` json:"agent_version"`
	// filter by agentStatus
	AgentStatus *StringComparator ` json:"agent_status"`
	// filter by agentName
	AgentName *StringComparator ` json:"agent_name"`
	// filter by model
	Model *StringComparator ` json:"model"`
	// filter by manufacturer
	Manufacturer *StringComparator ` json:"manufacturer"`
	// filter by serial
	Serial *StringComparator ` json:"serial"`
	// filter by family
	Family *StringComparator ` json:"family"`
	// filter by biosVersion
	BiosVersion *StringComparator ` json:"bios_version"`
	// filter by biosSerial
	BiosSerial *StringComparator      ` json:"bios_serial"`
	And        []AdapterDeviceBoolExp ` json:"and"`
	Or         []AdapterDeviceBoolExp ` json:"or"`
	Not        []AdapterDeviceBoolExp ` json:"not"`
}

// Boolean filter expression for AdapterDeviceUser
type AdapterDeviceUserBoolExp struct {
	// filter by deviceId
	DeviceID *UUIDComparator ` json:"device_id"`
	// filter by sid
	Sid *StringComparator ` json:"sid"`
	// filter by username
	Username *StringComparator ` json:"username"`
	// filter by lastUseDate
	LastUseDate *EpochComparator ` json:"last_use_date"`
	// filter by isLocal
	IsLocal *BooleanComparator ` json:"is_local"`
	// filter by isDisabled
	IsDisabled *BooleanComparator ` json:"is_disabled"`
	// filter by isAdmin
	IsAdmin *BooleanComparator ` json:"is_admin"`
	// filter by userDepartment
	UserDepartment *BooleanComparator ` json:"user_department"`
	// filter by passwordMaxAge
	PasswordMaxAge *IntComparator ` json:"password_max_age"`
	// filter by interpreter
	Interpreter *StringComparator          ` json:"interpreter"`
	And         []AdapterDeviceUserBoolExp ` json:"and"`
	Or          []AdapterDeviceUserBoolExp ` json:"or"`
	Not         []AdapterDeviceUserBoolExp ` json:"not"`
}

// Boolean filter expression for AdapterUser
type AdapterUserBoolExp struct {
	// filter by id
	ID *UUIDComparator ` json:"id"`
	// filter by fetchCycle
	FetchCycle *IntComparator ` json:"fetch_cycle"`
	// filter by adapterId
	AdapterID *StringComparator ` json:"adapter_id"`
	// filter by adapter
	Adapter *AdapterBoolExp ` json:"adapter"`
	// filter by adapterName
	AdapterName *StringComparator ` json:"adapter_name"`
	// filter by userId
	UserID *UUIDComparator ` json:"user_id"`
	// filter by adapterData
	AdapterData *AdapterDataBoolExp ` json:"adapter_data"`
	// filter by fetchTime
	FetchTime *EpochComparator ` json:"fetch_time"`
	// filter by lastSeen
	LastSeen *EpochComparator ` json:"last_seen"`
	// filter by username
	Username *StringComparator ` json:"username"`
	// filter by displayName
	DisplayName *StringComparator ` json:"display_name"`
	// filter by description
	Description *StringComparator ` json:"description"`
	// filter by domain
	Domain *StringComparator ` json:"domain"`
	// filter by userSid
	UserSid *StringComparator ` json:"user_sid"`
	// filter by firstName
	FirstName *StringComparator ` json:"first_name"`
	// filter by lastName
	LastName *StringComparator ` json:"last_name"`
	// filter by mail
	Mail *StringComparator ` json:"mail"`
	// filter by admin
	Admin *BooleanComparator ` json:"admin"`
	// filter by local
	Local *BooleanComparator ` json:"local"`
	// filter by delegatedAdmin
	DelegatedAdmin *BooleanComparator ` json:"delegated_admin"`
	// filter by mfaEnforced
	MfaEnforced *BooleanComparator ` json:"mfa_enforced"`
	// filter by mfaEnrolled
	MfaEnrolled *BooleanComparator ` json:"mfa_enrolled"`
	// filter by suspended
	Suspended *BooleanComparator ` json:"suspended"`
	// filter by locked
	Locked *BooleanComparator ` json:"locked"`
	// filter by disabled
	Disabled *BooleanComparator   ` json:"disabled"`
	And      []AdapterUserBoolExp ` json:"and"`
	Or       []AdapterUserBoolExp ` json:"or"`
	Not      []AdapterUserBoolExp ` json:"not"`
}

type CsGroup struct {
	ID               *string         ` json:"id"`
	Name             *string         ` json:"name"`
	CreatedBy        *string         ` json:"created_by"`
	CreatedTimestamp *internal.Epoch ` json:"created_timestamp"`
	Description      *string         ` json:"description"`
	GroupType        *string         ` json:"group_type"`
	ModifiedBy       *string         ` json:"modified_by"`
	ModifiedTime     *internal.Epoch ` json:"modified_time"`
}

type CsPolicy struct {
	Name                 *string                   ` json:"name"`
	Description          *string                   ` json:"description"`
	PlatformName         *string                   ` json:"platform_name"`
	Groups               []*CsGroup                ` json:"groups"`
	Enabled              *bool                     ` json:"enabled"`
	CreatedBy            *string                   ` json:"created_by"`
	CreatedTime          *internal.Epoch           ` json:"created_time"`
	PreventionSettings   []*CsPreventionSettings   ` json:"prevention_settings"`
	SensorUpdateSettings []*CsSensorUpdateSettings ` json:"sensor_update_settings"`
	// Returns aggregate of groups
	GroupsAggregate []GroupsAggregate ` json:"groups_aggregate"`
	// Returns aggregate of preventionSettings
	PreventionSettingsAggregate []PreventionSettingsAggregate ` json:"prevention_settings_aggregate"`
	// Returns aggregate of sensorUpdateSettings
	SensorUpdateSettingsAggregate []SensorUpdateSettingsAggregate ` json:"sensor_update_settings_aggregate"`
}

type CsPolicySettings struct {
	Enabled *bool ` json:"enabled"`
}

type CsPreventionSettings struct {
	Name     *string             ` json:"name"`
	Settings []*CsPolicySettings ` json:"settings"`
}

type CsSensorUpdateSettings struct {
	Build *string ` json:"build"`
}

// Boolean filter expression for csGroup
type CsGroupBoolExp struct {
	// filter by id
	ID *StringComparator ` json:"id"`
	// filter by name
	Name *StringComparator ` json:"name"`
	// filter by createdBy
	CreatedBy *StringComparator ` json:"created_by"`
	// filter by createdTimestamp
	CreatedTimestamp *EpochComparator ` json:"created_timestamp"`
	// filter by description
	Description *StringComparator ` json:"description"`
	// filter by groupType
	GroupType *StringComparator ` json:"group_type"`
	// filter by modifiedBy
	ModifiedBy *StringComparator ` json:"modified_by"`
	// filter by modifiedTime
	ModifiedTime *EpochComparator ` json:"modified_time"`
	And          []CsGroupBoolExp ` json:"and"`
	Or           []CsGroupBoolExp ` json:"or"`
	Not          []CsGroupBoolExp ` json:"not"`
}

// Boolean filter expression for csPolicy
type CsPolicyBoolExp struct {
	// filter by name
	Name *StringComparator ` json:"name"`
	// filter by description
	Description *StringComparator ` json:"description"`
	// filter by platformName
	PlatformName *StringComparator ` json:"platform_name"`
	// filter by groups
	Groups *CsGroupBoolExp ` json:"groups"`
	// filter by enabled
	Enabled *BooleanComparator ` json:"enabled"`
	// filter by createdBy
	CreatedBy *StringComparator ` json:"created_by"`
	// filter by createdTime
	CreatedTime *EpochComparator ` json:"created_time"`
	// filter by preventionSettings
	PreventionSettings *CsPreventionSettingsBoolExp ` json:"prevention_settings"`
	// filter by sensorUpdateSettings
	SensorUpdateSettings *CsSensorUpdateSettingsBoolExp ` json:"sensor_update_settings"`
	And                  []CsPolicyBoolExp              ` json:"and"`
	Or                   []CsPolicyBoolExp              ` json:"or"`
	Not                  []CsPolicyBoolExp              ` json:"not"`
}

// Boolean filter expression for csPolicySettings
type CsPolicySettingsBoolExp struct {
	// filter by enabled
	Enabled *BooleanComparator        ` json:"enabled"`
	And     []CsPolicySettingsBoolExp ` json:"and"`
	Or      []CsPolicySettingsBoolExp ` json:"or"`
	Not     []CsPolicySettingsBoolExp ` json:"not"`
}

// Boolean filter expression for csPreventionSettings
type CsPreventionSettingsBoolExp struct {
	// filter by name
	Name *StringComparator ` json:"name"`
	// filter by settings
	Settings *CsPolicySettingsBoolExp      ` json:"settings"`
	And      []CsPreventionSettingsBoolExp ` json:"and"`
	Or       []CsPreventionSettingsBoolExp ` json:"or"`
	Not      []CsPreventionSettingsBoolExp ` json:"not"`
}

// Boolean filter expression for csSensorUpdateSettings
type CsSensorUpdateSettingsBoolExp struct {
	// filter by build
	Build *StringComparator               ` json:"build"`
	And   []CsSensorUpdateSettingsBoolExp ` json:"and"`
	Or    []CsSensorUpdateSettingsBoolExp ` json:"or"`
	Not   []CsSensorUpdateSettingsBoolExp ` json:"not"`
}

// Boolean filter expression for Device
type DeviceBoolExp struct {
	// filter by id
	ID *UUIDComparator ` json:"id"`
	// filter by fetchCycle
	FetchCycle *IntComparator ` json:"fetch_cycle"`
	// filter by adapterCount
	AdapterCount *IntComparator ` json:"adapter_count"`
	// filter by adapterNames
	AdapterNames *StringArrayComparator ` json:"adapter_names"`
	// filter by hostnames
	Hostnames *StringArrayComparator ` json:"hostnames"`
	// filter by lastSeen
	LastSeen *EpochComparator ` json:"last_seen"`
	// filter by adapterDevices
	AdapterDevices *AdapterDeviceBoolExp ` json:"adapter_devices"`
	// filter by interfaces
	Interfaces *NetworkInterfaceBoolExp ` json:"interfaces"`
	// filter by tags
	Tags *TagBoolExp     ` json:"tags"`
	And  []DeviceBoolExp ` json:"and"`
	Or   []DeviceBoolExp ` json:"or"`
	Not  []DeviceBoolExp ` json:"not"`
}

type DevicesAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	Devices  []*Device              ` json:"devices"`
}

type FirewallRulesAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	// Firewall rules defined on this adapter device
	FirewallRules []*FirewallRule ` json:"firewall_rules"`
}

// Boolean filter expression for FirewallRule
type FirewallRuleBoolExp struct {
	// filter by name
	Name *StringComparator ` json:"name"`
	// filter by source
	Source *StringComparator ` json:"source"`
	// filter by type
	Type *AccessTypeComparator ` json:"type"`
	// filter by direction
	Direction *DirectionComparator ` json:"direction"`
	// filter by target
	Target *StringComparator ` json:"target"`
	// filter by protocol
	Protocol *StringComparator ` json:"protocol"`
	// filter by srcPort
	SrcPort *IntComparator ` json:"src_port"`
	// filter by dstPort
	DstPort *IntComparator        ` json:"dst_port"`
	And     []FirewallRuleBoolExp ` json:"and"`
	Or      []FirewallRuleBoolExp ` json:"or"`
	Not     []FirewallRuleBoolExp ` json:"not"`
}

// Boolean filter expression for GceTags
type GceTagsBoolExp struct {
	// filter by gceKey
	GceKey *StringComparator ` json:"gce_key"`
	// filter by gceValue
	GceValue *StringComparator ` json:"gce_value"`
	And      []GceTagsBoolExp  ` json:"and"`
	Or       []GceTagsBoolExp  ` json:"or"`
	Not      []GceTagsBoolExp  ` json:"not"`
}

type GroupsAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	Groups   []*CsGroup             ` json:"groups"`
}

type InstalledSoftwareAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	// Software installed on this device
	InstalledSoftware []*InstalledSoftware ` json:"installed_software"`
}

// Boolean filter expression for InstalledSoftware
type InstalledSoftwareBoolExp struct {
	// filter by name
	Name *StringComparator ` json:"name"`
	// filter by version
	Version *StringComparator ` json:"version"`
	// filter by architecture
	Architecture *ArchitectureComparator ` json:"architecture"`
	// filter by description
	Description *StringComparator ` json:"description"`
	// filter by vendor
	Vendor *StringComparator ` json:"vendor"`
	// filter by publisher
	Publisher *StringComparator ` json:"publisher"`
	// filter by cveCount
	CveCount *IntComparator ` json:"cve_count"`
	// filter by swLicense
	SwLicense *StringComparator ` json:"sw_license"`
	// filter by path
	Path *StringComparator          ` json:"path"`
	And  []InstalledSoftwareBoolExp ` json:"and"`
	Or   []InstalledSoftwareBoolExp ` json:"or"`
	Not  []InstalledSoftwareBoolExp ` json:"not"`
}

type InterfacesAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	// Unique set of network interfaces collected by all adapter devices
	Interfaces []*NetworkInterface ` json:"interfaces"`
}

// Boolean filter expression for NetworkInterface
type NetworkInterfaceBoolExp struct {
	// filter by deviceId
	DeviceID *UUIDComparator ` json:"device_id"`
	// filter by macAddr
	MacAddr *MacComparator ` json:"mac_addr"`
	// filter by ipAddrs
	IPAddrs *IPArrayComparator        ` json:"ip_addrs"`
	And     []NetworkInterfaceBoolExp ` json:"and"`
	Or      []NetworkInterfaceBoolExp ` json:"or"`
	Not     []NetworkInterfaceBoolExp ` json:"not"`
}

// Boolean filter expression for OperatingSystem
type OperatingSystemBoolExp struct {
	// filter by id
	ID *UUIDComparator ` json:"id"`
	// filter by type
	Type *StringComparator ` json:"type"`
	// filter by distribution
	Distribution *StringComparator ` json:"distribution"`
	// filter by architecture
	Architecture *IntComparator ` json:"architecture"`
	// filter by servicePack
	ServicePack *StringComparator ` json:"service_pack"`
	// filter by installDate
	InstallDate *EpochComparator ` json:"install_date"`
	// filter by kernelVersion
	KernelVersion *StringComparator ` json:"kernel_version"`
	// filter by codeName
	CodeName *StringComparator ` json:"code_name"`
	// filter by major
	Major *IntComparator ` json:"major"`
	// filter by minor
	Minor *IntComparator ` json:"minor"`
	// filter by build
	Build *StringComparator ` json:"build"`
	// filter by rawName
	RawName *StringComparator        ` json:"raw_name"`
	And     []OperatingSystemBoolExp ` json:"and"`
	Or      []OperatingSystemBoolExp ` json:"or"`
	Not     []OperatingSystemBoolExp ` json:"not"`
}

type PreventionSettingsAggregate struct {
	Group              []string                ` json:"group"`
	Distinct           []string                ` json:"distinct"`
	Count              *int                    ` json:"count"`
	Sum                map[string]interface{}  ` json:"sum"`
	Avg                map[string]interface{}  ` json:"avg"`
	Min                map[string]interface{}  ` json:"min"`
	Max                map[string]interface{}  ` json:"max"`
	PreventionSettings []*CsPreventionSettings ` json:"prevention_settings"`
}

type SensorUpdateSettingsAggregate struct {
	Group                []string                  ` json:"group"`
	Distinct             []string                  ` json:"distinct"`
	Count                *int                      ` json:"count"`
	Sum                  map[string]interface{}    ` json:"sum"`
	Avg                  map[string]interface{}    ` json:"avg"`
	Min                  map[string]interface{}    ` json:"min"`
	Max                  map[string]interface{}    ` json:"max"`
	SensorUpdateSettings []*CsSensorUpdateSettings ` json:"sensor_update_settings"`
}

// Boolean filter expression for Tag
type TagBoolExp struct {
	// filter by name
	Name *StringComparator ` json:"name"`
	// filter by creator
	Creator *StringComparator ` json:"creator"`
	// filter by level
	Level *StringComparator ` json:"level"`
	And   []TagBoolExp      ` json:"and"`
	Or    []TagBoolExp      ` json:"or"`
	Not   []TagBoolExp      ` json:"not"`
}

type TagsAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	// Unique set tags given to all adapter devices
	Tags []*Tag ` json:"tags"`
}

// Boolean filter expression for User
type UserBoolExp struct {
	// filter by id
	ID *UUIDComparator ` json:"id"`
	// filter by fetchCycle
	FetchCycle *IntComparator ` json:"fetch_cycle"`
	// filter by adapterCount
	AdapterCount *IntComparator ` json:"adapter_count"`
	// filter by adapterNames
	AdapterNames *StringArrayComparator ` json:"adapter_names"`
	// filter by usernames
	Usernames *StringArrayComparator ` json:"usernames"`
	// filter by lastSeen
	LastSeen *EpochComparator ` json:"last_seen"`
	// filter by adapterUsers
	AdapterUsers *AdapterUserBoolExp ` json:"adapter_users"`
	And          []UserBoolExp       ` json:"and"`
	Or           []UserBoolExp       ` json:"or"`
	Not          []UserBoolExp       ` json:"not"`
}

type UsersAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	Users    []*User                ` json:"users"`
}

type AccessType string

const (
	AccessTypeAllow AccessType = "ALLOW"
	AccessTypeDeny  AccessType = "DENY"
)

var AllAccessType = []AccessType{
	AccessTypeAllow,
	AccessTypeDeny,
}

func (e AccessType) IsValid() bool {
	switch e {
	case AccessTypeAllow, AccessTypeDeny:
		return true
	}
	return false
}

func (e AccessType) String() string {
	return string(e)
}

func (e *AccessType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessType", str)
	}
	return nil
}

func (e AccessType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdminType string

const (
	AdminTypeAdminUser       AdminType = "ADMIN_USER"
	AdminTypeGroupMembership AdminType = "GROUP_MEMBERSHIP"
)

var AllAdminType = []AdminType{
	AdminTypeAdminUser,
	AdminTypeGroupMembership,
}

func (e AdminType) IsValid() bool {
	switch e {
	case AdminTypeAdminUser, AdminTypeGroupMembership:
		return true
	}
	return false
}

func (e AdminType) String() string {
	return string(e)
}

func (e *AdminType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdminType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdminType", str)
	}
	return nil
}

func (e AdminType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AggregateOrdering string

const (
	AggregateOrderingCountAsc  AggregateOrdering = "count_ASC"
	AggregateOrderingCountDesc AggregateOrdering = "count_DESC"
	AggregateOrderingSumAsc    AggregateOrdering = "sum_ASC"
	AggregateOrderingSumDesc   AggregateOrdering = "sum_DESC"
	AggregateOrderingAvgAsc    AggregateOrdering = "avg_ASC"
	AggregateOrderingAvgDesc   AggregateOrdering = "avg_DESC"
	AggregateOrderingMinAsc    AggregateOrdering = "min_ASC"
	AggregateOrderingMinDesc   AggregateOrdering = "min_DESC"
	AggregateOrderingMaxAsc    AggregateOrdering = "max_ASC"
	AggregateOrderingMaxDesc   AggregateOrdering = "max_DESC"
)

var AllAggregateOrdering = []AggregateOrdering{
	AggregateOrderingCountAsc,
	AggregateOrderingCountDesc,
	AggregateOrderingSumAsc,
	AggregateOrderingSumDesc,
	AggregateOrderingAvgAsc,
	AggregateOrderingAvgDesc,
	AggregateOrderingMinAsc,
	AggregateOrderingMinDesc,
	AggregateOrderingMaxAsc,
	AggregateOrderingMaxDesc,
}

func (e AggregateOrdering) IsValid() bool {
	switch e {
	case AggregateOrderingCountAsc, AggregateOrderingCountDesc, AggregateOrderingSumAsc, AggregateOrderingSumDesc, AggregateOrderingAvgAsc, AggregateOrderingAvgDesc, AggregateOrderingMinAsc, AggregateOrderingMinDesc, AggregateOrderingMaxAsc, AggregateOrderingMaxDesc:
		return true
	}
	return false
}

func (e AggregateOrdering) String() string {
	return string(e)
}

func (e *AggregateOrdering) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AggregateOrdering(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AggregateOrdering", str)
	}
	return nil
}

func (e AggregateOrdering) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Architecture string

const (
	ArchitectureX86     Architecture = "X86"
	ArchitectureX64     Architecture = "X64"
	ArchitectureMips    Architecture = "MIPS"
	ArchitectureAlpha   Architecture = "ALPHA"
	ArchitectureArm     Architecture = "ARM"
	ArchitecturePowerPc Architecture = "POWER_PC"
	ArchitectureIa64    Architecture = "IA64"
)

var AllArchitecture = []Architecture{
	ArchitectureX86,
	ArchitectureX64,
	ArchitectureMips,
	ArchitectureAlpha,
	ArchitectureArm,
	ArchitecturePowerPc,
	ArchitectureIa64,
}

func (e Architecture) IsValid() bool {
	switch e {
	case ArchitectureX86, ArchitectureX64, ArchitectureMips, ArchitectureAlpha, ArchitectureArm, ArchitecturePowerPc, ArchitectureIa64:
		return true
	}
	return false
}

func (e Architecture) String() string {
	return string(e)
}

func (e *Architecture) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Architecture(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Architecture", str)
	}
	return nil
}

func (e Architecture) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CylanceDeviceState string

const (
	CylanceDeviceStateOnline  CylanceDeviceState = "ONLINE"
	CylanceDeviceStateOffline CylanceDeviceState = "OFFLINE"
)

var AllCylanceDeviceState = []CylanceDeviceState{
	CylanceDeviceStateOnline,
	CylanceDeviceStateOffline,
}

func (e CylanceDeviceState) IsValid() bool {
	switch e {
	case CylanceDeviceStateOnline, CylanceDeviceStateOffline:
		return true
	}
	return false
}

func (e CylanceDeviceState) String() string {
	return string(e)
}

func (e *CylanceDeviceState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CylanceDeviceState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CylanceDeviceState", str)
	}
	return nil
}

func (e CylanceDeviceState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Direction string

const (
	DirectionIngress Direction = "INGRESS"
	DirectionEgress  Direction = "EGRESS"
)

var AllDirection = []Direction{
	DirectionIngress,
	DirectionEgress,
}

func (e Direction) IsValid() bool {
	switch e {
	case DirectionIngress, DirectionEgress:
		return true
	}
	return false
}

func (e Direction) String() string {
	return string(e)
}

func (e *Direction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Direction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Direction", str)
	}
	return nil
}

func (e Direction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GCETagsAggregateColumns string

const (
	// groupBy by gceKey
	GCETagsAggregateColumnsGceKey GCETagsAggregateColumns = "gceKey"
	// groupBy by gceValue
	GCETagsAggregateColumnsGceValue GCETagsAggregateColumns = "gceValue"
)

var AllGCETagsAggregateColumns = []GCETagsAggregateColumns{
	GCETagsAggregateColumnsGceKey,
	GCETagsAggregateColumnsGceValue,
}

func (e GCETagsAggregateColumns) IsValid() bool {
	switch e {
	case GCETagsAggregateColumnsGceKey, GCETagsAggregateColumnsGceValue:
		return true
	}
	return false
}

func (e GCETagsAggregateColumns) String() string {
	return string(e)
}

func (e *GCETagsAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GCETagsAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GCETags_aggregate_columns", str)
	}
	return nil
}

func (e GCETagsAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GCETagsAggregateMaxColumns string

const (
	// max by gceKey
	GCETagsAggregateMaxColumnsGceKey GCETagsAggregateMaxColumns = "gceKey"
	// max by gceValue
	GCETagsAggregateMaxColumnsGceValue GCETagsAggregateMaxColumns = "gceValue"
)

var AllGCETagsAggregateMaxColumns = []GCETagsAggregateMaxColumns{
	GCETagsAggregateMaxColumnsGceKey,
	GCETagsAggregateMaxColumnsGceValue,
}

func (e GCETagsAggregateMaxColumns) IsValid() bool {
	switch e {
	case GCETagsAggregateMaxColumnsGceKey, GCETagsAggregateMaxColumnsGceValue:
		return true
	}
	return false
}

func (e GCETagsAggregateMaxColumns) String() string {
	return string(e)
}

func (e *GCETagsAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GCETagsAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GCETags_aggregate_max_columns", str)
	}
	return nil
}

func (e GCETagsAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GCETagsAggregateMinColumns string

const (
	// min by gceKey
	GCETagsAggregateMinColumnsGceKey GCETagsAggregateMinColumns = "gceKey"
	// min by gceValue
	GCETagsAggregateMinColumnsGceValue GCETagsAggregateMinColumns = "gceValue"
)

var AllGCETagsAggregateMinColumns = []GCETagsAggregateMinColumns{
	GCETagsAggregateMinColumnsGceKey,
	GCETagsAggregateMinColumnsGceValue,
}

func (e GCETagsAggregateMinColumns) IsValid() bool {
	switch e {
	case GCETagsAggregateMinColumnsGceKey, GCETagsAggregateMinColumnsGceValue:
		return true
	}
	return false
}

func (e GCETagsAggregateMinColumns) String() string {
	return string(e)
}

func (e *GCETagsAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GCETagsAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GCETags_aggregate_min_columns", str)
	}
	return nil
}

func (e GCETagsAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPFamily string

const (
	IPFamilyV4 IPFamily = "V4"
	IPFamilyV6 IPFamily = "V6"
)

var AllIPFamily = []IPFamily{
	IPFamilyV4,
	IPFamilyV6,
}

func (e IPFamily) IsValid() bool {
	switch e {
	case IPFamilyV4, IPFamilyV6:
		return true
	}
	return false
}

func (e IPFamily) String() string {
	return string(e)
}

func (e *IPFamily) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPFamily(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IPFamily", str)
	}
	return nil
}

func (e IPFamily) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OsTypes string

const (
	OsTypesWindows         OsTypes = "WINDOWS"
	OsTypesLinux           OsTypes = "LINUX"
	OsTypesOsX             OsTypes = "OS_X"
	OsTypesIos             OsTypes = "IOS"
	OsTypesAirOs           OsTypes = "AIR_OS"
	OsTypesAndroid         OsTypes = "ANDROID"
	OsTypesFreeBsd         OsTypes = "FREE_BSD"
	OsTypesVMWare          OsTypes = "VMWARE"
	OsTypesCisco           OsTypes = "CISCO"
	OsTypesMikrotik        OsTypes = "MIKROTIK"
	OsTypesVxworks         OsTypes = "VXWORKS"
	OsTypesF5NetworksBigIP OsTypes = "F5_NETWORKS_BIG_IP"
	OsTypesSolaris         OsTypes = "SOLARIS"
	OsTypesAix             OsTypes = "AIX"
	OsTypesPrinter         OsTypes = "PRINTER"
	OsTypesPlaystation     OsTypes = "PLAYSTATION"
	OsTypesCheckpoint      OsTypes = "CHECKPOINT"
	OsTypesArista          OsTypes = "ARISTA"
)

var AllOsTypes = []OsTypes{
	OsTypesWindows,
	OsTypesLinux,
	OsTypesOsX,
	OsTypesIos,
	OsTypesAirOs,
	OsTypesAndroid,
	OsTypesFreeBsd,
	OsTypesVMWare,
	OsTypesCisco,
	OsTypesMikrotik,
	OsTypesVxworks,
	OsTypesF5NetworksBigIP,
	OsTypesSolaris,
	OsTypesAix,
	OsTypesPrinter,
	OsTypesPlaystation,
	OsTypesCheckpoint,
	OsTypesArista,
}

func (e OsTypes) IsValid() bool {
	switch e {
	case OsTypesWindows, OsTypesLinux, OsTypesOsX, OsTypesIos, OsTypesAirOs, OsTypesAndroid, OsTypesFreeBsd, OsTypesVMWare, OsTypesCisco, OsTypesMikrotik, OsTypesVxworks, OsTypesF5NetworksBigIP, OsTypesSolaris, OsTypesAix, OsTypesPrinter, OsTypesPlaystation, OsTypesCheckpoint, OsTypesArista:
		return true
	}
	return false
}

func (e OsTypes) String() string {
	return string(e)
}

func (e *OsTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OsTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OsTypes", str)
	}
	return nil
}

func (e OsTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterDevicesAggregateAvgColumns string

const (
	// avg by fetchCycle
	AdapterDevicesAggregateAvgColumnsFetchCycle AdapterDevicesAggregateAvgColumns = "fetchCycle"
	// avg by fetchTime
	AdapterDevicesAggregateAvgColumnsFetchTime AdapterDevicesAggregateAvgColumns = "fetchTime"
	// avg by lastSeen
	AdapterDevicesAggregateAvgColumnsLastSeen AdapterDevicesAggregateAvgColumns = "lastSeen"
)

var AllAdapterDevicesAggregateAvgColumns = []AdapterDevicesAggregateAvgColumns{
	AdapterDevicesAggregateAvgColumnsFetchCycle,
	AdapterDevicesAggregateAvgColumnsFetchTime,
	AdapterDevicesAggregateAvgColumnsLastSeen,
}

func (e AdapterDevicesAggregateAvgColumns) IsValid() bool {
	switch e {
	case AdapterDevicesAggregateAvgColumnsFetchCycle, AdapterDevicesAggregateAvgColumnsFetchTime, AdapterDevicesAggregateAvgColumnsLastSeen:
		return true
	}
	return false
}

func (e AdapterDevicesAggregateAvgColumns) String() string {
	return string(e)
}

func (e *AdapterDevicesAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDevicesAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterDevices_aggregate_avg_columns", str)
	}
	return nil
}

func (e AdapterDevicesAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterDevicesAggregateColumns string

const (
	// groupBy by id
	AdapterDevicesAggregateColumnsID AdapterDevicesAggregateColumns = "id"
	// groupBy by fetchCycle
	AdapterDevicesAggregateColumnsFetchCycle AdapterDevicesAggregateColumns = "fetchCycle"
	// groupBy by adapterId
	AdapterDevicesAggregateColumnsAdapterID AdapterDevicesAggregateColumns = "adapterId"
	// groupBy by adapterName
	AdapterDevicesAggregateColumnsAdapterName AdapterDevicesAggregateColumns = "adapterName"
	// groupBy by deviceId
	AdapterDevicesAggregateColumnsDeviceID AdapterDevicesAggregateColumns = "deviceId"
	// groupBy by fetchTime
	AdapterDevicesAggregateColumnsFetchTime AdapterDevicesAggregateColumns = "fetchTime"
	// groupBy by hostname
	AdapterDevicesAggregateColumnsHostname AdapterDevicesAggregateColumns = "hostname"
	// groupBy by name
	AdapterDevicesAggregateColumnsName AdapterDevicesAggregateColumns = "name"
	// groupBy by lastSeen
	AdapterDevicesAggregateColumnsLastSeen AdapterDevicesAggregateColumns = "lastSeen"
	// groupBy by osId
	AdapterDevicesAggregateColumnsOsID AdapterDevicesAggregateColumns = "osId"
	// groupBy by prettyId
	AdapterDevicesAggregateColumnsPrettyID AdapterDevicesAggregateColumns = "prettyId"
	// groupBy by domain
	AdapterDevicesAggregateColumnsDomain AdapterDevicesAggregateColumns = "domain"
	// groupBy by agentVersion
	AdapterDevicesAggregateColumnsAgentVersion AdapterDevicesAggregateColumns = "agentVersion"
	// groupBy by agentStatus
	AdapterDevicesAggregateColumnsAgentStatus AdapterDevicesAggregateColumns = "agentStatus"
	// groupBy by agentName
	AdapterDevicesAggregateColumnsAgentName AdapterDevicesAggregateColumns = "agentName"
	// groupBy by model
	AdapterDevicesAggregateColumnsModel AdapterDevicesAggregateColumns = "model"
	// groupBy by manufacturer
	AdapterDevicesAggregateColumnsManufacturer AdapterDevicesAggregateColumns = "manufacturer"
	// groupBy by serial
	AdapterDevicesAggregateColumnsSerial AdapterDevicesAggregateColumns = "serial"
	// groupBy by family
	AdapterDevicesAggregateColumnsFamily AdapterDevicesAggregateColumns = "family"
	// groupBy by biosVersion
	AdapterDevicesAggregateColumnsBiosVersion AdapterDevicesAggregateColumns = "biosVersion"
	// groupBy by biosSerial
	AdapterDevicesAggregateColumnsBiosSerial AdapterDevicesAggregateColumns = "biosSerial"
)

var AllAdapterDevicesAggregateColumns = []AdapterDevicesAggregateColumns{
	AdapterDevicesAggregateColumnsID,
	AdapterDevicesAggregateColumnsFetchCycle,
	AdapterDevicesAggregateColumnsAdapterID,
	AdapterDevicesAggregateColumnsAdapterName,
	AdapterDevicesAggregateColumnsDeviceID,
	AdapterDevicesAggregateColumnsFetchTime,
	AdapterDevicesAggregateColumnsHostname,
	AdapterDevicesAggregateColumnsName,
	AdapterDevicesAggregateColumnsLastSeen,
	AdapterDevicesAggregateColumnsOsID,
	AdapterDevicesAggregateColumnsPrettyID,
	AdapterDevicesAggregateColumnsDomain,
	AdapterDevicesAggregateColumnsAgentVersion,
	AdapterDevicesAggregateColumnsAgentStatus,
	AdapterDevicesAggregateColumnsAgentName,
	AdapterDevicesAggregateColumnsModel,
	AdapterDevicesAggregateColumnsManufacturer,
	AdapterDevicesAggregateColumnsSerial,
	AdapterDevicesAggregateColumnsFamily,
	AdapterDevicesAggregateColumnsBiosVersion,
	AdapterDevicesAggregateColumnsBiosSerial,
}

func (e AdapterDevicesAggregateColumns) IsValid() bool {
	switch e {
	case AdapterDevicesAggregateColumnsID, AdapterDevicesAggregateColumnsFetchCycle, AdapterDevicesAggregateColumnsAdapterID, AdapterDevicesAggregateColumnsAdapterName, AdapterDevicesAggregateColumnsDeviceID, AdapterDevicesAggregateColumnsFetchTime, AdapterDevicesAggregateColumnsHostname, AdapterDevicesAggregateColumnsName, AdapterDevicesAggregateColumnsLastSeen, AdapterDevicesAggregateColumnsOsID, AdapterDevicesAggregateColumnsPrettyID, AdapterDevicesAggregateColumnsDomain, AdapterDevicesAggregateColumnsAgentVersion, AdapterDevicesAggregateColumnsAgentStatus, AdapterDevicesAggregateColumnsAgentName, AdapterDevicesAggregateColumnsModel, AdapterDevicesAggregateColumnsManufacturer, AdapterDevicesAggregateColumnsSerial, AdapterDevicesAggregateColumnsFamily, AdapterDevicesAggregateColumnsBiosVersion, AdapterDevicesAggregateColumnsBiosSerial:
		return true
	}
	return false
}

func (e AdapterDevicesAggregateColumns) String() string {
	return string(e)
}

func (e *AdapterDevicesAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDevicesAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterDevices_aggregate_columns", str)
	}
	return nil
}

func (e AdapterDevicesAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterDevicesAggregateMaxColumns string

const (
	// max by id
	AdapterDevicesAggregateMaxColumnsID AdapterDevicesAggregateMaxColumns = "id"
	// max by fetchCycle
	AdapterDevicesAggregateMaxColumnsFetchCycle AdapterDevicesAggregateMaxColumns = "fetchCycle"
	// max by adapterId
	AdapterDevicesAggregateMaxColumnsAdapterID AdapterDevicesAggregateMaxColumns = "adapterId"
	// max by adapterName
	AdapterDevicesAggregateMaxColumnsAdapterName AdapterDevicesAggregateMaxColumns = "adapterName"
	// max by deviceId
	AdapterDevicesAggregateMaxColumnsDeviceID AdapterDevicesAggregateMaxColumns = "deviceId"
	// max by fetchTime
	AdapterDevicesAggregateMaxColumnsFetchTime AdapterDevicesAggregateMaxColumns = "fetchTime"
	// max by hostname
	AdapterDevicesAggregateMaxColumnsHostname AdapterDevicesAggregateMaxColumns = "hostname"
	// max by name
	AdapterDevicesAggregateMaxColumnsName AdapterDevicesAggregateMaxColumns = "name"
	// max by lastSeen
	AdapterDevicesAggregateMaxColumnsLastSeen AdapterDevicesAggregateMaxColumns = "lastSeen"
	// max by osId
	AdapterDevicesAggregateMaxColumnsOsID AdapterDevicesAggregateMaxColumns = "osId"
	// max by prettyId
	AdapterDevicesAggregateMaxColumnsPrettyID AdapterDevicesAggregateMaxColumns = "prettyId"
	// max by domain
	AdapterDevicesAggregateMaxColumnsDomain AdapterDevicesAggregateMaxColumns = "domain"
	// max by agentVersion
	AdapterDevicesAggregateMaxColumnsAgentVersion AdapterDevicesAggregateMaxColumns = "agentVersion"
	// max by agentStatus
	AdapterDevicesAggregateMaxColumnsAgentStatus AdapterDevicesAggregateMaxColumns = "agentStatus"
	// max by agentName
	AdapterDevicesAggregateMaxColumnsAgentName AdapterDevicesAggregateMaxColumns = "agentName"
	// max by model
	AdapterDevicesAggregateMaxColumnsModel AdapterDevicesAggregateMaxColumns = "model"
	// max by manufacturer
	AdapterDevicesAggregateMaxColumnsManufacturer AdapterDevicesAggregateMaxColumns = "manufacturer"
	// max by serial
	AdapterDevicesAggregateMaxColumnsSerial AdapterDevicesAggregateMaxColumns = "serial"
	// max by family
	AdapterDevicesAggregateMaxColumnsFamily AdapterDevicesAggregateMaxColumns = "family"
	// max by biosVersion
	AdapterDevicesAggregateMaxColumnsBiosVersion AdapterDevicesAggregateMaxColumns = "biosVersion"
	// max by biosSerial
	AdapterDevicesAggregateMaxColumnsBiosSerial AdapterDevicesAggregateMaxColumns = "biosSerial"
)

var AllAdapterDevicesAggregateMaxColumns = []AdapterDevicesAggregateMaxColumns{
	AdapterDevicesAggregateMaxColumnsID,
	AdapterDevicesAggregateMaxColumnsFetchCycle,
	AdapterDevicesAggregateMaxColumnsAdapterID,
	AdapterDevicesAggregateMaxColumnsAdapterName,
	AdapterDevicesAggregateMaxColumnsDeviceID,
	AdapterDevicesAggregateMaxColumnsFetchTime,
	AdapterDevicesAggregateMaxColumnsHostname,
	AdapterDevicesAggregateMaxColumnsName,
	AdapterDevicesAggregateMaxColumnsLastSeen,
	AdapterDevicesAggregateMaxColumnsOsID,
	AdapterDevicesAggregateMaxColumnsPrettyID,
	AdapterDevicesAggregateMaxColumnsDomain,
	AdapterDevicesAggregateMaxColumnsAgentVersion,
	AdapterDevicesAggregateMaxColumnsAgentStatus,
	AdapterDevicesAggregateMaxColumnsAgentName,
	AdapterDevicesAggregateMaxColumnsModel,
	AdapterDevicesAggregateMaxColumnsManufacturer,
	AdapterDevicesAggregateMaxColumnsSerial,
	AdapterDevicesAggregateMaxColumnsFamily,
	AdapterDevicesAggregateMaxColumnsBiosVersion,
	AdapterDevicesAggregateMaxColumnsBiosSerial,
}

func (e AdapterDevicesAggregateMaxColumns) IsValid() bool {
	switch e {
	case AdapterDevicesAggregateMaxColumnsID, AdapterDevicesAggregateMaxColumnsFetchCycle, AdapterDevicesAggregateMaxColumnsAdapterID, AdapterDevicesAggregateMaxColumnsAdapterName, AdapterDevicesAggregateMaxColumnsDeviceID, AdapterDevicesAggregateMaxColumnsFetchTime, AdapterDevicesAggregateMaxColumnsHostname, AdapterDevicesAggregateMaxColumnsName, AdapterDevicesAggregateMaxColumnsLastSeen, AdapterDevicesAggregateMaxColumnsOsID, AdapterDevicesAggregateMaxColumnsPrettyID, AdapterDevicesAggregateMaxColumnsDomain, AdapterDevicesAggregateMaxColumnsAgentVersion, AdapterDevicesAggregateMaxColumnsAgentStatus, AdapterDevicesAggregateMaxColumnsAgentName, AdapterDevicesAggregateMaxColumnsModel, AdapterDevicesAggregateMaxColumnsManufacturer, AdapterDevicesAggregateMaxColumnsSerial, AdapterDevicesAggregateMaxColumnsFamily, AdapterDevicesAggregateMaxColumnsBiosVersion, AdapterDevicesAggregateMaxColumnsBiosSerial:
		return true
	}
	return false
}

func (e AdapterDevicesAggregateMaxColumns) String() string {
	return string(e)
}

func (e *AdapterDevicesAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDevicesAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterDevices_aggregate_max_columns", str)
	}
	return nil
}

func (e AdapterDevicesAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterDevicesAggregateMinColumns string

const (
	// min by id
	AdapterDevicesAggregateMinColumnsID AdapterDevicesAggregateMinColumns = "id"
	// min by fetchCycle
	AdapterDevicesAggregateMinColumnsFetchCycle AdapterDevicesAggregateMinColumns = "fetchCycle"
	// min by adapterId
	AdapterDevicesAggregateMinColumnsAdapterID AdapterDevicesAggregateMinColumns = "adapterId"
	// min by adapterName
	AdapterDevicesAggregateMinColumnsAdapterName AdapterDevicesAggregateMinColumns = "adapterName"
	// min by deviceId
	AdapterDevicesAggregateMinColumnsDeviceID AdapterDevicesAggregateMinColumns = "deviceId"
	// min by fetchTime
	AdapterDevicesAggregateMinColumnsFetchTime AdapterDevicesAggregateMinColumns = "fetchTime"
	// min by hostname
	AdapterDevicesAggregateMinColumnsHostname AdapterDevicesAggregateMinColumns = "hostname"
	// min by name
	AdapterDevicesAggregateMinColumnsName AdapterDevicesAggregateMinColumns = "name"
	// min by lastSeen
	AdapterDevicesAggregateMinColumnsLastSeen AdapterDevicesAggregateMinColumns = "lastSeen"
	// min by osId
	AdapterDevicesAggregateMinColumnsOsID AdapterDevicesAggregateMinColumns = "osId"
	// min by prettyId
	AdapterDevicesAggregateMinColumnsPrettyID AdapterDevicesAggregateMinColumns = "prettyId"
	// min by domain
	AdapterDevicesAggregateMinColumnsDomain AdapterDevicesAggregateMinColumns = "domain"
	// min by agentVersion
	AdapterDevicesAggregateMinColumnsAgentVersion AdapterDevicesAggregateMinColumns = "agentVersion"
	// min by agentStatus
	AdapterDevicesAggregateMinColumnsAgentStatus AdapterDevicesAggregateMinColumns = "agentStatus"
	// min by agentName
	AdapterDevicesAggregateMinColumnsAgentName AdapterDevicesAggregateMinColumns = "agentName"
	// min by model
	AdapterDevicesAggregateMinColumnsModel AdapterDevicesAggregateMinColumns = "model"
	// min by manufacturer
	AdapterDevicesAggregateMinColumnsManufacturer AdapterDevicesAggregateMinColumns = "manufacturer"
	// min by serial
	AdapterDevicesAggregateMinColumnsSerial AdapterDevicesAggregateMinColumns = "serial"
	// min by family
	AdapterDevicesAggregateMinColumnsFamily AdapterDevicesAggregateMinColumns = "family"
	// min by biosVersion
	AdapterDevicesAggregateMinColumnsBiosVersion AdapterDevicesAggregateMinColumns = "biosVersion"
	// min by biosSerial
	AdapterDevicesAggregateMinColumnsBiosSerial AdapterDevicesAggregateMinColumns = "biosSerial"
)

var AllAdapterDevicesAggregateMinColumns = []AdapterDevicesAggregateMinColumns{
	AdapterDevicesAggregateMinColumnsID,
	AdapterDevicesAggregateMinColumnsFetchCycle,
	AdapterDevicesAggregateMinColumnsAdapterID,
	AdapterDevicesAggregateMinColumnsAdapterName,
	AdapterDevicesAggregateMinColumnsDeviceID,
	AdapterDevicesAggregateMinColumnsFetchTime,
	AdapterDevicesAggregateMinColumnsHostname,
	AdapterDevicesAggregateMinColumnsName,
	AdapterDevicesAggregateMinColumnsLastSeen,
	AdapterDevicesAggregateMinColumnsOsID,
	AdapterDevicesAggregateMinColumnsPrettyID,
	AdapterDevicesAggregateMinColumnsDomain,
	AdapterDevicesAggregateMinColumnsAgentVersion,
	AdapterDevicesAggregateMinColumnsAgentStatus,
	AdapterDevicesAggregateMinColumnsAgentName,
	AdapterDevicesAggregateMinColumnsModel,
	AdapterDevicesAggregateMinColumnsManufacturer,
	AdapterDevicesAggregateMinColumnsSerial,
	AdapterDevicesAggregateMinColumnsFamily,
	AdapterDevicesAggregateMinColumnsBiosVersion,
	AdapterDevicesAggregateMinColumnsBiosSerial,
}

func (e AdapterDevicesAggregateMinColumns) IsValid() bool {
	switch e {
	case AdapterDevicesAggregateMinColumnsID, AdapterDevicesAggregateMinColumnsFetchCycle, AdapterDevicesAggregateMinColumnsAdapterID, AdapterDevicesAggregateMinColumnsAdapterName, AdapterDevicesAggregateMinColumnsDeviceID, AdapterDevicesAggregateMinColumnsFetchTime, AdapterDevicesAggregateMinColumnsHostname, AdapterDevicesAggregateMinColumnsName, AdapterDevicesAggregateMinColumnsLastSeen, AdapterDevicesAggregateMinColumnsOsID, AdapterDevicesAggregateMinColumnsPrettyID, AdapterDevicesAggregateMinColumnsDomain, AdapterDevicesAggregateMinColumnsAgentVersion, AdapterDevicesAggregateMinColumnsAgentStatus, AdapterDevicesAggregateMinColumnsAgentName, AdapterDevicesAggregateMinColumnsModel, AdapterDevicesAggregateMinColumnsManufacturer, AdapterDevicesAggregateMinColumnsSerial, AdapterDevicesAggregateMinColumnsFamily, AdapterDevicesAggregateMinColumnsBiosVersion, AdapterDevicesAggregateMinColumnsBiosSerial:
		return true
	}
	return false
}

func (e AdapterDevicesAggregateMinColumns) String() string {
	return string(e)
}

func (e *AdapterDevicesAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDevicesAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterDevices_aggregate_min_columns", str)
	}
	return nil
}

func (e AdapterDevicesAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterDevicesAggregateSumColumns string

const (
	// sum by fetchCycle
	AdapterDevicesAggregateSumColumnsFetchCycle AdapterDevicesAggregateSumColumns = "fetchCycle"
	// sum by fetchTime
	AdapterDevicesAggregateSumColumnsFetchTime AdapterDevicesAggregateSumColumns = "fetchTime"
	// sum by lastSeen
	AdapterDevicesAggregateSumColumnsLastSeen AdapterDevicesAggregateSumColumns = "lastSeen"
)

var AllAdapterDevicesAggregateSumColumns = []AdapterDevicesAggregateSumColumns{
	AdapterDevicesAggregateSumColumnsFetchCycle,
	AdapterDevicesAggregateSumColumnsFetchTime,
	AdapterDevicesAggregateSumColumnsLastSeen,
}

func (e AdapterDevicesAggregateSumColumns) IsValid() bool {
	switch e {
	case AdapterDevicesAggregateSumColumnsFetchCycle, AdapterDevicesAggregateSumColumnsFetchTime, AdapterDevicesAggregateSumColumnsLastSeen:
		return true
	}
	return false
}

func (e AdapterDevicesAggregateSumColumns) String() string {
	return string(e)
}

func (e *AdapterDevicesAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDevicesAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterDevices_aggregate_sum_columns", str)
	}
	return nil
}

func (e AdapterDevicesAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterUsersAggregateAvgColumns string

const (
	// avg by fetchCycle
	AdapterUsersAggregateAvgColumnsFetchCycle AdapterUsersAggregateAvgColumns = "fetchCycle"
	// avg by fetchTime
	AdapterUsersAggregateAvgColumnsFetchTime AdapterUsersAggregateAvgColumns = "fetchTime"
	// avg by lastSeen
	AdapterUsersAggregateAvgColumnsLastSeen AdapterUsersAggregateAvgColumns = "lastSeen"
)

var AllAdapterUsersAggregateAvgColumns = []AdapterUsersAggregateAvgColumns{
	AdapterUsersAggregateAvgColumnsFetchCycle,
	AdapterUsersAggregateAvgColumnsFetchTime,
	AdapterUsersAggregateAvgColumnsLastSeen,
}

func (e AdapterUsersAggregateAvgColumns) IsValid() bool {
	switch e {
	case AdapterUsersAggregateAvgColumnsFetchCycle, AdapterUsersAggregateAvgColumnsFetchTime, AdapterUsersAggregateAvgColumnsLastSeen:
		return true
	}
	return false
}

func (e AdapterUsersAggregateAvgColumns) String() string {
	return string(e)
}

func (e *AdapterUsersAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUsersAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterUsers_aggregate_avg_columns", str)
	}
	return nil
}

func (e AdapterUsersAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterUsersAggregateColumns string

const (
	// groupBy by id
	AdapterUsersAggregateColumnsID AdapterUsersAggregateColumns = "id"
	// groupBy by fetchCycle
	AdapterUsersAggregateColumnsFetchCycle AdapterUsersAggregateColumns = "fetchCycle"
	// groupBy by adapterId
	AdapterUsersAggregateColumnsAdapterID AdapterUsersAggregateColumns = "adapterId"
	// groupBy by adapterName
	AdapterUsersAggregateColumnsAdapterName AdapterUsersAggregateColumns = "adapterName"
	// groupBy by userId
	AdapterUsersAggregateColumnsUserID AdapterUsersAggregateColumns = "userId"
	// groupBy by fetchTime
	AdapterUsersAggregateColumnsFetchTime AdapterUsersAggregateColumns = "fetchTime"
	// groupBy by lastSeen
	AdapterUsersAggregateColumnsLastSeen AdapterUsersAggregateColumns = "lastSeen"
	// groupBy by username
	AdapterUsersAggregateColumnsUsername AdapterUsersAggregateColumns = "username"
	// groupBy by displayName
	AdapterUsersAggregateColumnsDisplayName AdapterUsersAggregateColumns = "displayName"
	// groupBy by description
	AdapterUsersAggregateColumnsDescription AdapterUsersAggregateColumns = "description"
	// groupBy by domain
	AdapterUsersAggregateColumnsDomain AdapterUsersAggregateColumns = "domain"
	// groupBy by userSid
	AdapterUsersAggregateColumnsUserSid AdapterUsersAggregateColumns = "userSid"
	// groupBy by firstName
	AdapterUsersAggregateColumnsFirstName AdapterUsersAggregateColumns = "firstName"
	// groupBy by lastName
	AdapterUsersAggregateColumnsLastName AdapterUsersAggregateColumns = "lastName"
	// groupBy by mail
	AdapterUsersAggregateColumnsMail AdapterUsersAggregateColumns = "mail"
)

var AllAdapterUsersAggregateColumns = []AdapterUsersAggregateColumns{
	AdapterUsersAggregateColumnsID,
	AdapterUsersAggregateColumnsFetchCycle,
	AdapterUsersAggregateColumnsAdapterID,
	AdapterUsersAggregateColumnsAdapterName,
	AdapterUsersAggregateColumnsUserID,
	AdapterUsersAggregateColumnsFetchTime,
	AdapterUsersAggregateColumnsLastSeen,
	AdapterUsersAggregateColumnsUsername,
	AdapterUsersAggregateColumnsDisplayName,
	AdapterUsersAggregateColumnsDescription,
	AdapterUsersAggregateColumnsDomain,
	AdapterUsersAggregateColumnsUserSid,
	AdapterUsersAggregateColumnsFirstName,
	AdapterUsersAggregateColumnsLastName,
	AdapterUsersAggregateColumnsMail,
}

func (e AdapterUsersAggregateColumns) IsValid() bool {
	switch e {
	case AdapterUsersAggregateColumnsID, AdapterUsersAggregateColumnsFetchCycle, AdapterUsersAggregateColumnsAdapterID, AdapterUsersAggregateColumnsAdapterName, AdapterUsersAggregateColumnsUserID, AdapterUsersAggregateColumnsFetchTime, AdapterUsersAggregateColumnsLastSeen, AdapterUsersAggregateColumnsUsername, AdapterUsersAggregateColumnsDisplayName, AdapterUsersAggregateColumnsDescription, AdapterUsersAggregateColumnsDomain, AdapterUsersAggregateColumnsUserSid, AdapterUsersAggregateColumnsFirstName, AdapterUsersAggregateColumnsLastName, AdapterUsersAggregateColumnsMail:
		return true
	}
	return false
}

func (e AdapterUsersAggregateColumns) String() string {
	return string(e)
}

func (e *AdapterUsersAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUsersAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterUsers_aggregate_columns", str)
	}
	return nil
}

func (e AdapterUsersAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterUsersAggregateMaxColumns string

const (
	// max by id
	AdapterUsersAggregateMaxColumnsID AdapterUsersAggregateMaxColumns = "id"
	// max by fetchCycle
	AdapterUsersAggregateMaxColumnsFetchCycle AdapterUsersAggregateMaxColumns = "fetchCycle"
	// max by adapterId
	AdapterUsersAggregateMaxColumnsAdapterID AdapterUsersAggregateMaxColumns = "adapterId"
	// max by adapterName
	AdapterUsersAggregateMaxColumnsAdapterName AdapterUsersAggregateMaxColumns = "adapterName"
	// max by userId
	AdapterUsersAggregateMaxColumnsUserID AdapterUsersAggregateMaxColumns = "userId"
	// max by fetchTime
	AdapterUsersAggregateMaxColumnsFetchTime AdapterUsersAggregateMaxColumns = "fetchTime"
	// max by lastSeen
	AdapterUsersAggregateMaxColumnsLastSeen AdapterUsersAggregateMaxColumns = "lastSeen"
	// max by username
	AdapterUsersAggregateMaxColumnsUsername AdapterUsersAggregateMaxColumns = "username"
	// max by displayName
	AdapterUsersAggregateMaxColumnsDisplayName AdapterUsersAggregateMaxColumns = "displayName"
	// max by description
	AdapterUsersAggregateMaxColumnsDescription AdapterUsersAggregateMaxColumns = "description"
	// max by domain
	AdapterUsersAggregateMaxColumnsDomain AdapterUsersAggregateMaxColumns = "domain"
	// max by userSid
	AdapterUsersAggregateMaxColumnsUserSid AdapterUsersAggregateMaxColumns = "userSid"
	// max by firstName
	AdapterUsersAggregateMaxColumnsFirstName AdapterUsersAggregateMaxColumns = "firstName"
	// max by lastName
	AdapterUsersAggregateMaxColumnsLastName AdapterUsersAggregateMaxColumns = "lastName"
	// max by mail
	AdapterUsersAggregateMaxColumnsMail AdapterUsersAggregateMaxColumns = "mail"
)

var AllAdapterUsersAggregateMaxColumns = []AdapterUsersAggregateMaxColumns{
	AdapterUsersAggregateMaxColumnsID,
	AdapterUsersAggregateMaxColumnsFetchCycle,
	AdapterUsersAggregateMaxColumnsAdapterID,
	AdapterUsersAggregateMaxColumnsAdapterName,
	AdapterUsersAggregateMaxColumnsUserID,
	AdapterUsersAggregateMaxColumnsFetchTime,
	AdapterUsersAggregateMaxColumnsLastSeen,
	AdapterUsersAggregateMaxColumnsUsername,
	AdapterUsersAggregateMaxColumnsDisplayName,
	AdapterUsersAggregateMaxColumnsDescription,
	AdapterUsersAggregateMaxColumnsDomain,
	AdapterUsersAggregateMaxColumnsUserSid,
	AdapterUsersAggregateMaxColumnsFirstName,
	AdapterUsersAggregateMaxColumnsLastName,
	AdapterUsersAggregateMaxColumnsMail,
}

func (e AdapterUsersAggregateMaxColumns) IsValid() bool {
	switch e {
	case AdapterUsersAggregateMaxColumnsID, AdapterUsersAggregateMaxColumnsFetchCycle, AdapterUsersAggregateMaxColumnsAdapterID, AdapterUsersAggregateMaxColumnsAdapterName, AdapterUsersAggregateMaxColumnsUserID, AdapterUsersAggregateMaxColumnsFetchTime, AdapterUsersAggregateMaxColumnsLastSeen, AdapterUsersAggregateMaxColumnsUsername, AdapterUsersAggregateMaxColumnsDisplayName, AdapterUsersAggregateMaxColumnsDescription, AdapterUsersAggregateMaxColumnsDomain, AdapterUsersAggregateMaxColumnsUserSid, AdapterUsersAggregateMaxColumnsFirstName, AdapterUsersAggregateMaxColumnsLastName, AdapterUsersAggregateMaxColumnsMail:
		return true
	}
	return false
}

func (e AdapterUsersAggregateMaxColumns) String() string {
	return string(e)
}

func (e *AdapterUsersAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUsersAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterUsers_aggregate_max_columns", str)
	}
	return nil
}

func (e AdapterUsersAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterUsersAggregateMinColumns string

const (
	// min by id
	AdapterUsersAggregateMinColumnsID AdapterUsersAggregateMinColumns = "id"
	// min by fetchCycle
	AdapterUsersAggregateMinColumnsFetchCycle AdapterUsersAggregateMinColumns = "fetchCycle"
	// min by adapterId
	AdapterUsersAggregateMinColumnsAdapterID AdapterUsersAggregateMinColumns = "adapterId"
	// min by adapterName
	AdapterUsersAggregateMinColumnsAdapterName AdapterUsersAggregateMinColumns = "adapterName"
	// min by userId
	AdapterUsersAggregateMinColumnsUserID AdapterUsersAggregateMinColumns = "userId"
	// min by fetchTime
	AdapterUsersAggregateMinColumnsFetchTime AdapterUsersAggregateMinColumns = "fetchTime"
	// min by lastSeen
	AdapterUsersAggregateMinColumnsLastSeen AdapterUsersAggregateMinColumns = "lastSeen"
	// min by username
	AdapterUsersAggregateMinColumnsUsername AdapterUsersAggregateMinColumns = "username"
	// min by displayName
	AdapterUsersAggregateMinColumnsDisplayName AdapterUsersAggregateMinColumns = "displayName"
	// min by description
	AdapterUsersAggregateMinColumnsDescription AdapterUsersAggregateMinColumns = "description"
	// min by domain
	AdapterUsersAggregateMinColumnsDomain AdapterUsersAggregateMinColumns = "domain"
	// min by userSid
	AdapterUsersAggregateMinColumnsUserSid AdapterUsersAggregateMinColumns = "userSid"
	// min by firstName
	AdapterUsersAggregateMinColumnsFirstName AdapterUsersAggregateMinColumns = "firstName"
	// min by lastName
	AdapterUsersAggregateMinColumnsLastName AdapterUsersAggregateMinColumns = "lastName"
	// min by mail
	AdapterUsersAggregateMinColumnsMail AdapterUsersAggregateMinColumns = "mail"
)

var AllAdapterUsersAggregateMinColumns = []AdapterUsersAggregateMinColumns{
	AdapterUsersAggregateMinColumnsID,
	AdapterUsersAggregateMinColumnsFetchCycle,
	AdapterUsersAggregateMinColumnsAdapterID,
	AdapterUsersAggregateMinColumnsAdapterName,
	AdapterUsersAggregateMinColumnsUserID,
	AdapterUsersAggregateMinColumnsFetchTime,
	AdapterUsersAggregateMinColumnsLastSeen,
	AdapterUsersAggregateMinColumnsUsername,
	AdapterUsersAggregateMinColumnsDisplayName,
	AdapterUsersAggregateMinColumnsDescription,
	AdapterUsersAggregateMinColumnsDomain,
	AdapterUsersAggregateMinColumnsUserSid,
	AdapterUsersAggregateMinColumnsFirstName,
	AdapterUsersAggregateMinColumnsLastName,
	AdapterUsersAggregateMinColumnsMail,
}

func (e AdapterUsersAggregateMinColumns) IsValid() bool {
	switch e {
	case AdapterUsersAggregateMinColumnsID, AdapterUsersAggregateMinColumnsFetchCycle, AdapterUsersAggregateMinColumnsAdapterID, AdapterUsersAggregateMinColumnsAdapterName, AdapterUsersAggregateMinColumnsUserID, AdapterUsersAggregateMinColumnsFetchTime, AdapterUsersAggregateMinColumnsLastSeen, AdapterUsersAggregateMinColumnsUsername, AdapterUsersAggregateMinColumnsDisplayName, AdapterUsersAggregateMinColumnsDescription, AdapterUsersAggregateMinColumnsDomain, AdapterUsersAggregateMinColumnsUserSid, AdapterUsersAggregateMinColumnsFirstName, AdapterUsersAggregateMinColumnsLastName, AdapterUsersAggregateMinColumnsMail:
		return true
	}
	return false
}

func (e AdapterUsersAggregateMinColumns) String() string {
	return string(e)
}

func (e *AdapterUsersAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUsersAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterUsers_aggregate_min_columns", str)
	}
	return nil
}

func (e AdapterUsersAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterUsersAggregateSumColumns string

const (
	// sum by fetchCycle
	AdapterUsersAggregateSumColumnsFetchCycle AdapterUsersAggregateSumColumns = "fetchCycle"
	// sum by fetchTime
	AdapterUsersAggregateSumColumnsFetchTime AdapterUsersAggregateSumColumns = "fetchTime"
	// sum by lastSeen
	AdapterUsersAggregateSumColumnsLastSeen AdapterUsersAggregateSumColumns = "lastSeen"
)

var AllAdapterUsersAggregateSumColumns = []AdapterUsersAggregateSumColumns{
	AdapterUsersAggregateSumColumnsFetchCycle,
	AdapterUsersAggregateSumColumnsFetchTime,
	AdapterUsersAggregateSumColumnsLastSeen,
}

func (e AdapterUsersAggregateSumColumns) IsValid() bool {
	switch e {
	case AdapterUsersAggregateSumColumnsFetchCycle, AdapterUsersAggregateSumColumnsFetchTime, AdapterUsersAggregateSumColumnsLastSeen:
		return true
	}
	return false
}

func (e AdapterUsersAggregateSumColumns) String() string {
	return string(e)
}

func (e *AdapterUsersAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUsersAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterUsers_aggregate_sum_columns", str)
	}
	return nil
}

func (e AdapterUsersAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for AdapterDeviceAdmin
type AdapterDeviceAdminOrderBy string

const (
	// Order by name in an ascending order
	AdapterDeviceAdminOrderByNameAsc AdapterDeviceAdminOrderBy = "name_ASC"
	// Order by name in a descending order
	AdapterDeviceAdminOrderByNameDesc AdapterDeviceAdminOrderBy = "name_DESC"
)

var AllAdapterDeviceAdminOrderBy = []AdapterDeviceAdminOrderBy{
	AdapterDeviceAdminOrderByNameAsc,
	AdapterDeviceAdminOrderByNameDesc,
}

func (e AdapterDeviceAdminOrderBy) IsValid() bool {
	switch e {
	case AdapterDeviceAdminOrderByNameAsc, AdapterDeviceAdminOrderByNameDesc:
		return true
	}
	return false
}

func (e AdapterDeviceAdminOrderBy) String() string {
	return string(e)
}

func (e *AdapterDeviceAdminOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDeviceAdminOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapter_device_admin_order_by", str)
	}
	return nil
}

func (e AdapterDeviceAdminOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for AdapterDevice
type AdapterDeviceOrderBy string

const (
	// Order by fetchCycle in an ascending order
	AdapterDeviceOrderByFetchCycleAsc AdapterDeviceOrderBy = "fetchCycle_ASC"
	// Order by fetchCycle in a descending order
	AdapterDeviceOrderByFetchCycleDesc AdapterDeviceOrderBy = "fetchCycle_DESC"
	// Order by adapterId in an ascending order
	AdapterDeviceOrderByAdapterIDAsc AdapterDeviceOrderBy = "adapterId_ASC"
	// Order by adapterId in a descending order
	AdapterDeviceOrderByAdapterIDDesc AdapterDeviceOrderBy = "adapterId_DESC"
	// Order by adapterName in an ascending order
	AdapterDeviceOrderByAdapterNameAsc AdapterDeviceOrderBy = "adapterName_ASC"
	// Order by adapterName in a descending order
	AdapterDeviceOrderByAdapterNameDesc AdapterDeviceOrderBy = "adapterName_DESC"
	// Order by fetchTime in an ascending order
	AdapterDeviceOrderByFetchTimeAsc AdapterDeviceOrderBy = "fetchTime_ASC"
	// Order by fetchTime in a descending order
	AdapterDeviceOrderByFetchTimeDesc AdapterDeviceOrderBy = "fetchTime_DESC"
	// Order by hostname in an ascending order
	AdapterDeviceOrderByHostnameAsc AdapterDeviceOrderBy = "hostname_ASC"
	// Order by hostname in a descending order
	AdapterDeviceOrderByHostnameDesc AdapterDeviceOrderBy = "hostname_DESC"
	// Order by name in an ascending order
	AdapterDeviceOrderByNameAsc AdapterDeviceOrderBy = "name_ASC"
	// Order by name in a descending order
	AdapterDeviceOrderByNameDesc AdapterDeviceOrderBy = "name_DESC"
	// Order by lastSeen in an ascending order
	AdapterDeviceOrderByLastSeenAsc AdapterDeviceOrderBy = "lastSeen_ASC"
	// Order by lastSeen in a descending order
	AdapterDeviceOrderByLastSeenDesc AdapterDeviceOrderBy = "lastSeen_DESC"
	// Order by prettyId in an ascending order
	AdapterDeviceOrderByPrettyIDAsc AdapterDeviceOrderBy = "prettyId_ASC"
	// Order by prettyId in a descending order
	AdapterDeviceOrderByPrettyIDDesc AdapterDeviceOrderBy = "prettyId_DESC"
	// Order by domain in an ascending order
	AdapterDeviceOrderByDomainAsc AdapterDeviceOrderBy = "domain_ASC"
	// Order by domain in a descending order
	AdapterDeviceOrderByDomainDesc AdapterDeviceOrderBy = "domain_DESC"
	// Order by agentVersion in an ascending order
	AdapterDeviceOrderByAgentVersionAsc AdapterDeviceOrderBy = "agentVersion_ASC"
	// Order by agentVersion in a descending order
	AdapterDeviceOrderByAgentVersionDesc AdapterDeviceOrderBy = "agentVersion_DESC"
	// Order by agentStatus in an ascending order
	AdapterDeviceOrderByAgentStatusAsc AdapterDeviceOrderBy = "agentStatus_ASC"
	// Order by agentStatus in a descending order
	AdapterDeviceOrderByAgentStatusDesc AdapterDeviceOrderBy = "agentStatus_DESC"
	// Order by agentName in an ascending order
	AdapterDeviceOrderByAgentNameAsc AdapterDeviceOrderBy = "agentName_ASC"
	// Order by agentName in a descending order
	AdapterDeviceOrderByAgentNameDesc AdapterDeviceOrderBy = "agentName_DESC"
	// Order by model in an ascending order
	AdapterDeviceOrderByModelAsc AdapterDeviceOrderBy = "model_ASC"
	// Order by model in a descending order
	AdapterDeviceOrderByModelDesc AdapterDeviceOrderBy = "model_DESC"
	// Order by manufacturer in an ascending order
	AdapterDeviceOrderByManufacturerAsc AdapterDeviceOrderBy = "manufacturer_ASC"
	// Order by manufacturer in a descending order
	AdapterDeviceOrderByManufacturerDesc AdapterDeviceOrderBy = "manufacturer_DESC"
	// Order by serial in an ascending order
	AdapterDeviceOrderBySerialAsc AdapterDeviceOrderBy = "serial_ASC"
	// Order by serial in a descending order
	AdapterDeviceOrderBySerialDesc AdapterDeviceOrderBy = "serial_DESC"
	// Order by family in an ascending order
	AdapterDeviceOrderByFamilyAsc AdapterDeviceOrderBy = "family_ASC"
	// Order by family in a descending order
	AdapterDeviceOrderByFamilyDesc AdapterDeviceOrderBy = "family_DESC"
	// Order by biosVersion in an ascending order
	AdapterDeviceOrderByBiosVersionAsc AdapterDeviceOrderBy = "biosVersion_ASC"
	// Order by biosVersion in a descending order
	AdapterDeviceOrderByBiosVersionDesc AdapterDeviceOrderBy = "biosVersion_DESC"
	// Order by biosSerial in an ascending order
	AdapterDeviceOrderByBiosSerialAsc AdapterDeviceOrderBy = "biosSerial_ASC"
	// Order by biosSerial in a descending order
	AdapterDeviceOrderByBiosSerialDesc AdapterDeviceOrderBy = "biosSerial_DESC"
)

var AllAdapterDeviceOrderBy = []AdapterDeviceOrderBy{
	AdapterDeviceOrderByFetchCycleAsc,
	AdapterDeviceOrderByFetchCycleDesc,
	AdapterDeviceOrderByAdapterIDAsc,
	AdapterDeviceOrderByAdapterIDDesc,
	AdapterDeviceOrderByAdapterNameAsc,
	AdapterDeviceOrderByAdapterNameDesc,
	AdapterDeviceOrderByFetchTimeAsc,
	AdapterDeviceOrderByFetchTimeDesc,
	AdapterDeviceOrderByHostnameAsc,
	AdapterDeviceOrderByHostnameDesc,
	AdapterDeviceOrderByNameAsc,
	AdapterDeviceOrderByNameDesc,
	AdapterDeviceOrderByLastSeenAsc,
	AdapterDeviceOrderByLastSeenDesc,
	AdapterDeviceOrderByPrettyIDAsc,
	AdapterDeviceOrderByPrettyIDDesc,
	AdapterDeviceOrderByDomainAsc,
	AdapterDeviceOrderByDomainDesc,
	AdapterDeviceOrderByAgentVersionAsc,
	AdapterDeviceOrderByAgentVersionDesc,
	AdapterDeviceOrderByAgentStatusAsc,
	AdapterDeviceOrderByAgentStatusDesc,
	AdapterDeviceOrderByAgentNameAsc,
	AdapterDeviceOrderByAgentNameDesc,
	AdapterDeviceOrderByModelAsc,
	AdapterDeviceOrderByModelDesc,
	AdapterDeviceOrderByManufacturerAsc,
	AdapterDeviceOrderByManufacturerDesc,
	AdapterDeviceOrderBySerialAsc,
	AdapterDeviceOrderBySerialDesc,
	AdapterDeviceOrderByFamilyAsc,
	AdapterDeviceOrderByFamilyDesc,
	AdapterDeviceOrderByBiosVersionAsc,
	AdapterDeviceOrderByBiosVersionDesc,
	AdapterDeviceOrderByBiosSerialAsc,
	AdapterDeviceOrderByBiosSerialDesc,
}

func (e AdapterDeviceOrderBy) IsValid() bool {
	switch e {
	case AdapterDeviceOrderByFetchCycleAsc, AdapterDeviceOrderByFetchCycleDesc, AdapterDeviceOrderByAdapterIDAsc, AdapterDeviceOrderByAdapterIDDesc, AdapterDeviceOrderByAdapterNameAsc, AdapterDeviceOrderByAdapterNameDesc, AdapterDeviceOrderByFetchTimeAsc, AdapterDeviceOrderByFetchTimeDesc, AdapterDeviceOrderByHostnameAsc, AdapterDeviceOrderByHostnameDesc, AdapterDeviceOrderByNameAsc, AdapterDeviceOrderByNameDesc, AdapterDeviceOrderByLastSeenAsc, AdapterDeviceOrderByLastSeenDesc, AdapterDeviceOrderByPrettyIDAsc, AdapterDeviceOrderByPrettyIDDesc, AdapterDeviceOrderByDomainAsc, AdapterDeviceOrderByDomainDesc, AdapterDeviceOrderByAgentVersionAsc, AdapterDeviceOrderByAgentVersionDesc, AdapterDeviceOrderByAgentStatusAsc, AdapterDeviceOrderByAgentStatusDesc, AdapterDeviceOrderByAgentNameAsc, AdapterDeviceOrderByAgentNameDesc, AdapterDeviceOrderByModelAsc, AdapterDeviceOrderByModelDesc, AdapterDeviceOrderByManufacturerAsc, AdapterDeviceOrderByManufacturerDesc, AdapterDeviceOrderBySerialAsc, AdapterDeviceOrderBySerialDesc, AdapterDeviceOrderByFamilyAsc, AdapterDeviceOrderByFamilyDesc, AdapterDeviceOrderByBiosVersionAsc, AdapterDeviceOrderByBiosVersionDesc, AdapterDeviceOrderByBiosSerialAsc, AdapterDeviceOrderByBiosSerialDesc:
		return true
	}
	return false
}

func (e AdapterDeviceOrderBy) String() string {
	return string(e)
}

func (e *AdapterDeviceOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDeviceOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapter_device_order_by", str)
	}
	return nil
}

func (e AdapterDeviceOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for AdapterDeviceUser
type AdapterDeviceUserOrderBy string

const (
	// Order by sid in an ascending order
	AdapterDeviceUserOrderBySidAsc AdapterDeviceUserOrderBy = "sid_ASC"
	// Order by sid in a descending order
	AdapterDeviceUserOrderBySidDesc AdapterDeviceUserOrderBy = "sid_DESC"
	// Order by username in an ascending order
	AdapterDeviceUserOrderByUsernameAsc AdapterDeviceUserOrderBy = "username_ASC"
	// Order by username in a descending order
	AdapterDeviceUserOrderByUsernameDesc AdapterDeviceUserOrderBy = "username_DESC"
	// Order by lastUseDate in an ascending order
	AdapterDeviceUserOrderByLastUseDateAsc AdapterDeviceUserOrderBy = "lastUseDate_ASC"
	// Order by lastUseDate in a descending order
	AdapterDeviceUserOrderByLastUseDateDesc AdapterDeviceUserOrderBy = "lastUseDate_DESC"
	// Order by passwordMaxAge in an ascending order
	AdapterDeviceUserOrderByPasswordMaxAgeAsc AdapterDeviceUserOrderBy = "passwordMaxAge_ASC"
	// Order by passwordMaxAge in a descending order
	AdapterDeviceUserOrderByPasswordMaxAgeDesc AdapterDeviceUserOrderBy = "passwordMaxAge_DESC"
	// Order by interpreter in an ascending order
	AdapterDeviceUserOrderByInterpreterAsc AdapterDeviceUserOrderBy = "interpreter_ASC"
	// Order by interpreter in a descending order
	AdapterDeviceUserOrderByInterpreterDesc AdapterDeviceUserOrderBy = "interpreter_DESC"
)

var AllAdapterDeviceUserOrderBy = []AdapterDeviceUserOrderBy{
	AdapterDeviceUserOrderBySidAsc,
	AdapterDeviceUserOrderBySidDesc,
	AdapterDeviceUserOrderByUsernameAsc,
	AdapterDeviceUserOrderByUsernameDesc,
	AdapterDeviceUserOrderByLastUseDateAsc,
	AdapterDeviceUserOrderByLastUseDateDesc,
	AdapterDeviceUserOrderByPasswordMaxAgeAsc,
	AdapterDeviceUserOrderByPasswordMaxAgeDesc,
	AdapterDeviceUserOrderByInterpreterAsc,
	AdapterDeviceUserOrderByInterpreterDesc,
}

func (e AdapterDeviceUserOrderBy) IsValid() bool {
	switch e {
	case AdapterDeviceUserOrderBySidAsc, AdapterDeviceUserOrderBySidDesc, AdapterDeviceUserOrderByUsernameAsc, AdapterDeviceUserOrderByUsernameDesc, AdapterDeviceUserOrderByLastUseDateAsc, AdapterDeviceUserOrderByLastUseDateDesc, AdapterDeviceUserOrderByPasswordMaxAgeAsc, AdapterDeviceUserOrderByPasswordMaxAgeDesc, AdapterDeviceUserOrderByInterpreterAsc, AdapterDeviceUserOrderByInterpreterDesc:
		return true
	}
	return false
}

func (e AdapterDeviceUserOrderBy) String() string {
	return string(e)
}

func (e *AdapterDeviceUserOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDeviceUserOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapter_device_user_order_by", str)
	}
	return nil
}

func (e AdapterDeviceUserOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for Adapter
type AdapterOrderBy string

const (
	// Order by id in an ascending order
	AdapterOrderByIDAsc AdapterOrderBy = "id_ASC"
	// Order by id in a descending order
	AdapterOrderByIDDesc AdapterOrderBy = "id_DESC"
	// Order by name in an ascending order
	AdapterOrderByNameAsc AdapterOrderBy = "name_ASC"
	// Order by name in a descending order
	AdapterOrderByNameDesc AdapterOrderBy = "name_DESC"
)

var AllAdapterOrderBy = []AdapterOrderBy{
	AdapterOrderByIDAsc,
	AdapterOrderByIDDesc,
	AdapterOrderByNameAsc,
	AdapterOrderByNameDesc,
}

func (e AdapterOrderBy) IsValid() bool {
	switch e {
	case AdapterOrderByIDAsc, AdapterOrderByIDDesc, AdapterOrderByNameAsc, AdapterOrderByNameDesc:
		return true
	}
	return false
}

func (e AdapterOrderBy) String() string {
	return string(e)
}

func (e *AdapterOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapter_order_by", str)
	}
	return nil
}

func (e AdapterOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for AdapterUser
type AdapterUserOrderBy string

const (
	// Order by fetchCycle in an ascending order
	AdapterUserOrderByFetchCycleAsc AdapterUserOrderBy = "fetchCycle_ASC"
	// Order by fetchCycle in a descending order
	AdapterUserOrderByFetchCycleDesc AdapterUserOrderBy = "fetchCycle_DESC"
	// Order by adapterId in an ascending order
	AdapterUserOrderByAdapterIDAsc AdapterUserOrderBy = "adapterId_ASC"
	// Order by adapterId in a descending order
	AdapterUserOrderByAdapterIDDesc AdapterUserOrderBy = "adapterId_DESC"
	// Order by adapterName in an ascending order
	AdapterUserOrderByAdapterNameAsc AdapterUserOrderBy = "adapterName_ASC"
	// Order by adapterName in a descending order
	AdapterUserOrderByAdapterNameDesc AdapterUserOrderBy = "adapterName_DESC"
	// Order by fetchTime in an ascending order
	AdapterUserOrderByFetchTimeAsc AdapterUserOrderBy = "fetchTime_ASC"
	// Order by fetchTime in a descending order
	AdapterUserOrderByFetchTimeDesc AdapterUserOrderBy = "fetchTime_DESC"
	// Order by lastSeen in an ascending order
	AdapterUserOrderByLastSeenAsc AdapterUserOrderBy = "lastSeen_ASC"
	// Order by lastSeen in a descending order
	AdapterUserOrderByLastSeenDesc AdapterUserOrderBy = "lastSeen_DESC"
	// Order by username in an ascending order
	AdapterUserOrderByUsernameAsc AdapterUserOrderBy = "username_ASC"
	// Order by username in a descending order
	AdapterUserOrderByUsernameDesc AdapterUserOrderBy = "username_DESC"
	// Order by displayName in an ascending order
	AdapterUserOrderByDisplayNameAsc AdapterUserOrderBy = "displayName_ASC"
	// Order by displayName in a descending order
	AdapterUserOrderByDisplayNameDesc AdapterUserOrderBy = "displayName_DESC"
	// Order by description in an ascending order
	AdapterUserOrderByDescriptionAsc AdapterUserOrderBy = "description_ASC"
	// Order by description in a descending order
	AdapterUserOrderByDescriptionDesc AdapterUserOrderBy = "description_DESC"
	// Order by domain in an ascending order
	AdapterUserOrderByDomainAsc AdapterUserOrderBy = "domain_ASC"
	// Order by domain in a descending order
	AdapterUserOrderByDomainDesc AdapterUserOrderBy = "domain_DESC"
	// Order by userSid in an ascending order
	AdapterUserOrderByUserSidAsc AdapterUserOrderBy = "userSid_ASC"
	// Order by userSid in a descending order
	AdapterUserOrderByUserSidDesc AdapterUserOrderBy = "userSid_DESC"
	// Order by firstName in an ascending order
	AdapterUserOrderByFirstNameAsc AdapterUserOrderBy = "firstName_ASC"
	// Order by firstName in a descending order
	AdapterUserOrderByFirstNameDesc AdapterUserOrderBy = "firstName_DESC"
	// Order by lastName in an ascending order
	AdapterUserOrderByLastNameAsc AdapterUserOrderBy = "lastName_ASC"
	// Order by lastName in a descending order
	AdapterUserOrderByLastNameDesc AdapterUserOrderBy = "lastName_DESC"
	// Order by mail in an ascending order
	AdapterUserOrderByMailAsc AdapterUserOrderBy = "mail_ASC"
	// Order by mail in a descending order
	AdapterUserOrderByMailDesc AdapterUserOrderBy = "mail_DESC"
)

var AllAdapterUserOrderBy = []AdapterUserOrderBy{
	AdapterUserOrderByFetchCycleAsc,
	AdapterUserOrderByFetchCycleDesc,
	AdapterUserOrderByAdapterIDAsc,
	AdapterUserOrderByAdapterIDDesc,
	AdapterUserOrderByAdapterNameAsc,
	AdapterUserOrderByAdapterNameDesc,
	AdapterUserOrderByFetchTimeAsc,
	AdapterUserOrderByFetchTimeDesc,
	AdapterUserOrderByLastSeenAsc,
	AdapterUserOrderByLastSeenDesc,
	AdapterUserOrderByUsernameAsc,
	AdapterUserOrderByUsernameDesc,
	AdapterUserOrderByDisplayNameAsc,
	AdapterUserOrderByDisplayNameDesc,
	AdapterUserOrderByDescriptionAsc,
	AdapterUserOrderByDescriptionDesc,
	AdapterUserOrderByDomainAsc,
	AdapterUserOrderByDomainDesc,
	AdapterUserOrderByUserSidAsc,
	AdapterUserOrderByUserSidDesc,
	AdapterUserOrderByFirstNameAsc,
	AdapterUserOrderByFirstNameDesc,
	AdapterUserOrderByLastNameAsc,
	AdapterUserOrderByLastNameDesc,
	AdapterUserOrderByMailAsc,
	AdapterUserOrderByMailDesc,
}

func (e AdapterUserOrderBy) IsValid() bool {
	switch e {
	case AdapterUserOrderByFetchCycleAsc, AdapterUserOrderByFetchCycleDesc, AdapterUserOrderByAdapterIDAsc, AdapterUserOrderByAdapterIDDesc, AdapterUserOrderByAdapterNameAsc, AdapterUserOrderByAdapterNameDesc, AdapterUserOrderByFetchTimeAsc, AdapterUserOrderByFetchTimeDesc, AdapterUserOrderByLastSeenAsc, AdapterUserOrderByLastSeenDesc, AdapterUserOrderByUsernameAsc, AdapterUserOrderByUsernameDesc, AdapterUserOrderByDisplayNameAsc, AdapterUserOrderByDisplayNameDesc, AdapterUserOrderByDescriptionAsc, AdapterUserOrderByDescriptionDesc, AdapterUserOrderByDomainAsc, AdapterUserOrderByDomainDesc, AdapterUserOrderByUserSidAsc, AdapterUserOrderByUserSidDesc, AdapterUserOrderByFirstNameAsc, AdapterUserOrderByFirstNameDesc, AdapterUserOrderByLastNameAsc, AdapterUserOrderByLastNameDesc, AdapterUserOrderByMailAsc, AdapterUserOrderByMailDesc:
		return true
	}
	return false
}

func (e AdapterUserOrderBy) String() string {
	return string(e)
}

func (e *AdapterUserOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUserOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapter_user_order_by", str)
	}
	return nil
}

func (e AdapterUserOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for csGroup
type CsGroupOrderBy string

const (
	// Order by id in an ascending order
	CsGroupOrderByIDAsc CsGroupOrderBy = "id_ASC"
	// Order by id in a descending order
	CsGroupOrderByIDDesc CsGroupOrderBy = "id_DESC"
	// Order by name in an ascending order
	CsGroupOrderByNameAsc CsGroupOrderBy = "name_ASC"
	// Order by name in a descending order
	CsGroupOrderByNameDesc CsGroupOrderBy = "name_DESC"
	// Order by createdBy in an ascending order
	CsGroupOrderByCreatedByAsc CsGroupOrderBy = "createdBy_ASC"
	// Order by createdBy in a descending order
	CsGroupOrderByCreatedByDesc CsGroupOrderBy = "createdBy_DESC"
	// Order by createdTimestamp in an ascending order
	CsGroupOrderByCreatedTimestampAsc CsGroupOrderBy = "createdTimestamp_ASC"
	// Order by createdTimestamp in a descending order
	CsGroupOrderByCreatedTimestampDesc CsGroupOrderBy = "createdTimestamp_DESC"
	// Order by description in an ascending order
	CsGroupOrderByDescriptionAsc CsGroupOrderBy = "description_ASC"
	// Order by description in a descending order
	CsGroupOrderByDescriptionDesc CsGroupOrderBy = "description_DESC"
	// Order by groupType in an ascending order
	CsGroupOrderByGroupTypeAsc CsGroupOrderBy = "groupType_ASC"
	// Order by groupType in a descending order
	CsGroupOrderByGroupTypeDesc CsGroupOrderBy = "groupType_DESC"
	// Order by modifiedBy in an ascending order
	CsGroupOrderByModifiedByAsc CsGroupOrderBy = "modifiedBy_ASC"
	// Order by modifiedBy in a descending order
	CsGroupOrderByModifiedByDesc CsGroupOrderBy = "modifiedBy_DESC"
	// Order by modifiedTime in an ascending order
	CsGroupOrderByModifiedTimeAsc CsGroupOrderBy = "modifiedTime_ASC"
	// Order by modifiedTime in a descending order
	CsGroupOrderByModifiedTimeDesc CsGroupOrderBy = "modifiedTime_DESC"
)

var AllCsGroupOrderBy = []CsGroupOrderBy{
	CsGroupOrderByIDAsc,
	CsGroupOrderByIDDesc,
	CsGroupOrderByNameAsc,
	CsGroupOrderByNameDesc,
	CsGroupOrderByCreatedByAsc,
	CsGroupOrderByCreatedByDesc,
	CsGroupOrderByCreatedTimestampAsc,
	CsGroupOrderByCreatedTimestampDesc,
	CsGroupOrderByDescriptionAsc,
	CsGroupOrderByDescriptionDesc,
	CsGroupOrderByGroupTypeAsc,
	CsGroupOrderByGroupTypeDesc,
	CsGroupOrderByModifiedByAsc,
	CsGroupOrderByModifiedByDesc,
	CsGroupOrderByModifiedTimeAsc,
	CsGroupOrderByModifiedTimeDesc,
}

func (e CsGroupOrderBy) IsValid() bool {
	switch e {
	case CsGroupOrderByIDAsc, CsGroupOrderByIDDesc, CsGroupOrderByNameAsc, CsGroupOrderByNameDesc, CsGroupOrderByCreatedByAsc, CsGroupOrderByCreatedByDesc, CsGroupOrderByCreatedTimestampAsc, CsGroupOrderByCreatedTimestampDesc, CsGroupOrderByDescriptionAsc, CsGroupOrderByDescriptionDesc, CsGroupOrderByGroupTypeAsc, CsGroupOrderByGroupTypeDesc, CsGroupOrderByModifiedByAsc, CsGroupOrderByModifiedByDesc, CsGroupOrderByModifiedTimeAsc, CsGroupOrderByModifiedTimeDesc:
		return true
	}
	return false
}

func (e CsGroupOrderBy) String() string {
	return string(e)
}

func (e *CsGroupOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CsGroupOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid cs_group_order_by", str)
	}
	return nil
}

func (e CsGroupOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for csPolicy
type CsPolicyOrderBy string

const (
	// Order by name in an ascending order
	CsPolicyOrderByNameAsc CsPolicyOrderBy = "name_ASC"
	// Order by name in a descending order
	CsPolicyOrderByNameDesc CsPolicyOrderBy = "name_DESC"
	// Order by description in an ascending order
	CsPolicyOrderByDescriptionAsc CsPolicyOrderBy = "description_ASC"
	// Order by description in a descending order
	CsPolicyOrderByDescriptionDesc CsPolicyOrderBy = "description_DESC"
	// Order by platformName in an ascending order
	CsPolicyOrderByPlatformNameAsc CsPolicyOrderBy = "platformName_ASC"
	// Order by platformName in a descending order
	CsPolicyOrderByPlatformNameDesc CsPolicyOrderBy = "platformName_DESC"
	// Order by createdBy in an ascending order
	CsPolicyOrderByCreatedByAsc CsPolicyOrderBy = "createdBy_ASC"
	// Order by createdBy in a descending order
	CsPolicyOrderByCreatedByDesc CsPolicyOrderBy = "createdBy_DESC"
	// Order by createdTime in an ascending order
	CsPolicyOrderByCreatedTimeAsc CsPolicyOrderBy = "createdTime_ASC"
	// Order by createdTime in a descending order
	CsPolicyOrderByCreatedTimeDesc CsPolicyOrderBy = "createdTime_DESC"
)

var AllCsPolicyOrderBy = []CsPolicyOrderBy{
	CsPolicyOrderByNameAsc,
	CsPolicyOrderByNameDesc,
	CsPolicyOrderByDescriptionAsc,
	CsPolicyOrderByDescriptionDesc,
	CsPolicyOrderByPlatformNameAsc,
	CsPolicyOrderByPlatformNameDesc,
	CsPolicyOrderByCreatedByAsc,
	CsPolicyOrderByCreatedByDesc,
	CsPolicyOrderByCreatedTimeAsc,
	CsPolicyOrderByCreatedTimeDesc,
}

func (e CsPolicyOrderBy) IsValid() bool {
	switch e {
	case CsPolicyOrderByNameAsc, CsPolicyOrderByNameDesc, CsPolicyOrderByDescriptionAsc, CsPolicyOrderByDescriptionDesc, CsPolicyOrderByPlatformNameAsc, CsPolicyOrderByPlatformNameDesc, CsPolicyOrderByCreatedByAsc, CsPolicyOrderByCreatedByDesc, CsPolicyOrderByCreatedTimeAsc, CsPolicyOrderByCreatedTimeDesc:
		return true
	}
	return false
}

func (e CsPolicyOrderBy) String() string {
	return string(e)
}

func (e *CsPolicyOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CsPolicyOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid cs_policy_order_by", str)
	}
	return nil
}

func (e CsPolicyOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for csPreventionSettings
type CsPreventionSettingsOrderBy string

const (
	// Order by name in an ascending order
	CsPreventionSettingsOrderByNameAsc CsPreventionSettingsOrderBy = "name_ASC"
	// Order by name in a descending order
	CsPreventionSettingsOrderByNameDesc CsPreventionSettingsOrderBy = "name_DESC"
)

var AllCsPreventionSettingsOrderBy = []CsPreventionSettingsOrderBy{
	CsPreventionSettingsOrderByNameAsc,
	CsPreventionSettingsOrderByNameDesc,
}

func (e CsPreventionSettingsOrderBy) IsValid() bool {
	switch e {
	case CsPreventionSettingsOrderByNameAsc, CsPreventionSettingsOrderByNameDesc:
		return true
	}
	return false
}

func (e CsPreventionSettingsOrderBy) String() string {
	return string(e)
}

func (e *CsPreventionSettingsOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CsPreventionSettingsOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid cs_prevention_settings_order_by", str)
	}
	return nil
}

func (e CsPreventionSettingsOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for csSensorUpdateSettings
type CsSensorUpdateSettingsOrderBy string

const (
	// Order by build in an ascending order
	CsSensorUpdateSettingsOrderByBuildAsc CsSensorUpdateSettingsOrderBy = "build_ASC"
	// Order by build in a descending order
	CsSensorUpdateSettingsOrderByBuildDesc CsSensorUpdateSettingsOrderBy = "build_DESC"
)

var AllCsSensorUpdateSettingsOrderBy = []CsSensorUpdateSettingsOrderBy{
	CsSensorUpdateSettingsOrderByBuildAsc,
	CsSensorUpdateSettingsOrderByBuildDesc,
}

func (e CsSensorUpdateSettingsOrderBy) IsValid() bool {
	switch e {
	case CsSensorUpdateSettingsOrderByBuildAsc, CsSensorUpdateSettingsOrderByBuildDesc:
		return true
	}
	return false
}

func (e CsSensorUpdateSettingsOrderBy) String() string {
	return string(e)
}

func (e *CsSensorUpdateSettingsOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CsSensorUpdateSettingsOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid cs_sensor_update_settings_order_by", str)
	}
	return nil
}

func (e CsSensorUpdateSettingsOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for Device
type DeviceOrderBy string

const (
	// Order by fetchCycle in an ascending order
	DeviceOrderByFetchCycleAsc DeviceOrderBy = "fetchCycle_ASC"
	// Order by fetchCycle in a descending order
	DeviceOrderByFetchCycleDesc DeviceOrderBy = "fetchCycle_DESC"
	// Order by adapterCount in an ascending order
	DeviceOrderByAdapterCountAsc DeviceOrderBy = "adapterCount_ASC"
	// Order by adapterCount in a descending order
	DeviceOrderByAdapterCountDesc DeviceOrderBy = "adapterCount_DESC"
	// Order by lastSeen in an ascending order
	DeviceOrderByLastSeenAsc DeviceOrderBy = "lastSeen_ASC"
	// Order by lastSeen in a descending order
	DeviceOrderByLastSeenDesc DeviceOrderBy = "lastSeen_DESC"
)

var AllDeviceOrderBy = []DeviceOrderBy{
	DeviceOrderByFetchCycleAsc,
	DeviceOrderByFetchCycleDesc,
	DeviceOrderByAdapterCountAsc,
	DeviceOrderByAdapterCountDesc,
	DeviceOrderByLastSeenAsc,
	DeviceOrderByLastSeenDesc,
}

func (e DeviceOrderBy) IsValid() bool {
	switch e {
	case DeviceOrderByFetchCycleAsc, DeviceOrderByFetchCycleDesc, DeviceOrderByAdapterCountAsc, DeviceOrderByAdapterCountDesc, DeviceOrderByLastSeenAsc, DeviceOrderByLastSeenDesc:
		return true
	}
	return false
}

func (e DeviceOrderBy) String() string {
	return string(e)
}

func (e *DeviceOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid device_order_by", str)
	}
	return nil
}

func (e DeviceOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DevicesAggregateAvgColumns string

const (
	// avg by fetchCycle
	DevicesAggregateAvgColumnsFetchCycle DevicesAggregateAvgColumns = "fetchCycle"
	// avg by adapterCount
	DevicesAggregateAvgColumnsAdapterCount DevicesAggregateAvgColumns = "adapterCount"
	// avg by lastSeen
	DevicesAggregateAvgColumnsLastSeen DevicesAggregateAvgColumns = "lastSeen"
)

var AllDevicesAggregateAvgColumns = []DevicesAggregateAvgColumns{
	DevicesAggregateAvgColumnsFetchCycle,
	DevicesAggregateAvgColumnsAdapterCount,
	DevicesAggregateAvgColumnsLastSeen,
}

func (e DevicesAggregateAvgColumns) IsValid() bool {
	switch e {
	case DevicesAggregateAvgColumnsFetchCycle, DevicesAggregateAvgColumnsAdapterCount, DevicesAggregateAvgColumnsLastSeen:
		return true
	}
	return false
}

func (e DevicesAggregateAvgColumns) String() string {
	return string(e)
}

func (e *DevicesAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DevicesAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid devices_aggregate_avg_columns", str)
	}
	return nil
}

func (e DevicesAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DevicesAggregateColumns string

const (
	// groupBy by id
	DevicesAggregateColumnsID DevicesAggregateColumns = "id"
	// groupBy by fetchCycle
	DevicesAggregateColumnsFetchCycle DevicesAggregateColumns = "fetchCycle"
	// groupBy by adapterCount
	DevicesAggregateColumnsAdapterCount DevicesAggregateColumns = "adapterCount"
	// groupBy by lastSeen
	DevicesAggregateColumnsLastSeen DevicesAggregateColumns = "lastSeen"
)

var AllDevicesAggregateColumns = []DevicesAggregateColumns{
	DevicesAggregateColumnsID,
	DevicesAggregateColumnsFetchCycle,
	DevicesAggregateColumnsAdapterCount,
	DevicesAggregateColumnsLastSeen,
}

func (e DevicesAggregateColumns) IsValid() bool {
	switch e {
	case DevicesAggregateColumnsID, DevicesAggregateColumnsFetchCycle, DevicesAggregateColumnsAdapterCount, DevicesAggregateColumnsLastSeen:
		return true
	}
	return false
}

func (e DevicesAggregateColumns) String() string {
	return string(e)
}

func (e *DevicesAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DevicesAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid devices_aggregate_columns", str)
	}
	return nil
}

func (e DevicesAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DevicesAggregateMaxColumns string

const (
	// max by id
	DevicesAggregateMaxColumnsID DevicesAggregateMaxColumns = "id"
	// max by fetchCycle
	DevicesAggregateMaxColumnsFetchCycle DevicesAggregateMaxColumns = "fetchCycle"
	// max by adapterCount
	DevicesAggregateMaxColumnsAdapterCount DevicesAggregateMaxColumns = "adapterCount"
	// max by lastSeen
	DevicesAggregateMaxColumnsLastSeen DevicesAggregateMaxColumns = "lastSeen"
)

var AllDevicesAggregateMaxColumns = []DevicesAggregateMaxColumns{
	DevicesAggregateMaxColumnsID,
	DevicesAggregateMaxColumnsFetchCycle,
	DevicesAggregateMaxColumnsAdapterCount,
	DevicesAggregateMaxColumnsLastSeen,
}

func (e DevicesAggregateMaxColumns) IsValid() bool {
	switch e {
	case DevicesAggregateMaxColumnsID, DevicesAggregateMaxColumnsFetchCycle, DevicesAggregateMaxColumnsAdapterCount, DevicesAggregateMaxColumnsLastSeen:
		return true
	}
	return false
}

func (e DevicesAggregateMaxColumns) String() string {
	return string(e)
}

func (e *DevicesAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DevicesAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid devices_aggregate_max_columns", str)
	}
	return nil
}

func (e DevicesAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DevicesAggregateMinColumns string

const (
	// min by id
	DevicesAggregateMinColumnsID DevicesAggregateMinColumns = "id"
	// min by fetchCycle
	DevicesAggregateMinColumnsFetchCycle DevicesAggregateMinColumns = "fetchCycle"
	// min by adapterCount
	DevicesAggregateMinColumnsAdapterCount DevicesAggregateMinColumns = "adapterCount"
	// min by lastSeen
	DevicesAggregateMinColumnsLastSeen DevicesAggregateMinColumns = "lastSeen"
)

var AllDevicesAggregateMinColumns = []DevicesAggregateMinColumns{
	DevicesAggregateMinColumnsID,
	DevicesAggregateMinColumnsFetchCycle,
	DevicesAggregateMinColumnsAdapterCount,
	DevicesAggregateMinColumnsLastSeen,
}

func (e DevicesAggregateMinColumns) IsValid() bool {
	switch e {
	case DevicesAggregateMinColumnsID, DevicesAggregateMinColumnsFetchCycle, DevicesAggregateMinColumnsAdapterCount, DevicesAggregateMinColumnsLastSeen:
		return true
	}
	return false
}

func (e DevicesAggregateMinColumns) String() string {
	return string(e)
}

func (e *DevicesAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DevicesAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid devices_aggregate_min_columns", str)
	}
	return nil
}

func (e DevicesAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DevicesAggregateSumColumns string

const (
	// sum by fetchCycle
	DevicesAggregateSumColumnsFetchCycle DevicesAggregateSumColumns = "fetchCycle"
	// sum by adapterCount
	DevicesAggregateSumColumnsAdapterCount DevicesAggregateSumColumns = "adapterCount"
	// sum by lastSeen
	DevicesAggregateSumColumnsLastSeen DevicesAggregateSumColumns = "lastSeen"
)

var AllDevicesAggregateSumColumns = []DevicesAggregateSumColumns{
	DevicesAggregateSumColumnsFetchCycle,
	DevicesAggregateSumColumnsAdapterCount,
	DevicesAggregateSumColumnsLastSeen,
}

func (e DevicesAggregateSumColumns) IsValid() bool {
	switch e {
	case DevicesAggregateSumColumnsFetchCycle, DevicesAggregateSumColumnsAdapterCount, DevicesAggregateSumColumnsLastSeen:
		return true
	}
	return false
}

func (e DevicesAggregateSumColumns) String() string {
	return string(e)
}

func (e *DevicesAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DevicesAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid devices_aggregate_sum_columns", str)
	}
	return nil
}

func (e DevicesAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FirewallRulesAggregateAvgColumns string

const (
	// avg by srcPort
	FirewallRulesAggregateAvgColumnsSrcPort FirewallRulesAggregateAvgColumns = "srcPort"
	// avg by dstPort
	FirewallRulesAggregateAvgColumnsDstPort FirewallRulesAggregateAvgColumns = "dstPort"
)

var AllFirewallRulesAggregateAvgColumns = []FirewallRulesAggregateAvgColumns{
	FirewallRulesAggregateAvgColumnsSrcPort,
	FirewallRulesAggregateAvgColumnsDstPort,
}

func (e FirewallRulesAggregateAvgColumns) IsValid() bool {
	switch e {
	case FirewallRulesAggregateAvgColumnsSrcPort, FirewallRulesAggregateAvgColumnsDstPort:
		return true
	}
	return false
}

func (e FirewallRulesAggregateAvgColumns) String() string {
	return string(e)
}

func (e *FirewallRulesAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRulesAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewallRules_aggregate_avg_columns", str)
	}
	return nil
}

func (e FirewallRulesAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FirewallRulesAggregateColumns string

const (
	// groupBy by name
	FirewallRulesAggregateColumnsName FirewallRulesAggregateColumns = "name"
	// groupBy by source
	FirewallRulesAggregateColumnsSource FirewallRulesAggregateColumns = "source"
	// groupBy by target
	FirewallRulesAggregateColumnsTarget FirewallRulesAggregateColumns = "target"
	// groupBy by protocol
	FirewallRulesAggregateColumnsProtocol FirewallRulesAggregateColumns = "protocol"
	// groupBy by srcPort
	FirewallRulesAggregateColumnsSrcPort FirewallRulesAggregateColumns = "srcPort"
	// groupBy by dstPort
	FirewallRulesAggregateColumnsDstPort FirewallRulesAggregateColumns = "dstPort"
)

var AllFirewallRulesAggregateColumns = []FirewallRulesAggregateColumns{
	FirewallRulesAggregateColumnsName,
	FirewallRulesAggregateColumnsSource,
	FirewallRulesAggregateColumnsTarget,
	FirewallRulesAggregateColumnsProtocol,
	FirewallRulesAggregateColumnsSrcPort,
	FirewallRulesAggregateColumnsDstPort,
}

func (e FirewallRulesAggregateColumns) IsValid() bool {
	switch e {
	case FirewallRulesAggregateColumnsName, FirewallRulesAggregateColumnsSource, FirewallRulesAggregateColumnsTarget, FirewallRulesAggregateColumnsProtocol, FirewallRulesAggregateColumnsSrcPort, FirewallRulesAggregateColumnsDstPort:
		return true
	}
	return false
}

func (e FirewallRulesAggregateColumns) String() string {
	return string(e)
}

func (e *FirewallRulesAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRulesAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewallRules_aggregate_columns", str)
	}
	return nil
}

func (e FirewallRulesAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FirewallRulesAggregateMaxColumns string

const (
	// max by name
	FirewallRulesAggregateMaxColumnsName FirewallRulesAggregateMaxColumns = "name"
	// max by source
	FirewallRulesAggregateMaxColumnsSource FirewallRulesAggregateMaxColumns = "source"
	// max by target
	FirewallRulesAggregateMaxColumnsTarget FirewallRulesAggregateMaxColumns = "target"
	// max by protocol
	FirewallRulesAggregateMaxColumnsProtocol FirewallRulesAggregateMaxColumns = "protocol"
	// max by srcPort
	FirewallRulesAggregateMaxColumnsSrcPort FirewallRulesAggregateMaxColumns = "srcPort"
	// max by dstPort
	FirewallRulesAggregateMaxColumnsDstPort FirewallRulesAggregateMaxColumns = "dstPort"
)

var AllFirewallRulesAggregateMaxColumns = []FirewallRulesAggregateMaxColumns{
	FirewallRulesAggregateMaxColumnsName,
	FirewallRulesAggregateMaxColumnsSource,
	FirewallRulesAggregateMaxColumnsTarget,
	FirewallRulesAggregateMaxColumnsProtocol,
	FirewallRulesAggregateMaxColumnsSrcPort,
	FirewallRulesAggregateMaxColumnsDstPort,
}

func (e FirewallRulesAggregateMaxColumns) IsValid() bool {
	switch e {
	case FirewallRulesAggregateMaxColumnsName, FirewallRulesAggregateMaxColumnsSource, FirewallRulesAggregateMaxColumnsTarget, FirewallRulesAggregateMaxColumnsProtocol, FirewallRulesAggregateMaxColumnsSrcPort, FirewallRulesAggregateMaxColumnsDstPort:
		return true
	}
	return false
}

func (e FirewallRulesAggregateMaxColumns) String() string {
	return string(e)
}

func (e *FirewallRulesAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRulesAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewallRules_aggregate_max_columns", str)
	}
	return nil
}

func (e FirewallRulesAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FirewallRulesAggregateMinColumns string

const (
	// min by name
	FirewallRulesAggregateMinColumnsName FirewallRulesAggregateMinColumns = "name"
	// min by source
	FirewallRulesAggregateMinColumnsSource FirewallRulesAggregateMinColumns = "source"
	// min by target
	FirewallRulesAggregateMinColumnsTarget FirewallRulesAggregateMinColumns = "target"
	// min by protocol
	FirewallRulesAggregateMinColumnsProtocol FirewallRulesAggregateMinColumns = "protocol"
	// min by srcPort
	FirewallRulesAggregateMinColumnsSrcPort FirewallRulesAggregateMinColumns = "srcPort"
	// min by dstPort
	FirewallRulesAggregateMinColumnsDstPort FirewallRulesAggregateMinColumns = "dstPort"
)

var AllFirewallRulesAggregateMinColumns = []FirewallRulesAggregateMinColumns{
	FirewallRulesAggregateMinColumnsName,
	FirewallRulesAggregateMinColumnsSource,
	FirewallRulesAggregateMinColumnsTarget,
	FirewallRulesAggregateMinColumnsProtocol,
	FirewallRulesAggregateMinColumnsSrcPort,
	FirewallRulesAggregateMinColumnsDstPort,
}

func (e FirewallRulesAggregateMinColumns) IsValid() bool {
	switch e {
	case FirewallRulesAggregateMinColumnsName, FirewallRulesAggregateMinColumnsSource, FirewallRulesAggregateMinColumnsTarget, FirewallRulesAggregateMinColumnsProtocol, FirewallRulesAggregateMinColumnsSrcPort, FirewallRulesAggregateMinColumnsDstPort:
		return true
	}
	return false
}

func (e FirewallRulesAggregateMinColumns) String() string {
	return string(e)
}

func (e *FirewallRulesAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRulesAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewallRules_aggregate_min_columns", str)
	}
	return nil
}

func (e FirewallRulesAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FirewallRulesAggregateSumColumns string

const (
	// sum by srcPort
	FirewallRulesAggregateSumColumnsSrcPort FirewallRulesAggregateSumColumns = "srcPort"
	// sum by dstPort
	FirewallRulesAggregateSumColumnsDstPort FirewallRulesAggregateSumColumns = "dstPort"
)

var AllFirewallRulesAggregateSumColumns = []FirewallRulesAggregateSumColumns{
	FirewallRulesAggregateSumColumnsSrcPort,
	FirewallRulesAggregateSumColumnsDstPort,
}

func (e FirewallRulesAggregateSumColumns) IsValid() bool {
	switch e {
	case FirewallRulesAggregateSumColumnsSrcPort, FirewallRulesAggregateSumColumnsDstPort:
		return true
	}
	return false
}

func (e FirewallRulesAggregateSumColumns) String() string {
	return string(e)
}

func (e *FirewallRulesAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRulesAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewallRules_aggregate_sum_columns", str)
	}
	return nil
}

func (e FirewallRulesAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for FirewallRule
type FirewallRuleOrderBy string

const (
	// Order by name in an ascending order
	FirewallRuleOrderByNameAsc FirewallRuleOrderBy = "name_ASC"
	// Order by name in a descending order
	FirewallRuleOrderByNameDesc FirewallRuleOrderBy = "name_DESC"
	// Order by source in an ascending order
	FirewallRuleOrderBySourceAsc FirewallRuleOrderBy = "source_ASC"
	// Order by source in a descending order
	FirewallRuleOrderBySourceDesc FirewallRuleOrderBy = "source_DESC"
	// Order by target in an ascending order
	FirewallRuleOrderByTargetAsc FirewallRuleOrderBy = "target_ASC"
	// Order by target in a descending order
	FirewallRuleOrderByTargetDesc FirewallRuleOrderBy = "target_DESC"
	// Order by protocol in an ascending order
	FirewallRuleOrderByProtocolAsc FirewallRuleOrderBy = "protocol_ASC"
	// Order by protocol in a descending order
	FirewallRuleOrderByProtocolDesc FirewallRuleOrderBy = "protocol_DESC"
	// Order by srcPort in an ascending order
	FirewallRuleOrderBySrcPortAsc FirewallRuleOrderBy = "srcPort_ASC"
	// Order by srcPort in a descending order
	FirewallRuleOrderBySrcPortDesc FirewallRuleOrderBy = "srcPort_DESC"
	// Order by dstPort in an ascending order
	FirewallRuleOrderByDstPortAsc FirewallRuleOrderBy = "dstPort_ASC"
	// Order by dstPort in a descending order
	FirewallRuleOrderByDstPortDesc FirewallRuleOrderBy = "dstPort_DESC"
)

var AllFirewallRuleOrderBy = []FirewallRuleOrderBy{
	FirewallRuleOrderByNameAsc,
	FirewallRuleOrderByNameDesc,
	FirewallRuleOrderBySourceAsc,
	FirewallRuleOrderBySourceDesc,
	FirewallRuleOrderByTargetAsc,
	FirewallRuleOrderByTargetDesc,
	FirewallRuleOrderByProtocolAsc,
	FirewallRuleOrderByProtocolDesc,
	FirewallRuleOrderBySrcPortAsc,
	FirewallRuleOrderBySrcPortDesc,
	FirewallRuleOrderByDstPortAsc,
	FirewallRuleOrderByDstPortDesc,
}

func (e FirewallRuleOrderBy) IsValid() bool {
	switch e {
	case FirewallRuleOrderByNameAsc, FirewallRuleOrderByNameDesc, FirewallRuleOrderBySourceAsc, FirewallRuleOrderBySourceDesc, FirewallRuleOrderByTargetAsc, FirewallRuleOrderByTargetDesc, FirewallRuleOrderByProtocolAsc, FirewallRuleOrderByProtocolDesc, FirewallRuleOrderBySrcPortAsc, FirewallRuleOrderBySrcPortDesc, FirewallRuleOrderByDstPortAsc, FirewallRuleOrderByDstPortDesc:
		return true
	}
	return false
}

func (e FirewallRuleOrderBy) String() string {
	return string(e)
}

func (e *FirewallRuleOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRuleOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewall_rule_order_by", str)
	}
	return nil
}

func (e FirewallRuleOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for GceTags
type GceTagsOrderBy string

const (
	// Order by gceKey in an ascending order
	GceTagsOrderByGceKeyAsc GceTagsOrderBy = "gceKey_ASC"
	// Order by gceKey in a descending order
	GceTagsOrderByGceKeyDesc GceTagsOrderBy = "gceKey_DESC"
	// Order by gceValue in an ascending order
	GceTagsOrderByGceValueAsc GceTagsOrderBy = "gceValue_ASC"
	// Order by gceValue in a descending order
	GceTagsOrderByGceValueDesc GceTagsOrderBy = "gceValue_DESC"
)

var AllGceTagsOrderBy = []GceTagsOrderBy{
	GceTagsOrderByGceKeyAsc,
	GceTagsOrderByGceKeyDesc,
	GceTagsOrderByGceValueAsc,
	GceTagsOrderByGceValueDesc,
}

func (e GceTagsOrderBy) IsValid() bool {
	switch e {
	case GceTagsOrderByGceKeyAsc, GceTagsOrderByGceKeyDesc, GceTagsOrderByGceValueAsc, GceTagsOrderByGceValueDesc:
		return true
	}
	return false
}

func (e GceTagsOrderBy) String() string {
	return string(e)
}

func (e *GceTagsOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GceTagsOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid gce_tags_order_by", str)
	}
	return nil
}

func (e GceTagsOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupsAggregateAvgColumns string

const (
	// avg by createdTimestamp
	GroupsAggregateAvgColumnsCreatedTimestamp GroupsAggregateAvgColumns = "createdTimestamp"
	// avg by modifiedTime
	GroupsAggregateAvgColumnsModifiedTime GroupsAggregateAvgColumns = "modifiedTime"
)

var AllGroupsAggregateAvgColumns = []GroupsAggregateAvgColumns{
	GroupsAggregateAvgColumnsCreatedTimestamp,
	GroupsAggregateAvgColumnsModifiedTime,
}

func (e GroupsAggregateAvgColumns) IsValid() bool {
	switch e {
	case GroupsAggregateAvgColumnsCreatedTimestamp, GroupsAggregateAvgColumnsModifiedTime:
		return true
	}
	return false
}

func (e GroupsAggregateAvgColumns) String() string {
	return string(e)
}

func (e *GroupsAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupsAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid groups_aggregate_avg_columns", str)
	}
	return nil
}

func (e GroupsAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupsAggregateColumns string

const (
	// groupBy by id
	GroupsAggregateColumnsID GroupsAggregateColumns = "id"
	// groupBy by name
	GroupsAggregateColumnsName GroupsAggregateColumns = "name"
	// groupBy by createdBy
	GroupsAggregateColumnsCreatedBy GroupsAggregateColumns = "createdBy"
	// groupBy by createdTimestamp
	GroupsAggregateColumnsCreatedTimestamp GroupsAggregateColumns = "createdTimestamp"
	// groupBy by description
	GroupsAggregateColumnsDescription GroupsAggregateColumns = "description"
	// groupBy by groupType
	GroupsAggregateColumnsGroupType GroupsAggregateColumns = "groupType"
	// groupBy by modifiedBy
	GroupsAggregateColumnsModifiedBy GroupsAggregateColumns = "modifiedBy"
	// groupBy by modifiedTime
	GroupsAggregateColumnsModifiedTime GroupsAggregateColumns = "modifiedTime"
)

var AllGroupsAggregateColumns = []GroupsAggregateColumns{
	GroupsAggregateColumnsID,
	GroupsAggregateColumnsName,
	GroupsAggregateColumnsCreatedBy,
	GroupsAggregateColumnsCreatedTimestamp,
	GroupsAggregateColumnsDescription,
	GroupsAggregateColumnsGroupType,
	GroupsAggregateColumnsModifiedBy,
	GroupsAggregateColumnsModifiedTime,
}

func (e GroupsAggregateColumns) IsValid() bool {
	switch e {
	case GroupsAggregateColumnsID, GroupsAggregateColumnsName, GroupsAggregateColumnsCreatedBy, GroupsAggregateColumnsCreatedTimestamp, GroupsAggregateColumnsDescription, GroupsAggregateColumnsGroupType, GroupsAggregateColumnsModifiedBy, GroupsAggregateColumnsModifiedTime:
		return true
	}
	return false
}

func (e GroupsAggregateColumns) String() string {
	return string(e)
}

func (e *GroupsAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupsAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid groups_aggregate_columns", str)
	}
	return nil
}

func (e GroupsAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupsAggregateMaxColumns string

const (
	// max by id
	GroupsAggregateMaxColumnsID GroupsAggregateMaxColumns = "id"
	// max by name
	GroupsAggregateMaxColumnsName GroupsAggregateMaxColumns = "name"
	// max by createdBy
	GroupsAggregateMaxColumnsCreatedBy GroupsAggregateMaxColumns = "createdBy"
	// max by createdTimestamp
	GroupsAggregateMaxColumnsCreatedTimestamp GroupsAggregateMaxColumns = "createdTimestamp"
	// max by description
	GroupsAggregateMaxColumnsDescription GroupsAggregateMaxColumns = "description"
	// max by groupType
	GroupsAggregateMaxColumnsGroupType GroupsAggregateMaxColumns = "groupType"
	// max by modifiedBy
	GroupsAggregateMaxColumnsModifiedBy GroupsAggregateMaxColumns = "modifiedBy"
	// max by modifiedTime
	GroupsAggregateMaxColumnsModifiedTime GroupsAggregateMaxColumns = "modifiedTime"
)

var AllGroupsAggregateMaxColumns = []GroupsAggregateMaxColumns{
	GroupsAggregateMaxColumnsID,
	GroupsAggregateMaxColumnsName,
	GroupsAggregateMaxColumnsCreatedBy,
	GroupsAggregateMaxColumnsCreatedTimestamp,
	GroupsAggregateMaxColumnsDescription,
	GroupsAggregateMaxColumnsGroupType,
	GroupsAggregateMaxColumnsModifiedBy,
	GroupsAggregateMaxColumnsModifiedTime,
}

func (e GroupsAggregateMaxColumns) IsValid() bool {
	switch e {
	case GroupsAggregateMaxColumnsID, GroupsAggregateMaxColumnsName, GroupsAggregateMaxColumnsCreatedBy, GroupsAggregateMaxColumnsCreatedTimestamp, GroupsAggregateMaxColumnsDescription, GroupsAggregateMaxColumnsGroupType, GroupsAggregateMaxColumnsModifiedBy, GroupsAggregateMaxColumnsModifiedTime:
		return true
	}
	return false
}

func (e GroupsAggregateMaxColumns) String() string {
	return string(e)
}

func (e *GroupsAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupsAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid groups_aggregate_max_columns", str)
	}
	return nil
}

func (e GroupsAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupsAggregateMinColumns string

const (
	// min by id
	GroupsAggregateMinColumnsID GroupsAggregateMinColumns = "id"
	// min by name
	GroupsAggregateMinColumnsName GroupsAggregateMinColumns = "name"
	// min by createdBy
	GroupsAggregateMinColumnsCreatedBy GroupsAggregateMinColumns = "createdBy"
	// min by createdTimestamp
	GroupsAggregateMinColumnsCreatedTimestamp GroupsAggregateMinColumns = "createdTimestamp"
	// min by description
	GroupsAggregateMinColumnsDescription GroupsAggregateMinColumns = "description"
	// min by groupType
	GroupsAggregateMinColumnsGroupType GroupsAggregateMinColumns = "groupType"
	// min by modifiedBy
	GroupsAggregateMinColumnsModifiedBy GroupsAggregateMinColumns = "modifiedBy"
	// min by modifiedTime
	GroupsAggregateMinColumnsModifiedTime GroupsAggregateMinColumns = "modifiedTime"
)

var AllGroupsAggregateMinColumns = []GroupsAggregateMinColumns{
	GroupsAggregateMinColumnsID,
	GroupsAggregateMinColumnsName,
	GroupsAggregateMinColumnsCreatedBy,
	GroupsAggregateMinColumnsCreatedTimestamp,
	GroupsAggregateMinColumnsDescription,
	GroupsAggregateMinColumnsGroupType,
	GroupsAggregateMinColumnsModifiedBy,
	GroupsAggregateMinColumnsModifiedTime,
}

func (e GroupsAggregateMinColumns) IsValid() bool {
	switch e {
	case GroupsAggregateMinColumnsID, GroupsAggregateMinColumnsName, GroupsAggregateMinColumnsCreatedBy, GroupsAggregateMinColumnsCreatedTimestamp, GroupsAggregateMinColumnsDescription, GroupsAggregateMinColumnsGroupType, GroupsAggregateMinColumnsModifiedBy, GroupsAggregateMinColumnsModifiedTime:
		return true
	}
	return false
}

func (e GroupsAggregateMinColumns) String() string {
	return string(e)
}

func (e *GroupsAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupsAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid groups_aggregate_min_columns", str)
	}
	return nil
}

func (e GroupsAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupsAggregateSumColumns string

const (
	// sum by createdTimestamp
	GroupsAggregateSumColumnsCreatedTimestamp GroupsAggregateSumColumns = "createdTimestamp"
	// sum by modifiedTime
	GroupsAggregateSumColumnsModifiedTime GroupsAggregateSumColumns = "modifiedTime"
)

var AllGroupsAggregateSumColumns = []GroupsAggregateSumColumns{
	GroupsAggregateSumColumnsCreatedTimestamp,
	GroupsAggregateSumColumnsModifiedTime,
}

func (e GroupsAggregateSumColumns) IsValid() bool {
	switch e {
	case GroupsAggregateSumColumnsCreatedTimestamp, GroupsAggregateSumColumnsModifiedTime:
		return true
	}
	return false
}

func (e GroupsAggregateSumColumns) String() string {
	return string(e)
}

func (e *GroupsAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupsAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid groups_aggregate_sum_columns", str)
	}
	return nil
}

func (e GroupsAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstalledSoftwareAggregateAvgColumns string

const (
	// avg by cveCount
	InstalledSoftwareAggregateAvgColumnsCveCount InstalledSoftwareAggregateAvgColumns = "cveCount"
)

var AllInstalledSoftwareAggregateAvgColumns = []InstalledSoftwareAggregateAvgColumns{
	InstalledSoftwareAggregateAvgColumnsCveCount,
}

func (e InstalledSoftwareAggregateAvgColumns) IsValid() bool {
	switch e {
	case InstalledSoftwareAggregateAvgColumnsCveCount:
		return true
	}
	return false
}

func (e InstalledSoftwareAggregateAvgColumns) String() string {
	return string(e)
}

func (e *InstalledSoftwareAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installedSoftware_aggregate_avg_columns", str)
	}
	return nil
}

func (e InstalledSoftwareAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstalledSoftwareAggregateColumns string

const (
	// groupBy by name
	InstalledSoftwareAggregateColumnsName InstalledSoftwareAggregateColumns = "name"
	// groupBy by version
	InstalledSoftwareAggregateColumnsVersion InstalledSoftwareAggregateColumns = "version"
	// groupBy by description
	InstalledSoftwareAggregateColumnsDescription InstalledSoftwareAggregateColumns = "description"
	// groupBy by vendor
	InstalledSoftwareAggregateColumnsVendor InstalledSoftwareAggregateColumns = "vendor"
	// groupBy by publisher
	InstalledSoftwareAggregateColumnsPublisher InstalledSoftwareAggregateColumns = "publisher"
	// groupBy by cveCount
	InstalledSoftwareAggregateColumnsCveCount InstalledSoftwareAggregateColumns = "cveCount"
	// groupBy by swLicense
	InstalledSoftwareAggregateColumnsSwLicense InstalledSoftwareAggregateColumns = "swLicense"
	// groupBy by path
	InstalledSoftwareAggregateColumnsPath InstalledSoftwareAggregateColumns = "path"
)

var AllInstalledSoftwareAggregateColumns = []InstalledSoftwareAggregateColumns{
	InstalledSoftwareAggregateColumnsName,
	InstalledSoftwareAggregateColumnsVersion,
	InstalledSoftwareAggregateColumnsDescription,
	InstalledSoftwareAggregateColumnsVendor,
	InstalledSoftwareAggregateColumnsPublisher,
	InstalledSoftwareAggregateColumnsCveCount,
	InstalledSoftwareAggregateColumnsSwLicense,
	InstalledSoftwareAggregateColumnsPath,
}

func (e InstalledSoftwareAggregateColumns) IsValid() bool {
	switch e {
	case InstalledSoftwareAggregateColumnsName, InstalledSoftwareAggregateColumnsVersion, InstalledSoftwareAggregateColumnsDescription, InstalledSoftwareAggregateColumnsVendor, InstalledSoftwareAggregateColumnsPublisher, InstalledSoftwareAggregateColumnsCveCount, InstalledSoftwareAggregateColumnsSwLicense, InstalledSoftwareAggregateColumnsPath:
		return true
	}
	return false
}

func (e InstalledSoftwareAggregateColumns) String() string {
	return string(e)
}

func (e *InstalledSoftwareAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installedSoftware_aggregate_columns", str)
	}
	return nil
}

func (e InstalledSoftwareAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstalledSoftwareAggregateMaxColumns string

const (
	// max by name
	InstalledSoftwareAggregateMaxColumnsName InstalledSoftwareAggregateMaxColumns = "name"
	// max by version
	InstalledSoftwareAggregateMaxColumnsVersion InstalledSoftwareAggregateMaxColumns = "version"
	// max by description
	InstalledSoftwareAggregateMaxColumnsDescription InstalledSoftwareAggregateMaxColumns = "description"
	// max by vendor
	InstalledSoftwareAggregateMaxColumnsVendor InstalledSoftwareAggregateMaxColumns = "vendor"
	// max by publisher
	InstalledSoftwareAggregateMaxColumnsPublisher InstalledSoftwareAggregateMaxColumns = "publisher"
	// max by cveCount
	InstalledSoftwareAggregateMaxColumnsCveCount InstalledSoftwareAggregateMaxColumns = "cveCount"
	// max by swLicense
	InstalledSoftwareAggregateMaxColumnsSwLicense InstalledSoftwareAggregateMaxColumns = "swLicense"
	// max by path
	InstalledSoftwareAggregateMaxColumnsPath InstalledSoftwareAggregateMaxColumns = "path"
)

var AllInstalledSoftwareAggregateMaxColumns = []InstalledSoftwareAggregateMaxColumns{
	InstalledSoftwareAggregateMaxColumnsName,
	InstalledSoftwareAggregateMaxColumnsVersion,
	InstalledSoftwareAggregateMaxColumnsDescription,
	InstalledSoftwareAggregateMaxColumnsVendor,
	InstalledSoftwareAggregateMaxColumnsPublisher,
	InstalledSoftwareAggregateMaxColumnsCveCount,
	InstalledSoftwareAggregateMaxColumnsSwLicense,
	InstalledSoftwareAggregateMaxColumnsPath,
}

func (e InstalledSoftwareAggregateMaxColumns) IsValid() bool {
	switch e {
	case InstalledSoftwareAggregateMaxColumnsName, InstalledSoftwareAggregateMaxColumnsVersion, InstalledSoftwareAggregateMaxColumnsDescription, InstalledSoftwareAggregateMaxColumnsVendor, InstalledSoftwareAggregateMaxColumnsPublisher, InstalledSoftwareAggregateMaxColumnsCveCount, InstalledSoftwareAggregateMaxColumnsSwLicense, InstalledSoftwareAggregateMaxColumnsPath:
		return true
	}
	return false
}

func (e InstalledSoftwareAggregateMaxColumns) String() string {
	return string(e)
}

func (e *InstalledSoftwareAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installedSoftware_aggregate_max_columns", str)
	}
	return nil
}

func (e InstalledSoftwareAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstalledSoftwareAggregateMinColumns string

const (
	// min by name
	InstalledSoftwareAggregateMinColumnsName InstalledSoftwareAggregateMinColumns = "name"
	// min by version
	InstalledSoftwareAggregateMinColumnsVersion InstalledSoftwareAggregateMinColumns = "version"
	// min by description
	InstalledSoftwareAggregateMinColumnsDescription InstalledSoftwareAggregateMinColumns = "description"
	// min by vendor
	InstalledSoftwareAggregateMinColumnsVendor InstalledSoftwareAggregateMinColumns = "vendor"
	// min by publisher
	InstalledSoftwareAggregateMinColumnsPublisher InstalledSoftwareAggregateMinColumns = "publisher"
	// min by cveCount
	InstalledSoftwareAggregateMinColumnsCveCount InstalledSoftwareAggregateMinColumns = "cveCount"
	// min by swLicense
	InstalledSoftwareAggregateMinColumnsSwLicense InstalledSoftwareAggregateMinColumns = "swLicense"
	// min by path
	InstalledSoftwareAggregateMinColumnsPath InstalledSoftwareAggregateMinColumns = "path"
)

var AllInstalledSoftwareAggregateMinColumns = []InstalledSoftwareAggregateMinColumns{
	InstalledSoftwareAggregateMinColumnsName,
	InstalledSoftwareAggregateMinColumnsVersion,
	InstalledSoftwareAggregateMinColumnsDescription,
	InstalledSoftwareAggregateMinColumnsVendor,
	InstalledSoftwareAggregateMinColumnsPublisher,
	InstalledSoftwareAggregateMinColumnsCveCount,
	InstalledSoftwareAggregateMinColumnsSwLicense,
	InstalledSoftwareAggregateMinColumnsPath,
}

func (e InstalledSoftwareAggregateMinColumns) IsValid() bool {
	switch e {
	case InstalledSoftwareAggregateMinColumnsName, InstalledSoftwareAggregateMinColumnsVersion, InstalledSoftwareAggregateMinColumnsDescription, InstalledSoftwareAggregateMinColumnsVendor, InstalledSoftwareAggregateMinColumnsPublisher, InstalledSoftwareAggregateMinColumnsCveCount, InstalledSoftwareAggregateMinColumnsSwLicense, InstalledSoftwareAggregateMinColumnsPath:
		return true
	}
	return false
}

func (e InstalledSoftwareAggregateMinColumns) String() string {
	return string(e)
}

func (e *InstalledSoftwareAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installedSoftware_aggregate_min_columns", str)
	}
	return nil
}

func (e InstalledSoftwareAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstalledSoftwareAggregateSumColumns string

const (
	// sum by cveCount
	InstalledSoftwareAggregateSumColumnsCveCount InstalledSoftwareAggregateSumColumns = "cveCount"
)

var AllInstalledSoftwareAggregateSumColumns = []InstalledSoftwareAggregateSumColumns{
	InstalledSoftwareAggregateSumColumnsCveCount,
}

func (e InstalledSoftwareAggregateSumColumns) IsValid() bool {
	switch e {
	case InstalledSoftwareAggregateSumColumnsCveCount:
		return true
	}
	return false
}

func (e InstalledSoftwareAggregateSumColumns) String() string {
	return string(e)
}

func (e *InstalledSoftwareAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installedSoftware_aggregate_sum_columns", str)
	}
	return nil
}

func (e InstalledSoftwareAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for InstalledSoftware
type InstalledSoftwareOrderBy string

const (
	// Order by name in an ascending order
	InstalledSoftwareOrderByNameAsc InstalledSoftwareOrderBy = "name_ASC"
	// Order by name in a descending order
	InstalledSoftwareOrderByNameDesc InstalledSoftwareOrderBy = "name_DESC"
	// Order by version in an ascending order
	InstalledSoftwareOrderByVersionAsc InstalledSoftwareOrderBy = "version_ASC"
	// Order by version in a descending order
	InstalledSoftwareOrderByVersionDesc InstalledSoftwareOrderBy = "version_DESC"
	// Order by description in an ascending order
	InstalledSoftwareOrderByDescriptionAsc InstalledSoftwareOrderBy = "description_ASC"
	// Order by description in a descending order
	InstalledSoftwareOrderByDescriptionDesc InstalledSoftwareOrderBy = "description_DESC"
	// Order by vendor in an ascending order
	InstalledSoftwareOrderByVendorAsc InstalledSoftwareOrderBy = "vendor_ASC"
	// Order by vendor in a descending order
	InstalledSoftwareOrderByVendorDesc InstalledSoftwareOrderBy = "vendor_DESC"
	// Order by publisher in an ascending order
	InstalledSoftwareOrderByPublisherAsc InstalledSoftwareOrderBy = "publisher_ASC"
	// Order by publisher in a descending order
	InstalledSoftwareOrderByPublisherDesc InstalledSoftwareOrderBy = "publisher_DESC"
	// Order by cveCount in an ascending order
	InstalledSoftwareOrderByCveCountAsc InstalledSoftwareOrderBy = "cveCount_ASC"
	// Order by cveCount in a descending order
	InstalledSoftwareOrderByCveCountDesc InstalledSoftwareOrderBy = "cveCount_DESC"
	// Order by swLicense in an ascending order
	InstalledSoftwareOrderBySwLicenseAsc InstalledSoftwareOrderBy = "swLicense_ASC"
	// Order by swLicense in a descending order
	InstalledSoftwareOrderBySwLicenseDesc InstalledSoftwareOrderBy = "swLicense_DESC"
	// Order by path in an ascending order
	InstalledSoftwareOrderByPathAsc InstalledSoftwareOrderBy = "path_ASC"
	// Order by path in a descending order
	InstalledSoftwareOrderByPathDesc InstalledSoftwareOrderBy = "path_DESC"
)

var AllInstalledSoftwareOrderBy = []InstalledSoftwareOrderBy{
	InstalledSoftwareOrderByNameAsc,
	InstalledSoftwareOrderByNameDesc,
	InstalledSoftwareOrderByVersionAsc,
	InstalledSoftwareOrderByVersionDesc,
	InstalledSoftwareOrderByDescriptionAsc,
	InstalledSoftwareOrderByDescriptionDesc,
	InstalledSoftwareOrderByVendorAsc,
	InstalledSoftwareOrderByVendorDesc,
	InstalledSoftwareOrderByPublisherAsc,
	InstalledSoftwareOrderByPublisherDesc,
	InstalledSoftwareOrderByCveCountAsc,
	InstalledSoftwareOrderByCveCountDesc,
	InstalledSoftwareOrderBySwLicenseAsc,
	InstalledSoftwareOrderBySwLicenseDesc,
	InstalledSoftwareOrderByPathAsc,
	InstalledSoftwareOrderByPathDesc,
}

func (e InstalledSoftwareOrderBy) IsValid() bool {
	switch e {
	case InstalledSoftwareOrderByNameAsc, InstalledSoftwareOrderByNameDesc, InstalledSoftwareOrderByVersionAsc, InstalledSoftwareOrderByVersionDesc, InstalledSoftwareOrderByDescriptionAsc, InstalledSoftwareOrderByDescriptionDesc, InstalledSoftwareOrderByVendorAsc, InstalledSoftwareOrderByVendorDesc, InstalledSoftwareOrderByPublisherAsc, InstalledSoftwareOrderByPublisherDesc, InstalledSoftwareOrderByCveCountAsc, InstalledSoftwareOrderByCveCountDesc, InstalledSoftwareOrderBySwLicenseAsc, InstalledSoftwareOrderBySwLicenseDesc, InstalledSoftwareOrderByPathAsc, InstalledSoftwareOrderByPathDesc:
		return true
	}
	return false
}

func (e InstalledSoftwareOrderBy) String() string {
	return string(e)
}

func (e *InstalledSoftwareOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installed_software_order_by", str)
	}
	return nil
}

func (e InstalledSoftwareOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InterfacesAggregateColumns string

const (
	// groupBy by deviceId
	InterfacesAggregateColumnsDeviceID InterfacesAggregateColumns = "deviceId"
	// groupBy by macAddr
	InterfacesAggregateColumnsMacAddr InterfacesAggregateColumns = "macAddr"
)

var AllInterfacesAggregateColumns = []InterfacesAggregateColumns{
	InterfacesAggregateColumnsDeviceID,
	InterfacesAggregateColumnsMacAddr,
}

func (e InterfacesAggregateColumns) IsValid() bool {
	switch e {
	case InterfacesAggregateColumnsDeviceID, InterfacesAggregateColumnsMacAddr:
		return true
	}
	return false
}

func (e InterfacesAggregateColumns) String() string {
	return string(e)
}

func (e *InterfacesAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfacesAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid interfaces_aggregate_columns", str)
	}
	return nil
}

func (e InterfacesAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InterfacesAggregateMaxColumns string

const (
	// max by deviceId
	InterfacesAggregateMaxColumnsDeviceID InterfacesAggregateMaxColumns = "deviceId"
	// max by macAddr
	InterfacesAggregateMaxColumnsMacAddr InterfacesAggregateMaxColumns = "macAddr"
)

var AllInterfacesAggregateMaxColumns = []InterfacesAggregateMaxColumns{
	InterfacesAggregateMaxColumnsDeviceID,
	InterfacesAggregateMaxColumnsMacAddr,
}

func (e InterfacesAggregateMaxColumns) IsValid() bool {
	switch e {
	case InterfacesAggregateMaxColumnsDeviceID, InterfacesAggregateMaxColumnsMacAddr:
		return true
	}
	return false
}

func (e InterfacesAggregateMaxColumns) String() string {
	return string(e)
}

func (e *InterfacesAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfacesAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid interfaces_aggregate_max_columns", str)
	}
	return nil
}

func (e InterfacesAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InterfacesAggregateMinColumns string

const (
	// min by deviceId
	InterfacesAggregateMinColumnsDeviceID InterfacesAggregateMinColumns = "deviceId"
	// min by macAddr
	InterfacesAggregateMinColumnsMacAddr InterfacesAggregateMinColumns = "macAddr"
)

var AllInterfacesAggregateMinColumns = []InterfacesAggregateMinColumns{
	InterfacesAggregateMinColumnsDeviceID,
	InterfacesAggregateMinColumnsMacAddr,
}

func (e InterfacesAggregateMinColumns) IsValid() bool {
	switch e {
	case InterfacesAggregateMinColumnsDeviceID, InterfacesAggregateMinColumnsMacAddr:
		return true
	}
	return false
}

func (e InterfacesAggregateMinColumns) String() string {
	return string(e)
}

func (e *InterfacesAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfacesAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid interfaces_aggregate_min_columns", str)
	}
	return nil
}

func (e InterfacesAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for OperatingSystem
type OperatingSystemOrderBy string

const (
	// Order by type in an ascending order
	OperatingSystemOrderByTypeAsc OperatingSystemOrderBy = "type_ASC"
	// Order by type in a descending order
	OperatingSystemOrderByTypeDesc OperatingSystemOrderBy = "type_DESC"
	// Order by distribution in an ascending order
	OperatingSystemOrderByDistributionAsc OperatingSystemOrderBy = "distribution_ASC"
	// Order by distribution in a descending order
	OperatingSystemOrderByDistributionDesc OperatingSystemOrderBy = "distribution_DESC"
	// Order by architecture in an ascending order
	OperatingSystemOrderByArchitectureAsc OperatingSystemOrderBy = "architecture_ASC"
	// Order by architecture in a descending order
	OperatingSystemOrderByArchitectureDesc OperatingSystemOrderBy = "architecture_DESC"
	// Order by servicePack in an ascending order
	OperatingSystemOrderByServicePackAsc OperatingSystemOrderBy = "servicePack_ASC"
	// Order by servicePack in a descending order
	OperatingSystemOrderByServicePackDesc OperatingSystemOrderBy = "servicePack_DESC"
	// Order by installDate in an ascending order
	OperatingSystemOrderByInstallDateAsc OperatingSystemOrderBy = "installDate_ASC"
	// Order by installDate in a descending order
	OperatingSystemOrderByInstallDateDesc OperatingSystemOrderBy = "installDate_DESC"
	// Order by kernelVersion in an ascending order
	OperatingSystemOrderByKernelVersionAsc OperatingSystemOrderBy = "kernelVersion_ASC"
	// Order by kernelVersion in a descending order
	OperatingSystemOrderByKernelVersionDesc OperatingSystemOrderBy = "kernelVersion_DESC"
	// Order by codeName in an ascending order
	OperatingSystemOrderByCodeNameAsc OperatingSystemOrderBy = "codeName_ASC"
	// Order by codeName in a descending order
	OperatingSystemOrderByCodeNameDesc OperatingSystemOrderBy = "codeName_DESC"
	// Order by major in an ascending order
	OperatingSystemOrderByMajorAsc OperatingSystemOrderBy = "major_ASC"
	// Order by major in a descending order
	OperatingSystemOrderByMajorDesc OperatingSystemOrderBy = "major_DESC"
	// Order by minor in an ascending order
	OperatingSystemOrderByMinorAsc OperatingSystemOrderBy = "minor_ASC"
	// Order by minor in a descending order
	OperatingSystemOrderByMinorDesc OperatingSystemOrderBy = "minor_DESC"
	// Order by build in an ascending order
	OperatingSystemOrderByBuildAsc OperatingSystemOrderBy = "build_ASC"
	// Order by build in a descending order
	OperatingSystemOrderByBuildDesc OperatingSystemOrderBy = "build_DESC"
	// Order by rawName in an ascending order
	OperatingSystemOrderByRawNameAsc OperatingSystemOrderBy = "rawName_ASC"
	// Order by rawName in a descending order
	OperatingSystemOrderByRawNameDesc OperatingSystemOrderBy = "rawName_DESC"
)

var AllOperatingSystemOrderBy = []OperatingSystemOrderBy{
	OperatingSystemOrderByTypeAsc,
	OperatingSystemOrderByTypeDesc,
	OperatingSystemOrderByDistributionAsc,
	OperatingSystemOrderByDistributionDesc,
	OperatingSystemOrderByArchitectureAsc,
	OperatingSystemOrderByArchitectureDesc,
	OperatingSystemOrderByServicePackAsc,
	OperatingSystemOrderByServicePackDesc,
	OperatingSystemOrderByInstallDateAsc,
	OperatingSystemOrderByInstallDateDesc,
	OperatingSystemOrderByKernelVersionAsc,
	OperatingSystemOrderByKernelVersionDesc,
	OperatingSystemOrderByCodeNameAsc,
	OperatingSystemOrderByCodeNameDesc,
	OperatingSystemOrderByMajorAsc,
	OperatingSystemOrderByMajorDesc,
	OperatingSystemOrderByMinorAsc,
	OperatingSystemOrderByMinorDesc,
	OperatingSystemOrderByBuildAsc,
	OperatingSystemOrderByBuildDesc,
	OperatingSystemOrderByRawNameAsc,
	OperatingSystemOrderByRawNameDesc,
}

func (e OperatingSystemOrderBy) IsValid() bool {
	switch e {
	case OperatingSystemOrderByTypeAsc, OperatingSystemOrderByTypeDesc, OperatingSystemOrderByDistributionAsc, OperatingSystemOrderByDistributionDesc, OperatingSystemOrderByArchitectureAsc, OperatingSystemOrderByArchitectureDesc, OperatingSystemOrderByServicePackAsc, OperatingSystemOrderByServicePackDesc, OperatingSystemOrderByInstallDateAsc, OperatingSystemOrderByInstallDateDesc, OperatingSystemOrderByKernelVersionAsc, OperatingSystemOrderByKernelVersionDesc, OperatingSystemOrderByCodeNameAsc, OperatingSystemOrderByCodeNameDesc, OperatingSystemOrderByMajorAsc, OperatingSystemOrderByMajorDesc, OperatingSystemOrderByMinorAsc, OperatingSystemOrderByMinorDesc, OperatingSystemOrderByBuildAsc, OperatingSystemOrderByBuildDesc, OperatingSystemOrderByRawNameAsc, OperatingSystemOrderByRawNameDesc:
		return true
	}
	return false
}

func (e OperatingSystemOrderBy) String() string {
	return string(e)
}

func (e *OperatingSystemOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperatingSystemOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid operating_system_order_by", str)
	}
	return nil
}

func (e OperatingSystemOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PreventionSettingsAggregateColumns string

const (
	// groupBy by name
	PreventionSettingsAggregateColumnsName PreventionSettingsAggregateColumns = "name"
)

var AllPreventionSettingsAggregateColumns = []PreventionSettingsAggregateColumns{
	PreventionSettingsAggregateColumnsName,
}

func (e PreventionSettingsAggregateColumns) IsValid() bool {
	switch e {
	case PreventionSettingsAggregateColumnsName:
		return true
	}
	return false
}

func (e PreventionSettingsAggregateColumns) String() string {
	return string(e)
}

func (e *PreventionSettingsAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PreventionSettingsAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid preventionSettings_aggregate_columns", str)
	}
	return nil
}

func (e PreventionSettingsAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PreventionSettingsAggregateMaxColumns string

const (
	// max by name
	PreventionSettingsAggregateMaxColumnsName PreventionSettingsAggregateMaxColumns = "name"
)

var AllPreventionSettingsAggregateMaxColumns = []PreventionSettingsAggregateMaxColumns{
	PreventionSettingsAggregateMaxColumnsName,
}

func (e PreventionSettingsAggregateMaxColumns) IsValid() bool {
	switch e {
	case PreventionSettingsAggregateMaxColumnsName:
		return true
	}
	return false
}

func (e PreventionSettingsAggregateMaxColumns) String() string {
	return string(e)
}

func (e *PreventionSettingsAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PreventionSettingsAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid preventionSettings_aggregate_max_columns", str)
	}
	return nil
}

func (e PreventionSettingsAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PreventionSettingsAggregateMinColumns string

const (
	// min by name
	PreventionSettingsAggregateMinColumnsName PreventionSettingsAggregateMinColumns = "name"
)

var AllPreventionSettingsAggregateMinColumns = []PreventionSettingsAggregateMinColumns{
	PreventionSettingsAggregateMinColumnsName,
}

func (e PreventionSettingsAggregateMinColumns) IsValid() bool {
	switch e {
	case PreventionSettingsAggregateMinColumnsName:
		return true
	}
	return false
}

func (e PreventionSettingsAggregateMinColumns) String() string {
	return string(e)
}

func (e *PreventionSettingsAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PreventionSettingsAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid preventionSettings_aggregate_min_columns", str)
	}
	return nil
}

func (e PreventionSettingsAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SensorUpdateSettingsAggregateColumns string

const (
	// groupBy by build
	SensorUpdateSettingsAggregateColumnsBuild SensorUpdateSettingsAggregateColumns = "build"
)

var AllSensorUpdateSettingsAggregateColumns = []SensorUpdateSettingsAggregateColumns{
	SensorUpdateSettingsAggregateColumnsBuild,
}

func (e SensorUpdateSettingsAggregateColumns) IsValid() bool {
	switch e {
	case SensorUpdateSettingsAggregateColumnsBuild:
		return true
	}
	return false
}

func (e SensorUpdateSettingsAggregateColumns) String() string {
	return string(e)
}

func (e *SensorUpdateSettingsAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SensorUpdateSettingsAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sensorUpdateSettings_aggregate_columns", str)
	}
	return nil
}

func (e SensorUpdateSettingsAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SensorUpdateSettingsAggregateMaxColumns string

const (
	// max by build
	SensorUpdateSettingsAggregateMaxColumnsBuild SensorUpdateSettingsAggregateMaxColumns = "build"
)

var AllSensorUpdateSettingsAggregateMaxColumns = []SensorUpdateSettingsAggregateMaxColumns{
	SensorUpdateSettingsAggregateMaxColumnsBuild,
}

func (e SensorUpdateSettingsAggregateMaxColumns) IsValid() bool {
	switch e {
	case SensorUpdateSettingsAggregateMaxColumnsBuild:
		return true
	}
	return false
}

func (e SensorUpdateSettingsAggregateMaxColumns) String() string {
	return string(e)
}

func (e *SensorUpdateSettingsAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SensorUpdateSettingsAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sensorUpdateSettings_aggregate_max_columns", str)
	}
	return nil
}

func (e SensorUpdateSettingsAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SensorUpdateSettingsAggregateMinColumns string

const (
	// min by build
	SensorUpdateSettingsAggregateMinColumnsBuild SensorUpdateSettingsAggregateMinColumns = "build"
)

var AllSensorUpdateSettingsAggregateMinColumns = []SensorUpdateSettingsAggregateMinColumns{
	SensorUpdateSettingsAggregateMinColumnsBuild,
}

func (e SensorUpdateSettingsAggregateMinColumns) IsValid() bool {
	switch e {
	case SensorUpdateSettingsAggregateMinColumnsBuild:
		return true
	}
	return false
}

func (e SensorUpdateSettingsAggregateMinColumns) String() string {
	return string(e)
}

func (e *SensorUpdateSettingsAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SensorUpdateSettingsAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sensorUpdateSettings_aggregate_min_columns", str)
	}
	return nil
}

func (e SensorUpdateSettingsAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for Tag
type TagOrderBy string

const (
	// Order by name in an ascending order
	TagOrderByNameAsc TagOrderBy = "name_ASC"
	// Order by name in a descending order
	TagOrderByNameDesc TagOrderBy = "name_DESC"
	// Order by creator in an ascending order
	TagOrderByCreatorAsc TagOrderBy = "creator_ASC"
	// Order by creator in a descending order
	TagOrderByCreatorDesc TagOrderBy = "creator_DESC"
	// Order by level in an ascending order
	TagOrderByLevelAsc TagOrderBy = "level_ASC"
	// Order by level in a descending order
	TagOrderByLevelDesc TagOrderBy = "level_DESC"
)

var AllTagOrderBy = []TagOrderBy{
	TagOrderByNameAsc,
	TagOrderByNameDesc,
	TagOrderByCreatorAsc,
	TagOrderByCreatorDesc,
	TagOrderByLevelAsc,
	TagOrderByLevelDesc,
}

func (e TagOrderBy) IsValid() bool {
	switch e {
	case TagOrderByNameAsc, TagOrderByNameDesc, TagOrderByCreatorAsc, TagOrderByCreatorDesc, TagOrderByLevelAsc, TagOrderByLevelDesc:
		return true
	}
	return false
}

func (e TagOrderBy) String() string {
	return string(e)
}

func (e *TagOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tag_order_by", str)
	}
	return nil
}

func (e TagOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagsAggregateColumns string

const (
	// groupBy by name
	TagsAggregateColumnsName TagsAggregateColumns = "name"
	// groupBy by creator
	TagsAggregateColumnsCreator TagsAggregateColumns = "creator"
	// groupBy by level
	TagsAggregateColumnsLevel TagsAggregateColumns = "level"
)

var AllTagsAggregateColumns = []TagsAggregateColumns{
	TagsAggregateColumnsName,
	TagsAggregateColumnsCreator,
	TagsAggregateColumnsLevel,
}

func (e TagsAggregateColumns) IsValid() bool {
	switch e {
	case TagsAggregateColumnsName, TagsAggregateColumnsCreator, TagsAggregateColumnsLevel:
		return true
	}
	return false
}

func (e TagsAggregateColumns) String() string {
	return string(e)
}

func (e *TagsAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagsAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tags_aggregate_columns", str)
	}
	return nil
}

func (e TagsAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagsAggregateMaxColumns string

const (
	// max by name
	TagsAggregateMaxColumnsName TagsAggregateMaxColumns = "name"
	// max by creator
	TagsAggregateMaxColumnsCreator TagsAggregateMaxColumns = "creator"
	// max by level
	TagsAggregateMaxColumnsLevel TagsAggregateMaxColumns = "level"
)

var AllTagsAggregateMaxColumns = []TagsAggregateMaxColumns{
	TagsAggregateMaxColumnsName,
	TagsAggregateMaxColumnsCreator,
	TagsAggregateMaxColumnsLevel,
}

func (e TagsAggregateMaxColumns) IsValid() bool {
	switch e {
	case TagsAggregateMaxColumnsName, TagsAggregateMaxColumnsCreator, TagsAggregateMaxColumnsLevel:
		return true
	}
	return false
}

func (e TagsAggregateMaxColumns) String() string {
	return string(e)
}

func (e *TagsAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagsAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tags_aggregate_max_columns", str)
	}
	return nil
}

func (e TagsAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagsAggregateMinColumns string

const (
	// min by name
	TagsAggregateMinColumnsName TagsAggregateMinColumns = "name"
	// min by creator
	TagsAggregateMinColumnsCreator TagsAggregateMinColumns = "creator"
	// min by level
	TagsAggregateMinColumnsLevel TagsAggregateMinColumns = "level"
)

var AllTagsAggregateMinColumns = []TagsAggregateMinColumns{
	TagsAggregateMinColumnsName,
	TagsAggregateMinColumnsCreator,
	TagsAggregateMinColumnsLevel,
}

func (e TagsAggregateMinColumns) IsValid() bool {
	switch e {
	case TagsAggregateMinColumnsName, TagsAggregateMinColumnsCreator, TagsAggregateMinColumnsLevel:
		return true
	}
	return false
}

func (e TagsAggregateMinColumns) String() string {
	return string(e)
}

func (e *TagsAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagsAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tags_aggregate_min_columns", str)
	}
	return nil
}

func (e TagsAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for User
type UserOrderBy string

const (
	// Order by fetchCycle in an ascending order
	UserOrderByFetchCycleAsc UserOrderBy = "fetchCycle_ASC"
	// Order by fetchCycle in a descending order
	UserOrderByFetchCycleDesc UserOrderBy = "fetchCycle_DESC"
	// Order by adapterCount in an ascending order
	UserOrderByAdapterCountAsc UserOrderBy = "adapterCount_ASC"
	// Order by adapterCount in a descending order
	UserOrderByAdapterCountDesc UserOrderBy = "adapterCount_DESC"
	// Order by lastSeen in an ascending order
	UserOrderByLastSeenAsc UserOrderBy = "lastSeen_ASC"
	// Order by lastSeen in a descending order
	UserOrderByLastSeenDesc UserOrderBy = "lastSeen_DESC"
)

var AllUserOrderBy = []UserOrderBy{
	UserOrderByFetchCycleAsc,
	UserOrderByFetchCycleDesc,
	UserOrderByAdapterCountAsc,
	UserOrderByAdapterCountDesc,
	UserOrderByLastSeenAsc,
	UserOrderByLastSeenDesc,
}

func (e UserOrderBy) IsValid() bool {
	switch e {
	case UserOrderByFetchCycleAsc, UserOrderByFetchCycleDesc, UserOrderByAdapterCountAsc, UserOrderByAdapterCountDesc, UserOrderByLastSeenAsc, UserOrderByLastSeenDesc:
		return true
	}
	return false
}

func (e UserOrderBy) String() string {
	return string(e)
}

func (e *UserOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid user_order_by", str)
	}
	return nil
}

func (e UserOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsersAggregateAvgColumns string

const (
	// avg by fetchCycle
	UsersAggregateAvgColumnsFetchCycle UsersAggregateAvgColumns = "fetchCycle"
	// avg by adapterCount
	UsersAggregateAvgColumnsAdapterCount UsersAggregateAvgColumns = "adapterCount"
	// avg by lastSeen
	UsersAggregateAvgColumnsLastSeen UsersAggregateAvgColumns = "lastSeen"
)

var AllUsersAggregateAvgColumns = []UsersAggregateAvgColumns{
	UsersAggregateAvgColumnsFetchCycle,
	UsersAggregateAvgColumnsAdapterCount,
	UsersAggregateAvgColumnsLastSeen,
}

func (e UsersAggregateAvgColumns) IsValid() bool {
	switch e {
	case UsersAggregateAvgColumnsFetchCycle, UsersAggregateAvgColumnsAdapterCount, UsersAggregateAvgColumnsLastSeen:
		return true
	}
	return false
}

func (e UsersAggregateAvgColumns) String() string {
	return string(e)
}

func (e *UsersAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_aggregate_avg_columns", str)
	}
	return nil
}

func (e UsersAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsersAggregateColumns string

const (
	// groupBy by id
	UsersAggregateColumnsID UsersAggregateColumns = "id"
	// groupBy by fetchCycle
	UsersAggregateColumnsFetchCycle UsersAggregateColumns = "fetchCycle"
	// groupBy by adapterCount
	UsersAggregateColumnsAdapterCount UsersAggregateColumns = "adapterCount"
	// groupBy by lastSeen
	UsersAggregateColumnsLastSeen UsersAggregateColumns = "lastSeen"
)

var AllUsersAggregateColumns = []UsersAggregateColumns{
	UsersAggregateColumnsID,
	UsersAggregateColumnsFetchCycle,
	UsersAggregateColumnsAdapterCount,
	UsersAggregateColumnsLastSeen,
}

func (e UsersAggregateColumns) IsValid() bool {
	switch e {
	case UsersAggregateColumnsID, UsersAggregateColumnsFetchCycle, UsersAggregateColumnsAdapterCount, UsersAggregateColumnsLastSeen:
		return true
	}
	return false
}

func (e UsersAggregateColumns) String() string {
	return string(e)
}

func (e *UsersAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_aggregate_columns", str)
	}
	return nil
}

func (e UsersAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsersAggregateMaxColumns string

const (
	// max by id
	UsersAggregateMaxColumnsID UsersAggregateMaxColumns = "id"
	// max by fetchCycle
	UsersAggregateMaxColumnsFetchCycle UsersAggregateMaxColumns = "fetchCycle"
	// max by adapterCount
	UsersAggregateMaxColumnsAdapterCount UsersAggregateMaxColumns = "adapterCount"
	// max by lastSeen
	UsersAggregateMaxColumnsLastSeen UsersAggregateMaxColumns = "lastSeen"
)

var AllUsersAggregateMaxColumns = []UsersAggregateMaxColumns{
	UsersAggregateMaxColumnsID,
	UsersAggregateMaxColumnsFetchCycle,
	UsersAggregateMaxColumnsAdapterCount,
	UsersAggregateMaxColumnsLastSeen,
}

func (e UsersAggregateMaxColumns) IsValid() bool {
	switch e {
	case UsersAggregateMaxColumnsID, UsersAggregateMaxColumnsFetchCycle, UsersAggregateMaxColumnsAdapterCount, UsersAggregateMaxColumnsLastSeen:
		return true
	}
	return false
}

func (e UsersAggregateMaxColumns) String() string {
	return string(e)
}

func (e *UsersAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_aggregate_max_columns", str)
	}
	return nil
}

func (e UsersAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsersAggregateMinColumns string

const (
	// min by id
	UsersAggregateMinColumnsID UsersAggregateMinColumns = "id"
	// min by fetchCycle
	UsersAggregateMinColumnsFetchCycle UsersAggregateMinColumns = "fetchCycle"
	// min by adapterCount
	UsersAggregateMinColumnsAdapterCount UsersAggregateMinColumns = "adapterCount"
	// min by lastSeen
	UsersAggregateMinColumnsLastSeen UsersAggregateMinColumns = "lastSeen"
)

var AllUsersAggregateMinColumns = []UsersAggregateMinColumns{
	UsersAggregateMinColumnsID,
	UsersAggregateMinColumnsFetchCycle,
	UsersAggregateMinColumnsAdapterCount,
	UsersAggregateMinColumnsLastSeen,
}

func (e UsersAggregateMinColumns) IsValid() bool {
	switch e {
	case UsersAggregateMinColumnsID, UsersAggregateMinColumnsFetchCycle, UsersAggregateMinColumnsAdapterCount, UsersAggregateMinColumnsLastSeen:
		return true
	}
	return false
}

func (e UsersAggregateMinColumns) String() string {
	return string(e)
}

func (e *UsersAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_aggregate_min_columns", str)
	}
	return nil
}

func (e UsersAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsersAggregateSumColumns string

const (
	// sum by fetchCycle
	UsersAggregateSumColumnsFetchCycle UsersAggregateSumColumns = "fetchCycle"
	// sum by adapterCount
	UsersAggregateSumColumnsAdapterCount UsersAggregateSumColumns = "adapterCount"
	// sum by lastSeen
	UsersAggregateSumColumnsLastSeen UsersAggregateSumColumns = "lastSeen"
)

var AllUsersAggregateSumColumns = []UsersAggregateSumColumns{
	UsersAggregateSumColumnsFetchCycle,
	UsersAggregateSumColumnsAdapterCount,
	UsersAggregateSumColumnsLastSeen,
}

func (e UsersAggregateSumColumns) IsValid() bool {
	switch e {
	case UsersAggregateSumColumnsFetchCycle, UsersAggregateSumColumnsAdapterCount, UsersAggregateSumColumnsLastSeen:
		return true
	}
	return false
}

func (e UsersAggregateSumColumns) String() string {
	return string(e)
}

func (e *UsersAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_aggregate_sum_columns", str)
	}
	return nil
}

func (e UsersAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
