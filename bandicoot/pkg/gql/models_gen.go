// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bandicoot/internal"
	"bandicoot/pkg/domain"
	"fmt"
	"io"
	"net"
	"strconv"
	"time"

	"github.com/satori/go.uuid"
)

type AdapterData interface {
	IsAdapterData()
}

type Aggregate interface {
	IsAggregate()
}

type ActiveDirectoryData struct {
	// AD Common Name (CN)
	AdCn *string ` json:"ad_cn"`
	// AD objectSid
	AdSid *string ` json:"ad_sid"`
	// AD objectGUID
	AdGUID *string ` json:"ad_guid"`
	// AD name
	AdName *string ` json:"ad_name"`
	// AD SAMAccountName
	AdSAMAccountName *string ` json:"ad_sam_account_name"`
	// AD User Principal Name
	AdUserPrincipalName *string ` json:"ad_user_principal_name"`
	// AD displayName
	AdDisplayName *string ` json:"ad_display_name"`
	// AD distinguishedName
	AdDistinguishedName *string ` json:"ad_distinguished_name"`
	// AD canonicalName
	AdCanonicalName *string ` json:"ad_canonical_name"`
	// AD accountExpires
	AdAccountExpires *internal.Epoch ` json:"ad_account_expires"`
	// AD objectClass
	AdObjectClass []*string ` json:"ad_object_class"`
	// AD objectCategory
	AdObjectCategory *string ` json:"ad_object_category"`
	// AD Organizational Unit
	AdOrganizationalUnit []*string ` json:"ad_organizational_unit"`
	// AD lastLogoff
	AdLastLogoff *time.Time ` json:"ad_last_logoff"`
	// AD lastLogon
	AdLastLogon *time.Time ` json:"ad_last_logon"`
	// AD lastLogonTimestamp
	AdLastLogonTimestamp *time.Time ` json:"ad_last_logon_timestamp"`
	// AD badPasswordTime
	AdBadPasswordTime *time.Time ` json:"ad_bad_password_time"`
	// AD badPwdCount
	AdBadPwdCount *int ` json:"ad_bad_pwd_count"`
	// AD managedBy
	AdManagedBy *string ` json:"ad_managed_by"`
	// AD pwdLastSet
	AdPasswordLastSet *time.Time ` json:"ad_password_last_set"`
	// AD Primary group ID
	AdPrimaryGroupID *int ` json:"ad_primary_group_id"`
	// AD Primary group ID
	AdPrimaryGroupDn *string ` json:"ad_primary_group_dn"`
	// AD memberOf
	AdMemberOf []*string ` json:"ad_member_of"`
	// AD memberOf (nested full list)
	AdMemberOfFull []*string ` json:"ad_member_of_full"`
	// AD uSNChanged
	AdUsnChanged *int ` json:"ad_usn_changed"`
	// AD uSNCreated
	AdUsnCreated *int ` json:"ad_usn_created"`
	// AD whenChanged
	AdWhenChanged *time.Time ` json:"ad_when_changed"`
	// AD whenCreated
	AdWhenCreated *time.Time ` json:"ad_when_created"`
	// AD isCriticalSystemObject
	AdIsCriticalSystemObject *bool ` json:"ad_is_critical_system_object"`
	// AD msDS-AllowedToDelegateTo
	AdMsdsAllowedToDelegateTo []*string ` json:"ad_msds_allowed_to_delegate_to"`
	// AD Password Must Change
	AdPwdMustChange *bool ` json:"ad_pwd_must_change"`
	// AD Resultant Password Settings Object
	AdMsdsResultantPso *string ` json:"ad_msds_resultant_pso"`
}

func (ActiveDirectoryData) IsAdapterData() {}

type Adapter struct {
	ID         domain.AdapterType ` json:"id"`
	Name       *string            ` json:"name"`
	Properties []*string          ` json:"properties"`
}

type AdapterDevice struct {
	// Unique id of adapter device
	ID uuid.UUID ` json:"id"`
	// Cycle adapter device was fetched
	FetchCycle int ` json:"fetch_cycle"`
	// Idadas of adapter that fetched this device
	AdapterID domain.AdapterType ` json:"adapter_id"`
	Adapter   *Adapter           ` json:"adapter"`
	// Name of adapter that fetched this advice
	AdapterName *string ` json:"adapter_name"`
	// Correlated device id
	DeviceID uuid.UUID ` json:"device_id"`
	// Unique data returned by adapter on this device
	AdapterData AdapterData ` json:"adapter_data"`
	// Data returned by this adapter as a json mappping
	Data map[string]interface{} ` json:"data"`
	// Time adapter was requested to fetch device by axonius
	FetchTime *internal.Epoch ` json:"fetch_time"`
	// hostname of device
	Hostname *string ` json:"hostname"`
	// name given to device by the adapter
	Name *string ` json:"name"`
	// Last time device was seen by adapter in Unix time
	LastSeen *internal.Epoch ` json:"last_seen"`
	OsID     uuid.UUID       ` json:"os_id"`
	// Operating system adapter device is running on
	Os *OperatingSystem ` json:"os"`
	// Pertty id given to adapter device when axonius created it
	PrettyID   *string            ` json:"pretty_id"`
	Tags       []*Tag             ` json:"tags"`
	Interfaces []NetworkInterface ` json:"interfaces"`
	// List of uses who last used the device
	LastUsedUsers []*string ` json:"last_used_users"`
	// Name of domain this adapter device belongs too
	Domain *string ` json:"domain"`
	// Whether this adapter device is part of the domain
	PartOfDomain *bool ` json:"part_of_domain"`
	// Users known by this device
	DeviceUsers []*AdapterDeviceUser ` json:"device_users"`
	// local admins known by this device
	LocalAdmins []*AdapterDeviceAdmin ` json:"local_admins"`
	// Firewall rules defined on this adapter device
	FirewallRules []*FirewallRule ` json:"firewall_rules"`
	// Software installed on this device
	InstalledSoftware []*InstalledSoftware ` json:"installed_software"`
	AgentVersion      *string              ` json:"agent_version"`
	AgentStatus       *string              ` json:"agent_status"`
	AgentName         *string              ` json:"agent_name"`
	Model             *string              ` json:"model"`
	Manufacturer      *string              ` json:"manufacturer"`
	Serial            *string              ` json:"serial"`
	Family            *string              ` json:"family"`
	BiosVersion       *string              ` json:"bios_version"`
	BiosSerial        *string              ` json:"bios_serial"`
	// Returns aggregate of tags
	TagsAggregate []TagsAggregate ` json:"tags_aggregate"`
	// Returns aggregate of interfaces
	InterfacesAggregate []InterfacesAggregate ` json:"interfaces_aggregate"`
	// Returns aggregate of firewallRules
	FirewallRulesAggregate []FirewallRulesAggregate ` json:"firewall_rules_aggregate"`
	// Returns aggregate of installedSoftware
	InstalledSoftwareAggregate []InstalledSoftwareAggregate ` json:"installed_software_aggregate"`
}

type AdapterDeviceAdmin struct {
	Name *string    ` json:"name"`
	Type *AdminType ` json:"type"`
}

// User known by an adapter device
type AdapterDeviceUser struct {
	DeviceID       *uuid.UUID      ` json:"device_id"`
	Sid            *string         ` json:"sid"`
	Username       *string         ` json:"username"`
	LastUseDate    *internal.Epoch ` json:"last_use_date"`
	IsLocal        *bool           ` json:"is_local"`
	IsDisabled     *bool           ` json:"is_disabled"`
	IsAdmin        *bool           ` json:"is_admin"`
	UserDepartment *bool           ` json:"user_department"`
	PasswordMaxAge *int            ` json:"password_max_age"`
	Interpreter    *string         ` json:"interpreter"`
}

type AdapterUser struct {
	// Unique id of adapter device
	ID uuid.UUID ` json:"id"`
	// Cycle adapter device was fetched
	FetchCycle int ` json:"fetch_cycle"`
	// Id of adapter that fetched this device
	AdapterID domain.AdapterType ` json:"adapter_id"`
	Adapter   *Adapter           ` json:"adapter"`
	// Name of adapter that fetched this advice
	AdapterName *string ` json:"adapter_name"`
	// Correlated device id
	UserID uuid.UUID ` json:"user_id"`
	// Unique data returned by adapter on this device
	AdapterData AdapterData ` json:"adapter_data"`
	// Data returned by this adapter as a json mappping
	Data map[string]interface{} ` json:"data"`
	// Time adapter was requested to fetch device by axonius
	FetchTime *internal.Epoch ` json:"fetch_time"`
	// Last time device was seen by adapter in Unix time
	LastSeen *internal.Epoch ` json:"last_seen"`
	// Username
	Username *string ` json:"username"`
	// User first name
	FirstName *string ` json:"first_name"`
	// User last name
	LastName *string ` json:"last_name"`
	// User email account
	Mail *string ` json:"mail"`
	// User account has admin privileges
	Admin *bool ` json:"admin"`
	// User entity is local
	Local *bool ` json:"local"`
	// User account is a delegated admin
	DelegatedAdmin *bool ` json:"delegated_admin"`
	// User account has multi-factor authentication enforced
	MfaEnforced *bool ` json:"mfa_enforced"`
	// User account is enrollled in multi-factor authenticaton
	MfaEnrolled *bool ` json:"mfa_enrolled"`
	// User account is suspended
	Suspended *bool ` json:"suspended"`
	// User account has been locked
	Locked *bool ` json:"locked"`
	// User account has been disabled
	Disabled *bool ` json:"disabled"`
}

type CPU struct {
	ID          int     ` json:"id"`
	Name        string  ` json:"name"`
	Manfacturer *string ` json:"manfacturer"`
	Bitness     *int    ` json:"bitness"`
	Family      *string ` json:"family"`
	// Core count of CPU
	Cores        *int     ` json:"cores"`
	CoresThreads *int     ` json:"cores_threads"`
	Ghz          *float64 ` json:"ghz"`
}

type CrowdStrikeData struct {
	ExternalIP         *string    ` json:"external_ip"`
	Groups             []*CsGroup ` json:"groups"`
	PreventionPolicy   *CsPolicy  ` json:"prevention_policy"`
	SensorUpdatePolicy *CsGroup   ` json:"sensor_update_policy"`
	CsAgentVersion     *string    ` json:"cs_agent_version"`
	// Returns aggregate of groups
	GroupsAggregate []GroupsAggregate ` json:"groups_aggregate"`
}

func (CrowdStrikeData) IsAdapterData() {}

type CylanceData struct {
	IsSafe          *string             ` json:"is_safe"`
	DeviceState     *CylanceDeviceState ` json:"device_state"`
	PolicyID        *string             ` json:"policy_id"`
	PolicyName      *string             ` json:"policy_name"`
	PoliciesDetails []*string           ` json:"policies_details"`
	TenantTag       *string             ` json:"tenant_tag"`
	ZoneNames       []*string           ` json:"zone_names"`
	AgentVersion    *string             ` json:"agent_version"`
}

func (CylanceData) IsAdapterData() {}

// Device aggregates one or more adapter device that were correlated
type Device struct {
	// Unique ID of correlated device
	ID uuid.UUID ` json:"id"`
	// Fetch cycle this device was collected
	FetchCycle int ` json:"fetch_cycle"`
	// Count of adapters that are correlated to this device
	AdapterCount int ` json:"adapter_count"`
	// Names of adapters that are correlated to this device
	AdapterNames []string ` json:"adapter_names"`
	// Unique hostnames given to device by all adapters
	Hostnames []string ` json:"hostnames"`
	// Last time device was seen by one of the adapters
	LastSeen *internal.Epoch ` json:"last_seen"`
	// Adapter devices that are correlated to this device
	AdapterDevices []AdapterDevice ` json:"adapter_devices"`
	// Unique set of network interfaces collected by all adapter devices
	Interfaces []NetworkInterface ` json:"interfaces"`
	// Unique set tags given to all adapter devices
	Tags []Tag ` json:"tags"`
	// Allows transformation of queried data to API v1
	CompatabilityAPI map[string]interface{} ` json:"compatability_api"`
	// Returns aggregate of adapterDevices
	AdapterDevicesAggregate []AdapterDevicesAggregate ` json:"adapter_devices_aggregate"`
	// Returns aggregate of interfaces
	InterfacesAggregate []InterfacesAggregate ` json:"interfaces_aggregate"`
	// Returns aggregate of tags
	TagsAggregate []TagsAggregate ` json:"tags_aggregate"`
}

type FirewallRule struct {
	Name      *string     ` json:"name"`
	Source    *string     ` json:"source"`
	Type      *AccessType ` json:"type"`
	Direction *Direction  ` json:"direction"`
	Target    *string     ` json:"target"`
	Protocol  *string     ` json:"protocol"`
	SrcPort   *int        ` json:"src_port"`
	DstPort   *int        ` json:"dst_port"`
}

type GCETagsAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	GCETags  []*GceTags             ` json:"gce_tags"`
}

type GceTags struct {
	GceKey   *string ` json:"gce_key"`
	GceValue *string ` json:"gce_value"`
}

type GoogleCloudData struct {
	ID      *string    ` json:"id"`
	Size    *string    ` json:"size"`
	Image   *string    ` json:"image"`
	GCETags []*GceTags ` json:"gce_tags"`
	// Returns aggregate of GCETags
	GCETagsAggregate []GCETagsAggregate ` json:"gce_tags_aggregate"`
}

type InstalledSoftware struct {
	// Software Name
	Name *string ` json:"name"`
	// Software Version
	Version      *string       ` json:"version"`
	Architecture *Architecture ` json:"architecture"`
	Description  *string       ` json:"description"`
	// Software Vendor
	Vendor    *string ` json:"vendor"`
	Publisher *string ` json:"publisher"`
	CveCount  *int    ` json:"cve_count"`
	SwLicense *string ` json:"sw_license"`
	Path      *string ` json:"path"`
}

type NetworkInterface struct {
	DeviceID *uuid.UUID ` json:"device_id"`
	MacAddr  *string    ` json:"mac_addr"`
	IPAddrs  []net.IP   ` json:"ip_addrs"`
}

// Operating System is the system installed on an adapter device
type OperatingSystem struct {
	ID            uuid.UUID       ` json:"id"`
	Type          *string         ` json:"type"`
	Distribution  *string         ` json:"distribution"`
	Architecture  *int            ` json:"architecture"`
	ServicePack   *string         ` json:"service_pack"`
	InstallDate   *internal.Epoch ` json:"install_date"`
	KernelVersion *string         ` json:"kernel_version"`
	CodeName      *string         ` json:"code_name"`
	Major         *int            ` json:"major"`
	Minor         *int            ` json:"minor"`
	Build         *string         ` json:"build"`
	RawName       *string         ` json:"raw_name"`
}

type Storage struct {
	DeviceID uuid.UUID ` json:"device_id"`
	// Path
	Path string ` json:"path"`
	// Device Name
	Name string ` json:"name"`
	// Size (GB)
	TotalSize float64 ` json:"total_size"`
	// Size (GB)
	FreeSize float64 ` json:"free_size"`
	// Whether drive is encrypted or not
	IsEncrypted bool ` json:"is_encrypted"`
	// Descirption of device
	Description *string ` json:"description"`
}

type Tag struct {
	Name    string ` json:"name"`
	Creator string ` json:"creator"`
	Level   string ` json:"level"`
}

type User struct {
	ID               uuid.UUID              ` json:"id"`
	FetchCycle       int                    ` json:"fetch_cycle"`
	AdapterCount     int                    ` json:"adapter_count"`
	AdapterNames     []string               ` json:"adapter_names"`
	Usernames        []string               ` json:"usernames"`
	LastSeen         *internal.Epoch        ` json:"last_seen"`
	AdapterUsers     []AdapterUser          ` json:"adapter_users"`
	CompatabilityAPI map[string]interface{} ` json:"compatability_api"`
	// Returns aggregate of adapterUsers
	AdapterUsersAggregate []AdapterUsersAggregate ` json:"adapter_users_aggregate"`
}

type AdapterDevicesAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	// Adapter devices that are correlated to this device
	AdapterDevices []*AdapterDevice ` json:"adapter_devices"`
}

type AdapterUsersAggregate struct {
	Group        []string               ` json:"group"`
	Distinct     []string               ` json:"distinct"`
	Count        *int                   ` json:"count"`
	Sum          map[string]interface{} ` json:"sum"`
	Avg          map[string]interface{} ` json:"avg"`
	Min          map[string]interface{} ` json:"min"`
	Max          map[string]interface{} ` json:"max"`
	AdapterUsers []*AdapterUser         ` json:"adapter_users"`
}

// Boolean filter expression for Adapter
type AdapterBoolExp struct {
	// eq comparison operator
	IDEq *domain.AdapterType ` json:"id_eq"`
	// neq comparison operator
	IDNeq *domain.AdapterType ` json:"id_neq"`
	// in comparison operator
	IDIn []*domain.AdapterType ` json:"id_in"`
	// not_in comparison operator
	IDNotIn []*domain.AdapterType ` json:"id_not_in"`
	// exists comparison operator
	NameExists *bool ` json:"name_exists"`
	// not comparison operator
	NameNot *string ` json:"name_not"`
	// eq comparison operator
	NameEq *string ` json:"name_eq"`
	// neq comparison operator
	NameNeq *string ` json:"name_neq"`
	// in comparison operator
	NameIn []*string ` json:"name_in"`
	// not_in comparison operator
	NameNotIn []*string ` json:"name_not_in"`
	// like comparison operator
	NameLike *string ` json:"name_like"`
	// not_like comparison operator
	NameNotLike *string ` json:"name_not_like"`
	// ilike comparison operator
	NameIlike *string ` json:"name_ilike"`
	// not_ilike comparison operator
	NameNotIlike *string ` json:"name_not_ilike"`
	// suffix comparison operator
	NameSuffix *string ` json:"name_suffix"`
	// prefix comparison operator
	NamePrefix *string ` json:"name_prefix"`
	// contains comparison operator
	PropertiesContains []*string ` json:"properties_contains"`
	// contained_by comparison operator
	PropertiesContainedBy []*string ` json:"properties_contained_by"`
	// overlap comparison operator
	PropertiesOverlap []*string ` json:"properties_overlap"`
	// size comparison operator
	PropertiesSize *int ` json:"properties_size"`
	// contains_regex comparison operator
	PropertiesContainsRegex *string          ` json:"properties_contains_regex"`
	And                     []AdapterBoolExp ` json:"and"`
	Or                      []AdapterBoolExp ` json:"or"`
	Not                     []AdapterBoolExp ` json:"not"`
}

// Boolean filter expression for AdapterData
type AdapterDataBoolExp struct {
	// exists comparison operator
	AdCnExists *bool ` json:"ad_cn_exists"`
	// not comparison operator
	AdCnNot *string ` json:"ad_cn_not"`
	// eq comparison operator
	AdCnEq *string ` json:"ad_cn_eq"`
	// neq comparison operator
	AdCnNeq *string ` json:"ad_cn_neq"`
	// in comparison operator
	AdCnIn []*string ` json:"ad_cn_in"`
	// not_in comparison operator
	AdCnNotIn []*string ` json:"ad_cn_not_in"`
	// like comparison operator
	AdCnLike *string ` json:"ad_cn_like"`
	// not_like comparison operator
	AdCnNotLike *string ` json:"ad_cn_not_like"`
	// ilike comparison operator
	AdCnIlike *string ` json:"ad_cn_ilike"`
	// not_ilike comparison operator
	AdCnNotIlike *string ` json:"ad_cn_not_ilike"`
	// suffix comparison operator
	AdCnSuffix *string ` json:"ad_cn_suffix"`
	// prefix comparison operator
	AdCnPrefix *string ` json:"ad_cn_prefix"`
	// exists comparison operator
	AdSidExists *bool ` json:"ad_sid_exists"`
	// not comparison operator
	AdSidNot *string ` json:"ad_sid_not"`
	// eq comparison operator
	AdSidEq *string ` json:"ad_sid_eq"`
	// neq comparison operator
	AdSidNeq *string ` json:"ad_sid_neq"`
	// in comparison operator
	AdSidIn []*string ` json:"ad_sid_in"`
	// not_in comparison operator
	AdSidNotIn []*string ` json:"ad_sid_not_in"`
	// like comparison operator
	AdSidLike *string ` json:"ad_sid_like"`
	// not_like comparison operator
	AdSidNotLike *string ` json:"ad_sid_not_like"`
	// ilike comparison operator
	AdSidIlike *string ` json:"ad_sid_ilike"`
	// not_ilike comparison operator
	AdSidNotIlike *string ` json:"ad_sid_not_ilike"`
	// suffix comparison operator
	AdSidSuffix *string ` json:"ad_sid_suffix"`
	// prefix comparison operator
	AdSidPrefix *string ` json:"ad_sid_prefix"`
	// exists comparison operator
	AdGUIDExists *bool ` json:"ad_guid_exists"`
	// not comparison operator
	AdGUIDNot *string ` json:"ad_guid_not"`
	// eq comparison operator
	AdGUIDEq *string ` json:"ad_guid_eq"`
	// neq comparison operator
	AdGUIDNeq *string ` json:"ad_guid_neq"`
	// in comparison operator
	AdGUIDIn []*string ` json:"ad_guid_in"`
	// not_in comparison operator
	AdGUIDNotIn []*string ` json:"ad_guid_not_in"`
	// like comparison operator
	AdGUIDLike *string ` json:"ad_guid_like"`
	// not_like comparison operator
	AdGUIDNotLike *string ` json:"ad_guid_not_like"`
	// ilike comparison operator
	AdGUIDIlike *string ` json:"ad_guid_ilike"`
	// not_ilike comparison operator
	AdGUIDNotIlike *string ` json:"ad_guid_not_ilike"`
	// suffix comparison operator
	AdGUIDSuffix *string ` json:"ad_guid_suffix"`
	// prefix comparison operator
	AdGUIDPrefix *string ` json:"ad_guid_prefix"`
	// exists comparison operator
	AdNameExists *bool ` json:"ad_name_exists"`
	// not comparison operator
	AdNameNot *string ` json:"ad_name_not"`
	// eq comparison operator
	AdNameEq *string ` json:"ad_name_eq"`
	// neq comparison operator
	AdNameNeq *string ` json:"ad_name_neq"`
	// in comparison operator
	AdNameIn []*string ` json:"ad_name_in"`
	// not_in comparison operator
	AdNameNotIn []*string ` json:"ad_name_not_in"`
	// like comparison operator
	AdNameLike *string ` json:"ad_name_like"`
	// not_like comparison operator
	AdNameNotLike *string ` json:"ad_name_not_like"`
	// ilike comparison operator
	AdNameIlike *string ` json:"ad_name_ilike"`
	// not_ilike comparison operator
	AdNameNotIlike *string ` json:"ad_name_not_ilike"`
	// suffix comparison operator
	AdNameSuffix *string ` json:"ad_name_suffix"`
	// prefix comparison operator
	AdNamePrefix *string ` json:"ad_name_prefix"`
	// exists comparison operator
	AdSAMAccountNameExists *bool ` json:"ad_sam_account_name_exists"`
	// not comparison operator
	AdSAMAccountNameNot *string ` json:"ad_sam_account_name_not"`
	// eq comparison operator
	AdSAMAccountNameEq *string ` json:"ad_sam_account_name_eq"`
	// neq comparison operator
	AdSAMAccountNameNeq *string ` json:"ad_sam_account_name_neq"`
	// in comparison operator
	AdSAMAccountNameIn []*string ` json:"ad_sam_account_name_in"`
	// not_in comparison operator
	AdSAMAccountNameNotIn []*string ` json:"ad_sam_account_name_not_in"`
	// like comparison operator
	AdSAMAccountNameLike *string ` json:"ad_sam_account_name_like"`
	// not_like comparison operator
	AdSAMAccountNameNotLike *string ` json:"ad_sam_account_name_not_like"`
	// ilike comparison operator
	AdSAMAccountNameIlike *string ` json:"ad_sam_account_name_ilike"`
	// not_ilike comparison operator
	AdSAMAccountNameNotIlike *string ` json:"ad_sam_account_name_not_ilike"`
	// suffix comparison operator
	AdSAMAccountNameSuffix *string ` json:"ad_sam_account_name_suffix"`
	// prefix comparison operator
	AdSAMAccountNamePrefix *string ` json:"ad_sam_account_name_prefix"`
	// exists comparison operator
	AdUserPrincipalNameExists *bool ` json:"ad_user_principal_name_exists"`
	// not comparison operator
	AdUserPrincipalNameNot *string ` json:"ad_user_principal_name_not"`
	// eq comparison operator
	AdUserPrincipalNameEq *string ` json:"ad_user_principal_name_eq"`
	// neq comparison operator
	AdUserPrincipalNameNeq *string ` json:"ad_user_principal_name_neq"`
	// in comparison operator
	AdUserPrincipalNameIn []*string ` json:"ad_user_principal_name_in"`
	// not_in comparison operator
	AdUserPrincipalNameNotIn []*string ` json:"ad_user_principal_name_not_in"`
	// like comparison operator
	AdUserPrincipalNameLike *string ` json:"ad_user_principal_name_like"`
	// not_like comparison operator
	AdUserPrincipalNameNotLike *string ` json:"ad_user_principal_name_not_like"`
	// ilike comparison operator
	AdUserPrincipalNameIlike *string ` json:"ad_user_principal_name_ilike"`
	// not_ilike comparison operator
	AdUserPrincipalNameNotIlike *string ` json:"ad_user_principal_name_not_ilike"`
	// suffix comparison operator
	AdUserPrincipalNameSuffix *string ` json:"ad_user_principal_name_suffix"`
	// prefix comparison operator
	AdUserPrincipalNamePrefix *string ` json:"ad_user_principal_name_prefix"`
	// exists comparison operator
	AdDisplayNameExists *bool ` json:"ad_display_name_exists"`
	// not comparison operator
	AdDisplayNameNot *string ` json:"ad_display_name_not"`
	// eq comparison operator
	AdDisplayNameEq *string ` json:"ad_display_name_eq"`
	// neq comparison operator
	AdDisplayNameNeq *string ` json:"ad_display_name_neq"`
	// in comparison operator
	AdDisplayNameIn []*string ` json:"ad_display_name_in"`
	// not_in comparison operator
	AdDisplayNameNotIn []*string ` json:"ad_display_name_not_in"`
	// like comparison operator
	AdDisplayNameLike *string ` json:"ad_display_name_like"`
	// not_like comparison operator
	AdDisplayNameNotLike *string ` json:"ad_display_name_not_like"`
	// ilike comparison operator
	AdDisplayNameIlike *string ` json:"ad_display_name_ilike"`
	// not_ilike comparison operator
	AdDisplayNameNotIlike *string ` json:"ad_display_name_not_ilike"`
	// suffix comparison operator
	AdDisplayNameSuffix *string ` json:"ad_display_name_suffix"`
	// prefix comparison operator
	AdDisplayNamePrefix *string ` json:"ad_display_name_prefix"`
	// exists comparison operator
	AdDistinguishedNameExists *bool ` json:"ad_distinguished_name_exists"`
	// not comparison operator
	AdDistinguishedNameNot *string ` json:"ad_distinguished_name_not"`
	// eq comparison operator
	AdDistinguishedNameEq *string ` json:"ad_distinguished_name_eq"`
	// neq comparison operator
	AdDistinguishedNameNeq *string ` json:"ad_distinguished_name_neq"`
	// in comparison operator
	AdDistinguishedNameIn []*string ` json:"ad_distinguished_name_in"`
	// not_in comparison operator
	AdDistinguishedNameNotIn []*string ` json:"ad_distinguished_name_not_in"`
	// like comparison operator
	AdDistinguishedNameLike *string ` json:"ad_distinguished_name_like"`
	// not_like comparison operator
	AdDistinguishedNameNotLike *string ` json:"ad_distinguished_name_not_like"`
	// ilike comparison operator
	AdDistinguishedNameIlike *string ` json:"ad_distinguished_name_ilike"`
	// not_ilike comparison operator
	AdDistinguishedNameNotIlike *string ` json:"ad_distinguished_name_not_ilike"`
	// suffix comparison operator
	AdDistinguishedNameSuffix *string ` json:"ad_distinguished_name_suffix"`
	// prefix comparison operator
	AdDistinguishedNamePrefix *string ` json:"ad_distinguished_name_prefix"`
	// exists comparison operator
	AdCanonicalNameExists *bool ` json:"ad_canonical_name_exists"`
	// not comparison operator
	AdCanonicalNameNot *string ` json:"ad_canonical_name_not"`
	// eq comparison operator
	AdCanonicalNameEq *string ` json:"ad_canonical_name_eq"`
	// neq comparison operator
	AdCanonicalNameNeq *string ` json:"ad_canonical_name_neq"`
	// in comparison operator
	AdCanonicalNameIn []*string ` json:"ad_canonical_name_in"`
	// not_in comparison operator
	AdCanonicalNameNotIn []*string ` json:"ad_canonical_name_not_in"`
	// like comparison operator
	AdCanonicalNameLike *string ` json:"ad_canonical_name_like"`
	// not_like comparison operator
	AdCanonicalNameNotLike *string ` json:"ad_canonical_name_not_like"`
	// ilike comparison operator
	AdCanonicalNameIlike *string ` json:"ad_canonical_name_ilike"`
	// not_ilike comparison operator
	AdCanonicalNameNotIlike *string ` json:"ad_canonical_name_not_ilike"`
	// suffix comparison operator
	AdCanonicalNameSuffix *string ` json:"ad_canonical_name_suffix"`
	// prefix comparison operator
	AdCanonicalNamePrefix *string ` json:"ad_canonical_name_prefix"`
	// exists comparison operator
	AdAccountExpiresExists *bool ` json:"ad_account_expires_exists"`
	// eq comparison operator
	AdAccountExpiresEq *internal.Epoch ` json:"ad_account_expires_eq"`
	// neq comparison operator
	AdAccountExpiresNeq *internal.Epoch ` json:"ad_account_expires_neq"`
	// in comparison operator
	AdAccountExpiresIn []*internal.Epoch ` json:"ad_account_expires_in"`
	// not_in comparison operator
	AdAccountExpiresNotIn []*internal.Epoch ` json:"ad_account_expires_not_in"`
	// gt comparison operator
	AdAccountExpiresGt *internal.Epoch ` json:"ad_account_expires_gt"`
	// gte comparison operator
	AdAccountExpiresGte *internal.Epoch ` json:"ad_account_expires_gte"`
	// lt comparison operator
	AdAccountExpiresLt *internal.Epoch ` json:"ad_account_expires_lt"`
	// lte comparison operator
	AdAccountExpiresLte *internal.Epoch ` json:"ad_account_expires_lte"`
	// days comparison operator
	AdAccountExpiresDays *int ` json:"ad_account_expires_days"`
	// contains comparison operator
	AdObjectClassContains []*string ` json:"ad_object_class_contains"`
	// contained_by comparison operator
	AdObjectClassContainedBy []*string ` json:"ad_object_class_contained_by"`
	// overlap comparison operator
	AdObjectClassOverlap []*string ` json:"ad_object_class_overlap"`
	// size comparison operator
	AdObjectClassSize *int ` json:"ad_object_class_size"`
	// contains_regex comparison operator
	AdObjectClassContainsRegex *string ` json:"ad_object_class_contains_regex"`
	// exists comparison operator
	AdObjectCategoryExists *bool ` json:"ad_object_category_exists"`
	// not comparison operator
	AdObjectCategoryNot *string ` json:"ad_object_category_not"`
	// eq comparison operator
	AdObjectCategoryEq *string ` json:"ad_object_category_eq"`
	// neq comparison operator
	AdObjectCategoryNeq *string ` json:"ad_object_category_neq"`
	// in comparison operator
	AdObjectCategoryIn []*string ` json:"ad_object_category_in"`
	// not_in comparison operator
	AdObjectCategoryNotIn []*string ` json:"ad_object_category_not_in"`
	// like comparison operator
	AdObjectCategoryLike *string ` json:"ad_object_category_like"`
	// not_like comparison operator
	AdObjectCategoryNotLike *string ` json:"ad_object_category_not_like"`
	// ilike comparison operator
	AdObjectCategoryIlike *string ` json:"ad_object_category_ilike"`
	// not_ilike comparison operator
	AdObjectCategoryNotIlike *string ` json:"ad_object_category_not_ilike"`
	// suffix comparison operator
	AdObjectCategorySuffix *string ` json:"ad_object_category_suffix"`
	// prefix comparison operator
	AdObjectCategoryPrefix *string ` json:"ad_object_category_prefix"`
	// contains comparison operator
	AdOrganizationalUnitContains []*string ` json:"ad_organizational_unit_contains"`
	// contained_by comparison operator
	AdOrganizationalUnitContainedBy []*string ` json:"ad_organizational_unit_contained_by"`
	// overlap comparison operator
	AdOrganizationalUnitOverlap []*string ` json:"ad_organizational_unit_overlap"`
	// size comparison operator
	AdOrganizationalUnitSize *int ` json:"ad_organizational_unit_size"`
	// contains_regex comparison operator
	AdOrganizationalUnitContainsRegex *string ` json:"ad_organizational_unit_contains_regex"`
	// exists comparison operator
	AdLastLogoffExists *bool ` json:"ad_last_logoff_exists"`
	// eq comparison operator
	AdLastLogoffEq *time.Time ` json:"ad_last_logoff_eq"`
	// neq comparison operator
	AdLastLogoffNeq *time.Time ` json:"ad_last_logoff_neq"`
	// in comparison operator
	AdLastLogoffIn []*time.Time ` json:"ad_last_logoff_in"`
	// not_in comparison operator
	AdLastLogoffNotIn []*time.Time ` json:"ad_last_logoff_not_in"`
	// gt comparison operator
	AdLastLogoffGt *time.Time ` json:"ad_last_logoff_gt"`
	// gte comparison operator
	AdLastLogoffGte *time.Time ` json:"ad_last_logoff_gte"`
	// lt comparison operator
	AdLastLogoffLt *time.Time ` json:"ad_last_logoff_lt"`
	// lte comparison operator
	AdLastLogoffLte *time.Time ` json:"ad_last_logoff_lte"`
	// days comparison operator
	AdLastLogoffDays *int ` json:"ad_last_logoff_days"`
	// exists comparison operator
	AdLastLogonExists *bool ` json:"ad_last_logon_exists"`
	// eq comparison operator
	AdLastLogonEq *time.Time ` json:"ad_last_logon_eq"`
	// neq comparison operator
	AdLastLogonNeq *time.Time ` json:"ad_last_logon_neq"`
	// in comparison operator
	AdLastLogonIn []*time.Time ` json:"ad_last_logon_in"`
	// not_in comparison operator
	AdLastLogonNotIn []*time.Time ` json:"ad_last_logon_not_in"`
	// gt comparison operator
	AdLastLogonGt *time.Time ` json:"ad_last_logon_gt"`
	// gte comparison operator
	AdLastLogonGte *time.Time ` json:"ad_last_logon_gte"`
	// lt comparison operator
	AdLastLogonLt *time.Time ` json:"ad_last_logon_lt"`
	// lte comparison operator
	AdLastLogonLte *time.Time ` json:"ad_last_logon_lte"`
	// days comparison operator
	AdLastLogonDays *int ` json:"ad_last_logon_days"`
	// exists comparison operator
	AdLastLogonTimestampExists *bool ` json:"ad_last_logon_timestamp_exists"`
	// eq comparison operator
	AdLastLogonTimestampEq *time.Time ` json:"ad_last_logon_timestamp_eq"`
	// neq comparison operator
	AdLastLogonTimestampNeq *time.Time ` json:"ad_last_logon_timestamp_neq"`
	// in comparison operator
	AdLastLogonTimestampIn []*time.Time ` json:"ad_last_logon_timestamp_in"`
	// not_in comparison operator
	AdLastLogonTimestampNotIn []*time.Time ` json:"ad_last_logon_timestamp_not_in"`
	// gt comparison operator
	AdLastLogonTimestampGt *time.Time ` json:"ad_last_logon_timestamp_gt"`
	// gte comparison operator
	AdLastLogonTimestampGte *time.Time ` json:"ad_last_logon_timestamp_gte"`
	// lt comparison operator
	AdLastLogonTimestampLt *time.Time ` json:"ad_last_logon_timestamp_lt"`
	// lte comparison operator
	AdLastLogonTimestampLte *time.Time ` json:"ad_last_logon_timestamp_lte"`
	// days comparison operator
	AdLastLogonTimestampDays *int ` json:"ad_last_logon_timestamp_days"`
	// exists comparison operator
	AdBadPasswordTimeExists *bool ` json:"ad_bad_password_time_exists"`
	// eq comparison operator
	AdBadPasswordTimeEq *time.Time ` json:"ad_bad_password_time_eq"`
	// neq comparison operator
	AdBadPasswordTimeNeq *time.Time ` json:"ad_bad_password_time_neq"`
	// in comparison operator
	AdBadPasswordTimeIn []*time.Time ` json:"ad_bad_password_time_in"`
	// not_in comparison operator
	AdBadPasswordTimeNotIn []*time.Time ` json:"ad_bad_password_time_not_in"`
	// gt comparison operator
	AdBadPasswordTimeGt *time.Time ` json:"ad_bad_password_time_gt"`
	// gte comparison operator
	AdBadPasswordTimeGte *time.Time ` json:"ad_bad_password_time_gte"`
	// lt comparison operator
	AdBadPasswordTimeLt *time.Time ` json:"ad_bad_password_time_lt"`
	// lte comparison operator
	AdBadPasswordTimeLte *time.Time ` json:"ad_bad_password_time_lte"`
	// days comparison operator
	AdBadPasswordTimeDays *int ` json:"ad_bad_password_time_days"`
	// exists comparison operator
	AdBadPwdCountExists *bool ` json:"ad_bad_pwd_count_exists"`
	// eq comparison operator
	AdBadPwdCountEq *int ` json:"ad_bad_pwd_count_eq"`
	// neq comparison operator
	AdBadPwdCountNeq *int ` json:"ad_bad_pwd_count_neq"`
	// in comparison operator
	AdBadPwdCountIn []*int ` json:"ad_bad_pwd_count_in"`
	// not_in comparison operator
	AdBadPwdCountNotIn []*int ` json:"ad_bad_pwd_count_not_in"`
	// gt comparison operator
	AdBadPwdCountGt *int ` json:"ad_bad_pwd_count_gt"`
	// gte comparison operator
	AdBadPwdCountGte *int ` json:"ad_bad_pwd_count_gte"`
	// lt comparison operator
	AdBadPwdCountLt *int ` json:"ad_bad_pwd_count_lt"`
	// lte comparison operator
	AdBadPwdCountLte *int ` json:"ad_bad_pwd_count_lte"`
	// exists comparison operator
	AdManagedByExists *bool ` json:"ad_managed_by_exists"`
	// not comparison operator
	AdManagedByNot *string ` json:"ad_managed_by_not"`
	// eq comparison operator
	AdManagedByEq *string ` json:"ad_managed_by_eq"`
	// neq comparison operator
	AdManagedByNeq *string ` json:"ad_managed_by_neq"`
	// in comparison operator
	AdManagedByIn []*string ` json:"ad_managed_by_in"`
	// not_in comparison operator
	AdManagedByNotIn []*string ` json:"ad_managed_by_not_in"`
	// like comparison operator
	AdManagedByLike *string ` json:"ad_managed_by_like"`
	// not_like comparison operator
	AdManagedByNotLike *string ` json:"ad_managed_by_not_like"`
	// ilike comparison operator
	AdManagedByIlike *string ` json:"ad_managed_by_ilike"`
	// not_ilike comparison operator
	AdManagedByNotIlike *string ` json:"ad_managed_by_not_ilike"`
	// suffix comparison operator
	AdManagedBySuffix *string ` json:"ad_managed_by_suffix"`
	// prefix comparison operator
	AdManagedByPrefix *string ` json:"ad_managed_by_prefix"`
	// exists comparison operator
	AdPasswordLastSetExists *bool ` json:"ad_password_last_set_exists"`
	// eq comparison operator
	AdPasswordLastSetEq *time.Time ` json:"ad_password_last_set_eq"`
	// neq comparison operator
	AdPasswordLastSetNeq *time.Time ` json:"ad_password_last_set_neq"`
	// in comparison operator
	AdPasswordLastSetIn []*time.Time ` json:"ad_password_last_set_in"`
	// not_in comparison operator
	AdPasswordLastSetNotIn []*time.Time ` json:"ad_password_last_set_not_in"`
	// gt comparison operator
	AdPasswordLastSetGt *time.Time ` json:"ad_password_last_set_gt"`
	// gte comparison operator
	AdPasswordLastSetGte *time.Time ` json:"ad_password_last_set_gte"`
	// lt comparison operator
	AdPasswordLastSetLt *time.Time ` json:"ad_password_last_set_lt"`
	// lte comparison operator
	AdPasswordLastSetLte *time.Time ` json:"ad_password_last_set_lte"`
	// days comparison operator
	AdPasswordLastSetDays *int ` json:"ad_password_last_set_days"`
	// exists comparison operator
	AdPrimaryGroupIDExists *bool ` json:"ad_primary_group_id_exists"`
	// eq comparison operator
	AdPrimaryGroupIDEq *int ` json:"ad_primary_group_id_eq"`
	// neq comparison operator
	AdPrimaryGroupIDNeq *int ` json:"ad_primary_group_id_neq"`
	// in comparison operator
	AdPrimaryGroupIDIn []*int ` json:"ad_primary_group_id_in"`
	// not_in comparison operator
	AdPrimaryGroupIDNotIn []*int ` json:"ad_primary_group_id_not_in"`
	// gt comparison operator
	AdPrimaryGroupIDGt *int ` json:"ad_primary_group_id_gt"`
	// gte comparison operator
	AdPrimaryGroupIDGte *int ` json:"ad_primary_group_id_gte"`
	// lt comparison operator
	AdPrimaryGroupIDLt *int ` json:"ad_primary_group_id_lt"`
	// lte comparison operator
	AdPrimaryGroupIDLte *int ` json:"ad_primary_group_id_lte"`
	// exists comparison operator
	AdPrimaryGroupDnExists *bool ` json:"ad_primary_group_dn_exists"`
	// not comparison operator
	AdPrimaryGroupDnNot *string ` json:"ad_primary_group_dn_not"`
	// eq comparison operator
	AdPrimaryGroupDnEq *string ` json:"ad_primary_group_dn_eq"`
	// neq comparison operator
	AdPrimaryGroupDnNeq *string ` json:"ad_primary_group_dn_neq"`
	// in comparison operator
	AdPrimaryGroupDnIn []*string ` json:"ad_primary_group_dn_in"`
	// not_in comparison operator
	AdPrimaryGroupDnNotIn []*string ` json:"ad_primary_group_dn_not_in"`
	// like comparison operator
	AdPrimaryGroupDnLike *string ` json:"ad_primary_group_dn_like"`
	// not_like comparison operator
	AdPrimaryGroupDnNotLike *string ` json:"ad_primary_group_dn_not_like"`
	// ilike comparison operator
	AdPrimaryGroupDnIlike *string ` json:"ad_primary_group_dn_ilike"`
	// not_ilike comparison operator
	AdPrimaryGroupDnNotIlike *string ` json:"ad_primary_group_dn_not_ilike"`
	// suffix comparison operator
	AdPrimaryGroupDnSuffix *string ` json:"ad_primary_group_dn_suffix"`
	// prefix comparison operator
	AdPrimaryGroupDnPrefix *string ` json:"ad_primary_group_dn_prefix"`
	// contains comparison operator
	AdMemberOfContains []*string ` json:"ad_member_of_contains"`
	// contained_by comparison operator
	AdMemberOfContainedBy []*string ` json:"ad_member_of_contained_by"`
	// overlap comparison operator
	AdMemberOfOverlap []*string ` json:"ad_member_of_overlap"`
	// size comparison operator
	AdMemberOfSize *int ` json:"ad_member_of_size"`
	// contains_regex comparison operator
	AdMemberOfContainsRegex *string ` json:"ad_member_of_contains_regex"`
	// contains comparison operator
	AdMemberOfFullContains []*string ` json:"ad_member_of_full_contains"`
	// contained_by comparison operator
	AdMemberOfFullContainedBy []*string ` json:"ad_member_of_full_contained_by"`
	// overlap comparison operator
	AdMemberOfFullOverlap []*string ` json:"ad_member_of_full_overlap"`
	// size comparison operator
	AdMemberOfFullSize *int ` json:"ad_member_of_full_size"`
	// contains_regex comparison operator
	AdMemberOfFullContainsRegex *string ` json:"ad_member_of_full_contains_regex"`
	// exists comparison operator
	AdUsnChangedExists *bool ` json:"ad_usn_changed_exists"`
	// eq comparison operator
	AdUsnChangedEq *int ` json:"ad_usn_changed_eq"`
	// neq comparison operator
	AdUsnChangedNeq *int ` json:"ad_usn_changed_neq"`
	// in comparison operator
	AdUsnChangedIn []*int ` json:"ad_usn_changed_in"`
	// not_in comparison operator
	AdUsnChangedNotIn []*int ` json:"ad_usn_changed_not_in"`
	// gt comparison operator
	AdUsnChangedGt *int ` json:"ad_usn_changed_gt"`
	// gte comparison operator
	AdUsnChangedGte *int ` json:"ad_usn_changed_gte"`
	// lt comparison operator
	AdUsnChangedLt *int ` json:"ad_usn_changed_lt"`
	// lte comparison operator
	AdUsnChangedLte *int ` json:"ad_usn_changed_lte"`
	// exists comparison operator
	AdUsnCreatedExists *bool ` json:"ad_usn_created_exists"`
	// eq comparison operator
	AdUsnCreatedEq *int ` json:"ad_usn_created_eq"`
	// neq comparison operator
	AdUsnCreatedNeq *int ` json:"ad_usn_created_neq"`
	// in comparison operator
	AdUsnCreatedIn []*int ` json:"ad_usn_created_in"`
	// not_in comparison operator
	AdUsnCreatedNotIn []*int ` json:"ad_usn_created_not_in"`
	// gt comparison operator
	AdUsnCreatedGt *int ` json:"ad_usn_created_gt"`
	// gte comparison operator
	AdUsnCreatedGte *int ` json:"ad_usn_created_gte"`
	// lt comparison operator
	AdUsnCreatedLt *int ` json:"ad_usn_created_lt"`
	// lte comparison operator
	AdUsnCreatedLte *int ` json:"ad_usn_created_lte"`
	// exists comparison operator
	AdWhenChangedExists *bool ` json:"ad_when_changed_exists"`
	// eq comparison operator
	AdWhenChangedEq *time.Time ` json:"ad_when_changed_eq"`
	// neq comparison operator
	AdWhenChangedNeq *time.Time ` json:"ad_when_changed_neq"`
	// in comparison operator
	AdWhenChangedIn []*time.Time ` json:"ad_when_changed_in"`
	// not_in comparison operator
	AdWhenChangedNotIn []*time.Time ` json:"ad_when_changed_not_in"`
	// gt comparison operator
	AdWhenChangedGt *time.Time ` json:"ad_when_changed_gt"`
	// gte comparison operator
	AdWhenChangedGte *time.Time ` json:"ad_when_changed_gte"`
	// lt comparison operator
	AdWhenChangedLt *time.Time ` json:"ad_when_changed_lt"`
	// lte comparison operator
	AdWhenChangedLte *time.Time ` json:"ad_when_changed_lte"`
	// days comparison operator
	AdWhenChangedDays *int ` json:"ad_when_changed_days"`
	// exists comparison operator
	AdWhenCreatedExists *bool ` json:"ad_when_created_exists"`
	// eq comparison operator
	AdWhenCreatedEq *time.Time ` json:"ad_when_created_eq"`
	// neq comparison operator
	AdWhenCreatedNeq *time.Time ` json:"ad_when_created_neq"`
	// in comparison operator
	AdWhenCreatedIn []*time.Time ` json:"ad_when_created_in"`
	// not_in comparison operator
	AdWhenCreatedNotIn []*time.Time ` json:"ad_when_created_not_in"`
	// gt comparison operator
	AdWhenCreatedGt *time.Time ` json:"ad_when_created_gt"`
	// gte comparison operator
	AdWhenCreatedGte *time.Time ` json:"ad_when_created_gte"`
	// lt comparison operator
	AdWhenCreatedLt *time.Time ` json:"ad_when_created_lt"`
	// lte comparison operator
	AdWhenCreatedLte *time.Time ` json:"ad_when_created_lte"`
	// days comparison operator
	AdWhenCreatedDays *int ` json:"ad_when_created_days"`
	// exists comparison operator
	AdIsCriticalSystemObjectExists *bool ` json:"ad_is_critical_system_object_exists"`
	// eq comparison operator
	AdIsCriticalSystemObjectEq *bool ` json:"ad_is_critical_system_object_eq"`
	// neq comparison operator
	AdIsCriticalSystemObjectNeq *bool ` json:"ad_is_critical_system_object_neq"`
	// contains comparison operator
	AdMsdsAllowedToDelegateToContains []*string ` json:"ad_msds_allowed_to_delegate_to_contains"`
	// contained_by comparison operator
	AdMsdsAllowedToDelegateToContainedBy []*string ` json:"ad_msds_allowed_to_delegate_to_contained_by"`
	// overlap comparison operator
	AdMsdsAllowedToDelegateToOverlap []*string ` json:"ad_msds_allowed_to_delegate_to_overlap"`
	// size comparison operator
	AdMsdsAllowedToDelegateToSize *int ` json:"ad_msds_allowed_to_delegate_to_size"`
	// contains_regex comparison operator
	AdMsdsAllowedToDelegateToContainsRegex *string ` json:"ad_msds_allowed_to_delegate_to_contains_regex"`
	// exists comparison operator
	AdPwdMustChangeExists *bool ` json:"ad_pwd_must_change_exists"`
	// eq comparison operator
	AdPwdMustChangeEq *bool ` json:"ad_pwd_must_change_eq"`
	// neq comparison operator
	AdPwdMustChangeNeq *bool ` json:"ad_pwd_must_change_neq"`
	// exists comparison operator
	AdMsdsResultantPsoExists *bool ` json:"ad_msds_resultant_pso_exists"`
	// not comparison operator
	AdMsdsResultantPsoNot *string ` json:"ad_msds_resultant_pso_not"`
	// eq comparison operator
	AdMsdsResultantPsoEq *string ` json:"ad_msds_resultant_pso_eq"`
	// neq comparison operator
	AdMsdsResultantPsoNeq *string ` json:"ad_msds_resultant_pso_neq"`
	// in comparison operator
	AdMsdsResultantPsoIn []*string ` json:"ad_msds_resultant_pso_in"`
	// not_in comparison operator
	AdMsdsResultantPsoNotIn []*string ` json:"ad_msds_resultant_pso_not_in"`
	// like comparison operator
	AdMsdsResultantPsoLike *string ` json:"ad_msds_resultant_pso_like"`
	// not_like comparison operator
	AdMsdsResultantPsoNotLike *string ` json:"ad_msds_resultant_pso_not_like"`
	// ilike comparison operator
	AdMsdsResultantPsoIlike *string ` json:"ad_msds_resultant_pso_ilike"`
	// not_ilike comparison operator
	AdMsdsResultantPsoNotIlike *string ` json:"ad_msds_resultant_pso_not_ilike"`
	// suffix comparison operator
	AdMsdsResultantPsoSuffix *string ` json:"ad_msds_resultant_pso_suffix"`
	// prefix comparison operator
	AdMsdsResultantPsoPrefix *string ` json:"ad_msds_resultant_pso_prefix"`
	// exists comparison operator
	IsSafeExists *bool ` json:"is_safe_exists"`
	// not comparison operator
	IsSafeNot *string ` json:"is_safe_not"`
	// eq comparison operator
	IsSafeEq *string ` json:"is_safe_eq"`
	// neq comparison operator
	IsSafeNeq *string ` json:"is_safe_neq"`
	// in comparison operator
	IsSafeIn []*string ` json:"is_safe_in"`
	// not_in comparison operator
	IsSafeNotIn []*string ` json:"is_safe_not_in"`
	// like comparison operator
	IsSafeLike *string ` json:"is_safe_like"`
	// not_like comparison operator
	IsSafeNotLike *string ` json:"is_safe_not_like"`
	// ilike comparison operator
	IsSafeIlike *string ` json:"is_safe_ilike"`
	// not_ilike comparison operator
	IsSafeNotIlike *string ` json:"is_safe_not_ilike"`
	// suffix comparison operator
	IsSafeSuffix *string ` json:"is_safe_suffix"`
	// prefix comparison operator
	IsSafePrefix *string ` json:"is_safe_prefix"`
	// eq comparison operator
	DeviceStateEq *CylanceDeviceState ` json:"device_state_eq"`
	// neq comparison operator
	DeviceStateNeq *CylanceDeviceState ` json:"device_state_neq"`
	// in comparison operator
	DeviceStateIn []*CylanceDeviceState ` json:"device_state_in"`
	// not_in comparison operator
	DeviceStateNotIn []*CylanceDeviceState ` json:"device_state_not_in"`
	// exists comparison operator
	PolicyIDExists *bool ` json:"policy_id_exists"`
	// not comparison operator
	PolicyIDNot *string ` json:"policy_id_not"`
	// eq comparison operator
	PolicyIDEq *string ` json:"policy_id_eq"`
	// neq comparison operator
	PolicyIDNeq *string ` json:"policy_id_neq"`
	// in comparison operator
	PolicyIDIn []*string ` json:"policy_id_in"`
	// not_in comparison operator
	PolicyIDNotIn []*string ` json:"policy_id_not_in"`
	// like comparison operator
	PolicyIDLike *string ` json:"policy_id_like"`
	// not_like comparison operator
	PolicyIDNotLike *string ` json:"policy_id_not_like"`
	// ilike comparison operator
	PolicyIDIlike *string ` json:"policy_id_ilike"`
	// not_ilike comparison operator
	PolicyIDNotIlike *string ` json:"policy_id_not_ilike"`
	// suffix comparison operator
	PolicyIDSuffix *string ` json:"policy_id_suffix"`
	// prefix comparison operator
	PolicyIDPrefix *string ` json:"policy_id_prefix"`
	// exists comparison operator
	PolicyNameExists *bool ` json:"policy_name_exists"`
	// not comparison operator
	PolicyNameNot *string ` json:"policy_name_not"`
	// eq comparison operator
	PolicyNameEq *string ` json:"policy_name_eq"`
	// neq comparison operator
	PolicyNameNeq *string ` json:"policy_name_neq"`
	// in comparison operator
	PolicyNameIn []*string ` json:"policy_name_in"`
	// not_in comparison operator
	PolicyNameNotIn []*string ` json:"policy_name_not_in"`
	// like comparison operator
	PolicyNameLike *string ` json:"policy_name_like"`
	// not_like comparison operator
	PolicyNameNotLike *string ` json:"policy_name_not_like"`
	// ilike comparison operator
	PolicyNameIlike *string ` json:"policy_name_ilike"`
	// not_ilike comparison operator
	PolicyNameNotIlike *string ` json:"policy_name_not_ilike"`
	// suffix comparison operator
	PolicyNameSuffix *string ` json:"policy_name_suffix"`
	// prefix comparison operator
	PolicyNamePrefix *string ` json:"policy_name_prefix"`
	// contains comparison operator
	PoliciesDetailsContains []*string ` json:"policies_details_contains"`
	// contained_by comparison operator
	PoliciesDetailsContainedBy []*string ` json:"policies_details_contained_by"`
	// overlap comparison operator
	PoliciesDetailsOverlap []*string ` json:"policies_details_overlap"`
	// size comparison operator
	PoliciesDetailsSize *int ` json:"policies_details_size"`
	// contains_regex comparison operator
	PoliciesDetailsContainsRegex *string ` json:"policies_details_contains_regex"`
	// exists comparison operator
	TenantTagExists *bool ` json:"tenant_tag_exists"`
	// not comparison operator
	TenantTagNot *string ` json:"tenant_tag_not"`
	// eq comparison operator
	TenantTagEq *string ` json:"tenant_tag_eq"`
	// neq comparison operator
	TenantTagNeq *string ` json:"tenant_tag_neq"`
	// in comparison operator
	TenantTagIn []*string ` json:"tenant_tag_in"`
	// not_in comparison operator
	TenantTagNotIn []*string ` json:"tenant_tag_not_in"`
	// like comparison operator
	TenantTagLike *string ` json:"tenant_tag_like"`
	// not_like comparison operator
	TenantTagNotLike *string ` json:"tenant_tag_not_like"`
	// ilike comparison operator
	TenantTagIlike *string ` json:"tenant_tag_ilike"`
	// not_ilike comparison operator
	TenantTagNotIlike *string ` json:"tenant_tag_not_ilike"`
	// suffix comparison operator
	TenantTagSuffix *string ` json:"tenant_tag_suffix"`
	// prefix comparison operator
	TenantTagPrefix *string ` json:"tenant_tag_prefix"`
	// contains comparison operator
	ZoneNamesContains []*string ` json:"zone_names_contains"`
	// contained_by comparison operator
	ZoneNamesContainedBy []*string ` json:"zone_names_contained_by"`
	// overlap comparison operator
	ZoneNamesOverlap []*string ` json:"zone_names_overlap"`
	// size comparison operator
	ZoneNamesSize *int ` json:"zone_names_size"`
	// contains_regex comparison operator
	ZoneNamesContainsRegex *string ` json:"zone_names_contains_regex"`
	// exists comparison operator
	AgentVersionExists *bool ` json:"agent_version_exists"`
	// not comparison operator
	AgentVersionNot *string ` json:"agent_version_not"`
	// eq comparison operator
	AgentVersionEq *string ` json:"agent_version_eq"`
	// neq comparison operator
	AgentVersionNeq *string ` json:"agent_version_neq"`
	// in comparison operator
	AgentVersionIn []*string ` json:"agent_version_in"`
	// not_in comparison operator
	AgentVersionNotIn []*string ` json:"agent_version_not_in"`
	// like comparison operator
	AgentVersionLike *string ` json:"agent_version_like"`
	// not_like comparison operator
	AgentVersionNotLike *string ` json:"agent_version_not_like"`
	// ilike comparison operator
	AgentVersionIlike *string ` json:"agent_version_ilike"`
	// not_ilike comparison operator
	AgentVersionNotIlike *string ` json:"agent_version_not_ilike"`
	// suffix comparison operator
	AgentVersionSuffix *string ` json:"agent_version_suffix"`
	// prefix comparison operator
	AgentVersionPrefix *string ` json:"agent_version_prefix"`
	// exists comparison operator
	ExternalIPExists *bool ` json:"external_ip_exists"`
	// not comparison operator
	ExternalIPNot *string ` json:"external_ip_not"`
	// eq comparison operator
	ExternalIPEq *string ` json:"external_ip_eq"`
	// neq comparison operator
	ExternalIPNeq *string ` json:"external_ip_neq"`
	// in comparison operator
	ExternalIPIn []*string ` json:"external_ip_in"`
	// not_in comparison operator
	ExternalIPNotIn []*string ` json:"external_ip_not_in"`
	// like comparison operator
	ExternalIPLike *string ` json:"external_ip_like"`
	// not_like comparison operator
	ExternalIPNotLike *string ` json:"external_ip_not_like"`
	// ilike comparison operator
	ExternalIPIlike *string ` json:"external_ip_ilike"`
	// not_ilike comparison operator
	ExternalIPNotIlike *string ` json:"external_ip_not_ilike"`
	// suffix comparison operator
	ExternalIPSuffix *string ` json:"external_ip_suffix"`
	// prefix comparison operator
	ExternalIPPrefix *string ` json:"external_ip_prefix"`
	// filter by groups
	Groups *CsGroupBoolExp ` json:"groups"`
	// filter by preventionPolicy
	PreventionPolicy *CsPolicyBoolExp ` json:"prevention_policy"`
	// filter by sensorUpdatePolicy
	SensorUpdatePolicy *CsGroupBoolExp ` json:"sensor_update_policy"`
	// exists comparison operator
	CsAgentVersionExists *bool ` json:"cs_agent_version_exists"`
	// not comparison operator
	CsAgentVersionNot *string ` json:"cs_agent_version_not"`
	// eq comparison operator
	CsAgentVersionEq *string ` json:"cs_agent_version_eq"`
	// neq comparison operator
	CsAgentVersionNeq *string ` json:"cs_agent_version_neq"`
	// in comparison operator
	CsAgentVersionIn []*string ` json:"cs_agent_version_in"`
	// not_in comparison operator
	CsAgentVersionNotIn []*string ` json:"cs_agent_version_not_in"`
	// like comparison operator
	CsAgentVersionLike *string ` json:"cs_agent_version_like"`
	// not_like comparison operator
	CsAgentVersionNotLike *string ` json:"cs_agent_version_not_like"`
	// ilike comparison operator
	CsAgentVersionIlike *string ` json:"cs_agent_version_ilike"`
	// not_ilike comparison operator
	CsAgentVersionNotIlike *string ` json:"cs_agent_version_not_ilike"`
	// suffix comparison operator
	CsAgentVersionSuffix *string ` json:"cs_agent_version_suffix"`
	// prefix comparison operator
	CsAgentVersionPrefix *string              ` json:"cs_agent_version_prefix"`
	And                  []AdapterDataBoolExp ` json:"and"`
	Or                   []AdapterDataBoolExp ` json:"or"`
	Not                  []AdapterDataBoolExp ` json:"not"`
}

// Boolean filter expression for AdapterDeviceAdmin
type AdapterDeviceAdminBoolExp struct {
	// exists comparison operator
	NameExists *bool ` json:"name_exists"`
	// not comparison operator
	NameNot *string ` json:"name_not"`
	// eq comparison operator
	NameEq *string ` json:"name_eq"`
	// neq comparison operator
	NameNeq *string ` json:"name_neq"`
	// in comparison operator
	NameIn []*string ` json:"name_in"`
	// not_in comparison operator
	NameNotIn []*string ` json:"name_not_in"`
	// like comparison operator
	NameLike *string ` json:"name_like"`
	// not_like comparison operator
	NameNotLike *string ` json:"name_not_like"`
	// ilike comparison operator
	NameIlike *string ` json:"name_ilike"`
	// not_ilike comparison operator
	NameNotIlike *string ` json:"name_not_ilike"`
	// suffix comparison operator
	NameSuffix *string ` json:"name_suffix"`
	// prefix comparison operator
	NamePrefix *string ` json:"name_prefix"`
	// eq comparison operator
	TypeEq *AdminType ` json:"type_eq"`
	// neq comparison operator
	TypeNeq *AdminType ` json:"type_neq"`
	// in comparison operator
	TypeIn []*AdminType ` json:"type_in"`
	// not_in comparison operator
	TypeNotIn []*AdminType                ` json:"type_not_in"`
	And       []AdapterDeviceAdminBoolExp ` json:"and"`
	Or        []AdapterDeviceAdminBoolExp ` json:"or"`
	Not       []AdapterDeviceAdminBoolExp ` json:"not"`
}

// Boolean filter expression for AdapterDevice
type AdapterDeviceBoolExp struct {
	// exists comparison operator
	IDExists *bool ` json:"id_exists"`
	// eq comparison operator
	IDEq *uuid.UUID ` json:"id_eq"`
	// neq comparison operator
	IDNeq *uuid.UUID ` json:"id_neq"`
	// in comparison operator
	IDIn []*uuid.UUID ` json:"id_in"`
	// not_in comparison operator
	IDNotIn []*uuid.UUID ` json:"id_not_in"`
	// gt comparison operator
	IDGt *uuid.UUID ` json:"id_gt"`
	// gte comparison operator
	IDGte *uuid.UUID ` json:"id_gte"`
	// lt comparison operator
	IDLt *uuid.UUID ` json:"id_lt"`
	// lte comparison operator
	IDLte *uuid.UUID ` json:"id_lte"`
	// exists comparison operator
	FetchCycleExists *bool ` json:"fetch_cycle_exists"`
	// eq comparison operator
	FetchCycleEq *int ` json:"fetch_cycle_eq"`
	// neq comparison operator
	FetchCycleNeq *int ` json:"fetch_cycle_neq"`
	// in comparison operator
	FetchCycleIn []*int ` json:"fetch_cycle_in"`
	// not_in comparison operator
	FetchCycleNotIn []*int ` json:"fetch_cycle_not_in"`
	// gt comparison operator
	FetchCycleGt *int ` json:"fetch_cycle_gt"`
	// gte comparison operator
	FetchCycleGte *int ` json:"fetch_cycle_gte"`
	// lt comparison operator
	FetchCycleLt *int ` json:"fetch_cycle_lt"`
	// lte comparison operator
	FetchCycleLte *int ` json:"fetch_cycle_lte"`
	// eq comparison operator
	AdapterIDEq *domain.AdapterType ` json:"adapter_id_eq"`
	// neq comparison operator
	AdapterIDNeq *domain.AdapterType ` json:"adapter_id_neq"`
	// in comparison operator
	AdapterIDIn []*domain.AdapterType ` json:"adapter_id_in"`
	// not_in comparison operator
	AdapterIDNotIn []*domain.AdapterType ` json:"adapter_id_not_in"`
	// filter by adapter
	Adapter *AdapterBoolExp ` json:"adapter"`
	// exists comparison operator
	AdapterNameExists *bool ` json:"adapter_name_exists"`
	// not comparison operator
	AdapterNameNot *string ` json:"adapter_name_not"`
	// eq comparison operator
	AdapterNameEq *string ` json:"adapter_name_eq"`
	// neq comparison operator
	AdapterNameNeq *string ` json:"adapter_name_neq"`
	// in comparison operator
	AdapterNameIn []*string ` json:"adapter_name_in"`
	// not_in comparison operator
	AdapterNameNotIn []*string ` json:"adapter_name_not_in"`
	// like comparison operator
	AdapterNameLike *string ` json:"adapter_name_like"`
	// not_like comparison operator
	AdapterNameNotLike *string ` json:"adapter_name_not_like"`
	// ilike comparison operator
	AdapterNameIlike *string ` json:"adapter_name_ilike"`
	// not_ilike comparison operator
	AdapterNameNotIlike *string ` json:"adapter_name_not_ilike"`
	// suffix comparison operator
	AdapterNameSuffix *string ` json:"adapter_name_suffix"`
	// prefix comparison operator
	AdapterNamePrefix *string ` json:"adapter_name_prefix"`
	// exists comparison operator
	DeviceIDExists *bool ` json:"device_id_exists"`
	// eq comparison operator
	DeviceIDEq *uuid.UUID ` json:"device_id_eq"`
	// neq comparison operator
	DeviceIDNeq *uuid.UUID ` json:"device_id_neq"`
	// in comparison operator
	DeviceIDIn []*uuid.UUID ` json:"device_id_in"`
	// not_in comparison operator
	DeviceIDNotIn []*uuid.UUID ` json:"device_id_not_in"`
	// gt comparison operator
	DeviceIDGt *uuid.UUID ` json:"device_id_gt"`
	// gte comparison operator
	DeviceIDGte *uuid.UUID ` json:"device_id_gte"`
	// lt comparison operator
	DeviceIDLt *uuid.UUID ` json:"device_id_lt"`
	// lte comparison operator
	DeviceIDLte *uuid.UUID ` json:"device_id_lte"`
	// filter by adapterData
	AdapterData *AdapterDataBoolExp ` json:"adapter_data"`
	// exists comparison operator
	FetchTimeExists *bool ` json:"fetch_time_exists"`
	// eq comparison operator
	FetchTimeEq *internal.Epoch ` json:"fetch_time_eq"`
	// neq comparison operator
	FetchTimeNeq *internal.Epoch ` json:"fetch_time_neq"`
	// in comparison operator
	FetchTimeIn []*internal.Epoch ` json:"fetch_time_in"`
	// not_in comparison operator
	FetchTimeNotIn []*internal.Epoch ` json:"fetch_time_not_in"`
	// gt comparison operator
	FetchTimeGt *internal.Epoch ` json:"fetch_time_gt"`
	// gte comparison operator
	FetchTimeGte *internal.Epoch ` json:"fetch_time_gte"`
	// lt comparison operator
	FetchTimeLt *internal.Epoch ` json:"fetch_time_lt"`
	// lte comparison operator
	FetchTimeLte *internal.Epoch ` json:"fetch_time_lte"`
	// days comparison operator
	FetchTimeDays *int ` json:"fetch_time_days"`
	// exists comparison operator
	HostnameExists *bool ` json:"hostname_exists"`
	// not comparison operator
	HostnameNot *string ` json:"hostname_not"`
	// eq comparison operator
	HostnameEq *string ` json:"hostname_eq"`
	// neq comparison operator
	HostnameNeq *string ` json:"hostname_neq"`
	// in comparison operator
	HostnameIn []*string ` json:"hostname_in"`
	// not_in comparison operator
	HostnameNotIn []*string ` json:"hostname_not_in"`
	// like comparison operator
	HostnameLike *string ` json:"hostname_like"`
	// not_like comparison operator
	HostnameNotLike *string ` json:"hostname_not_like"`
	// ilike comparison operator
	HostnameIlike *string ` json:"hostname_ilike"`
	// not_ilike comparison operator
	HostnameNotIlike *string ` json:"hostname_not_ilike"`
	// suffix comparison operator
	HostnameSuffix *string ` json:"hostname_suffix"`
	// prefix comparison operator
	HostnamePrefix *string ` json:"hostname_prefix"`
	// exists comparison operator
	NameExists *bool ` json:"name_exists"`
	// not comparison operator
	NameNot *string ` json:"name_not"`
	// eq comparison operator
	NameEq *string ` json:"name_eq"`
	// neq comparison operator
	NameNeq *string ` json:"name_neq"`
	// in comparison operator
	NameIn []*string ` json:"name_in"`
	// not_in comparison operator
	NameNotIn []*string ` json:"name_not_in"`
	// like comparison operator
	NameLike *string ` json:"name_like"`
	// not_like comparison operator
	NameNotLike *string ` json:"name_not_like"`
	// ilike comparison operator
	NameIlike *string ` json:"name_ilike"`
	// not_ilike comparison operator
	NameNotIlike *string ` json:"name_not_ilike"`
	// suffix comparison operator
	NameSuffix *string ` json:"name_suffix"`
	// prefix comparison operator
	NamePrefix *string ` json:"name_prefix"`
	// exists comparison operator
	LastSeenExists *bool ` json:"last_seen_exists"`
	// eq comparison operator
	LastSeenEq *internal.Epoch ` json:"last_seen_eq"`
	// neq comparison operator
	LastSeenNeq *internal.Epoch ` json:"last_seen_neq"`
	// in comparison operator
	LastSeenIn []*internal.Epoch ` json:"last_seen_in"`
	// not_in comparison operator
	LastSeenNotIn []*internal.Epoch ` json:"last_seen_not_in"`
	// gt comparison operator
	LastSeenGt *internal.Epoch ` json:"last_seen_gt"`
	// gte comparison operator
	LastSeenGte *internal.Epoch ` json:"last_seen_gte"`
	// lt comparison operator
	LastSeenLt *internal.Epoch ` json:"last_seen_lt"`
	// lte comparison operator
	LastSeenLte *internal.Epoch ` json:"last_seen_lte"`
	// days comparison operator
	LastSeenDays *int ` json:"last_seen_days"`
	// exists comparison operator
	OsIDExists *bool ` json:"os_id_exists"`
	// eq comparison operator
	OsIDEq *uuid.UUID ` json:"os_id_eq"`
	// neq comparison operator
	OsIDNeq *uuid.UUID ` json:"os_id_neq"`
	// in comparison operator
	OsIDIn []*uuid.UUID ` json:"os_id_in"`
	// not_in comparison operator
	OsIDNotIn []*uuid.UUID ` json:"os_id_not_in"`
	// gt comparison operator
	OsIDGt *uuid.UUID ` json:"os_id_gt"`
	// gte comparison operator
	OsIDGte *uuid.UUID ` json:"os_id_gte"`
	// lt comparison operator
	OsIDLt *uuid.UUID ` json:"os_id_lt"`
	// lte comparison operator
	OsIDLte *uuid.UUID ` json:"os_id_lte"`
	// filter by os
	Os *OperatingSystemBoolExp ` json:"os"`
	// exists comparison operator
	PrettyIDExists *bool ` json:"pretty_id_exists"`
	// not comparison operator
	PrettyIDNot *string ` json:"pretty_id_not"`
	// eq comparison operator
	PrettyIDEq *string ` json:"pretty_id_eq"`
	// neq comparison operator
	PrettyIDNeq *string ` json:"pretty_id_neq"`
	// in comparison operator
	PrettyIDIn []*string ` json:"pretty_id_in"`
	// not_in comparison operator
	PrettyIDNotIn []*string ` json:"pretty_id_not_in"`
	// like comparison operator
	PrettyIDLike *string ` json:"pretty_id_like"`
	// not_like comparison operator
	PrettyIDNotLike *string ` json:"pretty_id_not_like"`
	// ilike comparison operator
	PrettyIDIlike *string ` json:"pretty_id_ilike"`
	// not_ilike comparison operator
	PrettyIDNotIlike *string ` json:"pretty_id_not_ilike"`
	// suffix comparison operator
	PrettyIDSuffix *string ` json:"pretty_id_suffix"`
	// prefix comparison operator
	PrettyIDPrefix *string ` json:"pretty_id_prefix"`
	// filter by tags
	Tags *TagBoolExp ` json:"tags"`
	// filter by interfaces
	Interfaces *NetworkInterfaceBoolExp ` json:"interfaces"`
	// contains comparison operator
	LastUsedUsersContains []*string ` json:"last_used_users_contains"`
	// contained_by comparison operator
	LastUsedUsersContainedBy []*string ` json:"last_used_users_contained_by"`
	// overlap comparison operator
	LastUsedUsersOverlap []*string ` json:"last_used_users_overlap"`
	// size comparison operator
	LastUsedUsersSize *int ` json:"last_used_users_size"`
	// contains_regex comparison operator
	LastUsedUsersContainsRegex *string ` json:"last_used_users_contains_regex"`
	// exists comparison operator
	DomainExists *bool ` json:"domain_exists"`
	// not comparison operator
	DomainNot *string ` json:"domain_not"`
	// eq comparison operator
	DomainEq *string ` json:"domain_eq"`
	// neq comparison operator
	DomainNeq *string ` json:"domain_neq"`
	// in comparison operator
	DomainIn []*string ` json:"domain_in"`
	// not_in comparison operator
	DomainNotIn []*string ` json:"domain_not_in"`
	// like comparison operator
	DomainLike *string ` json:"domain_like"`
	// not_like comparison operator
	DomainNotLike *string ` json:"domain_not_like"`
	// ilike comparison operator
	DomainIlike *string ` json:"domain_ilike"`
	// not_ilike comparison operator
	DomainNotIlike *string ` json:"domain_not_ilike"`
	// suffix comparison operator
	DomainSuffix *string ` json:"domain_suffix"`
	// prefix comparison operator
	DomainPrefix *string ` json:"domain_prefix"`
	// exists comparison operator
	PartOfDomainExists *bool ` json:"part_of_domain_exists"`
	// eq comparison operator
	PartOfDomainEq *bool ` json:"part_of_domain_eq"`
	// neq comparison operator
	PartOfDomainNeq *bool ` json:"part_of_domain_neq"`
	// filter by deviceUsers
	DeviceUsers *AdapterDeviceUserBoolExp ` json:"device_users"`
	// filter by localAdmins
	LocalAdmins *AdapterDeviceAdminBoolExp ` json:"local_admins"`
	// filter by firewallRules
	FirewallRules *FirewallRuleBoolExp ` json:"firewall_rules"`
	// filter by installedSoftware
	InstalledSoftware *InstalledSoftwareBoolExp ` json:"installed_software"`
	// exists comparison operator
	AgentVersionExists *bool ` json:"agent_version_exists"`
	// not comparison operator
	AgentVersionNot *string ` json:"agent_version_not"`
	// eq comparison operator
	AgentVersionEq *string ` json:"agent_version_eq"`
	// neq comparison operator
	AgentVersionNeq *string ` json:"agent_version_neq"`
	// in comparison operator
	AgentVersionIn []*string ` json:"agent_version_in"`
	// not_in comparison operator
	AgentVersionNotIn []*string ` json:"agent_version_not_in"`
	// like comparison operator
	AgentVersionLike *string ` json:"agent_version_like"`
	// not_like comparison operator
	AgentVersionNotLike *string ` json:"agent_version_not_like"`
	// ilike comparison operator
	AgentVersionIlike *string ` json:"agent_version_ilike"`
	// not_ilike comparison operator
	AgentVersionNotIlike *string ` json:"agent_version_not_ilike"`
	// suffix comparison operator
	AgentVersionSuffix *string ` json:"agent_version_suffix"`
	// prefix comparison operator
	AgentVersionPrefix *string ` json:"agent_version_prefix"`
	// exists comparison operator
	AgentStatusExists *bool ` json:"agent_status_exists"`
	// not comparison operator
	AgentStatusNot *string ` json:"agent_status_not"`
	// eq comparison operator
	AgentStatusEq *string ` json:"agent_status_eq"`
	// neq comparison operator
	AgentStatusNeq *string ` json:"agent_status_neq"`
	// in comparison operator
	AgentStatusIn []*string ` json:"agent_status_in"`
	// not_in comparison operator
	AgentStatusNotIn []*string ` json:"agent_status_not_in"`
	// like comparison operator
	AgentStatusLike *string ` json:"agent_status_like"`
	// not_like comparison operator
	AgentStatusNotLike *string ` json:"agent_status_not_like"`
	// ilike comparison operator
	AgentStatusIlike *string ` json:"agent_status_ilike"`
	// not_ilike comparison operator
	AgentStatusNotIlike *string ` json:"agent_status_not_ilike"`
	// suffix comparison operator
	AgentStatusSuffix *string ` json:"agent_status_suffix"`
	// prefix comparison operator
	AgentStatusPrefix *string ` json:"agent_status_prefix"`
	// exists comparison operator
	AgentNameExists *bool ` json:"agent_name_exists"`
	// not comparison operator
	AgentNameNot *string ` json:"agent_name_not"`
	// eq comparison operator
	AgentNameEq *string ` json:"agent_name_eq"`
	// neq comparison operator
	AgentNameNeq *string ` json:"agent_name_neq"`
	// in comparison operator
	AgentNameIn []*string ` json:"agent_name_in"`
	// not_in comparison operator
	AgentNameNotIn []*string ` json:"agent_name_not_in"`
	// like comparison operator
	AgentNameLike *string ` json:"agent_name_like"`
	// not_like comparison operator
	AgentNameNotLike *string ` json:"agent_name_not_like"`
	// ilike comparison operator
	AgentNameIlike *string ` json:"agent_name_ilike"`
	// not_ilike comparison operator
	AgentNameNotIlike *string ` json:"agent_name_not_ilike"`
	// suffix comparison operator
	AgentNameSuffix *string ` json:"agent_name_suffix"`
	// prefix comparison operator
	AgentNamePrefix *string ` json:"agent_name_prefix"`
	// exists comparison operator
	ModelExists *bool ` json:"model_exists"`
	// not comparison operator
	ModelNot *string ` json:"model_not"`
	// eq comparison operator
	ModelEq *string ` json:"model_eq"`
	// neq comparison operator
	ModelNeq *string ` json:"model_neq"`
	// in comparison operator
	ModelIn []*string ` json:"model_in"`
	// not_in comparison operator
	ModelNotIn []*string ` json:"model_not_in"`
	// like comparison operator
	ModelLike *string ` json:"model_like"`
	// not_like comparison operator
	ModelNotLike *string ` json:"model_not_like"`
	// ilike comparison operator
	ModelIlike *string ` json:"model_ilike"`
	// not_ilike comparison operator
	ModelNotIlike *string ` json:"model_not_ilike"`
	// suffix comparison operator
	ModelSuffix *string ` json:"model_suffix"`
	// prefix comparison operator
	ModelPrefix *string ` json:"model_prefix"`
	// exists comparison operator
	ManufacturerExists *bool ` json:"manufacturer_exists"`
	// not comparison operator
	ManufacturerNot *string ` json:"manufacturer_not"`
	// eq comparison operator
	ManufacturerEq *string ` json:"manufacturer_eq"`
	// neq comparison operator
	ManufacturerNeq *string ` json:"manufacturer_neq"`
	// in comparison operator
	ManufacturerIn []*string ` json:"manufacturer_in"`
	// not_in comparison operator
	ManufacturerNotIn []*string ` json:"manufacturer_not_in"`
	// like comparison operator
	ManufacturerLike *string ` json:"manufacturer_like"`
	// not_like comparison operator
	ManufacturerNotLike *string ` json:"manufacturer_not_like"`
	// ilike comparison operator
	ManufacturerIlike *string ` json:"manufacturer_ilike"`
	// not_ilike comparison operator
	ManufacturerNotIlike *string ` json:"manufacturer_not_ilike"`
	// suffix comparison operator
	ManufacturerSuffix *string ` json:"manufacturer_suffix"`
	// prefix comparison operator
	ManufacturerPrefix *string ` json:"manufacturer_prefix"`
	// exists comparison operator
	SerialExists *bool ` json:"serial_exists"`
	// not comparison operator
	SerialNot *string ` json:"serial_not"`
	// eq comparison operator
	SerialEq *string ` json:"serial_eq"`
	// neq comparison operator
	SerialNeq *string ` json:"serial_neq"`
	// in comparison operator
	SerialIn []*string ` json:"serial_in"`
	// not_in comparison operator
	SerialNotIn []*string ` json:"serial_not_in"`
	// like comparison operator
	SerialLike *string ` json:"serial_like"`
	// not_like comparison operator
	SerialNotLike *string ` json:"serial_not_like"`
	// ilike comparison operator
	SerialIlike *string ` json:"serial_ilike"`
	// not_ilike comparison operator
	SerialNotIlike *string ` json:"serial_not_ilike"`
	// suffix comparison operator
	SerialSuffix *string ` json:"serial_suffix"`
	// prefix comparison operator
	SerialPrefix *string ` json:"serial_prefix"`
	// exists comparison operator
	FamilyExists *bool ` json:"family_exists"`
	// not comparison operator
	FamilyNot *string ` json:"family_not"`
	// eq comparison operator
	FamilyEq *string ` json:"family_eq"`
	// neq comparison operator
	FamilyNeq *string ` json:"family_neq"`
	// in comparison operator
	FamilyIn []*string ` json:"family_in"`
	// not_in comparison operator
	FamilyNotIn []*string ` json:"family_not_in"`
	// like comparison operator
	FamilyLike *string ` json:"family_like"`
	// not_like comparison operator
	FamilyNotLike *string ` json:"family_not_like"`
	// ilike comparison operator
	FamilyIlike *string ` json:"family_ilike"`
	// not_ilike comparison operator
	FamilyNotIlike *string ` json:"family_not_ilike"`
	// suffix comparison operator
	FamilySuffix *string ` json:"family_suffix"`
	// prefix comparison operator
	FamilyPrefix *string ` json:"family_prefix"`
	// exists comparison operator
	BiosVersionExists *bool ` json:"bios_version_exists"`
	// not comparison operator
	BiosVersionNot *string ` json:"bios_version_not"`
	// eq comparison operator
	BiosVersionEq *string ` json:"bios_version_eq"`
	// neq comparison operator
	BiosVersionNeq *string ` json:"bios_version_neq"`
	// in comparison operator
	BiosVersionIn []*string ` json:"bios_version_in"`
	// not_in comparison operator
	BiosVersionNotIn []*string ` json:"bios_version_not_in"`
	// like comparison operator
	BiosVersionLike *string ` json:"bios_version_like"`
	// not_like comparison operator
	BiosVersionNotLike *string ` json:"bios_version_not_like"`
	// ilike comparison operator
	BiosVersionIlike *string ` json:"bios_version_ilike"`
	// not_ilike comparison operator
	BiosVersionNotIlike *string ` json:"bios_version_not_ilike"`
	// suffix comparison operator
	BiosVersionSuffix *string ` json:"bios_version_suffix"`
	// prefix comparison operator
	BiosVersionPrefix *string ` json:"bios_version_prefix"`
	// exists comparison operator
	BiosSerialExists *bool ` json:"bios_serial_exists"`
	// not comparison operator
	BiosSerialNot *string ` json:"bios_serial_not"`
	// eq comparison operator
	BiosSerialEq *string ` json:"bios_serial_eq"`
	// neq comparison operator
	BiosSerialNeq *string ` json:"bios_serial_neq"`
	// in comparison operator
	BiosSerialIn []*string ` json:"bios_serial_in"`
	// not_in comparison operator
	BiosSerialNotIn []*string ` json:"bios_serial_not_in"`
	// like comparison operator
	BiosSerialLike *string ` json:"bios_serial_like"`
	// not_like comparison operator
	BiosSerialNotLike *string ` json:"bios_serial_not_like"`
	// ilike comparison operator
	BiosSerialIlike *string ` json:"bios_serial_ilike"`
	// not_ilike comparison operator
	BiosSerialNotIlike *string ` json:"bios_serial_not_ilike"`
	// suffix comparison operator
	BiosSerialSuffix *string ` json:"bios_serial_suffix"`
	// prefix comparison operator
	BiosSerialPrefix *string                ` json:"bios_serial_prefix"`
	And              []AdapterDeviceBoolExp ` json:"and"`
	Or               []AdapterDeviceBoolExp ` json:"or"`
	Not              []AdapterDeviceBoolExp ` json:"not"`
}

// Boolean filter expression for AdapterDeviceUser
type AdapterDeviceUserBoolExp struct {
	// exists comparison operator
	DeviceIDExists *bool ` json:"device_id_exists"`
	// eq comparison operator
	DeviceIDEq *uuid.UUID ` json:"device_id_eq"`
	// neq comparison operator
	DeviceIDNeq *uuid.UUID ` json:"device_id_neq"`
	// in comparison operator
	DeviceIDIn []*uuid.UUID ` json:"device_id_in"`
	// not_in comparison operator
	DeviceIDNotIn []*uuid.UUID ` json:"device_id_not_in"`
	// gt comparison operator
	DeviceIDGt *uuid.UUID ` json:"device_id_gt"`
	// gte comparison operator
	DeviceIDGte *uuid.UUID ` json:"device_id_gte"`
	// lt comparison operator
	DeviceIDLt *uuid.UUID ` json:"device_id_lt"`
	// lte comparison operator
	DeviceIDLte *uuid.UUID ` json:"device_id_lte"`
	// exists comparison operator
	SidExists *bool ` json:"sid_exists"`
	// not comparison operator
	SidNot *string ` json:"sid_not"`
	// eq comparison operator
	SidEq *string ` json:"sid_eq"`
	// neq comparison operator
	SidNeq *string ` json:"sid_neq"`
	// in comparison operator
	SidIn []*string ` json:"sid_in"`
	// not_in comparison operator
	SidNotIn []*string ` json:"sid_not_in"`
	// like comparison operator
	SidLike *string ` json:"sid_like"`
	// not_like comparison operator
	SidNotLike *string ` json:"sid_not_like"`
	// ilike comparison operator
	SidIlike *string ` json:"sid_ilike"`
	// not_ilike comparison operator
	SidNotIlike *string ` json:"sid_not_ilike"`
	// suffix comparison operator
	SidSuffix *string ` json:"sid_suffix"`
	// prefix comparison operator
	SidPrefix *string ` json:"sid_prefix"`
	// exists comparison operator
	UsernameExists *bool ` json:"username_exists"`
	// not comparison operator
	UsernameNot *string ` json:"username_not"`
	// eq comparison operator
	UsernameEq *string ` json:"username_eq"`
	// neq comparison operator
	UsernameNeq *string ` json:"username_neq"`
	// in comparison operator
	UsernameIn []*string ` json:"username_in"`
	// not_in comparison operator
	UsernameNotIn []*string ` json:"username_not_in"`
	// like comparison operator
	UsernameLike *string ` json:"username_like"`
	// not_like comparison operator
	UsernameNotLike *string ` json:"username_not_like"`
	// ilike comparison operator
	UsernameIlike *string ` json:"username_ilike"`
	// not_ilike comparison operator
	UsernameNotIlike *string ` json:"username_not_ilike"`
	// suffix comparison operator
	UsernameSuffix *string ` json:"username_suffix"`
	// prefix comparison operator
	UsernamePrefix *string ` json:"username_prefix"`
	// exists comparison operator
	LastUseDateExists *bool ` json:"last_use_date_exists"`
	// eq comparison operator
	LastUseDateEq *internal.Epoch ` json:"last_use_date_eq"`
	// neq comparison operator
	LastUseDateNeq *internal.Epoch ` json:"last_use_date_neq"`
	// in comparison operator
	LastUseDateIn []*internal.Epoch ` json:"last_use_date_in"`
	// not_in comparison operator
	LastUseDateNotIn []*internal.Epoch ` json:"last_use_date_not_in"`
	// gt comparison operator
	LastUseDateGt *internal.Epoch ` json:"last_use_date_gt"`
	// gte comparison operator
	LastUseDateGte *internal.Epoch ` json:"last_use_date_gte"`
	// lt comparison operator
	LastUseDateLt *internal.Epoch ` json:"last_use_date_lt"`
	// lte comparison operator
	LastUseDateLte *internal.Epoch ` json:"last_use_date_lte"`
	// days comparison operator
	LastUseDateDays *int ` json:"last_use_date_days"`
	// exists comparison operator
	IsLocalExists *bool ` json:"is_local_exists"`
	// eq comparison operator
	IsLocalEq *bool ` json:"is_local_eq"`
	// neq comparison operator
	IsLocalNeq *bool ` json:"is_local_neq"`
	// exists comparison operator
	IsDisabledExists *bool ` json:"is_disabled_exists"`
	// eq comparison operator
	IsDisabledEq *bool ` json:"is_disabled_eq"`
	// neq comparison operator
	IsDisabledNeq *bool ` json:"is_disabled_neq"`
	// exists comparison operator
	IsAdminExists *bool ` json:"is_admin_exists"`
	// eq comparison operator
	IsAdminEq *bool ` json:"is_admin_eq"`
	// neq comparison operator
	IsAdminNeq *bool ` json:"is_admin_neq"`
	// exists comparison operator
	UserDepartmentExists *bool ` json:"user_department_exists"`
	// eq comparison operator
	UserDepartmentEq *bool ` json:"user_department_eq"`
	// neq comparison operator
	UserDepartmentNeq *bool ` json:"user_department_neq"`
	// exists comparison operator
	PasswordMaxAgeExists *bool ` json:"password_max_age_exists"`
	// eq comparison operator
	PasswordMaxAgeEq *int ` json:"password_max_age_eq"`
	// neq comparison operator
	PasswordMaxAgeNeq *int ` json:"password_max_age_neq"`
	// in comparison operator
	PasswordMaxAgeIn []*int ` json:"password_max_age_in"`
	// not_in comparison operator
	PasswordMaxAgeNotIn []*int ` json:"password_max_age_not_in"`
	// gt comparison operator
	PasswordMaxAgeGt *int ` json:"password_max_age_gt"`
	// gte comparison operator
	PasswordMaxAgeGte *int ` json:"password_max_age_gte"`
	// lt comparison operator
	PasswordMaxAgeLt *int ` json:"password_max_age_lt"`
	// lte comparison operator
	PasswordMaxAgeLte *int ` json:"password_max_age_lte"`
	// exists comparison operator
	InterpreterExists *bool ` json:"interpreter_exists"`
	// not comparison operator
	InterpreterNot *string ` json:"interpreter_not"`
	// eq comparison operator
	InterpreterEq *string ` json:"interpreter_eq"`
	// neq comparison operator
	InterpreterNeq *string ` json:"interpreter_neq"`
	// in comparison operator
	InterpreterIn []*string ` json:"interpreter_in"`
	// not_in comparison operator
	InterpreterNotIn []*string ` json:"interpreter_not_in"`
	// like comparison operator
	InterpreterLike *string ` json:"interpreter_like"`
	// not_like comparison operator
	InterpreterNotLike *string ` json:"interpreter_not_like"`
	// ilike comparison operator
	InterpreterIlike *string ` json:"interpreter_ilike"`
	// not_ilike comparison operator
	InterpreterNotIlike *string ` json:"interpreter_not_ilike"`
	// suffix comparison operator
	InterpreterSuffix *string ` json:"interpreter_suffix"`
	// prefix comparison operator
	InterpreterPrefix *string                    ` json:"interpreter_prefix"`
	And               []AdapterDeviceUserBoolExp ` json:"and"`
	Or                []AdapterDeviceUserBoolExp ` json:"or"`
	Not               []AdapterDeviceUserBoolExp ` json:"not"`
}

// Boolean filter expression for AdapterUser
type AdapterUserBoolExp struct {
	// exists comparison operator
	IDExists *bool ` json:"id_exists"`
	// eq comparison operator
	IDEq *uuid.UUID ` json:"id_eq"`
	// neq comparison operator
	IDNeq *uuid.UUID ` json:"id_neq"`
	// in comparison operator
	IDIn []*uuid.UUID ` json:"id_in"`
	// not_in comparison operator
	IDNotIn []*uuid.UUID ` json:"id_not_in"`
	// gt comparison operator
	IDGt *uuid.UUID ` json:"id_gt"`
	// gte comparison operator
	IDGte *uuid.UUID ` json:"id_gte"`
	// lt comparison operator
	IDLt *uuid.UUID ` json:"id_lt"`
	// lte comparison operator
	IDLte *uuid.UUID ` json:"id_lte"`
	// exists comparison operator
	FetchCycleExists *bool ` json:"fetch_cycle_exists"`
	// eq comparison operator
	FetchCycleEq *int ` json:"fetch_cycle_eq"`
	// neq comparison operator
	FetchCycleNeq *int ` json:"fetch_cycle_neq"`
	// in comparison operator
	FetchCycleIn []*int ` json:"fetch_cycle_in"`
	// not_in comparison operator
	FetchCycleNotIn []*int ` json:"fetch_cycle_not_in"`
	// gt comparison operator
	FetchCycleGt *int ` json:"fetch_cycle_gt"`
	// gte comparison operator
	FetchCycleGte *int ` json:"fetch_cycle_gte"`
	// lt comparison operator
	FetchCycleLt *int ` json:"fetch_cycle_lt"`
	// lte comparison operator
	FetchCycleLte *int ` json:"fetch_cycle_lte"`
	// eq comparison operator
	AdapterIDEq *domain.AdapterType ` json:"adapter_id_eq"`
	// neq comparison operator
	AdapterIDNeq *domain.AdapterType ` json:"adapter_id_neq"`
	// in comparison operator
	AdapterIDIn []*domain.AdapterType ` json:"adapter_id_in"`
	// not_in comparison operator
	AdapterIDNotIn []*domain.AdapterType ` json:"adapter_id_not_in"`
	// filter by adapter
	Adapter *AdapterBoolExp ` json:"adapter"`
	// exists comparison operator
	AdapterNameExists *bool ` json:"adapter_name_exists"`
	// not comparison operator
	AdapterNameNot *string ` json:"adapter_name_not"`
	// eq comparison operator
	AdapterNameEq *string ` json:"adapter_name_eq"`
	// neq comparison operator
	AdapterNameNeq *string ` json:"adapter_name_neq"`
	// in comparison operator
	AdapterNameIn []*string ` json:"adapter_name_in"`
	// not_in comparison operator
	AdapterNameNotIn []*string ` json:"adapter_name_not_in"`
	// like comparison operator
	AdapterNameLike *string ` json:"adapter_name_like"`
	// not_like comparison operator
	AdapterNameNotLike *string ` json:"adapter_name_not_like"`
	// ilike comparison operator
	AdapterNameIlike *string ` json:"adapter_name_ilike"`
	// not_ilike comparison operator
	AdapterNameNotIlike *string ` json:"adapter_name_not_ilike"`
	// suffix comparison operator
	AdapterNameSuffix *string ` json:"adapter_name_suffix"`
	// prefix comparison operator
	AdapterNamePrefix *string ` json:"adapter_name_prefix"`
	// exists comparison operator
	UserIDExists *bool ` json:"user_id_exists"`
	// eq comparison operator
	UserIDEq *uuid.UUID ` json:"user_id_eq"`
	// neq comparison operator
	UserIDNeq *uuid.UUID ` json:"user_id_neq"`
	// in comparison operator
	UserIDIn []*uuid.UUID ` json:"user_id_in"`
	// not_in comparison operator
	UserIDNotIn []*uuid.UUID ` json:"user_id_not_in"`
	// gt comparison operator
	UserIDGt *uuid.UUID ` json:"user_id_gt"`
	// gte comparison operator
	UserIDGte *uuid.UUID ` json:"user_id_gte"`
	// lt comparison operator
	UserIDLt *uuid.UUID ` json:"user_id_lt"`
	// lte comparison operator
	UserIDLte *uuid.UUID ` json:"user_id_lte"`
	// filter by adapterData
	AdapterData *AdapterDataBoolExp ` json:"adapter_data"`
	// exists comparison operator
	FetchTimeExists *bool ` json:"fetch_time_exists"`
	// eq comparison operator
	FetchTimeEq *internal.Epoch ` json:"fetch_time_eq"`
	// neq comparison operator
	FetchTimeNeq *internal.Epoch ` json:"fetch_time_neq"`
	// in comparison operator
	FetchTimeIn []*internal.Epoch ` json:"fetch_time_in"`
	// not_in comparison operator
	FetchTimeNotIn []*internal.Epoch ` json:"fetch_time_not_in"`
	// gt comparison operator
	FetchTimeGt *internal.Epoch ` json:"fetch_time_gt"`
	// gte comparison operator
	FetchTimeGte *internal.Epoch ` json:"fetch_time_gte"`
	// lt comparison operator
	FetchTimeLt *internal.Epoch ` json:"fetch_time_lt"`
	// lte comparison operator
	FetchTimeLte *internal.Epoch ` json:"fetch_time_lte"`
	// days comparison operator
	FetchTimeDays *int ` json:"fetch_time_days"`
	// exists comparison operator
	LastSeenExists *bool ` json:"last_seen_exists"`
	// eq comparison operator
	LastSeenEq *internal.Epoch ` json:"last_seen_eq"`
	// neq comparison operator
	LastSeenNeq *internal.Epoch ` json:"last_seen_neq"`
	// in comparison operator
	LastSeenIn []*internal.Epoch ` json:"last_seen_in"`
	// not_in comparison operator
	LastSeenNotIn []*internal.Epoch ` json:"last_seen_not_in"`
	// gt comparison operator
	LastSeenGt *internal.Epoch ` json:"last_seen_gt"`
	// gte comparison operator
	LastSeenGte *internal.Epoch ` json:"last_seen_gte"`
	// lt comparison operator
	LastSeenLt *internal.Epoch ` json:"last_seen_lt"`
	// lte comparison operator
	LastSeenLte *internal.Epoch ` json:"last_seen_lte"`
	// days comparison operator
	LastSeenDays *int ` json:"last_seen_days"`
	// exists comparison operator
	UsernameExists *bool ` json:"username_exists"`
	// not comparison operator
	UsernameNot *string ` json:"username_not"`
	// eq comparison operator
	UsernameEq *string ` json:"username_eq"`
	// neq comparison operator
	UsernameNeq *string ` json:"username_neq"`
	// in comparison operator
	UsernameIn []*string ` json:"username_in"`
	// not_in comparison operator
	UsernameNotIn []*string ` json:"username_not_in"`
	// like comparison operator
	UsernameLike *string ` json:"username_like"`
	// not_like comparison operator
	UsernameNotLike *string ` json:"username_not_like"`
	// ilike comparison operator
	UsernameIlike *string ` json:"username_ilike"`
	// not_ilike comparison operator
	UsernameNotIlike *string ` json:"username_not_ilike"`
	// suffix comparison operator
	UsernameSuffix *string ` json:"username_suffix"`
	// prefix comparison operator
	UsernamePrefix *string ` json:"username_prefix"`
	// exists comparison operator
	FirstNameExists *bool ` json:"first_name_exists"`
	// not comparison operator
	FirstNameNot *string ` json:"first_name_not"`
	// eq comparison operator
	FirstNameEq *string ` json:"first_name_eq"`
	// neq comparison operator
	FirstNameNeq *string ` json:"first_name_neq"`
	// in comparison operator
	FirstNameIn []*string ` json:"first_name_in"`
	// not_in comparison operator
	FirstNameNotIn []*string ` json:"first_name_not_in"`
	// like comparison operator
	FirstNameLike *string ` json:"first_name_like"`
	// not_like comparison operator
	FirstNameNotLike *string ` json:"first_name_not_like"`
	// ilike comparison operator
	FirstNameIlike *string ` json:"first_name_ilike"`
	// not_ilike comparison operator
	FirstNameNotIlike *string ` json:"first_name_not_ilike"`
	// suffix comparison operator
	FirstNameSuffix *string ` json:"first_name_suffix"`
	// prefix comparison operator
	FirstNamePrefix *string ` json:"first_name_prefix"`
	// exists comparison operator
	LastNameExists *bool ` json:"last_name_exists"`
	// not comparison operator
	LastNameNot *string ` json:"last_name_not"`
	// eq comparison operator
	LastNameEq *string ` json:"last_name_eq"`
	// neq comparison operator
	LastNameNeq *string ` json:"last_name_neq"`
	// in comparison operator
	LastNameIn []*string ` json:"last_name_in"`
	// not_in comparison operator
	LastNameNotIn []*string ` json:"last_name_not_in"`
	// like comparison operator
	LastNameLike *string ` json:"last_name_like"`
	// not_like comparison operator
	LastNameNotLike *string ` json:"last_name_not_like"`
	// ilike comparison operator
	LastNameIlike *string ` json:"last_name_ilike"`
	// not_ilike comparison operator
	LastNameNotIlike *string ` json:"last_name_not_ilike"`
	// suffix comparison operator
	LastNameSuffix *string ` json:"last_name_suffix"`
	// prefix comparison operator
	LastNamePrefix *string ` json:"last_name_prefix"`
	// exists comparison operator
	MailExists *bool ` json:"mail_exists"`
	// not comparison operator
	MailNot *string ` json:"mail_not"`
	// eq comparison operator
	MailEq *string ` json:"mail_eq"`
	// neq comparison operator
	MailNeq *string ` json:"mail_neq"`
	// in comparison operator
	MailIn []*string ` json:"mail_in"`
	// not_in comparison operator
	MailNotIn []*string ` json:"mail_not_in"`
	// like comparison operator
	MailLike *string ` json:"mail_like"`
	// not_like comparison operator
	MailNotLike *string ` json:"mail_not_like"`
	// ilike comparison operator
	MailIlike *string ` json:"mail_ilike"`
	// not_ilike comparison operator
	MailNotIlike *string ` json:"mail_not_ilike"`
	// suffix comparison operator
	MailSuffix *string ` json:"mail_suffix"`
	// prefix comparison operator
	MailPrefix *string ` json:"mail_prefix"`
	// exists comparison operator
	AdminExists *bool ` json:"admin_exists"`
	// eq comparison operator
	AdminEq *bool ` json:"admin_eq"`
	// neq comparison operator
	AdminNeq *bool ` json:"admin_neq"`
	// exists comparison operator
	LocalExists *bool ` json:"local_exists"`
	// eq comparison operator
	LocalEq *bool ` json:"local_eq"`
	// neq comparison operator
	LocalNeq *bool ` json:"local_neq"`
	// exists comparison operator
	DelegatedAdminExists *bool ` json:"delegated_admin_exists"`
	// eq comparison operator
	DelegatedAdminEq *bool ` json:"delegated_admin_eq"`
	// neq comparison operator
	DelegatedAdminNeq *bool ` json:"delegated_admin_neq"`
	// exists comparison operator
	MfaEnforcedExists *bool ` json:"mfa_enforced_exists"`
	// eq comparison operator
	MfaEnforcedEq *bool ` json:"mfa_enforced_eq"`
	// neq comparison operator
	MfaEnforcedNeq *bool ` json:"mfa_enforced_neq"`
	// exists comparison operator
	MfaEnrolledExists *bool ` json:"mfa_enrolled_exists"`
	// eq comparison operator
	MfaEnrolledEq *bool ` json:"mfa_enrolled_eq"`
	// neq comparison operator
	MfaEnrolledNeq *bool ` json:"mfa_enrolled_neq"`
	// exists comparison operator
	SuspendedExists *bool ` json:"suspended_exists"`
	// eq comparison operator
	SuspendedEq *bool ` json:"suspended_eq"`
	// neq comparison operator
	SuspendedNeq *bool ` json:"suspended_neq"`
	// exists comparison operator
	LockedExists *bool ` json:"locked_exists"`
	// eq comparison operator
	LockedEq *bool ` json:"locked_eq"`
	// neq comparison operator
	LockedNeq *bool ` json:"locked_neq"`
	// exists comparison operator
	DisabledExists *bool ` json:"disabled_exists"`
	// eq comparison operator
	DisabledEq *bool ` json:"disabled_eq"`
	// neq comparison operator
	DisabledNeq *bool                ` json:"disabled_neq"`
	And         []AdapterUserBoolExp ` json:"and"`
	Or          []AdapterUserBoolExp ` json:"or"`
	Not         []AdapterUserBoolExp ` json:"not"`
}

type CsGroup struct {
	ID               *string         ` json:"id"`
	Name             *string         ` json:"name"`
	CreatedBy        *string         ` json:"created_by"`
	CreatedTimestamp *internal.Epoch ` json:"created_timestamp"`
	Description      *string         ` json:"description"`
	GroupType        *string         ` json:"group_type"`
	ModifiedBy       *string         ` json:"modified_by"`
	ModifiedTime     *internal.Epoch ` json:"modified_time"`
}

type CsPolicy struct {
	Name                 *string                   ` json:"name"`
	Description          *string                   ` json:"description"`
	PlatformName         *string                   ` json:"platform_name"`
	Groups               []*CsGroup                ` json:"groups"`
	Enabled              *bool                     ` json:"enabled"`
	CreatedBy            *string                   ` json:"created_by"`
	CreatedTime          *internal.Epoch           ` json:"created_time"`
	PreventionSettings   []*CsPreventionSettings   ` json:"prevention_settings"`
	SensorUpdateSettings []*CsSensorUpdateSettings ` json:"sensor_update_settings"`
	// Returns aggregate of groups
	GroupsAggregate []GroupsAggregate ` json:"groups_aggregate"`
	// Returns aggregate of preventionSettings
	PreventionSettingsAggregate []PreventionSettingsAggregate ` json:"prevention_settings_aggregate"`
	// Returns aggregate of sensorUpdateSettings
	SensorUpdateSettingsAggregate []SensorUpdateSettingsAggregate ` json:"sensor_update_settings_aggregate"`
}

type CsPolicySettings struct {
	Enabled *bool ` json:"enabled"`
}

type CsPreventionSettings struct {
	Name     *string             ` json:"name"`
	Settings []*CsPolicySettings ` json:"settings"`
}

type CsSensorUpdateSettings struct {
	Build *string ` json:"build"`
}

// Boolean filter expression for csGroup
type CsGroupBoolExp struct {
	// exists comparison operator
	IDExists *bool ` json:"id_exists"`
	// not comparison operator
	IDNot *string ` json:"id_not"`
	// eq comparison operator
	IDEq *string ` json:"id_eq"`
	// neq comparison operator
	IDNeq *string ` json:"id_neq"`
	// in comparison operator
	IDIn []*string ` json:"id_in"`
	// not_in comparison operator
	IDNotIn []*string ` json:"id_not_in"`
	// like comparison operator
	IDLike *string ` json:"id_like"`
	// not_like comparison operator
	IDNotLike *string ` json:"id_not_like"`
	// ilike comparison operator
	IDIlike *string ` json:"id_ilike"`
	// not_ilike comparison operator
	IDNotIlike *string ` json:"id_not_ilike"`
	// suffix comparison operator
	IDSuffix *string ` json:"id_suffix"`
	// prefix comparison operator
	IDPrefix *string ` json:"id_prefix"`
	// exists comparison operator
	NameExists *bool ` json:"name_exists"`
	// not comparison operator
	NameNot *string ` json:"name_not"`
	// eq comparison operator
	NameEq *string ` json:"name_eq"`
	// neq comparison operator
	NameNeq *string ` json:"name_neq"`
	// in comparison operator
	NameIn []*string ` json:"name_in"`
	// not_in comparison operator
	NameNotIn []*string ` json:"name_not_in"`
	// like comparison operator
	NameLike *string ` json:"name_like"`
	// not_like comparison operator
	NameNotLike *string ` json:"name_not_like"`
	// ilike comparison operator
	NameIlike *string ` json:"name_ilike"`
	// not_ilike comparison operator
	NameNotIlike *string ` json:"name_not_ilike"`
	// suffix comparison operator
	NameSuffix *string ` json:"name_suffix"`
	// prefix comparison operator
	NamePrefix *string ` json:"name_prefix"`
	// exists comparison operator
	CreatedByExists *bool ` json:"created_by_exists"`
	// not comparison operator
	CreatedByNot *string ` json:"created_by_not"`
	// eq comparison operator
	CreatedByEq *string ` json:"created_by_eq"`
	// neq comparison operator
	CreatedByNeq *string ` json:"created_by_neq"`
	// in comparison operator
	CreatedByIn []*string ` json:"created_by_in"`
	// not_in comparison operator
	CreatedByNotIn []*string ` json:"created_by_not_in"`
	// like comparison operator
	CreatedByLike *string ` json:"created_by_like"`
	// not_like comparison operator
	CreatedByNotLike *string ` json:"created_by_not_like"`
	// ilike comparison operator
	CreatedByIlike *string ` json:"created_by_ilike"`
	// not_ilike comparison operator
	CreatedByNotIlike *string ` json:"created_by_not_ilike"`
	// suffix comparison operator
	CreatedBySuffix *string ` json:"created_by_suffix"`
	// prefix comparison operator
	CreatedByPrefix *string ` json:"created_by_prefix"`
	// exists comparison operator
	CreatedTimestampExists *bool ` json:"created_timestamp_exists"`
	// eq comparison operator
	CreatedTimestampEq *internal.Epoch ` json:"created_timestamp_eq"`
	// neq comparison operator
	CreatedTimestampNeq *internal.Epoch ` json:"created_timestamp_neq"`
	// in comparison operator
	CreatedTimestampIn []*internal.Epoch ` json:"created_timestamp_in"`
	// not_in comparison operator
	CreatedTimestampNotIn []*internal.Epoch ` json:"created_timestamp_not_in"`
	// gt comparison operator
	CreatedTimestampGt *internal.Epoch ` json:"created_timestamp_gt"`
	// gte comparison operator
	CreatedTimestampGte *internal.Epoch ` json:"created_timestamp_gte"`
	// lt comparison operator
	CreatedTimestampLt *internal.Epoch ` json:"created_timestamp_lt"`
	// lte comparison operator
	CreatedTimestampLte *internal.Epoch ` json:"created_timestamp_lte"`
	// days comparison operator
	CreatedTimestampDays *int ` json:"created_timestamp_days"`
	// exists comparison operator
	DescriptionExists *bool ` json:"description_exists"`
	// not comparison operator
	DescriptionNot *string ` json:"description_not"`
	// eq comparison operator
	DescriptionEq *string ` json:"description_eq"`
	// neq comparison operator
	DescriptionNeq *string ` json:"description_neq"`
	// in comparison operator
	DescriptionIn []*string ` json:"description_in"`
	// not_in comparison operator
	DescriptionNotIn []*string ` json:"description_not_in"`
	// like comparison operator
	DescriptionLike *string ` json:"description_like"`
	// not_like comparison operator
	DescriptionNotLike *string ` json:"description_not_like"`
	// ilike comparison operator
	DescriptionIlike *string ` json:"description_ilike"`
	// not_ilike comparison operator
	DescriptionNotIlike *string ` json:"description_not_ilike"`
	// suffix comparison operator
	DescriptionSuffix *string ` json:"description_suffix"`
	// prefix comparison operator
	DescriptionPrefix *string ` json:"description_prefix"`
	// exists comparison operator
	GroupTypeExists *bool ` json:"group_type_exists"`
	// not comparison operator
	GroupTypeNot *string ` json:"group_type_not"`
	// eq comparison operator
	GroupTypeEq *string ` json:"group_type_eq"`
	// neq comparison operator
	GroupTypeNeq *string ` json:"group_type_neq"`
	// in comparison operator
	GroupTypeIn []*string ` json:"group_type_in"`
	// not_in comparison operator
	GroupTypeNotIn []*string ` json:"group_type_not_in"`
	// like comparison operator
	GroupTypeLike *string ` json:"group_type_like"`
	// not_like comparison operator
	GroupTypeNotLike *string ` json:"group_type_not_like"`
	// ilike comparison operator
	GroupTypeIlike *string ` json:"group_type_ilike"`
	// not_ilike comparison operator
	GroupTypeNotIlike *string ` json:"group_type_not_ilike"`
	// suffix comparison operator
	GroupTypeSuffix *string ` json:"group_type_suffix"`
	// prefix comparison operator
	GroupTypePrefix *string ` json:"group_type_prefix"`
	// exists comparison operator
	ModifiedByExists *bool ` json:"modified_by_exists"`
	// not comparison operator
	ModifiedByNot *string ` json:"modified_by_not"`
	// eq comparison operator
	ModifiedByEq *string ` json:"modified_by_eq"`
	// neq comparison operator
	ModifiedByNeq *string ` json:"modified_by_neq"`
	// in comparison operator
	ModifiedByIn []*string ` json:"modified_by_in"`
	// not_in comparison operator
	ModifiedByNotIn []*string ` json:"modified_by_not_in"`
	// like comparison operator
	ModifiedByLike *string ` json:"modified_by_like"`
	// not_like comparison operator
	ModifiedByNotLike *string ` json:"modified_by_not_like"`
	// ilike comparison operator
	ModifiedByIlike *string ` json:"modified_by_ilike"`
	// not_ilike comparison operator
	ModifiedByNotIlike *string ` json:"modified_by_not_ilike"`
	// suffix comparison operator
	ModifiedBySuffix *string ` json:"modified_by_suffix"`
	// prefix comparison operator
	ModifiedByPrefix *string ` json:"modified_by_prefix"`
	// exists comparison operator
	ModifiedTimeExists *bool ` json:"modified_time_exists"`
	// eq comparison operator
	ModifiedTimeEq *internal.Epoch ` json:"modified_time_eq"`
	// neq comparison operator
	ModifiedTimeNeq *internal.Epoch ` json:"modified_time_neq"`
	// in comparison operator
	ModifiedTimeIn []*internal.Epoch ` json:"modified_time_in"`
	// not_in comparison operator
	ModifiedTimeNotIn []*internal.Epoch ` json:"modified_time_not_in"`
	// gt comparison operator
	ModifiedTimeGt *internal.Epoch ` json:"modified_time_gt"`
	// gte comparison operator
	ModifiedTimeGte *internal.Epoch ` json:"modified_time_gte"`
	// lt comparison operator
	ModifiedTimeLt *internal.Epoch ` json:"modified_time_lt"`
	// lte comparison operator
	ModifiedTimeLte *internal.Epoch ` json:"modified_time_lte"`
	// days comparison operator
	ModifiedTimeDays *int             ` json:"modified_time_days"`
	And              []CsGroupBoolExp ` json:"and"`
	Or               []CsGroupBoolExp ` json:"or"`
	Not              []CsGroupBoolExp ` json:"not"`
}

// Boolean filter expression for csPolicy
type CsPolicyBoolExp struct {
	// exists comparison operator
	NameExists *bool ` json:"name_exists"`
	// not comparison operator
	NameNot *string ` json:"name_not"`
	// eq comparison operator
	NameEq *string ` json:"name_eq"`
	// neq comparison operator
	NameNeq *string ` json:"name_neq"`
	// in comparison operator
	NameIn []*string ` json:"name_in"`
	// not_in comparison operator
	NameNotIn []*string ` json:"name_not_in"`
	// like comparison operator
	NameLike *string ` json:"name_like"`
	// not_like comparison operator
	NameNotLike *string ` json:"name_not_like"`
	// ilike comparison operator
	NameIlike *string ` json:"name_ilike"`
	// not_ilike comparison operator
	NameNotIlike *string ` json:"name_not_ilike"`
	// suffix comparison operator
	NameSuffix *string ` json:"name_suffix"`
	// prefix comparison operator
	NamePrefix *string ` json:"name_prefix"`
	// exists comparison operator
	DescriptionExists *bool ` json:"description_exists"`
	// not comparison operator
	DescriptionNot *string ` json:"description_not"`
	// eq comparison operator
	DescriptionEq *string ` json:"description_eq"`
	// neq comparison operator
	DescriptionNeq *string ` json:"description_neq"`
	// in comparison operator
	DescriptionIn []*string ` json:"description_in"`
	// not_in comparison operator
	DescriptionNotIn []*string ` json:"description_not_in"`
	// like comparison operator
	DescriptionLike *string ` json:"description_like"`
	// not_like comparison operator
	DescriptionNotLike *string ` json:"description_not_like"`
	// ilike comparison operator
	DescriptionIlike *string ` json:"description_ilike"`
	// not_ilike comparison operator
	DescriptionNotIlike *string ` json:"description_not_ilike"`
	// suffix comparison operator
	DescriptionSuffix *string ` json:"description_suffix"`
	// prefix comparison operator
	DescriptionPrefix *string ` json:"description_prefix"`
	// exists comparison operator
	PlatformNameExists *bool ` json:"platform_name_exists"`
	// not comparison operator
	PlatformNameNot *string ` json:"platform_name_not"`
	// eq comparison operator
	PlatformNameEq *string ` json:"platform_name_eq"`
	// neq comparison operator
	PlatformNameNeq *string ` json:"platform_name_neq"`
	// in comparison operator
	PlatformNameIn []*string ` json:"platform_name_in"`
	// not_in comparison operator
	PlatformNameNotIn []*string ` json:"platform_name_not_in"`
	// like comparison operator
	PlatformNameLike *string ` json:"platform_name_like"`
	// not_like comparison operator
	PlatformNameNotLike *string ` json:"platform_name_not_like"`
	// ilike comparison operator
	PlatformNameIlike *string ` json:"platform_name_ilike"`
	// not_ilike comparison operator
	PlatformNameNotIlike *string ` json:"platform_name_not_ilike"`
	// suffix comparison operator
	PlatformNameSuffix *string ` json:"platform_name_suffix"`
	// prefix comparison operator
	PlatformNamePrefix *string ` json:"platform_name_prefix"`
	// filter by groups
	Groups *CsGroupBoolExp ` json:"groups"`
	// exists comparison operator
	EnabledExists *bool ` json:"enabled_exists"`
	// eq comparison operator
	EnabledEq *bool ` json:"enabled_eq"`
	// neq comparison operator
	EnabledNeq *bool ` json:"enabled_neq"`
	// exists comparison operator
	CreatedByExists *bool ` json:"created_by_exists"`
	// not comparison operator
	CreatedByNot *string ` json:"created_by_not"`
	// eq comparison operator
	CreatedByEq *string ` json:"created_by_eq"`
	// neq comparison operator
	CreatedByNeq *string ` json:"created_by_neq"`
	// in comparison operator
	CreatedByIn []*string ` json:"created_by_in"`
	// not_in comparison operator
	CreatedByNotIn []*string ` json:"created_by_not_in"`
	// like comparison operator
	CreatedByLike *string ` json:"created_by_like"`
	// not_like comparison operator
	CreatedByNotLike *string ` json:"created_by_not_like"`
	// ilike comparison operator
	CreatedByIlike *string ` json:"created_by_ilike"`
	// not_ilike comparison operator
	CreatedByNotIlike *string ` json:"created_by_not_ilike"`
	// suffix comparison operator
	CreatedBySuffix *string ` json:"created_by_suffix"`
	// prefix comparison operator
	CreatedByPrefix *string ` json:"created_by_prefix"`
	// exists comparison operator
	CreatedTimeExists *bool ` json:"created_time_exists"`
	// eq comparison operator
	CreatedTimeEq *internal.Epoch ` json:"created_time_eq"`
	// neq comparison operator
	CreatedTimeNeq *internal.Epoch ` json:"created_time_neq"`
	// in comparison operator
	CreatedTimeIn []*internal.Epoch ` json:"created_time_in"`
	// not_in comparison operator
	CreatedTimeNotIn []*internal.Epoch ` json:"created_time_not_in"`
	// gt comparison operator
	CreatedTimeGt *internal.Epoch ` json:"created_time_gt"`
	// gte comparison operator
	CreatedTimeGte *internal.Epoch ` json:"created_time_gte"`
	// lt comparison operator
	CreatedTimeLt *internal.Epoch ` json:"created_time_lt"`
	// lte comparison operator
	CreatedTimeLte *internal.Epoch ` json:"created_time_lte"`
	// days comparison operator
	CreatedTimeDays *int ` json:"created_time_days"`
	// filter by preventionSettings
	PreventionSettings *CsPreventionSettingsBoolExp ` json:"prevention_settings"`
	// filter by sensorUpdateSettings
	SensorUpdateSettings *CsSensorUpdateSettingsBoolExp ` json:"sensor_update_settings"`
	And                  []CsPolicyBoolExp              ` json:"and"`
	Or                   []CsPolicyBoolExp              ` json:"or"`
	Not                  []CsPolicyBoolExp              ` json:"not"`
}

// Boolean filter expression for csPolicySettings
type CsPolicySettingsBoolExp struct {
	// exists comparison operator
	EnabledExists *bool ` json:"enabled_exists"`
	// eq comparison operator
	EnabledEq *bool ` json:"enabled_eq"`
	// neq comparison operator
	EnabledNeq *bool                     ` json:"enabled_neq"`
	And        []CsPolicySettingsBoolExp ` json:"and"`
	Or         []CsPolicySettingsBoolExp ` json:"or"`
	Not        []CsPolicySettingsBoolExp ` json:"not"`
}

// Boolean filter expression for csPreventionSettings
type CsPreventionSettingsBoolExp struct {
	// exists comparison operator
	NameExists *bool ` json:"name_exists"`
	// not comparison operator
	NameNot *string ` json:"name_not"`
	// eq comparison operator
	NameEq *string ` json:"name_eq"`
	// neq comparison operator
	NameNeq *string ` json:"name_neq"`
	// in comparison operator
	NameIn []*string ` json:"name_in"`
	// not_in comparison operator
	NameNotIn []*string ` json:"name_not_in"`
	// like comparison operator
	NameLike *string ` json:"name_like"`
	// not_like comparison operator
	NameNotLike *string ` json:"name_not_like"`
	// ilike comparison operator
	NameIlike *string ` json:"name_ilike"`
	// not_ilike comparison operator
	NameNotIlike *string ` json:"name_not_ilike"`
	// suffix comparison operator
	NameSuffix *string ` json:"name_suffix"`
	// prefix comparison operator
	NamePrefix *string ` json:"name_prefix"`
	// filter by settings
	Settings *CsPolicySettingsBoolExp      ` json:"settings"`
	And      []CsPreventionSettingsBoolExp ` json:"and"`
	Or       []CsPreventionSettingsBoolExp ` json:"or"`
	Not      []CsPreventionSettingsBoolExp ` json:"not"`
}

// Boolean filter expression for csSensorUpdateSettings
type CsSensorUpdateSettingsBoolExp struct {
	// exists comparison operator
	BuildExists *bool ` json:"build_exists"`
	// not comparison operator
	BuildNot *string ` json:"build_not"`
	// eq comparison operator
	BuildEq *string ` json:"build_eq"`
	// neq comparison operator
	BuildNeq *string ` json:"build_neq"`
	// in comparison operator
	BuildIn []*string ` json:"build_in"`
	// not_in comparison operator
	BuildNotIn []*string ` json:"build_not_in"`
	// like comparison operator
	BuildLike *string ` json:"build_like"`
	// not_like comparison operator
	BuildNotLike *string ` json:"build_not_like"`
	// ilike comparison operator
	BuildIlike *string ` json:"build_ilike"`
	// not_ilike comparison operator
	BuildNotIlike *string ` json:"build_not_ilike"`
	// suffix comparison operator
	BuildSuffix *string ` json:"build_suffix"`
	// prefix comparison operator
	BuildPrefix *string                         ` json:"build_prefix"`
	And         []CsSensorUpdateSettingsBoolExp ` json:"and"`
	Or          []CsSensorUpdateSettingsBoolExp ` json:"or"`
	Not         []CsSensorUpdateSettingsBoolExp ` json:"not"`
}

// Boolean filter expression for Device
type DeviceBoolExp struct {
	// exists comparison operator
	IDExists *bool ` json:"id_exists"`
	// eq comparison operator
	IDEq *uuid.UUID ` json:"id_eq"`
	// neq comparison operator
	IDNeq *uuid.UUID ` json:"id_neq"`
	// in comparison operator
	IDIn []*uuid.UUID ` json:"id_in"`
	// not_in comparison operator
	IDNotIn []*uuid.UUID ` json:"id_not_in"`
	// gt comparison operator
	IDGt *uuid.UUID ` json:"id_gt"`
	// gte comparison operator
	IDGte *uuid.UUID ` json:"id_gte"`
	// lt comparison operator
	IDLt *uuid.UUID ` json:"id_lt"`
	// lte comparison operator
	IDLte *uuid.UUID ` json:"id_lte"`
	// exists comparison operator
	FetchCycleExists *bool ` json:"fetch_cycle_exists"`
	// eq comparison operator
	FetchCycleEq *int ` json:"fetch_cycle_eq"`
	// neq comparison operator
	FetchCycleNeq *int ` json:"fetch_cycle_neq"`
	// in comparison operator
	FetchCycleIn []*int ` json:"fetch_cycle_in"`
	// not_in comparison operator
	FetchCycleNotIn []*int ` json:"fetch_cycle_not_in"`
	// gt comparison operator
	FetchCycleGt *int ` json:"fetch_cycle_gt"`
	// gte comparison operator
	FetchCycleGte *int ` json:"fetch_cycle_gte"`
	// lt comparison operator
	FetchCycleLt *int ` json:"fetch_cycle_lt"`
	// lte comparison operator
	FetchCycleLte *int ` json:"fetch_cycle_lte"`
	// exists comparison operator
	AdapterCountExists *bool ` json:"adapter_count_exists"`
	// eq comparison operator
	AdapterCountEq *int ` json:"adapter_count_eq"`
	// neq comparison operator
	AdapterCountNeq *int ` json:"adapter_count_neq"`
	// in comparison operator
	AdapterCountIn []*int ` json:"adapter_count_in"`
	// not_in comparison operator
	AdapterCountNotIn []*int ` json:"adapter_count_not_in"`
	// gt comparison operator
	AdapterCountGt *int ` json:"adapter_count_gt"`
	// gte comparison operator
	AdapterCountGte *int ` json:"adapter_count_gte"`
	// lt comparison operator
	AdapterCountLt *int ` json:"adapter_count_lt"`
	// lte comparison operator
	AdapterCountLte *int ` json:"adapter_count_lte"`
	// contains comparison operator
	AdapterNamesContains []*string ` json:"adapter_names_contains"`
	// contained_by comparison operator
	AdapterNamesContainedBy []*string ` json:"adapter_names_contained_by"`
	// overlap comparison operator
	AdapterNamesOverlap []*string ` json:"adapter_names_overlap"`
	// size comparison operator
	AdapterNamesSize *int ` json:"adapter_names_size"`
	// contains_regex comparison operator
	AdapterNamesContainsRegex *string ` json:"adapter_names_contains_regex"`
	// contains comparison operator
	HostnamesContains []*string ` json:"hostnames_contains"`
	// contained_by comparison operator
	HostnamesContainedBy []*string ` json:"hostnames_contained_by"`
	// overlap comparison operator
	HostnamesOverlap []*string ` json:"hostnames_overlap"`
	// size comparison operator
	HostnamesSize *int ` json:"hostnames_size"`
	// contains_regex comparison operator
	HostnamesContainsRegex *string ` json:"hostnames_contains_regex"`
	// exists comparison operator
	LastSeenExists *bool ` json:"last_seen_exists"`
	// eq comparison operator
	LastSeenEq *internal.Epoch ` json:"last_seen_eq"`
	// neq comparison operator
	LastSeenNeq *internal.Epoch ` json:"last_seen_neq"`
	// in comparison operator
	LastSeenIn []*internal.Epoch ` json:"last_seen_in"`
	// not_in comparison operator
	LastSeenNotIn []*internal.Epoch ` json:"last_seen_not_in"`
	// gt comparison operator
	LastSeenGt *internal.Epoch ` json:"last_seen_gt"`
	// gte comparison operator
	LastSeenGte *internal.Epoch ` json:"last_seen_gte"`
	// lt comparison operator
	LastSeenLt *internal.Epoch ` json:"last_seen_lt"`
	// lte comparison operator
	LastSeenLte *internal.Epoch ` json:"last_seen_lte"`
	// days comparison operator
	LastSeenDays *int ` json:"last_seen_days"`
	// filter by adapterDevices
	AdapterDevices *AdapterDeviceBoolExp ` json:"adapter_devices"`
	// filter by interfaces
	Interfaces *NetworkInterfaceBoolExp ` json:"interfaces"`
	// filter by tags
	Tags *TagBoolExp     ` json:"tags"`
	And  []DeviceBoolExp ` json:"and"`
	Or   []DeviceBoolExp ` json:"or"`
	Not  []DeviceBoolExp ` json:"not"`
}

type DevicesAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	Devices  []*Device              ` json:"devices"`
}

type FirewallRulesAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	// Firewall rules defined on this adapter device
	FirewallRules []*FirewallRule ` json:"firewall_rules"`
}

// Boolean filter expression for FirewallRule
type FirewallRuleBoolExp struct {
	// exists comparison operator
	NameExists *bool ` json:"name_exists"`
	// not comparison operator
	NameNot *string ` json:"name_not"`
	// eq comparison operator
	NameEq *string ` json:"name_eq"`
	// neq comparison operator
	NameNeq *string ` json:"name_neq"`
	// in comparison operator
	NameIn []*string ` json:"name_in"`
	// not_in comparison operator
	NameNotIn []*string ` json:"name_not_in"`
	// like comparison operator
	NameLike *string ` json:"name_like"`
	// not_like comparison operator
	NameNotLike *string ` json:"name_not_like"`
	// ilike comparison operator
	NameIlike *string ` json:"name_ilike"`
	// not_ilike comparison operator
	NameNotIlike *string ` json:"name_not_ilike"`
	// suffix comparison operator
	NameSuffix *string ` json:"name_suffix"`
	// prefix comparison operator
	NamePrefix *string ` json:"name_prefix"`
	// exists comparison operator
	SourceExists *bool ` json:"source_exists"`
	// not comparison operator
	SourceNot *string ` json:"source_not"`
	// eq comparison operator
	SourceEq *string ` json:"source_eq"`
	// neq comparison operator
	SourceNeq *string ` json:"source_neq"`
	// in comparison operator
	SourceIn []*string ` json:"source_in"`
	// not_in comparison operator
	SourceNotIn []*string ` json:"source_not_in"`
	// like comparison operator
	SourceLike *string ` json:"source_like"`
	// not_like comparison operator
	SourceNotLike *string ` json:"source_not_like"`
	// ilike comparison operator
	SourceIlike *string ` json:"source_ilike"`
	// not_ilike comparison operator
	SourceNotIlike *string ` json:"source_not_ilike"`
	// suffix comparison operator
	SourceSuffix *string ` json:"source_suffix"`
	// prefix comparison operator
	SourcePrefix *string ` json:"source_prefix"`
	// eq comparison operator
	TypeEq *AccessType ` json:"type_eq"`
	// neq comparison operator
	TypeNeq *AccessType ` json:"type_neq"`
	// in comparison operator
	TypeIn []*AccessType ` json:"type_in"`
	// not_in comparison operator
	TypeNotIn []*AccessType ` json:"type_not_in"`
	// eq comparison operator
	DirectionEq *Direction ` json:"direction_eq"`
	// neq comparison operator
	DirectionNeq *Direction ` json:"direction_neq"`
	// in comparison operator
	DirectionIn []*Direction ` json:"direction_in"`
	// not_in comparison operator
	DirectionNotIn []*Direction ` json:"direction_not_in"`
	// exists comparison operator
	TargetExists *bool ` json:"target_exists"`
	// not comparison operator
	TargetNot *string ` json:"target_not"`
	// eq comparison operator
	TargetEq *string ` json:"target_eq"`
	// neq comparison operator
	TargetNeq *string ` json:"target_neq"`
	// in comparison operator
	TargetIn []*string ` json:"target_in"`
	// not_in comparison operator
	TargetNotIn []*string ` json:"target_not_in"`
	// like comparison operator
	TargetLike *string ` json:"target_like"`
	// not_like comparison operator
	TargetNotLike *string ` json:"target_not_like"`
	// ilike comparison operator
	TargetIlike *string ` json:"target_ilike"`
	// not_ilike comparison operator
	TargetNotIlike *string ` json:"target_not_ilike"`
	// suffix comparison operator
	TargetSuffix *string ` json:"target_suffix"`
	// prefix comparison operator
	TargetPrefix *string ` json:"target_prefix"`
	// exists comparison operator
	ProtocolExists *bool ` json:"protocol_exists"`
	// not comparison operator
	ProtocolNot *string ` json:"protocol_not"`
	// eq comparison operator
	ProtocolEq *string ` json:"protocol_eq"`
	// neq comparison operator
	ProtocolNeq *string ` json:"protocol_neq"`
	// in comparison operator
	ProtocolIn []*string ` json:"protocol_in"`
	// not_in comparison operator
	ProtocolNotIn []*string ` json:"protocol_not_in"`
	// like comparison operator
	ProtocolLike *string ` json:"protocol_like"`
	// not_like comparison operator
	ProtocolNotLike *string ` json:"protocol_not_like"`
	// ilike comparison operator
	ProtocolIlike *string ` json:"protocol_ilike"`
	// not_ilike comparison operator
	ProtocolNotIlike *string ` json:"protocol_not_ilike"`
	// suffix comparison operator
	ProtocolSuffix *string ` json:"protocol_suffix"`
	// prefix comparison operator
	ProtocolPrefix *string ` json:"protocol_prefix"`
	// exists comparison operator
	SrcPortExists *bool ` json:"src_port_exists"`
	// eq comparison operator
	SrcPortEq *int ` json:"src_port_eq"`
	// neq comparison operator
	SrcPortNeq *int ` json:"src_port_neq"`
	// in comparison operator
	SrcPortIn []*int ` json:"src_port_in"`
	// not_in comparison operator
	SrcPortNotIn []*int ` json:"src_port_not_in"`
	// gt comparison operator
	SrcPortGt *int ` json:"src_port_gt"`
	// gte comparison operator
	SrcPortGte *int ` json:"src_port_gte"`
	// lt comparison operator
	SrcPortLt *int ` json:"src_port_lt"`
	// lte comparison operator
	SrcPortLte *int ` json:"src_port_lte"`
	// exists comparison operator
	DstPortExists *bool ` json:"dst_port_exists"`
	// eq comparison operator
	DstPortEq *int ` json:"dst_port_eq"`
	// neq comparison operator
	DstPortNeq *int ` json:"dst_port_neq"`
	// in comparison operator
	DstPortIn []*int ` json:"dst_port_in"`
	// not_in comparison operator
	DstPortNotIn []*int ` json:"dst_port_not_in"`
	// gt comparison operator
	DstPortGt *int ` json:"dst_port_gt"`
	// gte comparison operator
	DstPortGte *int ` json:"dst_port_gte"`
	// lt comparison operator
	DstPortLt *int ` json:"dst_port_lt"`
	// lte comparison operator
	DstPortLte *int                  ` json:"dst_port_lte"`
	And        []FirewallRuleBoolExp ` json:"and"`
	Or         []FirewallRuleBoolExp ` json:"or"`
	Not        []FirewallRuleBoolExp ` json:"not"`
}

// Boolean filter expression for GceTags
type GceTagsBoolExp struct {
	// exists comparison operator
	GceKeyExists *bool ` json:"gce_key_exists"`
	// not comparison operator
	GceKeyNot *string ` json:"gce_key_not"`
	// eq comparison operator
	GceKeyEq *string ` json:"gce_key_eq"`
	// neq comparison operator
	GceKeyNeq *string ` json:"gce_key_neq"`
	// in comparison operator
	GceKeyIn []*string ` json:"gce_key_in"`
	// not_in comparison operator
	GceKeyNotIn []*string ` json:"gce_key_not_in"`
	// like comparison operator
	GceKeyLike *string ` json:"gce_key_like"`
	// not_like comparison operator
	GceKeyNotLike *string ` json:"gce_key_not_like"`
	// ilike comparison operator
	GceKeyIlike *string ` json:"gce_key_ilike"`
	// not_ilike comparison operator
	GceKeyNotIlike *string ` json:"gce_key_not_ilike"`
	// suffix comparison operator
	GceKeySuffix *string ` json:"gce_key_suffix"`
	// prefix comparison operator
	GceKeyPrefix *string ` json:"gce_key_prefix"`
	// exists comparison operator
	GceValueExists *bool ` json:"gce_value_exists"`
	// not comparison operator
	GceValueNot *string ` json:"gce_value_not"`
	// eq comparison operator
	GceValueEq *string ` json:"gce_value_eq"`
	// neq comparison operator
	GceValueNeq *string ` json:"gce_value_neq"`
	// in comparison operator
	GceValueIn []*string ` json:"gce_value_in"`
	// not_in comparison operator
	GceValueNotIn []*string ` json:"gce_value_not_in"`
	// like comparison operator
	GceValueLike *string ` json:"gce_value_like"`
	// not_like comparison operator
	GceValueNotLike *string ` json:"gce_value_not_like"`
	// ilike comparison operator
	GceValueIlike *string ` json:"gce_value_ilike"`
	// not_ilike comparison operator
	GceValueNotIlike *string ` json:"gce_value_not_ilike"`
	// suffix comparison operator
	GceValueSuffix *string ` json:"gce_value_suffix"`
	// prefix comparison operator
	GceValuePrefix *string          ` json:"gce_value_prefix"`
	And            []GceTagsBoolExp ` json:"and"`
	Or             []GceTagsBoolExp ` json:"or"`
	Not            []GceTagsBoolExp ` json:"not"`
}

type GroupsAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	Groups   []*CsGroup             ` json:"groups"`
}

type InstalledSoftwareAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	// Software installed on this device
	InstalledSoftware []*InstalledSoftware ` json:"installed_software"`
}

// Boolean filter expression for InstalledSoftware
type InstalledSoftwareBoolExp struct {
	// exists comparison operator
	NameExists *bool ` json:"name_exists"`
	// not comparison operator
	NameNot *string ` json:"name_not"`
	// eq comparison operator
	NameEq *string ` json:"name_eq"`
	// neq comparison operator
	NameNeq *string ` json:"name_neq"`
	// in comparison operator
	NameIn []*string ` json:"name_in"`
	// not_in comparison operator
	NameNotIn []*string ` json:"name_not_in"`
	// like comparison operator
	NameLike *string ` json:"name_like"`
	// not_like comparison operator
	NameNotLike *string ` json:"name_not_like"`
	// ilike comparison operator
	NameIlike *string ` json:"name_ilike"`
	// not_ilike comparison operator
	NameNotIlike *string ` json:"name_not_ilike"`
	// suffix comparison operator
	NameSuffix *string ` json:"name_suffix"`
	// prefix comparison operator
	NamePrefix *string ` json:"name_prefix"`
	// exists comparison operator
	VersionExists *bool ` json:"version_exists"`
	// not comparison operator
	VersionNot *string ` json:"version_not"`
	// eq comparison operator
	VersionEq *string ` json:"version_eq"`
	// neq comparison operator
	VersionNeq *string ` json:"version_neq"`
	// in comparison operator
	VersionIn []*string ` json:"version_in"`
	// not_in comparison operator
	VersionNotIn []*string ` json:"version_not_in"`
	// like comparison operator
	VersionLike *string ` json:"version_like"`
	// not_like comparison operator
	VersionNotLike *string ` json:"version_not_like"`
	// ilike comparison operator
	VersionIlike *string ` json:"version_ilike"`
	// not_ilike comparison operator
	VersionNotIlike *string ` json:"version_not_ilike"`
	// suffix comparison operator
	VersionSuffix *string ` json:"version_suffix"`
	// prefix comparison operator
	VersionPrefix *string ` json:"version_prefix"`
	// eq comparison operator
	ArchitectureEq *Architecture ` json:"architecture_eq"`
	// neq comparison operator
	ArchitectureNeq *Architecture ` json:"architecture_neq"`
	// in comparison operator
	ArchitectureIn []*Architecture ` json:"architecture_in"`
	// not_in comparison operator
	ArchitectureNotIn []*Architecture ` json:"architecture_not_in"`
	// exists comparison operator
	DescriptionExists *bool ` json:"description_exists"`
	// not comparison operator
	DescriptionNot *string ` json:"description_not"`
	// eq comparison operator
	DescriptionEq *string ` json:"description_eq"`
	// neq comparison operator
	DescriptionNeq *string ` json:"description_neq"`
	// in comparison operator
	DescriptionIn []*string ` json:"description_in"`
	// not_in comparison operator
	DescriptionNotIn []*string ` json:"description_not_in"`
	// like comparison operator
	DescriptionLike *string ` json:"description_like"`
	// not_like comparison operator
	DescriptionNotLike *string ` json:"description_not_like"`
	// ilike comparison operator
	DescriptionIlike *string ` json:"description_ilike"`
	// not_ilike comparison operator
	DescriptionNotIlike *string ` json:"description_not_ilike"`
	// suffix comparison operator
	DescriptionSuffix *string ` json:"description_suffix"`
	// prefix comparison operator
	DescriptionPrefix *string ` json:"description_prefix"`
	// exists comparison operator
	VendorExists *bool ` json:"vendor_exists"`
	// not comparison operator
	VendorNot *string ` json:"vendor_not"`
	// eq comparison operator
	VendorEq *string ` json:"vendor_eq"`
	// neq comparison operator
	VendorNeq *string ` json:"vendor_neq"`
	// in comparison operator
	VendorIn []*string ` json:"vendor_in"`
	// not_in comparison operator
	VendorNotIn []*string ` json:"vendor_not_in"`
	// like comparison operator
	VendorLike *string ` json:"vendor_like"`
	// not_like comparison operator
	VendorNotLike *string ` json:"vendor_not_like"`
	// ilike comparison operator
	VendorIlike *string ` json:"vendor_ilike"`
	// not_ilike comparison operator
	VendorNotIlike *string ` json:"vendor_not_ilike"`
	// suffix comparison operator
	VendorSuffix *string ` json:"vendor_suffix"`
	// prefix comparison operator
	VendorPrefix *string ` json:"vendor_prefix"`
	// exists comparison operator
	PublisherExists *bool ` json:"publisher_exists"`
	// not comparison operator
	PublisherNot *string ` json:"publisher_not"`
	// eq comparison operator
	PublisherEq *string ` json:"publisher_eq"`
	// neq comparison operator
	PublisherNeq *string ` json:"publisher_neq"`
	// in comparison operator
	PublisherIn []*string ` json:"publisher_in"`
	// not_in comparison operator
	PublisherNotIn []*string ` json:"publisher_not_in"`
	// like comparison operator
	PublisherLike *string ` json:"publisher_like"`
	// not_like comparison operator
	PublisherNotLike *string ` json:"publisher_not_like"`
	// ilike comparison operator
	PublisherIlike *string ` json:"publisher_ilike"`
	// not_ilike comparison operator
	PublisherNotIlike *string ` json:"publisher_not_ilike"`
	// suffix comparison operator
	PublisherSuffix *string ` json:"publisher_suffix"`
	// prefix comparison operator
	PublisherPrefix *string ` json:"publisher_prefix"`
	// exists comparison operator
	CveCountExists *bool ` json:"cve_count_exists"`
	// eq comparison operator
	CveCountEq *int ` json:"cve_count_eq"`
	// neq comparison operator
	CveCountNeq *int ` json:"cve_count_neq"`
	// in comparison operator
	CveCountIn []*int ` json:"cve_count_in"`
	// not_in comparison operator
	CveCountNotIn []*int ` json:"cve_count_not_in"`
	// gt comparison operator
	CveCountGt *int ` json:"cve_count_gt"`
	// gte comparison operator
	CveCountGte *int ` json:"cve_count_gte"`
	// lt comparison operator
	CveCountLt *int ` json:"cve_count_lt"`
	// lte comparison operator
	CveCountLte *int ` json:"cve_count_lte"`
	// exists comparison operator
	SwLicenseExists *bool ` json:"sw_license_exists"`
	// not comparison operator
	SwLicenseNot *string ` json:"sw_license_not"`
	// eq comparison operator
	SwLicenseEq *string ` json:"sw_license_eq"`
	// neq comparison operator
	SwLicenseNeq *string ` json:"sw_license_neq"`
	// in comparison operator
	SwLicenseIn []*string ` json:"sw_license_in"`
	// not_in comparison operator
	SwLicenseNotIn []*string ` json:"sw_license_not_in"`
	// like comparison operator
	SwLicenseLike *string ` json:"sw_license_like"`
	// not_like comparison operator
	SwLicenseNotLike *string ` json:"sw_license_not_like"`
	// ilike comparison operator
	SwLicenseIlike *string ` json:"sw_license_ilike"`
	// not_ilike comparison operator
	SwLicenseNotIlike *string ` json:"sw_license_not_ilike"`
	// suffix comparison operator
	SwLicenseSuffix *string ` json:"sw_license_suffix"`
	// prefix comparison operator
	SwLicensePrefix *string ` json:"sw_license_prefix"`
	// exists comparison operator
	PathExists *bool ` json:"path_exists"`
	// not comparison operator
	PathNot *string ` json:"path_not"`
	// eq comparison operator
	PathEq *string ` json:"path_eq"`
	// neq comparison operator
	PathNeq *string ` json:"path_neq"`
	// in comparison operator
	PathIn []*string ` json:"path_in"`
	// not_in comparison operator
	PathNotIn []*string ` json:"path_not_in"`
	// like comparison operator
	PathLike *string ` json:"path_like"`
	// not_like comparison operator
	PathNotLike *string ` json:"path_not_like"`
	// ilike comparison operator
	PathIlike *string ` json:"path_ilike"`
	// not_ilike comparison operator
	PathNotIlike *string ` json:"path_not_ilike"`
	// suffix comparison operator
	PathSuffix *string ` json:"path_suffix"`
	// prefix comparison operator
	PathPrefix *string                    ` json:"path_prefix"`
	And        []InstalledSoftwareBoolExp ` json:"and"`
	Or         []InstalledSoftwareBoolExp ` json:"or"`
	Not        []InstalledSoftwareBoolExp ` json:"not"`
}

type InterfacesAggregate struct {
	Group      []string               ` json:"group"`
	Distinct   []string               ` json:"distinct"`
	Count      *int                   ` json:"count"`
	Sum        map[string]interface{} ` json:"sum"`
	Avg        map[string]interface{} ` json:"avg"`
	Min        map[string]interface{} ` json:"min"`
	Max        map[string]interface{} ` json:"max"`
	Interfaces []*NetworkInterface    ` json:"interfaces"`
}

// Boolean filter expression for NetworkInterface
type NetworkInterfaceBoolExp struct {
	// exists comparison operator
	DeviceIDExists *bool ` json:"device_id_exists"`
	// eq comparison operator
	DeviceIDEq *uuid.UUID ` json:"device_id_eq"`
	// neq comparison operator
	DeviceIDNeq *uuid.UUID ` json:"device_id_neq"`
	// in comparison operator
	DeviceIDIn []*uuid.UUID ` json:"device_id_in"`
	// not_in comparison operator
	DeviceIDNotIn []*uuid.UUID ` json:"device_id_not_in"`
	// gt comparison operator
	DeviceIDGt *uuid.UUID ` json:"device_id_gt"`
	// gte comparison operator
	DeviceIDGte *uuid.UUID ` json:"device_id_gte"`
	// lt comparison operator
	DeviceIDLt *uuid.UUID ` json:"device_id_lt"`
	// lte comparison operator
	DeviceIDLte *uuid.UUID ` json:"device_id_lte"`
	// exists comparison operator
	MacAddrExists *bool ` json:"mac_addr_exists"`
	// eq comparison operator
	MacAddrEq *string ` json:"mac_addr_eq"`
	// neq comparison operator
	MacAddrNeq *string ` json:"mac_addr_neq"`
	// in comparison operator
	MacAddrIn []*string ` json:"mac_addr_in"`
	// not_in comparison operator
	MacAddrNotIn []*string ` json:"mac_addr_not_in"`
	// contains comparison operator
	IPAddrsContains []*net.IP ` json:"ip_addrs_contains"`
	// contained_by comparison operator
	IPAddrsContainedBy []*net.IP ` json:"ip_addrs_contained_by"`
	// overlap comparison operator
	IPAddrsOverlap []*net.IP ` json:"ip_addrs_overlap"`
	// size comparison operator
	IPAddrsSize *int ` json:"ip_addrs_size"`
	// in_subnet comparison operator
	IPAddrsInSubnet *net.IPNet ` json:"ip_addrs_in_subnet"`
	// ip_family comparison operator
	IPAddrsIPFamily *IPFamily                 ` json:"ip_addrs_ip_family"`
	And             []NetworkInterfaceBoolExp ` json:"and"`
	Or              []NetworkInterfaceBoolExp ` json:"or"`
	Not             []NetworkInterfaceBoolExp ` json:"not"`
}

// Boolean filter expression for OperatingSystem
type OperatingSystemBoolExp struct {
	// exists comparison operator
	IDExists *bool ` json:"id_exists"`
	// eq comparison operator
	IDEq *uuid.UUID ` json:"id_eq"`
	// neq comparison operator
	IDNeq *uuid.UUID ` json:"id_neq"`
	// in comparison operator
	IDIn []*uuid.UUID ` json:"id_in"`
	// not_in comparison operator
	IDNotIn []*uuid.UUID ` json:"id_not_in"`
	// gt comparison operator
	IDGt *uuid.UUID ` json:"id_gt"`
	// gte comparison operator
	IDGte *uuid.UUID ` json:"id_gte"`
	// lt comparison operator
	IDLt *uuid.UUID ` json:"id_lt"`
	// lte comparison operator
	IDLte *uuid.UUID ` json:"id_lte"`
	// exists comparison operator
	TypeExists *bool ` json:"type_exists"`
	// not comparison operator
	TypeNot *string ` json:"type_not"`
	// eq comparison operator
	TypeEq *string ` json:"type_eq"`
	// neq comparison operator
	TypeNeq *string ` json:"type_neq"`
	// in comparison operator
	TypeIn []*string ` json:"type_in"`
	// not_in comparison operator
	TypeNotIn []*string ` json:"type_not_in"`
	// like comparison operator
	TypeLike *string ` json:"type_like"`
	// not_like comparison operator
	TypeNotLike *string ` json:"type_not_like"`
	// ilike comparison operator
	TypeIlike *string ` json:"type_ilike"`
	// not_ilike comparison operator
	TypeNotIlike *string ` json:"type_not_ilike"`
	// suffix comparison operator
	TypeSuffix *string ` json:"type_suffix"`
	// prefix comparison operator
	TypePrefix *string ` json:"type_prefix"`
	// exists comparison operator
	DistributionExists *bool ` json:"distribution_exists"`
	// not comparison operator
	DistributionNot *string ` json:"distribution_not"`
	// eq comparison operator
	DistributionEq *string ` json:"distribution_eq"`
	// neq comparison operator
	DistributionNeq *string ` json:"distribution_neq"`
	// in comparison operator
	DistributionIn []*string ` json:"distribution_in"`
	// not_in comparison operator
	DistributionNotIn []*string ` json:"distribution_not_in"`
	// like comparison operator
	DistributionLike *string ` json:"distribution_like"`
	// not_like comparison operator
	DistributionNotLike *string ` json:"distribution_not_like"`
	// ilike comparison operator
	DistributionIlike *string ` json:"distribution_ilike"`
	// not_ilike comparison operator
	DistributionNotIlike *string ` json:"distribution_not_ilike"`
	// suffix comparison operator
	DistributionSuffix *string ` json:"distribution_suffix"`
	// prefix comparison operator
	DistributionPrefix *string ` json:"distribution_prefix"`
	// exists comparison operator
	ArchitectureExists *bool ` json:"architecture_exists"`
	// eq comparison operator
	ArchitectureEq *int ` json:"architecture_eq"`
	// neq comparison operator
	ArchitectureNeq *int ` json:"architecture_neq"`
	// in comparison operator
	ArchitectureIn []*int ` json:"architecture_in"`
	// not_in comparison operator
	ArchitectureNotIn []*int ` json:"architecture_not_in"`
	// gt comparison operator
	ArchitectureGt *int ` json:"architecture_gt"`
	// gte comparison operator
	ArchitectureGte *int ` json:"architecture_gte"`
	// lt comparison operator
	ArchitectureLt *int ` json:"architecture_lt"`
	// lte comparison operator
	ArchitectureLte *int ` json:"architecture_lte"`
	// exists comparison operator
	ServicePackExists *bool ` json:"service_pack_exists"`
	// not comparison operator
	ServicePackNot *string ` json:"service_pack_not"`
	// eq comparison operator
	ServicePackEq *string ` json:"service_pack_eq"`
	// neq comparison operator
	ServicePackNeq *string ` json:"service_pack_neq"`
	// in comparison operator
	ServicePackIn []*string ` json:"service_pack_in"`
	// not_in comparison operator
	ServicePackNotIn []*string ` json:"service_pack_not_in"`
	// like comparison operator
	ServicePackLike *string ` json:"service_pack_like"`
	// not_like comparison operator
	ServicePackNotLike *string ` json:"service_pack_not_like"`
	// ilike comparison operator
	ServicePackIlike *string ` json:"service_pack_ilike"`
	// not_ilike comparison operator
	ServicePackNotIlike *string ` json:"service_pack_not_ilike"`
	// suffix comparison operator
	ServicePackSuffix *string ` json:"service_pack_suffix"`
	// prefix comparison operator
	ServicePackPrefix *string ` json:"service_pack_prefix"`
	// exists comparison operator
	InstallDateExists *bool ` json:"install_date_exists"`
	// eq comparison operator
	InstallDateEq *internal.Epoch ` json:"install_date_eq"`
	// neq comparison operator
	InstallDateNeq *internal.Epoch ` json:"install_date_neq"`
	// in comparison operator
	InstallDateIn []*internal.Epoch ` json:"install_date_in"`
	// not_in comparison operator
	InstallDateNotIn []*internal.Epoch ` json:"install_date_not_in"`
	// gt comparison operator
	InstallDateGt *internal.Epoch ` json:"install_date_gt"`
	// gte comparison operator
	InstallDateGte *internal.Epoch ` json:"install_date_gte"`
	// lt comparison operator
	InstallDateLt *internal.Epoch ` json:"install_date_lt"`
	// lte comparison operator
	InstallDateLte *internal.Epoch ` json:"install_date_lte"`
	// days comparison operator
	InstallDateDays *int ` json:"install_date_days"`
	// exists comparison operator
	KernelVersionExists *bool ` json:"kernel_version_exists"`
	// not comparison operator
	KernelVersionNot *string ` json:"kernel_version_not"`
	// eq comparison operator
	KernelVersionEq *string ` json:"kernel_version_eq"`
	// neq comparison operator
	KernelVersionNeq *string ` json:"kernel_version_neq"`
	// in comparison operator
	KernelVersionIn []*string ` json:"kernel_version_in"`
	// not_in comparison operator
	KernelVersionNotIn []*string ` json:"kernel_version_not_in"`
	// like comparison operator
	KernelVersionLike *string ` json:"kernel_version_like"`
	// not_like comparison operator
	KernelVersionNotLike *string ` json:"kernel_version_not_like"`
	// ilike comparison operator
	KernelVersionIlike *string ` json:"kernel_version_ilike"`
	// not_ilike comparison operator
	KernelVersionNotIlike *string ` json:"kernel_version_not_ilike"`
	// suffix comparison operator
	KernelVersionSuffix *string ` json:"kernel_version_suffix"`
	// prefix comparison operator
	KernelVersionPrefix *string ` json:"kernel_version_prefix"`
	// exists comparison operator
	CodeNameExists *bool ` json:"code_name_exists"`
	// not comparison operator
	CodeNameNot *string ` json:"code_name_not"`
	// eq comparison operator
	CodeNameEq *string ` json:"code_name_eq"`
	// neq comparison operator
	CodeNameNeq *string ` json:"code_name_neq"`
	// in comparison operator
	CodeNameIn []*string ` json:"code_name_in"`
	// not_in comparison operator
	CodeNameNotIn []*string ` json:"code_name_not_in"`
	// like comparison operator
	CodeNameLike *string ` json:"code_name_like"`
	// not_like comparison operator
	CodeNameNotLike *string ` json:"code_name_not_like"`
	// ilike comparison operator
	CodeNameIlike *string ` json:"code_name_ilike"`
	// not_ilike comparison operator
	CodeNameNotIlike *string ` json:"code_name_not_ilike"`
	// suffix comparison operator
	CodeNameSuffix *string ` json:"code_name_suffix"`
	// prefix comparison operator
	CodeNamePrefix *string ` json:"code_name_prefix"`
	// exists comparison operator
	MajorExists *bool ` json:"major_exists"`
	// eq comparison operator
	MajorEq *int ` json:"major_eq"`
	// neq comparison operator
	MajorNeq *int ` json:"major_neq"`
	// in comparison operator
	MajorIn []*int ` json:"major_in"`
	// not_in comparison operator
	MajorNotIn []*int ` json:"major_not_in"`
	// gt comparison operator
	MajorGt *int ` json:"major_gt"`
	// gte comparison operator
	MajorGte *int ` json:"major_gte"`
	// lt comparison operator
	MajorLt *int ` json:"major_lt"`
	// lte comparison operator
	MajorLte *int ` json:"major_lte"`
	// exists comparison operator
	MinorExists *bool ` json:"minor_exists"`
	// eq comparison operator
	MinorEq *int ` json:"minor_eq"`
	// neq comparison operator
	MinorNeq *int ` json:"minor_neq"`
	// in comparison operator
	MinorIn []*int ` json:"minor_in"`
	// not_in comparison operator
	MinorNotIn []*int ` json:"minor_not_in"`
	// gt comparison operator
	MinorGt *int ` json:"minor_gt"`
	// gte comparison operator
	MinorGte *int ` json:"minor_gte"`
	// lt comparison operator
	MinorLt *int ` json:"minor_lt"`
	// lte comparison operator
	MinorLte *int ` json:"minor_lte"`
	// exists comparison operator
	BuildExists *bool ` json:"build_exists"`
	// not comparison operator
	BuildNot *string ` json:"build_not"`
	// eq comparison operator
	BuildEq *string ` json:"build_eq"`
	// neq comparison operator
	BuildNeq *string ` json:"build_neq"`
	// in comparison operator
	BuildIn []*string ` json:"build_in"`
	// not_in comparison operator
	BuildNotIn []*string ` json:"build_not_in"`
	// like comparison operator
	BuildLike *string ` json:"build_like"`
	// not_like comparison operator
	BuildNotLike *string ` json:"build_not_like"`
	// ilike comparison operator
	BuildIlike *string ` json:"build_ilike"`
	// not_ilike comparison operator
	BuildNotIlike *string ` json:"build_not_ilike"`
	// suffix comparison operator
	BuildSuffix *string ` json:"build_suffix"`
	// prefix comparison operator
	BuildPrefix *string ` json:"build_prefix"`
	// exists comparison operator
	RawNameExists *bool ` json:"raw_name_exists"`
	// not comparison operator
	RawNameNot *string ` json:"raw_name_not"`
	// eq comparison operator
	RawNameEq *string ` json:"raw_name_eq"`
	// neq comparison operator
	RawNameNeq *string ` json:"raw_name_neq"`
	// in comparison operator
	RawNameIn []*string ` json:"raw_name_in"`
	// not_in comparison operator
	RawNameNotIn []*string ` json:"raw_name_not_in"`
	// like comparison operator
	RawNameLike *string ` json:"raw_name_like"`
	// not_like comparison operator
	RawNameNotLike *string ` json:"raw_name_not_like"`
	// ilike comparison operator
	RawNameIlike *string ` json:"raw_name_ilike"`
	// not_ilike comparison operator
	RawNameNotIlike *string ` json:"raw_name_not_ilike"`
	// suffix comparison operator
	RawNameSuffix *string ` json:"raw_name_suffix"`
	// prefix comparison operator
	RawNamePrefix *string                  ` json:"raw_name_prefix"`
	And           []OperatingSystemBoolExp ` json:"and"`
	Or            []OperatingSystemBoolExp ` json:"or"`
	Not           []OperatingSystemBoolExp ` json:"not"`
}

type PreventionSettingsAggregate struct {
	Group              []string                ` json:"group"`
	Distinct           []string                ` json:"distinct"`
	Count              *int                    ` json:"count"`
	Sum                map[string]interface{}  ` json:"sum"`
	Avg                map[string]interface{}  ` json:"avg"`
	Min                map[string]interface{}  ` json:"min"`
	Max                map[string]interface{}  ` json:"max"`
	PreventionSettings []*CsPreventionSettings ` json:"prevention_settings"`
}

type SensorUpdateSettingsAggregate struct {
	Group                []string                  ` json:"group"`
	Distinct             []string                  ` json:"distinct"`
	Count                *int                      ` json:"count"`
	Sum                  map[string]interface{}    ` json:"sum"`
	Avg                  map[string]interface{}    ` json:"avg"`
	Min                  map[string]interface{}    ` json:"min"`
	Max                  map[string]interface{}    ` json:"max"`
	SensorUpdateSettings []*CsSensorUpdateSettings ` json:"sensor_update_settings"`
}

// Boolean filter expression for Tag
type TagBoolExp struct {
	// exists comparison operator
	NameExists *bool ` json:"name_exists"`
	// not comparison operator
	NameNot *string ` json:"name_not"`
	// eq comparison operator
	NameEq *string ` json:"name_eq"`
	// neq comparison operator
	NameNeq *string ` json:"name_neq"`
	// in comparison operator
	NameIn []*string ` json:"name_in"`
	// not_in comparison operator
	NameNotIn []*string ` json:"name_not_in"`
	// like comparison operator
	NameLike *string ` json:"name_like"`
	// not_like comparison operator
	NameNotLike *string ` json:"name_not_like"`
	// ilike comparison operator
	NameIlike *string ` json:"name_ilike"`
	// not_ilike comparison operator
	NameNotIlike *string ` json:"name_not_ilike"`
	// suffix comparison operator
	NameSuffix *string ` json:"name_suffix"`
	// prefix comparison operator
	NamePrefix *string ` json:"name_prefix"`
	// exists comparison operator
	CreatorExists *bool ` json:"creator_exists"`
	// not comparison operator
	CreatorNot *string ` json:"creator_not"`
	// eq comparison operator
	CreatorEq *string ` json:"creator_eq"`
	// neq comparison operator
	CreatorNeq *string ` json:"creator_neq"`
	// in comparison operator
	CreatorIn []*string ` json:"creator_in"`
	// not_in comparison operator
	CreatorNotIn []*string ` json:"creator_not_in"`
	// like comparison operator
	CreatorLike *string ` json:"creator_like"`
	// not_like comparison operator
	CreatorNotLike *string ` json:"creator_not_like"`
	// ilike comparison operator
	CreatorIlike *string ` json:"creator_ilike"`
	// not_ilike comparison operator
	CreatorNotIlike *string ` json:"creator_not_ilike"`
	// suffix comparison operator
	CreatorSuffix *string ` json:"creator_suffix"`
	// prefix comparison operator
	CreatorPrefix *string ` json:"creator_prefix"`
	// exists comparison operator
	LevelExists *bool ` json:"level_exists"`
	// not comparison operator
	LevelNot *string ` json:"level_not"`
	// eq comparison operator
	LevelEq *string ` json:"level_eq"`
	// neq comparison operator
	LevelNeq *string ` json:"level_neq"`
	// in comparison operator
	LevelIn []*string ` json:"level_in"`
	// not_in comparison operator
	LevelNotIn []*string ` json:"level_not_in"`
	// like comparison operator
	LevelLike *string ` json:"level_like"`
	// not_like comparison operator
	LevelNotLike *string ` json:"level_not_like"`
	// ilike comparison operator
	LevelIlike *string ` json:"level_ilike"`
	// not_ilike comparison operator
	LevelNotIlike *string ` json:"level_not_ilike"`
	// suffix comparison operator
	LevelSuffix *string ` json:"level_suffix"`
	// prefix comparison operator
	LevelPrefix *string      ` json:"level_prefix"`
	And         []TagBoolExp ` json:"and"`
	Or          []TagBoolExp ` json:"or"`
	Not         []TagBoolExp ` json:"not"`
}

type TagsAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	Tags     []*Tag                 ` json:"tags"`
}

// Boolean filter expression for User
type UserBoolExp struct {
	// exists comparison operator
	IDExists *bool ` json:"id_exists"`
	// eq comparison operator
	IDEq *uuid.UUID ` json:"id_eq"`
	// neq comparison operator
	IDNeq *uuid.UUID ` json:"id_neq"`
	// in comparison operator
	IDIn []*uuid.UUID ` json:"id_in"`
	// not_in comparison operator
	IDNotIn []*uuid.UUID ` json:"id_not_in"`
	// gt comparison operator
	IDGt *uuid.UUID ` json:"id_gt"`
	// gte comparison operator
	IDGte *uuid.UUID ` json:"id_gte"`
	// lt comparison operator
	IDLt *uuid.UUID ` json:"id_lt"`
	// lte comparison operator
	IDLte *uuid.UUID ` json:"id_lte"`
	// exists comparison operator
	FetchCycleExists *bool ` json:"fetch_cycle_exists"`
	// eq comparison operator
	FetchCycleEq *int ` json:"fetch_cycle_eq"`
	// neq comparison operator
	FetchCycleNeq *int ` json:"fetch_cycle_neq"`
	// in comparison operator
	FetchCycleIn []*int ` json:"fetch_cycle_in"`
	// not_in comparison operator
	FetchCycleNotIn []*int ` json:"fetch_cycle_not_in"`
	// gt comparison operator
	FetchCycleGt *int ` json:"fetch_cycle_gt"`
	// gte comparison operator
	FetchCycleGte *int ` json:"fetch_cycle_gte"`
	// lt comparison operator
	FetchCycleLt *int ` json:"fetch_cycle_lt"`
	// lte comparison operator
	FetchCycleLte *int ` json:"fetch_cycle_lte"`
	// exists comparison operator
	AdapterCountExists *bool ` json:"adapter_count_exists"`
	// eq comparison operator
	AdapterCountEq *int ` json:"adapter_count_eq"`
	// neq comparison operator
	AdapterCountNeq *int ` json:"adapter_count_neq"`
	// in comparison operator
	AdapterCountIn []*int ` json:"adapter_count_in"`
	// not_in comparison operator
	AdapterCountNotIn []*int ` json:"adapter_count_not_in"`
	// gt comparison operator
	AdapterCountGt *int ` json:"adapter_count_gt"`
	// gte comparison operator
	AdapterCountGte *int ` json:"adapter_count_gte"`
	// lt comparison operator
	AdapterCountLt *int ` json:"adapter_count_lt"`
	// lte comparison operator
	AdapterCountLte *int ` json:"adapter_count_lte"`
	// contains comparison operator
	AdapterNamesContains []*string ` json:"adapter_names_contains"`
	// contained_by comparison operator
	AdapterNamesContainedBy []*string ` json:"adapter_names_contained_by"`
	// overlap comparison operator
	AdapterNamesOverlap []*string ` json:"adapter_names_overlap"`
	// size comparison operator
	AdapterNamesSize *int ` json:"adapter_names_size"`
	// contains_regex comparison operator
	AdapterNamesContainsRegex *string ` json:"adapter_names_contains_regex"`
	// contains comparison operator
	UsernamesContains []*string ` json:"usernames_contains"`
	// contained_by comparison operator
	UsernamesContainedBy []*string ` json:"usernames_contained_by"`
	// overlap comparison operator
	UsernamesOverlap []*string ` json:"usernames_overlap"`
	// size comparison operator
	UsernamesSize *int ` json:"usernames_size"`
	// contains_regex comparison operator
	UsernamesContainsRegex *string ` json:"usernames_contains_regex"`
	// exists comparison operator
	LastSeenExists *bool ` json:"last_seen_exists"`
	// eq comparison operator
	LastSeenEq *internal.Epoch ` json:"last_seen_eq"`
	// neq comparison operator
	LastSeenNeq *internal.Epoch ` json:"last_seen_neq"`
	// in comparison operator
	LastSeenIn []*internal.Epoch ` json:"last_seen_in"`
	// not_in comparison operator
	LastSeenNotIn []*internal.Epoch ` json:"last_seen_not_in"`
	// gt comparison operator
	LastSeenGt *internal.Epoch ` json:"last_seen_gt"`
	// gte comparison operator
	LastSeenGte *internal.Epoch ` json:"last_seen_gte"`
	// lt comparison operator
	LastSeenLt *internal.Epoch ` json:"last_seen_lt"`
	// lte comparison operator
	LastSeenLte *internal.Epoch ` json:"last_seen_lte"`
	// days comparison operator
	LastSeenDays *int ` json:"last_seen_days"`
	// filter by adapterUsers
	AdapterUsers *AdapterUserBoolExp ` json:"adapter_users"`
	And          []UserBoolExp       ` json:"and"`
	Or           []UserBoolExp       ` json:"or"`
	Not          []UserBoolExp       ` json:"not"`
}

type UsersAggregate struct {
	Group    []string               ` json:"group"`
	Distinct []string               ` json:"distinct"`
	Count    *int                   ` json:"count"`
	Sum      map[string]interface{} ` json:"sum"`
	Avg      map[string]interface{} ` json:"avg"`
	Min      map[string]interface{} ` json:"min"`
	Max      map[string]interface{} ` json:"max"`
	Users    []*User                ` json:"users"`
}

type AccessType string

const (
	AccessTypeAllow AccessType = "ALLOW"
	AccessTypeDeny  AccessType = "DENY"
)

var AllAccessType = []AccessType{
	AccessTypeAllow,
	AccessTypeDeny,
}

func (e AccessType) IsValid() bool {
	switch e {
	case AccessTypeAllow, AccessTypeDeny:
		return true
	}
	return false
}

func (e AccessType) String() string {
	return string(e)
}

func (e *AccessType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessType", str)
	}
	return nil
}

func (e AccessType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdminType string

const (
	AdminTypeAdminUser       AdminType = "ADMIN_USER"
	AdminTypeGroupMembership AdminType = "GROUP_MEMBERSHIP"
)

var AllAdminType = []AdminType{
	AdminTypeAdminUser,
	AdminTypeGroupMembership,
}

func (e AdminType) IsValid() bool {
	switch e {
	case AdminTypeAdminUser, AdminTypeGroupMembership:
		return true
	}
	return false
}

func (e AdminType) String() string {
	return string(e)
}

func (e *AdminType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdminType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdminType", str)
	}
	return nil
}

func (e AdminType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AggregateOrdering string

const (
	AggregateOrderingCountAsc  AggregateOrdering = "count_ASC"
	AggregateOrderingCountDesc AggregateOrdering = "count_DESC"
	AggregateOrderingSumAsc    AggregateOrdering = "sum_ASC"
	AggregateOrderingSumDesc   AggregateOrdering = "sum_DESC"
	AggregateOrderingAvgAsc    AggregateOrdering = "avg_ASC"
	AggregateOrderingAvgDesc   AggregateOrdering = "avg_DESC"
	AggregateOrderingMinAsc    AggregateOrdering = "min_ASC"
	AggregateOrderingMinDesc   AggregateOrdering = "min_DESC"
	AggregateOrderingMaxAsc    AggregateOrdering = "max_ASC"
	AggregateOrderingMaxDesc   AggregateOrdering = "max_DESC"
)

var AllAggregateOrdering = []AggregateOrdering{
	AggregateOrderingCountAsc,
	AggregateOrderingCountDesc,
	AggregateOrderingSumAsc,
	AggregateOrderingSumDesc,
	AggregateOrderingAvgAsc,
	AggregateOrderingAvgDesc,
	AggregateOrderingMinAsc,
	AggregateOrderingMinDesc,
	AggregateOrderingMaxAsc,
	AggregateOrderingMaxDesc,
}

func (e AggregateOrdering) IsValid() bool {
	switch e {
	case AggregateOrderingCountAsc, AggregateOrderingCountDesc, AggregateOrderingSumAsc, AggregateOrderingSumDesc, AggregateOrderingAvgAsc, AggregateOrderingAvgDesc, AggregateOrderingMinAsc, AggregateOrderingMinDesc, AggregateOrderingMaxAsc, AggregateOrderingMaxDesc:
		return true
	}
	return false
}

func (e AggregateOrdering) String() string {
	return string(e)
}

func (e *AggregateOrdering) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AggregateOrdering(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AggregateOrdering", str)
	}
	return nil
}

func (e AggregateOrdering) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Architecture string

const (
	ArchitectureX86     Architecture = "X86"
	ArchitectureX64     Architecture = "X64"
	ArchitectureMips    Architecture = "MIPS"
	ArchitectureAlpha   Architecture = "ALPHA"
	ArchitectureArm     Architecture = "ARM"
	ArchitecturePowerPc Architecture = "POWER_PC"
	ArchitectureIa64    Architecture = "IA64"
)

var AllArchitecture = []Architecture{
	ArchitectureX86,
	ArchitectureX64,
	ArchitectureMips,
	ArchitectureAlpha,
	ArchitectureArm,
	ArchitecturePowerPc,
	ArchitectureIa64,
}

func (e Architecture) IsValid() bool {
	switch e {
	case ArchitectureX86, ArchitectureX64, ArchitectureMips, ArchitectureAlpha, ArchitectureArm, ArchitecturePowerPc, ArchitectureIa64:
		return true
	}
	return false
}

func (e Architecture) String() string {
	return string(e)
}

func (e *Architecture) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Architecture(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Architecture", str)
	}
	return nil
}

func (e Architecture) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CylanceDeviceState string

const (
	CylanceDeviceStateOnline  CylanceDeviceState = "ONLINE"
	CylanceDeviceStateOffline CylanceDeviceState = "OFFLINE"
)

var AllCylanceDeviceState = []CylanceDeviceState{
	CylanceDeviceStateOnline,
	CylanceDeviceStateOffline,
}

func (e CylanceDeviceState) IsValid() bool {
	switch e {
	case CylanceDeviceStateOnline, CylanceDeviceStateOffline:
		return true
	}
	return false
}

func (e CylanceDeviceState) String() string {
	return string(e)
}

func (e *CylanceDeviceState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CylanceDeviceState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CylanceDeviceState", str)
	}
	return nil
}

func (e CylanceDeviceState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Direction string

const (
	DirectionIngress Direction = "INGRESS"
	DirectionEgress  Direction = "EGRESS"
)

var AllDirection = []Direction{
	DirectionIngress,
	DirectionEgress,
}

func (e Direction) IsValid() bool {
	switch e {
	case DirectionIngress, DirectionEgress:
		return true
	}
	return false
}

func (e Direction) String() string {
	return string(e)
}

func (e *Direction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Direction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Direction", str)
	}
	return nil
}

func (e Direction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GCETagsAggregateColumns string

const (
	// groupBy by gceKey
	GCETagsAggregateColumnsGceKey GCETagsAggregateColumns = "gceKey"
	// groupBy by gceValue
	GCETagsAggregateColumnsGceValue GCETagsAggregateColumns = "gceValue"
)

var AllGCETagsAggregateColumns = []GCETagsAggregateColumns{
	GCETagsAggregateColumnsGceKey,
	GCETagsAggregateColumnsGceValue,
}

func (e GCETagsAggregateColumns) IsValid() bool {
	switch e {
	case GCETagsAggregateColumnsGceKey, GCETagsAggregateColumnsGceValue:
		return true
	}
	return false
}

func (e GCETagsAggregateColumns) String() string {
	return string(e)
}

func (e *GCETagsAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GCETagsAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GCETags_aggregate_columns", str)
	}
	return nil
}

func (e GCETagsAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GCETagsAggregateMaxColumns string

const (
	// max by gceKey
	GCETagsAggregateMaxColumnsGceKey GCETagsAggregateMaxColumns = "gceKey"
	// max by gceValue
	GCETagsAggregateMaxColumnsGceValue GCETagsAggregateMaxColumns = "gceValue"
)

var AllGCETagsAggregateMaxColumns = []GCETagsAggregateMaxColumns{
	GCETagsAggregateMaxColumnsGceKey,
	GCETagsAggregateMaxColumnsGceValue,
}

func (e GCETagsAggregateMaxColumns) IsValid() bool {
	switch e {
	case GCETagsAggregateMaxColumnsGceKey, GCETagsAggregateMaxColumnsGceValue:
		return true
	}
	return false
}

func (e GCETagsAggregateMaxColumns) String() string {
	return string(e)
}

func (e *GCETagsAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GCETagsAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GCETags_aggregate_max_columns", str)
	}
	return nil
}

func (e GCETagsAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GCETagsAggregateMinColumns string

const (
	// min by gceKey
	GCETagsAggregateMinColumnsGceKey GCETagsAggregateMinColumns = "gceKey"
	// min by gceValue
	GCETagsAggregateMinColumnsGceValue GCETagsAggregateMinColumns = "gceValue"
)

var AllGCETagsAggregateMinColumns = []GCETagsAggregateMinColumns{
	GCETagsAggregateMinColumnsGceKey,
	GCETagsAggregateMinColumnsGceValue,
}

func (e GCETagsAggregateMinColumns) IsValid() bool {
	switch e {
	case GCETagsAggregateMinColumnsGceKey, GCETagsAggregateMinColumnsGceValue:
		return true
	}
	return false
}

func (e GCETagsAggregateMinColumns) String() string {
	return string(e)
}

func (e *GCETagsAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GCETagsAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GCETags_aggregate_min_columns", str)
	}
	return nil
}

func (e GCETagsAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPFamily string

const (
	IPFamilyV4 IPFamily = "V4"
	IPFamilyV6 IPFamily = "V6"
)

var AllIPFamily = []IPFamily{
	IPFamilyV4,
	IPFamilyV6,
}

func (e IPFamily) IsValid() bool {
	switch e {
	case IPFamilyV4, IPFamilyV6:
		return true
	}
	return false
}

func (e IPFamily) String() string {
	return string(e)
}

func (e *IPFamily) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPFamily(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IPFamily", str)
	}
	return nil
}

func (e IPFamily) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OsTypes string

const (
	OsTypesWindows         OsTypes = "WINDOWS"
	OsTypesLinux           OsTypes = "LINUX"
	OsTypesOsX             OsTypes = "OS_X"
	OsTypesIos             OsTypes = "IOS"
	OsTypesAirOs           OsTypes = "AIR_OS"
	OsTypesAndroid         OsTypes = "ANDROID"
	OsTypesFreeBsd         OsTypes = "FREE_BSD"
	OsTypesVMWare          OsTypes = "VMWARE"
	OsTypesCisco           OsTypes = "CISCO"
	OsTypesMikrotik        OsTypes = "MIKROTIK"
	OsTypesVxworks         OsTypes = "VXWORKS"
	OsTypesF5NetworksBigIP OsTypes = "F5_NETWORKS_BIG_IP"
	OsTypesSolaris         OsTypes = "SOLARIS"
	OsTypesAix             OsTypes = "AIX"
	OsTypesPrinter         OsTypes = "PRINTER"
	OsTypesPlaystation     OsTypes = "PLAYSTATION"
	OsTypesCheckpoint      OsTypes = "CHECKPOINT"
	OsTypesArista          OsTypes = "ARISTA"
)

var AllOsTypes = []OsTypes{
	OsTypesWindows,
	OsTypesLinux,
	OsTypesOsX,
	OsTypesIos,
	OsTypesAirOs,
	OsTypesAndroid,
	OsTypesFreeBsd,
	OsTypesVMWare,
	OsTypesCisco,
	OsTypesMikrotik,
	OsTypesVxworks,
	OsTypesF5NetworksBigIP,
	OsTypesSolaris,
	OsTypesAix,
	OsTypesPrinter,
	OsTypesPlaystation,
	OsTypesCheckpoint,
	OsTypesArista,
}

func (e OsTypes) IsValid() bool {
	switch e {
	case OsTypesWindows, OsTypesLinux, OsTypesOsX, OsTypesIos, OsTypesAirOs, OsTypesAndroid, OsTypesFreeBsd, OsTypesVMWare, OsTypesCisco, OsTypesMikrotik, OsTypesVxworks, OsTypesF5NetworksBigIP, OsTypesSolaris, OsTypesAix, OsTypesPrinter, OsTypesPlaystation, OsTypesCheckpoint, OsTypesArista:
		return true
	}
	return false
}

func (e OsTypes) String() string {
	return string(e)
}

func (e *OsTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OsTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OsTypes", str)
	}
	return nil
}

func (e OsTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterDevicesAggregateAvgColumns string

const (
	// avg by fetchCycle
	AdapterDevicesAggregateAvgColumnsFetchCycle AdapterDevicesAggregateAvgColumns = "fetchCycle"
	// avg by fetchTime
	AdapterDevicesAggregateAvgColumnsFetchTime AdapterDevicesAggregateAvgColumns = "fetchTime"
	// avg by lastSeen
	AdapterDevicesAggregateAvgColumnsLastSeen AdapterDevicesAggregateAvgColumns = "lastSeen"
)

var AllAdapterDevicesAggregateAvgColumns = []AdapterDevicesAggregateAvgColumns{
	AdapterDevicesAggregateAvgColumnsFetchCycle,
	AdapterDevicesAggregateAvgColumnsFetchTime,
	AdapterDevicesAggregateAvgColumnsLastSeen,
}

func (e AdapterDevicesAggregateAvgColumns) IsValid() bool {
	switch e {
	case AdapterDevicesAggregateAvgColumnsFetchCycle, AdapterDevicesAggregateAvgColumnsFetchTime, AdapterDevicesAggregateAvgColumnsLastSeen:
		return true
	}
	return false
}

func (e AdapterDevicesAggregateAvgColumns) String() string {
	return string(e)
}

func (e *AdapterDevicesAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDevicesAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterDevices_aggregate_avg_columns", str)
	}
	return nil
}

func (e AdapterDevicesAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterDevicesAggregateColumns string

const (
	// groupBy by id
	AdapterDevicesAggregateColumnsID AdapterDevicesAggregateColumns = "id"
	// groupBy by fetchCycle
	AdapterDevicesAggregateColumnsFetchCycle AdapterDevicesAggregateColumns = "fetchCycle"
	// groupBy by adapterName
	AdapterDevicesAggregateColumnsAdapterName AdapterDevicesAggregateColumns = "adapterName"
	// groupBy by deviceId
	AdapterDevicesAggregateColumnsDeviceID AdapterDevicesAggregateColumns = "deviceId"
	// groupBy by fetchTime
	AdapterDevicesAggregateColumnsFetchTime AdapterDevicesAggregateColumns = "fetchTime"
	// groupBy by hostname
	AdapterDevicesAggregateColumnsHostname AdapterDevicesAggregateColumns = "hostname"
	// groupBy by name
	AdapterDevicesAggregateColumnsName AdapterDevicesAggregateColumns = "name"
	// groupBy by lastSeen
	AdapterDevicesAggregateColumnsLastSeen AdapterDevicesAggregateColumns = "lastSeen"
	// groupBy by osId
	AdapterDevicesAggregateColumnsOsID AdapterDevicesAggregateColumns = "osId"
	// groupBy by prettyId
	AdapterDevicesAggregateColumnsPrettyID AdapterDevicesAggregateColumns = "prettyId"
	// groupBy by domain
	AdapterDevicesAggregateColumnsDomain AdapterDevicesAggregateColumns = "domain"
	// groupBy by agentVersion
	AdapterDevicesAggregateColumnsAgentVersion AdapterDevicesAggregateColumns = "agentVersion"
	// groupBy by agentStatus
	AdapterDevicesAggregateColumnsAgentStatus AdapterDevicesAggregateColumns = "agentStatus"
	// groupBy by agentName
	AdapterDevicesAggregateColumnsAgentName AdapterDevicesAggregateColumns = "agentName"
	// groupBy by model
	AdapterDevicesAggregateColumnsModel AdapterDevicesAggregateColumns = "model"
	// groupBy by manufacturer
	AdapterDevicesAggregateColumnsManufacturer AdapterDevicesAggregateColumns = "manufacturer"
	// groupBy by serial
	AdapterDevicesAggregateColumnsSerial AdapterDevicesAggregateColumns = "serial"
	// groupBy by family
	AdapterDevicesAggregateColumnsFamily AdapterDevicesAggregateColumns = "family"
	// groupBy by biosVersion
	AdapterDevicesAggregateColumnsBiosVersion AdapterDevicesAggregateColumns = "biosVersion"
	// groupBy by biosSerial
	AdapterDevicesAggregateColumnsBiosSerial AdapterDevicesAggregateColumns = "biosSerial"
)

var AllAdapterDevicesAggregateColumns = []AdapterDevicesAggregateColumns{
	AdapterDevicesAggregateColumnsID,
	AdapterDevicesAggregateColumnsFetchCycle,
	AdapterDevicesAggregateColumnsAdapterName,
	AdapterDevicesAggregateColumnsDeviceID,
	AdapterDevicesAggregateColumnsFetchTime,
	AdapterDevicesAggregateColumnsHostname,
	AdapterDevicesAggregateColumnsName,
	AdapterDevicesAggregateColumnsLastSeen,
	AdapterDevicesAggregateColumnsOsID,
	AdapterDevicesAggregateColumnsPrettyID,
	AdapterDevicesAggregateColumnsDomain,
	AdapterDevicesAggregateColumnsAgentVersion,
	AdapterDevicesAggregateColumnsAgentStatus,
	AdapterDevicesAggregateColumnsAgentName,
	AdapterDevicesAggregateColumnsModel,
	AdapterDevicesAggregateColumnsManufacturer,
	AdapterDevicesAggregateColumnsSerial,
	AdapterDevicesAggregateColumnsFamily,
	AdapterDevicesAggregateColumnsBiosVersion,
	AdapterDevicesAggregateColumnsBiosSerial,
}

func (e AdapterDevicesAggregateColumns) IsValid() bool {
	switch e {
	case AdapterDevicesAggregateColumnsID, AdapterDevicesAggregateColumnsFetchCycle, AdapterDevicesAggregateColumnsAdapterName, AdapterDevicesAggregateColumnsDeviceID, AdapterDevicesAggregateColumnsFetchTime, AdapterDevicesAggregateColumnsHostname, AdapterDevicesAggregateColumnsName, AdapterDevicesAggregateColumnsLastSeen, AdapterDevicesAggregateColumnsOsID, AdapterDevicesAggregateColumnsPrettyID, AdapterDevicesAggregateColumnsDomain, AdapterDevicesAggregateColumnsAgentVersion, AdapterDevicesAggregateColumnsAgentStatus, AdapterDevicesAggregateColumnsAgentName, AdapterDevicesAggregateColumnsModel, AdapterDevicesAggregateColumnsManufacturer, AdapterDevicesAggregateColumnsSerial, AdapterDevicesAggregateColumnsFamily, AdapterDevicesAggregateColumnsBiosVersion, AdapterDevicesAggregateColumnsBiosSerial:
		return true
	}
	return false
}

func (e AdapterDevicesAggregateColumns) String() string {
	return string(e)
}

func (e *AdapterDevicesAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDevicesAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterDevices_aggregate_columns", str)
	}
	return nil
}

func (e AdapterDevicesAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterDevicesAggregateMaxColumns string

const (
	// max by id
	AdapterDevicesAggregateMaxColumnsID AdapterDevicesAggregateMaxColumns = "id"
	// max by fetchCycle
	AdapterDevicesAggregateMaxColumnsFetchCycle AdapterDevicesAggregateMaxColumns = "fetchCycle"
	// max by adapterName
	AdapterDevicesAggregateMaxColumnsAdapterName AdapterDevicesAggregateMaxColumns = "adapterName"
	// max by deviceId
	AdapterDevicesAggregateMaxColumnsDeviceID AdapterDevicesAggregateMaxColumns = "deviceId"
	// max by fetchTime
	AdapterDevicesAggregateMaxColumnsFetchTime AdapterDevicesAggregateMaxColumns = "fetchTime"
	// max by hostname
	AdapterDevicesAggregateMaxColumnsHostname AdapterDevicesAggregateMaxColumns = "hostname"
	// max by name
	AdapterDevicesAggregateMaxColumnsName AdapterDevicesAggregateMaxColumns = "name"
	// max by lastSeen
	AdapterDevicesAggregateMaxColumnsLastSeen AdapterDevicesAggregateMaxColumns = "lastSeen"
	// max by osId
	AdapterDevicesAggregateMaxColumnsOsID AdapterDevicesAggregateMaxColumns = "osId"
	// max by prettyId
	AdapterDevicesAggregateMaxColumnsPrettyID AdapterDevicesAggregateMaxColumns = "prettyId"
	// max by domain
	AdapterDevicesAggregateMaxColumnsDomain AdapterDevicesAggregateMaxColumns = "domain"
	// max by agentVersion
	AdapterDevicesAggregateMaxColumnsAgentVersion AdapterDevicesAggregateMaxColumns = "agentVersion"
	// max by agentStatus
	AdapterDevicesAggregateMaxColumnsAgentStatus AdapterDevicesAggregateMaxColumns = "agentStatus"
	// max by agentName
	AdapterDevicesAggregateMaxColumnsAgentName AdapterDevicesAggregateMaxColumns = "agentName"
	// max by model
	AdapterDevicesAggregateMaxColumnsModel AdapterDevicesAggregateMaxColumns = "model"
	// max by manufacturer
	AdapterDevicesAggregateMaxColumnsManufacturer AdapterDevicesAggregateMaxColumns = "manufacturer"
	// max by serial
	AdapterDevicesAggregateMaxColumnsSerial AdapterDevicesAggregateMaxColumns = "serial"
	// max by family
	AdapterDevicesAggregateMaxColumnsFamily AdapterDevicesAggregateMaxColumns = "family"
	// max by biosVersion
	AdapterDevicesAggregateMaxColumnsBiosVersion AdapterDevicesAggregateMaxColumns = "biosVersion"
	// max by biosSerial
	AdapterDevicesAggregateMaxColumnsBiosSerial AdapterDevicesAggregateMaxColumns = "biosSerial"
)

var AllAdapterDevicesAggregateMaxColumns = []AdapterDevicesAggregateMaxColumns{
	AdapterDevicesAggregateMaxColumnsID,
	AdapterDevicesAggregateMaxColumnsFetchCycle,
	AdapterDevicesAggregateMaxColumnsAdapterName,
	AdapterDevicesAggregateMaxColumnsDeviceID,
	AdapterDevicesAggregateMaxColumnsFetchTime,
	AdapterDevicesAggregateMaxColumnsHostname,
	AdapterDevicesAggregateMaxColumnsName,
	AdapterDevicesAggregateMaxColumnsLastSeen,
	AdapterDevicesAggregateMaxColumnsOsID,
	AdapterDevicesAggregateMaxColumnsPrettyID,
	AdapterDevicesAggregateMaxColumnsDomain,
	AdapterDevicesAggregateMaxColumnsAgentVersion,
	AdapterDevicesAggregateMaxColumnsAgentStatus,
	AdapterDevicesAggregateMaxColumnsAgentName,
	AdapterDevicesAggregateMaxColumnsModel,
	AdapterDevicesAggregateMaxColumnsManufacturer,
	AdapterDevicesAggregateMaxColumnsSerial,
	AdapterDevicesAggregateMaxColumnsFamily,
	AdapterDevicesAggregateMaxColumnsBiosVersion,
	AdapterDevicesAggregateMaxColumnsBiosSerial,
}

func (e AdapterDevicesAggregateMaxColumns) IsValid() bool {
	switch e {
	case AdapterDevicesAggregateMaxColumnsID, AdapterDevicesAggregateMaxColumnsFetchCycle, AdapterDevicesAggregateMaxColumnsAdapterName, AdapterDevicesAggregateMaxColumnsDeviceID, AdapterDevicesAggregateMaxColumnsFetchTime, AdapterDevicesAggregateMaxColumnsHostname, AdapterDevicesAggregateMaxColumnsName, AdapterDevicesAggregateMaxColumnsLastSeen, AdapterDevicesAggregateMaxColumnsOsID, AdapterDevicesAggregateMaxColumnsPrettyID, AdapterDevicesAggregateMaxColumnsDomain, AdapterDevicesAggregateMaxColumnsAgentVersion, AdapterDevicesAggregateMaxColumnsAgentStatus, AdapterDevicesAggregateMaxColumnsAgentName, AdapterDevicesAggregateMaxColumnsModel, AdapterDevicesAggregateMaxColumnsManufacturer, AdapterDevicesAggregateMaxColumnsSerial, AdapterDevicesAggregateMaxColumnsFamily, AdapterDevicesAggregateMaxColumnsBiosVersion, AdapterDevicesAggregateMaxColumnsBiosSerial:
		return true
	}
	return false
}

func (e AdapterDevicesAggregateMaxColumns) String() string {
	return string(e)
}

func (e *AdapterDevicesAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDevicesAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterDevices_aggregate_max_columns", str)
	}
	return nil
}

func (e AdapterDevicesAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterDevicesAggregateMinColumns string

const (
	// min by id
	AdapterDevicesAggregateMinColumnsID AdapterDevicesAggregateMinColumns = "id"
	// min by fetchCycle
	AdapterDevicesAggregateMinColumnsFetchCycle AdapterDevicesAggregateMinColumns = "fetchCycle"
	// min by adapterName
	AdapterDevicesAggregateMinColumnsAdapterName AdapterDevicesAggregateMinColumns = "adapterName"
	// min by deviceId
	AdapterDevicesAggregateMinColumnsDeviceID AdapterDevicesAggregateMinColumns = "deviceId"
	// min by fetchTime
	AdapterDevicesAggregateMinColumnsFetchTime AdapterDevicesAggregateMinColumns = "fetchTime"
	// min by hostname
	AdapterDevicesAggregateMinColumnsHostname AdapterDevicesAggregateMinColumns = "hostname"
	// min by name
	AdapterDevicesAggregateMinColumnsName AdapterDevicesAggregateMinColumns = "name"
	// min by lastSeen
	AdapterDevicesAggregateMinColumnsLastSeen AdapterDevicesAggregateMinColumns = "lastSeen"
	// min by osId
	AdapterDevicesAggregateMinColumnsOsID AdapterDevicesAggregateMinColumns = "osId"
	// min by prettyId
	AdapterDevicesAggregateMinColumnsPrettyID AdapterDevicesAggregateMinColumns = "prettyId"
	// min by domain
	AdapterDevicesAggregateMinColumnsDomain AdapterDevicesAggregateMinColumns = "domain"
	// min by agentVersion
	AdapterDevicesAggregateMinColumnsAgentVersion AdapterDevicesAggregateMinColumns = "agentVersion"
	// min by agentStatus
	AdapterDevicesAggregateMinColumnsAgentStatus AdapterDevicesAggregateMinColumns = "agentStatus"
	// min by agentName
	AdapterDevicesAggregateMinColumnsAgentName AdapterDevicesAggregateMinColumns = "agentName"
	// min by model
	AdapterDevicesAggregateMinColumnsModel AdapterDevicesAggregateMinColumns = "model"
	// min by manufacturer
	AdapterDevicesAggregateMinColumnsManufacturer AdapterDevicesAggregateMinColumns = "manufacturer"
	// min by serial
	AdapterDevicesAggregateMinColumnsSerial AdapterDevicesAggregateMinColumns = "serial"
	// min by family
	AdapterDevicesAggregateMinColumnsFamily AdapterDevicesAggregateMinColumns = "family"
	// min by biosVersion
	AdapterDevicesAggregateMinColumnsBiosVersion AdapterDevicesAggregateMinColumns = "biosVersion"
	// min by biosSerial
	AdapterDevicesAggregateMinColumnsBiosSerial AdapterDevicesAggregateMinColumns = "biosSerial"
)

var AllAdapterDevicesAggregateMinColumns = []AdapterDevicesAggregateMinColumns{
	AdapterDevicesAggregateMinColumnsID,
	AdapterDevicesAggregateMinColumnsFetchCycle,
	AdapterDevicesAggregateMinColumnsAdapterName,
	AdapterDevicesAggregateMinColumnsDeviceID,
	AdapterDevicesAggregateMinColumnsFetchTime,
	AdapterDevicesAggregateMinColumnsHostname,
	AdapterDevicesAggregateMinColumnsName,
	AdapterDevicesAggregateMinColumnsLastSeen,
	AdapterDevicesAggregateMinColumnsOsID,
	AdapterDevicesAggregateMinColumnsPrettyID,
	AdapterDevicesAggregateMinColumnsDomain,
	AdapterDevicesAggregateMinColumnsAgentVersion,
	AdapterDevicesAggregateMinColumnsAgentStatus,
	AdapterDevicesAggregateMinColumnsAgentName,
	AdapterDevicesAggregateMinColumnsModel,
	AdapterDevicesAggregateMinColumnsManufacturer,
	AdapterDevicesAggregateMinColumnsSerial,
	AdapterDevicesAggregateMinColumnsFamily,
	AdapterDevicesAggregateMinColumnsBiosVersion,
	AdapterDevicesAggregateMinColumnsBiosSerial,
}

func (e AdapterDevicesAggregateMinColumns) IsValid() bool {
	switch e {
	case AdapterDevicesAggregateMinColumnsID, AdapterDevicesAggregateMinColumnsFetchCycle, AdapterDevicesAggregateMinColumnsAdapterName, AdapterDevicesAggregateMinColumnsDeviceID, AdapterDevicesAggregateMinColumnsFetchTime, AdapterDevicesAggregateMinColumnsHostname, AdapterDevicesAggregateMinColumnsName, AdapterDevicesAggregateMinColumnsLastSeen, AdapterDevicesAggregateMinColumnsOsID, AdapterDevicesAggregateMinColumnsPrettyID, AdapterDevicesAggregateMinColumnsDomain, AdapterDevicesAggregateMinColumnsAgentVersion, AdapterDevicesAggregateMinColumnsAgentStatus, AdapterDevicesAggregateMinColumnsAgentName, AdapterDevicesAggregateMinColumnsModel, AdapterDevicesAggregateMinColumnsManufacturer, AdapterDevicesAggregateMinColumnsSerial, AdapterDevicesAggregateMinColumnsFamily, AdapterDevicesAggregateMinColumnsBiosVersion, AdapterDevicesAggregateMinColumnsBiosSerial:
		return true
	}
	return false
}

func (e AdapterDevicesAggregateMinColumns) String() string {
	return string(e)
}

func (e *AdapterDevicesAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDevicesAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterDevices_aggregate_min_columns", str)
	}
	return nil
}

func (e AdapterDevicesAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterDevicesAggregateSumColumns string

const (
	// sum by fetchCycle
	AdapterDevicesAggregateSumColumnsFetchCycle AdapterDevicesAggregateSumColumns = "fetchCycle"
	// sum by fetchTime
	AdapterDevicesAggregateSumColumnsFetchTime AdapterDevicesAggregateSumColumns = "fetchTime"
	// sum by lastSeen
	AdapterDevicesAggregateSumColumnsLastSeen AdapterDevicesAggregateSumColumns = "lastSeen"
)

var AllAdapterDevicesAggregateSumColumns = []AdapterDevicesAggregateSumColumns{
	AdapterDevicesAggregateSumColumnsFetchCycle,
	AdapterDevicesAggregateSumColumnsFetchTime,
	AdapterDevicesAggregateSumColumnsLastSeen,
}

func (e AdapterDevicesAggregateSumColumns) IsValid() bool {
	switch e {
	case AdapterDevicesAggregateSumColumnsFetchCycle, AdapterDevicesAggregateSumColumnsFetchTime, AdapterDevicesAggregateSumColumnsLastSeen:
		return true
	}
	return false
}

func (e AdapterDevicesAggregateSumColumns) String() string {
	return string(e)
}

func (e *AdapterDevicesAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDevicesAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterDevices_aggregate_sum_columns", str)
	}
	return nil
}

func (e AdapterDevicesAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterUsersAggregateAvgColumns string

const (
	// avg by fetchCycle
	AdapterUsersAggregateAvgColumnsFetchCycle AdapterUsersAggregateAvgColumns = "fetchCycle"
	// avg by fetchTime
	AdapterUsersAggregateAvgColumnsFetchTime AdapterUsersAggregateAvgColumns = "fetchTime"
	// avg by lastSeen
	AdapterUsersAggregateAvgColumnsLastSeen AdapterUsersAggregateAvgColumns = "lastSeen"
)

var AllAdapterUsersAggregateAvgColumns = []AdapterUsersAggregateAvgColumns{
	AdapterUsersAggregateAvgColumnsFetchCycle,
	AdapterUsersAggregateAvgColumnsFetchTime,
	AdapterUsersAggregateAvgColumnsLastSeen,
}

func (e AdapterUsersAggregateAvgColumns) IsValid() bool {
	switch e {
	case AdapterUsersAggregateAvgColumnsFetchCycle, AdapterUsersAggregateAvgColumnsFetchTime, AdapterUsersAggregateAvgColumnsLastSeen:
		return true
	}
	return false
}

func (e AdapterUsersAggregateAvgColumns) String() string {
	return string(e)
}

func (e *AdapterUsersAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUsersAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterUsers_aggregate_avg_columns", str)
	}
	return nil
}

func (e AdapterUsersAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterUsersAggregateColumns string

const (
	// groupBy by id
	AdapterUsersAggregateColumnsID AdapterUsersAggregateColumns = "id"
	// groupBy by fetchCycle
	AdapterUsersAggregateColumnsFetchCycle AdapterUsersAggregateColumns = "fetchCycle"
	// groupBy by adapterName
	AdapterUsersAggregateColumnsAdapterName AdapterUsersAggregateColumns = "adapterName"
	// groupBy by userId
	AdapterUsersAggregateColumnsUserID AdapterUsersAggregateColumns = "userId"
	// groupBy by fetchTime
	AdapterUsersAggregateColumnsFetchTime AdapterUsersAggregateColumns = "fetchTime"
	// groupBy by lastSeen
	AdapterUsersAggregateColumnsLastSeen AdapterUsersAggregateColumns = "lastSeen"
	// groupBy by username
	AdapterUsersAggregateColumnsUsername AdapterUsersAggregateColumns = "username"
	// groupBy by firstName
	AdapterUsersAggregateColumnsFirstName AdapterUsersAggregateColumns = "firstName"
	// groupBy by lastName
	AdapterUsersAggregateColumnsLastName AdapterUsersAggregateColumns = "lastName"
	// groupBy by mail
	AdapterUsersAggregateColumnsMail AdapterUsersAggregateColumns = "mail"
)

var AllAdapterUsersAggregateColumns = []AdapterUsersAggregateColumns{
	AdapterUsersAggregateColumnsID,
	AdapterUsersAggregateColumnsFetchCycle,
	AdapterUsersAggregateColumnsAdapterName,
	AdapterUsersAggregateColumnsUserID,
	AdapterUsersAggregateColumnsFetchTime,
	AdapterUsersAggregateColumnsLastSeen,
	AdapterUsersAggregateColumnsUsername,
	AdapterUsersAggregateColumnsFirstName,
	AdapterUsersAggregateColumnsLastName,
	AdapterUsersAggregateColumnsMail,
}

func (e AdapterUsersAggregateColumns) IsValid() bool {
	switch e {
	case AdapterUsersAggregateColumnsID, AdapterUsersAggregateColumnsFetchCycle, AdapterUsersAggregateColumnsAdapterName, AdapterUsersAggregateColumnsUserID, AdapterUsersAggregateColumnsFetchTime, AdapterUsersAggregateColumnsLastSeen, AdapterUsersAggregateColumnsUsername, AdapterUsersAggregateColumnsFirstName, AdapterUsersAggregateColumnsLastName, AdapterUsersAggregateColumnsMail:
		return true
	}
	return false
}

func (e AdapterUsersAggregateColumns) String() string {
	return string(e)
}

func (e *AdapterUsersAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUsersAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterUsers_aggregate_columns", str)
	}
	return nil
}

func (e AdapterUsersAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterUsersAggregateMaxColumns string

const (
	// max by id
	AdapterUsersAggregateMaxColumnsID AdapterUsersAggregateMaxColumns = "id"
	// max by fetchCycle
	AdapterUsersAggregateMaxColumnsFetchCycle AdapterUsersAggregateMaxColumns = "fetchCycle"
	// max by adapterName
	AdapterUsersAggregateMaxColumnsAdapterName AdapterUsersAggregateMaxColumns = "adapterName"
	// max by userId
	AdapterUsersAggregateMaxColumnsUserID AdapterUsersAggregateMaxColumns = "userId"
	// max by fetchTime
	AdapterUsersAggregateMaxColumnsFetchTime AdapterUsersAggregateMaxColumns = "fetchTime"
	// max by lastSeen
	AdapterUsersAggregateMaxColumnsLastSeen AdapterUsersAggregateMaxColumns = "lastSeen"
	// max by username
	AdapterUsersAggregateMaxColumnsUsername AdapterUsersAggregateMaxColumns = "username"
	// max by firstName
	AdapterUsersAggregateMaxColumnsFirstName AdapterUsersAggregateMaxColumns = "firstName"
	// max by lastName
	AdapterUsersAggregateMaxColumnsLastName AdapterUsersAggregateMaxColumns = "lastName"
	// max by mail
	AdapterUsersAggregateMaxColumnsMail AdapterUsersAggregateMaxColumns = "mail"
)

var AllAdapterUsersAggregateMaxColumns = []AdapterUsersAggregateMaxColumns{
	AdapterUsersAggregateMaxColumnsID,
	AdapterUsersAggregateMaxColumnsFetchCycle,
	AdapterUsersAggregateMaxColumnsAdapterName,
	AdapterUsersAggregateMaxColumnsUserID,
	AdapterUsersAggregateMaxColumnsFetchTime,
	AdapterUsersAggregateMaxColumnsLastSeen,
	AdapterUsersAggregateMaxColumnsUsername,
	AdapterUsersAggregateMaxColumnsFirstName,
	AdapterUsersAggregateMaxColumnsLastName,
	AdapterUsersAggregateMaxColumnsMail,
}

func (e AdapterUsersAggregateMaxColumns) IsValid() bool {
	switch e {
	case AdapterUsersAggregateMaxColumnsID, AdapterUsersAggregateMaxColumnsFetchCycle, AdapterUsersAggregateMaxColumnsAdapterName, AdapterUsersAggregateMaxColumnsUserID, AdapterUsersAggregateMaxColumnsFetchTime, AdapterUsersAggregateMaxColumnsLastSeen, AdapterUsersAggregateMaxColumnsUsername, AdapterUsersAggregateMaxColumnsFirstName, AdapterUsersAggregateMaxColumnsLastName, AdapterUsersAggregateMaxColumnsMail:
		return true
	}
	return false
}

func (e AdapterUsersAggregateMaxColumns) String() string {
	return string(e)
}

func (e *AdapterUsersAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUsersAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterUsers_aggregate_max_columns", str)
	}
	return nil
}

func (e AdapterUsersAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterUsersAggregateMinColumns string

const (
	// min by id
	AdapterUsersAggregateMinColumnsID AdapterUsersAggregateMinColumns = "id"
	// min by fetchCycle
	AdapterUsersAggregateMinColumnsFetchCycle AdapterUsersAggregateMinColumns = "fetchCycle"
	// min by adapterName
	AdapterUsersAggregateMinColumnsAdapterName AdapterUsersAggregateMinColumns = "adapterName"
	// min by userId
	AdapterUsersAggregateMinColumnsUserID AdapterUsersAggregateMinColumns = "userId"
	// min by fetchTime
	AdapterUsersAggregateMinColumnsFetchTime AdapterUsersAggregateMinColumns = "fetchTime"
	// min by lastSeen
	AdapterUsersAggregateMinColumnsLastSeen AdapterUsersAggregateMinColumns = "lastSeen"
	// min by username
	AdapterUsersAggregateMinColumnsUsername AdapterUsersAggregateMinColumns = "username"
	// min by firstName
	AdapterUsersAggregateMinColumnsFirstName AdapterUsersAggregateMinColumns = "firstName"
	// min by lastName
	AdapterUsersAggregateMinColumnsLastName AdapterUsersAggregateMinColumns = "lastName"
	// min by mail
	AdapterUsersAggregateMinColumnsMail AdapterUsersAggregateMinColumns = "mail"
)

var AllAdapterUsersAggregateMinColumns = []AdapterUsersAggregateMinColumns{
	AdapterUsersAggregateMinColumnsID,
	AdapterUsersAggregateMinColumnsFetchCycle,
	AdapterUsersAggregateMinColumnsAdapterName,
	AdapterUsersAggregateMinColumnsUserID,
	AdapterUsersAggregateMinColumnsFetchTime,
	AdapterUsersAggregateMinColumnsLastSeen,
	AdapterUsersAggregateMinColumnsUsername,
	AdapterUsersAggregateMinColumnsFirstName,
	AdapterUsersAggregateMinColumnsLastName,
	AdapterUsersAggregateMinColumnsMail,
}

func (e AdapterUsersAggregateMinColumns) IsValid() bool {
	switch e {
	case AdapterUsersAggregateMinColumnsID, AdapterUsersAggregateMinColumnsFetchCycle, AdapterUsersAggregateMinColumnsAdapterName, AdapterUsersAggregateMinColumnsUserID, AdapterUsersAggregateMinColumnsFetchTime, AdapterUsersAggregateMinColumnsLastSeen, AdapterUsersAggregateMinColumnsUsername, AdapterUsersAggregateMinColumnsFirstName, AdapterUsersAggregateMinColumnsLastName, AdapterUsersAggregateMinColumnsMail:
		return true
	}
	return false
}

func (e AdapterUsersAggregateMinColumns) String() string {
	return string(e)
}

func (e *AdapterUsersAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUsersAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterUsers_aggregate_min_columns", str)
	}
	return nil
}

func (e AdapterUsersAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdapterUsersAggregateSumColumns string

const (
	// sum by fetchCycle
	AdapterUsersAggregateSumColumnsFetchCycle AdapterUsersAggregateSumColumns = "fetchCycle"
	// sum by fetchTime
	AdapterUsersAggregateSumColumnsFetchTime AdapterUsersAggregateSumColumns = "fetchTime"
	// sum by lastSeen
	AdapterUsersAggregateSumColumnsLastSeen AdapterUsersAggregateSumColumns = "lastSeen"
)

var AllAdapterUsersAggregateSumColumns = []AdapterUsersAggregateSumColumns{
	AdapterUsersAggregateSumColumnsFetchCycle,
	AdapterUsersAggregateSumColumnsFetchTime,
	AdapterUsersAggregateSumColumnsLastSeen,
}

func (e AdapterUsersAggregateSumColumns) IsValid() bool {
	switch e {
	case AdapterUsersAggregateSumColumnsFetchCycle, AdapterUsersAggregateSumColumnsFetchTime, AdapterUsersAggregateSumColumnsLastSeen:
		return true
	}
	return false
}

func (e AdapterUsersAggregateSumColumns) String() string {
	return string(e)
}

func (e *AdapterUsersAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUsersAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapterUsers_aggregate_sum_columns", str)
	}
	return nil
}

func (e AdapterUsersAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for AdapterDeviceAdmin
type AdapterDeviceAdminOrderBy string

const (
	// Order by name in an ascending order
	AdapterDeviceAdminOrderByNameAsc AdapterDeviceAdminOrderBy = "name_ASC"
	// Order by name in a descending order
	AdapterDeviceAdminOrderByNameDesc AdapterDeviceAdminOrderBy = "name_DESC"
)

var AllAdapterDeviceAdminOrderBy = []AdapterDeviceAdminOrderBy{
	AdapterDeviceAdminOrderByNameAsc,
	AdapterDeviceAdminOrderByNameDesc,
}

func (e AdapterDeviceAdminOrderBy) IsValid() bool {
	switch e {
	case AdapterDeviceAdminOrderByNameAsc, AdapterDeviceAdminOrderByNameDesc:
		return true
	}
	return false
}

func (e AdapterDeviceAdminOrderBy) String() string {
	return string(e)
}

func (e *AdapterDeviceAdminOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDeviceAdminOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapter_device_admin_order_by", str)
	}
	return nil
}

func (e AdapterDeviceAdminOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for AdapterDevice
type AdapterDeviceOrderBy string

const (
	// Order by fetchCycle in an ascending order
	AdapterDeviceOrderByFetchCycleAsc AdapterDeviceOrderBy = "fetchCycle_ASC"
	// Order by fetchCycle in a descending order
	AdapterDeviceOrderByFetchCycleDesc AdapterDeviceOrderBy = "fetchCycle_DESC"
	// Order by adapterName in an ascending order
	AdapterDeviceOrderByAdapterNameAsc AdapterDeviceOrderBy = "adapterName_ASC"
	// Order by adapterName in a descending order
	AdapterDeviceOrderByAdapterNameDesc AdapterDeviceOrderBy = "adapterName_DESC"
	// Order by fetchTime in an ascending order
	AdapterDeviceOrderByFetchTimeAsc AdapterDeviceOrderBy = "fetchTime_ASC"
	// Order by fetchTime in a descending order
	AdapterDeviceOrderByFetchTimeDesc AdapterDeviceOrderBy = "fetchTime_DESC"
	// Order by hostname in an ascending order
	AdapterDeviceOrderByHostnameAsc AdapterDeviceOrderBy = "hostname_ASC"
	// Order by hostname in a descending order
	AdapterDeviceOrderByHostnameDesc AdapterDeviceOrderBy = "hostname_DESC"
	// Order by name in an ascending order
	AdapterDeviceOrderByNameAsc AdapterDeviceOrderBy = "name_ASC"
	// Order by name in a descending order
	AdapterDeviceOrderByNameDesc AdapterDeviceOrderBy = "name_DESC"
	// Order by lastSeen in an ascending order
	AdapterDeviceOrderByLastSeenAsc AdapterDeviceOrderBy = "lastSeen_ASC"
	// Order by lastSeen in a descending order
	AdapterDeviceOrderByLastSeenDesc AdapterDeviceOrderBy = "lastSeen_DESC"
	// Order by prettyId in an ascending order
	AdapterDeviceOrderByPrettyIDAsc AdapterDeviceOrderBy = "prettyId_ASC"
	// Order by prettyId in a descending order
	AdapterDeviceOrderByPrettyIDDesc AdapterDeviceOrderBy = "prettyId_DESC"
	// Order by domain in an ascending order
	AdapterDeviceOrderByDomainAsc AdapterDeviceOrderBy = "domain_ASC"
	// Order by domain in a descending order
	AdapterDeviceOrderByDomainDesc AdapterDeviceOrderBy = "domain_DESC"
	// Order by agentVersion in an ascending order
	AdapterDeviceOrderByAgentVersionAsc AdapterDeviceOrderBy = "agentVersion_ASC"
	// Order by agentVersion in a descending order
	AdapterDeviceOrderByAgentVersionDesc AdapterDeviceOrderBy = "agentVersion_DESC"
	// Order by agentStatus in an ascending order
	AdapterDeviceOrderByAgentStatusAsc AdapterDeviceOrderBy = "agentStatus_ASC"
	// Order by agentStatus in a descending order
	AdapterDeviceOrderByAgentStatusDesc AdapterDeviceOrderBy = "agentStatus_DESC"
	// Order by agentName in an ascending order
	AdapterDeviceOrderByAgentNameAsc AdapterDeviceOrderBy = "agentName_ASC"
	// Order by agentName in a descending order
	AdapterDeviceOrderByAgentNameDesc AdapterDeviceOrderBy = "agentName_DESC"
	// Order by model in an ascending order
	AdapterDeviceOrderByModelAsc AdapterDeviceOrderBy = "model_ASC"
	// Order by model in a descending order
	AdapterDeviceOrderByModelDesc AdapterDeviceOrderBy = "model_DESC"
	// Order by manufacturer in an ascending order
	AdapterDeviceOrderByManufacturerAsc AdapterDeviceOrderBy = "manufacturer_ASC"
	// Order by manufacturer in a descending order
	AdapterDeviceOrderByManufacturerDesc AdapterDeviceOrderBy = "manufacturer_DESC"
	// Order by serial in an ascending order
	AdapterDeviceOrderBySerialAsc AdapterDeviceOrderBy = "serial_ASC"
	// Order by serial in a descending order
	AdapterDeviceOrderBySerialDesc AdapterDeviceOrderBy = "serial_DESC"
	// Order by family in an ascending order
	AdapterDeviceOrderByFamilyAsc AdapterDeviceOrderBy = "family_ASC"
	// Order by family in a descending order
	AdapterDeviceOrderByFamilyDesc AdapterDeviceOrderBy = "family_DESC"
	// Order by biosVersion in an ascending order
	AdapterDeviceOrderByBiosVersionAsc AdapterDeviceOrderBy = "biosVersion_ASC"
	// Order by biosVersion in a descending order
	AdapterDeviceOrderByBiosVersionDesc AdapterDeviceOrderBy = "biosVersion_DESC"
	// Order by biosSerial in an ascending order
	AdapterDeviceOrderByBiosSerialAsc AdapterDeviceOrderBy = "biosSerial_ASC"
	// Order by biosSerial in a descending order
	AdapterDeviceOrderByBiosSerialDesc AdapterDeviceOrderBy = "biosSerial_DESC"
)

var AllAdapterDeviceOrderBy = []AdapterDeviceOrderBy{
	AdapterDeviceOrderByFetchCycleAsc,
	AdapterDeviceOrderByFetchCycleDesc,
	AdapterDeviceOrderByAdapterNameAsc,
	AdapterDeviceOrderByAdapterNameDesc,
	AdapterDeviceOrderByFetchTimeAsc,
	AdapterDeviceOrderByFetchTimeDesc,
	AdapterDeviceOrderByHostnameAsc,
	AdapterDeviceOrderByHostnameDesc,
	AdapterDeviceOrderByNameAsc,
	AdapterDeviceOrderByNameDesc,
	AdapterDeviceOrderByLastSeenAsc,
	AdapterDeviceOrderByLastSeenDesc,
	AdapterDeviceOrderByPrettyIDAsc,
	AdapterDeviceOrderByPrettyIDDesc,
	AdapterDeviceOrderByDomainAsc,
	AdapterDeviceOrderByDomainDesc,
	AdapterDeviceOrderByAgentVersionAsc,
	AdapterDeviceOrderByAgentVersionDesc,
	AdapterDeviceOrderByAgentStatusAsc,
	AdapterDeviceOrderByAgentStatusDesc,
	AdapterDeviceOrderByAgentNameAsc,
	AdapterDeviceOrderByAgentNameDesc,
	AdapterDeviceOrderByModelAsc,
	AdapterDeviceOrderByModelDesc,
	AdapterDeviceOrderByManufacturerAsc,
	AdapterDeviceOrderByManufacturerDesc,
	AdapterDeviceOrderBySerialAsc,
	AdapterDeviceOrderBySerialDesc,
	AdapterDeviceOrderByFamilyAsc,
	AdapterDeviceOrderByFamilyDesc,
	AdapterDeviceOrderByBiosVersionAsc,
	AdapterDeviceOrderByBiosVersionDesc,
	AdapterDeviceOrderByBiosSerialAsc,
	AdapterDeviceOrderByBiosSerialDesc,
}

func (e AdapterDeviceOrderBy) IsValid() bool {
	switch e {
	case AdapterDeviceOrderByFetchCycleAsc, AdapterDeviceOrderByFetchCycleDesc, AdapterDeviceOrderByAdapterNameAsc, AdapterDeviceOrderByAdapterNameDesc, AdapterDeviceOrderByFetchTimeAsc, AdapterDeviceOrderByFetchTimeDesc, AdapterDeviceOrderByHostnameAsc, AdapterDeviceOrderByHostnameDesc, AdapterDeviceOrderByNameAsc, AdapterDeviceOrderByNameDesc, AdapterDeviceOrderByLastSeenAsc, AdapterDeviceOrderByLastSeenDesc, AdapterDeviceOrderByPrettyIDAsc, AdapterDeviceOrderByPrettyIDDesc, AdapterDeviceOrderByDomainAsc, AdapterDeviceOrderByDomainDesc, AdapterDeviceOrderByAgentVersionAsc, AdapterDeviceOrderByAgentVersionDesc, AdapterDeviceOrderByAgentStatusAsc, AdapterDeviceOrderByAgentStatusDesc, AdapterDeviceOrderByAgentNameAsc, AdapterDeviceOrderByAgentNameDesc, AdapterDeviceOrderByModelAsc, AdapterDeviceOrderByModelDesc, AdapterDeviceOrderByManufacturerAsc, AdapterDeviceOrderByManufacturerDesc, AdapterDeviceOrderBySerialAsc, AdapterDeviceOrderBySerialDesc, AdapterDeviceOrderByFamilyAsc, AdapterDeviceOrderByFamilyDesc, AdapterDeviceOrderByBiosVersionAsc, AdapterDeviceOrderByBiosVersionDesc, AdapterDeviceOrderByBiosSerialAsc, AdapterDeviceOrderByBiosSerialDesc:
		return true
	}
	return false
}

func (e AdapterDeviceOrderBy) String() string {
	return string(e)
}

func (e *AdapterDeviceOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDeviceOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapter_device_order_by", str)
	}
	return nil
}

func (e AdapterDeviceOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for AdapterDeviceUser
type AdapterDeviceUserOrderBy string

const (
	// Order by sid in an ascending order
	AdapterDeviceUserOrderBySidAsc AdapterDeviceUserOrderBy = "sid_ASC"
	// Order by sid in a descending order
	AdapterDeviceUserOrderBySidDesc AdapterDeviceUserOrderBy = "sid_DESC"
	// Order by username in an ascending order
	AdapterDeviceUserOrderByUsernameAsc AdapterDeviceUserOrderBy = "username_ASC"
	// Order by username in a descending order
	AdapterDeviceUserOrderByUsernameDesc AdapterDeviceUserOrderBy = "username_DESC"
	// Order by lastUseDate in an ascending order
	AdapterDeviceUserOrderByLastUseDateAsc AdapterDeviceUserOrderBy = "lastUseDate_ASC"
	// Order by lastUseDate in a descending order
	AdapterDeviceUserOrderByLastUseDateDesc AdapterDeviceUserOrderBy = "lastUseDate_DESC"
	// Order by passwordMaxAge in an ascending order
	AdapterDeviceUserOrderByPasswordMaxAgeAsc AdapterDeviceUserOrderBy = "passwordMaxAge_ASC"
	// Order by passwordMaxAge in a descending order
	AdapterDeviceUserOrderByPasswordMaxAgeDesc AdapterDeviceUserOrderBy = "passwordMaxAge_DESC"
	// Order by interpreter in an ascending order
	AdapterDeviceUserOrderByInterpreterAsc AdapterDeviceUserOrderBy = "interpreter_ASC"
	// Order by interpreter in a descending order
	AdapterDeviceUserOrderByInterpreterDesc AdapterDeviceUserOrderBy = "interpreter_DESC"
)

var AllAdapterDeviceUserOrderBy = []AdapterDeviceUserOrderBy{
	AdapterDeviceUserOrderBySidAsc,
	AdapterDeviceUserOrderBySidDesc,
	AdapterDeviceUserOrderByUsernameAsc,
	AdapterDeviceUserOrderByUsernameDesc,
	AdapterDeviceUserOrderByLastUseDateAsc,
	AdapterDeviceUserOrderByLastUseDateDesc,
	AdapterDeviceUserOrderByPasswordMaxAgeAsc,
	AdapterDeviceUserOrderByPasswordMaxAgeDesc,
	AdapterDeviceUserOrderByInterpreterAsc,
	AdapterDeviceUserOrderByInterpreterDesc,
}

func (e AdapterDeviceUserOrderBy) IsValid() bool {
	switch e {
	case AdapterDeviceUserOrderBySidAsc, AdapterDeviceUserOrderBySidDesc, AdapterDeviceUserOrderByUsernameAsc, AdapterDeviceUserOrderByUsernameDesc, AdapterDeviceUserOrderByLastUseDateAsc, AdapterDeviceUserOrderByLastUseDateDesc, AdapterDeviceUserOrderByPasswordMaxAgeAsc, AdapterDeviceUserOrderByPasswordMaxAgeDesc, AdapterDeviceUserOrderByInterpreterAsc, AdapterDeviceUserOrderByInterpreterDesc:
		return true
	}
	return false
}

func (e AdapterDeviceUserOrderBy) String() string {
	return string(e)
}

func (e *AdapterDeviceUserOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterDeviceUserOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapter_device_user_order_by", str)
	}
	return nil
}

func (e AdapterDeviceUserOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for Adapter
type AdapterOrderBy string

const (
	// Order by name in an ascending order
	AdapterOrderByNameAsc AdapterOrderBy = "name_ASC"
	// Order by name in a descending order
	AdapterOrderByNameDesc AdapterOrderBy = "name_DESC"
)

var AllAdapterOrderBy = []AdapterOrderBy{
	AdapterOrderByNameAsc,
	AdapterOrderByNameDesc,
}

func (e AdapterOrderBy) IsValid() bool {
	switch e {
	case AdapterOrderByNameAsc, AdapterOrderByNameDesc:
		return true
	}
	return false
}

func (e AdapterOrderBy) String() string {
	return string(e)
}

func (e *AdapterOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapter_order_by", str)
	}
	return nil
}

func (e AdapterOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for AdapterUser
type AdapterUserOrderBy string

const (
	// Order by fetchCycle in an ascending order
	AdapterUserOrderByFetchCycleAsc AdapterUserOrderBy = "fetchCycle_ASC"
	// Order by fetchCycle in a descending order
	AdapterUserOrderByFetchCycleDesc AdapterUserOrderBy = "fetchCycle_DESC"
	// Order by adapterName in an ascending order
	AdapterUserOrderByAdapterNameAsc AdapterUserOrderBy = "adapterName_ASC"
	// Order by adapterName in a descending order
	AdapterUserOrderByAdapterNameDesc AdapterUserOrderBy = "adapterName_DESC"
	// Order by fetchTime in an ascending order
	AdapterUserOrderByFetchTimeAsc AdapterUserOrderBy = "fetchTime_ASC"
	// Order by fetchTime in a descending order
	AdapterUserOrderByFetchTimeDesc AdapterUserOrderBy = "fetchTime_DESC"
	// Order by lastSeen in an ascending order
	AdapterUserOrderByLastSeenAsc AdapterUserOrderBy = "lastSeen_ASC"
	// Order by lastSeen in a descending order
	AdapterUserOrderByLastSeenDesc AdapterUserOrderBy = "lastSeen_DESC"
	// Order by username in an ascending order
	AdapterUserOrderByUsernameAsc AdapterUserOrderBy = "username_ASC"
	// Order by username in a descending order
	AdapterUserOrderByUsernameDesc AdapterUserOrderBy = "username_DESC"
	// Order by firstName in an ascending order
	AdapterUserOrderByFirstNameAsc AdapterUserOrderBy = "firstName_ASC"
	// Order by firstName in a descending order
	AdapterUserOrderByFirstNameDesc AdapterUserOrderBy = "firstName_DESC"
	// Order by lastName in an ascending order
	AdapterUserOrderByLastNameAsc AdapterUserOrderBy = "lastName_ASC"
	// Order by lastName in a descending order
	AdapterUserOrderByLastNameDesc AdapterUserOrderBy = "lastName_DESC"
	// Order by mail in an ascending order
	AdapterUserOrderByMailAsc AdapterUserOrderBy = "mail_ASC"
	// Order by mail in a descending order
	AdapterUserOrderByMailDesc AdapterUserOrderBy = "mail_DESC"
)

var AllAdapterUserOrderBy = []AdapterUserOrderBy{
	AdapterUserOrderByFetchCycleAsc,
	AdapterUserOrderByFetchCycleDesc,
	AdapterUserOrderByAdapterNameAsc,
	AdapterUserOrderByAdapterNameDesc,
	AdapterUserOrderByFetchTimeAsc,
	AdapterUserOrderByFetchTimeDesc,
	AdapterUserOrderByLastSeenAsc,
	AdapterUserOrderByLastSeenDesc,
	AdapterUserOrderByUsernameAsc,
	AdapterUserOrderByUsernameDesc,
	AdapterUserOrderByFirstNameAsc,
	AdapterUserOrderByFirstNameDesc,
	AdapterUserOrderByLastNameAsc,
	AdapterUserOrderByLastNameDesc,
	AdapterUserOrderByMailAsc,
	AdapterUserOrderByMailDesc,
}

func (e AdapterUserOrderBy) IsValid() bool {
	switch e {
	case AdapterUserOrderByFetchCycleAsc, AdapterUserOrderByFetchCycleDesc, AdapterUserOrderByAdapterNameAsc, AdapterUserOrderByAdapterNameDesc, AdapterUserOrderByFetchTimeAsc, AdapterUserOrderByFetchTimeDesc, AdapterUserOrderByLastSeenAsc, AdapterUserOrderByLastSeenDesc, AdapterUserOrderByUsernameAsc, AdapterUserOrderByUsernameDesc, AdapterUserOrderByFirstNameAsc, AdapterUserOrderByFirstNameDesc, AdapterUserOrderByLastNameAsc, AdapterUserOrderByLastNameDesc, AdapterUserOrderByMailAsc, AdapterUserOrderByMailDesc:
		return true
	}
	return false
}

func (e AdapterUserOrderBy) String() string {
	return string(e)
}

func (e *AdapterUserOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdapterUserOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid adapter_user_order_by", str)
	}
	return nil
}

func (e AdapterUserOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for csGroup
type CsGroupOrderBy string

const (
	// Order by id in an ascending order
	CsGroupOrderByIDAsc CsGroupOrderBy = "id_ASC"
	// Order by id in a descending order
	CsGroupOrderByIDDesc CsGroupOrderBy = "id_DESC"
	// Order by name in an ascending order
	CsGroupOrderByNameAsc CsGroupOrderBy = "name_ASC"
	// Order by name in a descending order
	CsGroupOrderByNameDesc CsGroupOrderBy = "name_DESC"
	// Order by createdBy in an ascending order
	CsGroupOrderByCreatedByAsc CsGroupOrderBy = "createdBy_ASC"
	// Order by createdBy in a descending order
	CsGroupOrderByCreatedByDesc CsGroupOrderBy = "createdBy_DESC"
	// Order by createdTimestamp in an ascending order
	CsGroupOrderByCreatedTimestampAsc CsGroupOrderBy = "createdTimestamp_ASC"
	// Order by createdTimestamp in a descending order
	CsGroupOrderByCreatedTimestampDesc CsGroupOrderBy = "createdTimestamp_DESC"
	// Order by description in an ascending order
	CsGroupOrderByDescriptionAsc CsGroupOrderBy = "description_ASC"
	// Order by description in a descending order
	CsGroupOrderByDescriptionDesc CsGroupOrderBy = "description_DESC"
	// Order by groupType in an ascending order
	CsGroupOrderByGroupTypeAsc CsGroupOrderBy = "groupType_ASC"
	// Order by groupType in a descending order
	CsGroupOrderByGroupTypeDesc CsGroupOrderBy = "groupType_DESC"
	// Order by modifiedBy in an ascending order
	CsGroupOrderByModifiedByAsc CsGroupOrderBy = "modifiedBy_ASC"
	// Order by modifiedBy in a descending order
	CsGroupOrderByModifiedByDesc CsGroupOrderBy = "modifiedBy_DESC"
	// Order by modifiedTime in an ascending order
	CsGroupOrderByModifiedTimeAsc CsGroupOrderBy = "modifiedTime_ASC"
	// Order by modifiedTime in a descending order
	CsGroupOrderByModifiedTimeDesc CsGroupOrderBy = "modifiedTime_DESC"
)

var AllCsGroupOrderBy = []CsGroupOrderBy{
	CsGroupOrderByIDAsc,
	CsGroupOrderByIDDesc,
	CsGroupOrderByNameAsc,
	CsGroupOrderByNameDesc,
	CsGroupOrderByCreatedByAsc,
	CsGroupOrderByCreatedByDesc,
	CsGroupOrderByCreatedTimestampAsc,
	CsGroupOrderByCreatedTimestampDesc,
	CsGroupOrderByDescriptionAsc,
	CsGroupOrderByDescriptionDesc,
	CsGroupOrderByGroupTypeAsc,
	CsGroupOrderByGroupTypeDesc,
	CsGroupOrderByModifiedByAsc,
	CsGroupOrderByModifiedByDesc,
	CsGroupOrderByModifiedTimeAsc,
	CsGroupOrderByModifiedTimeDesc,
}

func (e CsGroupOrderBy) IsValid() bool {
	switch e {
	case CsGroupOrderByIDAsc, CsGroupOrderByIDDesc, CsGroupOrderByNameAsc, CsGroupOrderByNameDesc, CsGroupOrderByCreatedByAsc, CsGroupOrderByCreatedByDesc, CsGroupOrderByCreatedTimestampAsc, CsGroupOrderByCreatedTimestampDesc, CsGroupOrderByDescriptionAsc, CsGroupOrderByDescriptionDesc, CsGroupOrderByGroupTypeAsc, CsGroupOrderByGroupTypeDesc, CsGroupOrderByModifiedByAsc, CsGroupOrderByModifiedByDesc, CsGroupOrderByModifiedTimeAsc, CsGroupOrderByModifiedTimeDesc:
		return true
	}
	return false
}

func (e CsGroupOrderBy) String() string {
	return string(e)
}

func (e *CsGroupOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CsGroupOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid cs_group_order_by", str)
	}
	return nil
}

func (e CsGroupOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for csPolicy
type CsPolicyOrderBy string

const (
	// Order by name in an ascending order
	CsPolicyOrderByNameAsc CsPolicyOrderBy = "name_ASC"
	// Order by name in a descending order
	CsPolicyOrderByNameDesc CsPolicyOrderBy = "name_DESC"
	// Order by description in an ascending order
	CsPolicyOrderByDescriptionAsc CsPolicyOrderBy = "description_ASC"
	// Order by description in a descending order
	CsPolicyOrderByDescriptionDesc CsPolicyOrderBy = "description_DESC"
	// Order by platformName in an ascending order
	CsPolicyOrderByPlatformNameAsc CsPolicyOrderBy = "platformName_ASC"
	// Order by platformName in a descending order
	CsPolicyOrderByPlatformNameDesc CsPolicyOrderBy = "platformName_DESC"
	// Order by createdBy in an ascending order
	CsPolicyOrderByCreatedByAsc CsPolicyOrderBy = "createdBy_ASC"
	// Order by createdBy in a descending order
	CsPolicyOrderByCreatedByDesc CsPolicyOrderBy = "createdBy_DESC"
	// Order by createdTime in an ascending order
	CsPolicyOrderByCreatedTimeAsc CsPolicyOrderBy = "createdTime_ASC"
	// Order by createdTime in a descending order
	CsPolicyOrderByCreatedTimeDesc CsPolicyOrderBy = "createdTime_DESC"
)

var AllCsPolicyOrderBy = []CsPolicyOrderBy{
	CsPolicyOrderByNameAsc,
	CsPolicyOrderByNameDesc,
	CsPolicyOrderByDescriptionAsc,
	CsPolicyOrderByDescriptionDesc,
	CsPolicyOrderByPlatformNameAsc,
	CsPolicyOrderByPlatformNameDesc,
	CsPolicyOrderByCreatedByAsc,
	CsPolicyOrderByCreatedByDesc,
	CsPolicyOrderByCreatedTimeAsc,
	CsPolicyOrderByCreatedTimeDesc,
}

func (e CsPolicyOrderBy) IsValid() bool {
	switch e {
	case CsPolicyOrderByNameAsc, CsPolicyOrderByNameDesc, CsPolicyOrderByDescriptionAsc, CsPolicyOrderByDescriptionDesc, CsPolicyOrderByPlatformNameAsc, CsPolicyOrderByPlatformNameDesc, CsPolicyOrderByCreatedByAsc, CsPolicyOrderByCreatedByDesc, CsPolicyOrderByCreatedTimeAsc, CsPolicyOrderByCreatedTimeDesc:
		return true
	}
	return false
}

func (e CsPolicyOrderBy) String() string {
	return string(e)
}

func (e *CsPolicyOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CsPolicyOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid cs_policy_order_by", str)
	}
	return nil
}

func (e CsPolicyOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for csPreventionSettings
type CsPreventionSettingsOrderBy string

const (
	// Order by name in an ascending order
	CsPreventionSettingsOrderByNameAsc CsPreventionSettingsOrderBy = "name_ASC"
	// Order by name in a descending order
	CsPreventionSettingsOrderByNameDesc CsPreventionSettingsOrderBy = "name_DESC"
)

var AllCsPreventionSettingsOrderBy = []CsPreventionSettingsOrderBy{
	CsPreventionSettingsOrderByNameAsc,
	CsPreventionSettingsOrderByNameDesc,
}

func (e CsPreventionSettingsOrderBy) IsValid() bool {
	switch e {
	case CsPreventionSettingsOrderByNameAsc, CsPreventionSettingsOrderByNameDesc:
		return true
	}
	return false
}

func (e CsPreventionSettingsOrderBy) String() string {
	return string(e)
}

func (e *CsPreventionSettingsOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CsPreventionSettingsOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid cs_prevention_settings_order_by", str)
	}
	return nil
}

func (e CsPreventionSettingsOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for csSensorUpdateSettings
type CsSensorUpdateSettingsOrderBy string

const (
	// Order by build in an ascending order
	CsSensorUpdateSettingsOrderByBuildAsc CsSensorUpdateSettingsOrderBy = "build_ASC"
	// Order by build in a descending order
	CsSensorUpdateSettingsOrderByBuildDesc CsSensorUpdateSettingsOrderBy = "build_DESC"
)

var AllCsSensorUpdateSettingsOrderBy = []CsSensorUpdateSettingsOrderBy{
	CsSensorUpdateSettingsOrderByBuildAsc,
	CsSensorUpdateSettingsOrderByBuildDesc,
}

func (e CsSensorUpdateSettingsOrderBy) IsValid() bool {
	switch e {
	case CsSensorUpdateSettingsOrderByBuildAsc, CsSensorUpdateSettingsOrderByBuildDesc:
		return true
	}
	return false
}

func (e CsSensorUpdateSettingsOrderBy) String() string {
	return string(e)
}

func (e *CsSensorUpdateSettingsOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CsSensorUpdateSettingsOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid cs_sensor_update_settings_order_by", str)
	}
	return nil
}

func (e CsSensorUpdateSettingsOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for Device
type DeviceOrderBy string

const (
	// Order by fetchCycle in an ascending order
	DeviceOrderByFetchCycleAsc DeviceOrderBy = "fetchCycle_ASC"
	// Order by fetchCycle in a descending order
	DeviceOrderByFetchCycleDesc DeviceOrderBy = "fetchCycle_DESC"
	// Order by adapterCount in an ascending order
	DeviceOrderByAdapterCountAsc DeviceOrderBy = "adapterCount_ASC"
	// Order by adapterCount in a descending order
	DeviceOrderByAdapterCountDesc DeviceOrderBy = "adapterCount_DESC"
	// Order by lastSeen in an ascending order
	DeviceOrderByLastSeenAsc DeviceOrderBy = "lastSeen_ASC"
	// Order by lastSeen in a descending order
	DeviceOrderByLastSeenDesc DeviceOrderBy = "lastSeen_DESC"
)

var AllDeviceOrderBy = []DeviceOrderBy{
	DeviceOrderByFetchCycleAsc,
	DeviceOrderByFetchCycleDesc,
	DeviceOrderByAdapterCountAsc,
	DeviceOrderByAdapterCountDesc,
	DeviceOrderByLastSeenAsc,
	DeviceOrderByLastSeenDesc,
}

func (e DeviceOrderBy) IsValid() bool {
	switch e {
	case DeviceOrderByFetchCycleAsc, DeviceOrderByFetchCycleDesc, DeviceOrderByAdapterCountAsc, DeviceOrderByAdapterCountDesc, DeviceOrderByLastSeenAsc, DeviceOrderByLastSeenDesc:
		return true
	}
	return false
}

func (e DeviceOrderBy) String() string {
	return string(e)
}

func (e *DeviceOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid device_order_by", str)
	}
	return nil
}

func (e DeviceOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DevicesAggregateAvgColumns string

const (
	// avg by fetchCycle
	DevicesAggregateAvgColumnsFetchCycle DevicesAggregateAvgColumns = "fetchCycle"
	// avg by adapterCount
	DevicesAggregateAvgColumnsAdapterCount DevicesAggregateAvgColumns = "adapterCount"
	// avg by lastSeen
	DevicesAggregateAvgColumnsLastSeen DevicesAggregateAvgColumns = "lastSeen"
)

var AllDevicesAggregateAvgColumns = []DevicesAggregateAvgColumns{
	DevicesAggregateAvgColumnsFetchCycle,
	DevicesAggregateAvgColumnsAdapterCount,
	DevicesAggregateAvgColumnsLastSeen,
}

func (e DevicesAggregateAvgColumns) IsValid() bool {
	switch e {
	case DevicesAggregateAvgColumnsFetchCycle, DevicesAggregateAvgColumnsAdapterCount, DevicesAggregateAvgColumnsLastSeen:
		return true
	}
	return false
}

func (e DevicesAggregateAvgColumns) String() string {
	return string(e)
}

func (e *DevicesAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DevicesAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid devices_aggregate_avg_columns", str)
	}
	return nil
}

func (e DevicesAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DevicesAggregateColumns string

const (
	// groupBy by id
	DevicesAggregateColumnsID DevicesAggregateColumns = "id"
	// groupBy by fetchCycle
	DevicesAggregateColumnsFetchCycle DevicesAggregateColumns = "fetchCycle"
	// groupBy by adapterCount
	DevicesAggregateColumnsAdapterCount DevicesAggregateColumns = "adapterCount"
	// groupBy by lastSeen
	DevicesAggregateColumnsLastSeen DevicesAggregateColumns = "lastSeen"
)

var AllDevicesAggregateColumns = []DevicesAggregateColumns{
	DevicesAggregateColumnsID,
	DevicesAggregateColumnsFetchCycle,
	DevicesAggregateColumnsAdapterCount,
	DevicesAggregateColumnsLastSeen,
}

func (e DevicesAggregateColumns) IsValid() bool {
	switch e {
	case DevicesAggregateColumnsID, DevicesAggregateColumnsFetchCycle, DevicesAggregateColumnsAdapterCount, DevicesAggregateColumnsLastSeen:
		return true
	}
	return false
}

func (e DevicesAggregateColumns) String() string {
	return string(e)
}

func (e *DevicesAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DevicesAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid devices_aggregate_columns", str)
	}
	return nil
}

func (e DevicesAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DevicesAggregateMaxColumns string

const (
	// max by id
	DevicesAggregateMaxColumnsID DevicesAggregateMaxColumns = "id"
	// max by fetchCycle
	DevicesAggregateMaxColumnsFetchCycle DevicesAggregateMaxColumns = "fetchCycle"
	// max by adapterCount
	DevicesAggregateMaxColumnsAdapterCount DevicesAggregateMaxColumns = "adapterCount"
	// max by lastSeen
	DevicesAggregateMaxColumnsLastSeen DevicesAggregateMaxColumns = "lastSeen"
)

var AllDevicesAggregateMaxColumns = []DevicesAggregateMaxColumns{
	DevicesAggregateMaxColumnsID,
	DevicesAggregateMaxColumnsFetchCycle,
	DevicesAggregateMaxColumnsAdapterCount,
	DevicesAggregateMaxColumnsLastSeen,
}

func (e DevicesAggregateMaxColumns) IsValid() bool {
	switch e {
	case DevicesAggregateMaxColumnsID, DevicesAggregateMaxColumnsFetchCycle, DevicesAggregateMaxColumnsAdapterCount, DevicesAggregateMaxColumnsLastSeen:
		return true
	}
	return false
}

func (e DevicesAggregateMaxColumns) String() string {
	return string(e)
}

func (e *DevicesAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DevicesAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid devices_aggregate_max_columns", str)
	}
	return nil
}

func (e DevicesAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DevicesAggregateMinColumns string

const (
	// min by id
	DevicesAggregateMinColumnsID DevicesAggregateMinColumns = "id"
	// min by fetchCycle
	DevicesAggregateMinColumnsFetchCycle DevicesAggregateMinColumns = "fetchCycle"
	// min by adapterCount
	DevicesAggregateMinColumnsAdapterCount DevicesAggregateMinColumns = "adapterCount"
	// min by lastSeen
	DevicesAggregateMinColumnsLastSeen DevicesAggregateMinColumns = "lastSeen"
)

var AllDevicesAggregateMinColumns = []DevicesAggregateMinColumns{
	DevicesAggregateMinColumnsID,
	DevicesAggregateMinColumnsFetchCycle,
	DevicesAggregateMinColumnsAdapterCount,
	DevicesAggregateMinColumnsLastSeen,
}

func (e DevicesAggregateMinColumns) IsValid() bool {
	switch e {
	case DevicesAggregateMinColumnsID, DevicesAggregateMinColumnsFetchCycle, DevicesAggregateMinColumnsAdapterCount, DevicesAggregateMinColumnsLastSeen:
		return true
	}
	return false
}

func (e DevicesAggregateMinColumns) String() string {
	return string(e)
}

func (e *DevicesAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DevicesAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid devices_aggregate_min_columns", str)
	}
	return nil
}

func (e DevicesAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DevicesAggregateSumColumns string

const (
	// sum by fetchCycle
	DevicesAggregateSumColumnsFetchCycle DevicesAggregateSumColumns = "fetchCycle"
	// sum by adapterCount
	DevicesAggregateSumColumnsAdapterCount DevicesAggregateSumColumns = "adapterCount"
	// sum by lastSeen
	DevicesAggregateSumColumnsLastSeen DevicesAggregateSumColumns = "lastSeen"
)

var AllDevicesAggregateSumColumns = []DevicesAggregateSumColumns{
	DevicesAggregateSumColumnsFetchCycle,
	DevicesAggregateSumColumnsAdapterCount,
	DevicesAggregateSumColumnsLastSeen,
}

func (e DevicesAggregateSumColumns) IsValid() bool {
	switch e {
	case DevicesAggregateSumColumnsFetchCycle, DevicesAggregateSumColumnsAdapterCount, DevicesAggregateSumColumnsLastSeen:
		return true
	}
	return false
}

func (e DevicesAggregateSumColumns) String() string {
	return string(e)
}

func (e *DevicesAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DevicesAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid devices_aggregate_sum_columns", str)
	}
	return nil
}

func (e DevicesAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FirewallRulesAggregateAvgColumns string

const (
	// avg by srcPort
	FirewallRulesAggregateAvgColumnsSrcPort FirewallRulesAggregateAvgColumns = "srcPort"
	// avg by dstPort
	FirewallRulesAggregateAvgColumnsDstPort FirewallRulesAggregateAvgColumns = "dstPort"
)

var AllFirewallRulesAggregateAvgColumns = []FirewallRulesAggregateAvgColumns{
	FirewallRulesAggregateAvgColumnsSrcPort,
	FirewallRulesAggregateAvgColumnsDstPort,
}

func (e FirewallRulesAggregateAvgColumns) IsValid() bool {
	switch e {
	case FirewallRulesAggregateAvgColumnsSrcPort, FirewallRulesAggregateAvgColumnsDstPort:
		return true
	}
	return false
}

func (e FirewallRulesAggregateAvgColumns) String() string {
	return string(e)
}

func (e *FirewallRulesAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRulesAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewallRules_aggregate_avg_columns", str)
	}
	return nil
}

func (e FirewallRulesAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FirewallRulesAggregateColumns string

const (
	// groupBy by name
	FirewallRulesAggregateColumnsName FirewallRulesAggregateColumns = "name"
	// groupBy by source
	FirewallRulesAggregateColumnsSource FirewallRulesAggregateColumns = "source"
	// groupBy by target
	FirewallRulesAggregateColumnsTarget FirewallRulesAggregateColumns = "target"
	// groupBy by protocol
	FirewallRulesAggregateColumnsProtocol FirewallRulesAggregateColumns = "protocol"
	// groupBy by srcPort
	FirewallRulesAggregateColumnsSrcPort FirewallRulesAggregateColumns = "srcPort"
	// groupBy by dstPort
	FirewallRulesAggregateColumnsDstPort FirewallRulesAggregateColumns = "dstPort"
)

var AllFirewallRulesAggregateColumns = []FirewallRulesAggregateColumns{
	FirewallRulesAggregateColumnsName,
	FirewallRulesAggregateColumnsSource,
	FirewallRulesAggregateColumnsTarget,
	FirewallRulesAggregateColumnsProtocol,
	FirewallRulesAggregateColumnsSrcPort,
	FirewallRulesAggregateColumnsDstPort,
}

func (e FirewallRulesAggregateColumns) IsValid() bool {
	switch e {
	case FirewallRulesAggregateColumnsName, FirewallRulesAggregateColumnsSource, FirewallRulesAggregateColumnsTarget, FirewallRulesAggregateColumnsProtocol, FirewallRulesAggregateColumnsSrcPort, FirewallRulesAggregateColumnsDstPort:
		return true
	}
	return false
}

func (e FirewallRulesAggregateColumns) String() string {
	return string(e)
}

func (e *FirewallRulesAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRulesAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewallRules_aggregate_columns", str)
	}
	return nil
}

func (e FirewallRulesAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FirewallRulesAggregateMaxColumns string

const (
	// max by name
	FirewallRulesAggregateMaxColumnsName FirewallRulesAggregateMaxColumns = "name"
	// max by source
	FirewallRulesAggregateMaxColumnsSource FirewallRulesAggregateMaxColumns = "source"
	// max by target
	FirewallRulesAggregateMaxColumnsTarget FirewallRulesAggregateMaxColumns = "target"
	// max by protocol
	FirewallRulesAggregateMaxColumnsProtocol FirewallRulesAggregateMaxColumns = "protocol"
	// max by srcPort
	FirewallRulesAggregateMaxColumnsSrcPort FirewallRulesAggregateMaxColumns = "srcPort"
	// max by dstPort
	FirewallRulesAggregateMaxColumnsDstPort FirewallRulesAggregateMaxColumns = "dstPort"
)

var AllFirewallRulesAggregateMaxColumns = []FirewallRulesAggregateMaxColumns{
	FirewallRulesAggregateMaxColumnsName,
	FirewallRulesAggregateMaxColumnsSource,
	FirewallRulesAggregateMaxColumnsTarget,
	FirewallRulesAggregateMaxColumnsProtocol,
	FirewallRulesAggregateMaxColumnsSrcPort,
	FirewallRulesAggregateMaxColumnsDstPort,
}

func (e FirewallRulesAggregateMaxColumns) IsValid() bool {
	switch e {
	case FirewallRulesAggregateMaxColumnsName, FirewallRulesAggregateMaxColumnsSource, FirewallRulesAggregateMaxColumnsTarget, FirewallRulesAggregateMaxColumnsProtocol, FirewallRulesAggregateMaxColumnsSrcPort, FirewallRulesAggregateMaxColumnsDstPort:
		return true
	}
	return false
}

func (e FirewallRulesAggregateMaxColumns) String() string {
	return string(e)
}

func (e *FirewallRulesAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRulesAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewallRules_aggregate_max_columns", str)
	}
	return nil
}

func (e FirewallRulesAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FirewallRulesAggregateMinColumns string

const (
	// min by name
	FirewallRulesAggregateMinColumnsName FirewallRulesAggregateMinColumns = "name"
	// min by source
	FirewallRulesAggregateMinColumnsSource FirewallRulesAggregateMinColumns = "source"
	// min by target
	FirewallRulesAggregateMinColumnsTarget FirewallRulesAggregateMinColumns = "target"
	// min by protocol
	FirewallRulesAggregateMinColumnsProtocol FirewallRulesAggregateMinColumns = "protocol"
	// min by srcPort
	FirewallRulesAggregateMinColumnsSrcPort FirewallRulesAggregateMinColumns = "srcPort"
	// min by dstPort
	FirewallRulesAggregateMinColumnsDstPort FirewallRulesAggregateMinColumns = "dstPort"
)

var AllFirewallRulesAggregateMinColumns = []FirewallRulesAggregateMinColumns{
	FirewallRulesAggregateMinColumnsName,
	FirewallRulesAggregateMinColumnsSource,
	FirewallRulesAggregateMinColumnsTarget,
	FirewallRulesAggregateMinColumnsProtocol,
	FirewallRulesAggregateMinColumnsSrcPort,
	FirewallRulesAggregateMinColumnsDstPort,
}

func (e FirewallRulesAggregateMinColumns) IsValid() bool {
	switch e {
	case FirewallRulesAggregateMinColumnsName, FirewallRulesAggregateMinColumnsSource, FirewallRulesAggregateMinColumnsTarget, FirewallRulesAggregateMinColumnsProtocol, FirewallRulesAggregateMinColumnsSrcPort, FirewallRulesAggregateMinColumnsDstPort:
		return true
	}
	return false
}

func (e FirewallRulesAggregateMinColumns) String() string {
	return string(e)
}

func (e *FirewallRulesAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRulesAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewallRules_aggregate_min_columns", str)
	}
	return nil
}

func (e FirewallRulesAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FirewallRulesAggregateSumColumns string

const (
	// sum by srcPort
	FirewallRulesAggregateSumColumnsSrcPort FirewallRulesAggregateSumColumns = "srcPort"
	// sum by dstPort
	FirewallRulesAggregateSumColumnsDstPort FirewallRulesAggregateSumColumns = "dstPort"
)

var AllFirewallRulesAggregateSumColumns = []FirewallRulesAggregateSumColumns{
	FirewallRulesAggregateSumColumnsSrcPort,
	FirewallRulesAggregateSumColumnsDstPort,
}

func (e FirewallRulesAggregateSumColumns) IsValid() bool {
	switch e {
	case FirewallRulesAggregateSumColumnsSrcPort, FirewallRulesAggregateSumColumnsDstPort:
		return true
	}
	return false
}

func (e FirewallRulesAggregateSumColumns) String() string {
	return string(e)
}

func (e *FirewallRulesAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRulesAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewallRules_aggregate_sum_columns", str)
	}
	return nil
}

func (e FirewallRulesAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for FirewallRule
type FirewallRuleOrderBy string

const (
	// Order by name in an ascending order
	FirewallRuleOrderByNameAsc FirewallRuleOrderBy = "name_ASC"
	// Order by name in a descending order
	FirewallRuleOrderByNameDesc FirewallRuleOrderBy = "name_DESC"
	// Order by source in an ascending order
	FirewallRuleOrderBySourceAsc FirewallRuleOrderBy = "source_ASC"
	// Order by source in a descending order
	FirewallRuleOrderBySourceDesc FirewallRuleOrderBy = "source_DESC"
	// Order by target in an ascending order
	FirewallRuleOrderByTargetAsc FirewallRuleOrderBy = "target_ASC"
	// Order by target in a descending order
	FirewallRuleOrderByTargetDesc FirewallRuleOrderBy = "target_DESC"
	// Order by protocol in an ascending order
	FirewallRuleOrderByProtocolAsc FirewallRuleOrderBy = "protocol_ASC"
	// Order by protocol in a descending order
	FirewallRuleOrderByProtocolDesc FirewallRuleOrderBy = "protocol_DESC"
	// Order by srcPort in an ascending order
	FirewallRuleOrderBySrcPortAsc FirewallRuleOrderBy = "srcPort_ASC"
	// Order by srcPort in a descending order
	FirewallRuleOrderBySrcPortDesc FirewallRuleOrderBy = "srcPort_DESC"
	// Order by dstPort in an ascending order
	FirewallRuleOrderByDstPortAsc FirewallRuleOrderBy = "dstPort_ASC"
	// Order by dstPort in a descending order
	FirewallRuleOrderByDstPortDesc FirewallRuleOrderBy = "dstPort_DESC"
)

var AllFirewallRuleOrderBy = []FirewallRuleOrderBy{
	FirewallRuleOrderByNameAsc,
	FirewallRuleOrderByNameDesc,
	FirewallRuleOrderBySourceAsc,
	FirewallRuleOrderBySourceDesc,
	FirewallRuleOrderByTargetAsc,
	FirewallRuleOrderByTargetDesc,
	FirewallRuleOrderByProtocolAsc,
	FirewallRuleOrderByProtocolDesc,
	FirewallRuleOrderBySrcPortAsc,
	FirewallRuleOrderBySrcPortDesc,
	FirewallRuleOrderByDstPortAsc,
	FirewallRuleOrderByDstPortDesc,
}

func (e FirewallRuleOrderBy) IsValid() bool {
	switch e {
	case FirewallRuleOrderByNameAsc, FirewallRuleOrderByNameDesc, FirewallRuleOrderBySourceAsc, FirewallRuleOrderBySourceDesc, FirewallRuleOrderByTargetAsc, FirewallRuleOrderByTargetDesc, FirewallRuleOrderByProtocolAsc, FirewallRuleOrderByProtocolDesc, FirewallRuleOrderBySrcPortAsc, FirewallRuleOrderBySrcPortDesc, FirewallRuleOrderByDstPortAsc, FirewallRuleOrderByDstPortDesc:
		return true
	}
	return false
}

func (e FirewallRuleOrderBy) String() string {
	return string(e)
}

func (e *FirewallRuleOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallRuleOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid firewall_rule_order_by", str)
	}
	return nil
}

func (e FirewallRuleOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for GceTags
type GceTagsOrderBy string

const (
	// Order by gceKey in an ascending order
	GceTagsOrderByGceKeyAsc GceTagsOrderBy = "gceKey_ASC"
	// Order by gceKey in a descending order
	GceTagsOrderByGceKeyDesc GceTagsOrderBy = "gceKey_DESC"
	// Order by gceValue in an ascending order
	GceTagsOrderByGceValueAsc GceTagsOrderBy = "gceValue_ASC"
	// Order by gceValue in a descending order
	GceTagsOrderByGceValueDesc GceTagsOrderBy = "gceValue_DESC"
)

var AllGceTagsOrderBy = []GceTagsOrderBy{
	GceTagsOrderByGceKeyAsc,
	GceTagsOrderByGceKeyDesc,
	GceTagsOrderByGceValueAsc,
	GceTagsOrderByGceValueDesc,
}

func (e GceTagsOrderBy) IsValid() bool {
	switch e {
	case GceTagsOrderByGceKeyAsc, GceTagsOrderByGceKeyDesc, GceTagsOrderByGceValueAsc, GceTagsOrderByGceValueDesc:
		return true
	}
	return false
}

func (e GceTagsOrderBy) String() string {
	return string(e)
}

func (e *GceTagsOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GceTagsOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid gce_tags_order_by", str)
	}
	return nil
}

func (e GceTagsOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupsAggregateAvgColumns string

const (
	// avg by createdTimestamp
	GroupsAggregateAvgColumnsCreatedTimestamp GroupsAggregateAvgColumns = "createdTimestamp"
	// avg by modifiedTime
	GroupsAggregateAvgColumnsModifiedTime GroupsAggregateAvgColumns = "modifiedTime"
)

var AllGroupsAggregateAvgColumns = []GroupsAggregateAvgColumns{
	GroupsAggregateAvgColumnsCreatedTimestamp,
	GroupsAggregateAvgColumnsModifiedTime,
}

func (e GroupsAggregateAvgColumns) IsValid() bool {
	switch e {
	case GroupsAggregateAvgColumnsCreatedTimestamp, GroupsAggregateAvgColumnsModifiedTime:
		return true
	}
	return false
}

func (e GroupsAggregateAvgColumns) String() string {
	return string(e)
}

func (e *GroupsAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupsAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid groups_aggregate_avg_columns", str)
	}
	return nil
}

func (e GroupsAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupsAggregateColumns string

const (
	// groupBy by id
	GroupsAggregateColumnsID GroupsAggregateColumns = "id"
	// groupBy by name
	GroupsAggregateColumnsName GroupsAggregateColumns = "name"
	// groupBy by createdBy
	GroupsAggregateColumnsCreatedBy GroupsAggregateColumns = "createdBy"
	// groupBy by createdTimestamp
	GroupsAggregateColumnsCreatedTimestamp GroupsAggregateColumns = "createdTimestamp"
	// groupBy by description
	GroupsAggregateColumnsDescription GroupsAggregateColumns = "description"
	// groupBy by groupType
	GroupsAggregateColumnsGroupType GroupsAggregateColumns = "groupType"
	// groupBy by modifiedBy
	GroupsAggregateColumnsModifiedBy GroupsAggregateColumns = "modifiedBy"
	// groupBy by modifiedTime
	GroupsAggregateColumnsModifiedTime GroupsAggregateColumns = "modifiedTime"
)

var AllGroupsAggregateColumns = []GroupsAggregateColumns{
	GroupsAggregateColumnsID,
	GroupsAggregateColumnsName,
	GroupsAggregateColumnsCreatedBy,
	GroupsAggregateColumnsCreatedTimestamp,
	GroupsAggregateColumnsDescription,
	GroupsAggregateColumnsGroupType,
	GroupsAggregateColumnsModifiedBy,
	GroupsAggregateColumnsModifiedTime,
}

func (e GroupsAggregateColumns) IsValid() bool {
	switch e {
	case GroupsAggregateColumnsID, GroupsAggregateColumnsName, GroupsAggregateColumnsCreatedBy, GroupsAggregateColumnsCreatedTimestamp, GroupsAggregateColumnsDescription, GroupsAggregateColumnsGroupType, GroupsAggregateColumnsModifiedBy, GroupsAggregateColumnsModifiedTime:
		return true
	}
	return false
}

func (e GroupsAggregateColumns) String() string {
	return string(e)
}

func (e *GroupsAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupsAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid groups_aggregate_columns", str)
	}
	return nil
}

func (e GroupsAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupsAggregateMaxColumns string

const (
	// max by id
	GroupsAggregateMaxColumnsID GroupsAggregateMaxColumns = "id"
	// max by name
	GroupsAggregateMaxColumnsName GroupsAggregateMaxColumns = "name"
	// max by createdBy
	GroupsAggregateMaxColumnsCreatedBy GroupsAggregateMaxColumns = "createdBy"
	// max by createdTimestamp
	GroupsAggregateMaxColumnsCreatedTimestamp GroupsAggregateMaxColumns = "createdTimestamp"
	// max by description
	GroupsAggregateMaxColumnsDescription GroupsAggregateMaxColumns = "description"
	// max by groupType
	GroupsAggregateMaxColumnsGroupType GroupsAggregateMaxColumns = "groupType"
	// max by modifiedBy
	GroupsAggregateMaxColumnsModifiedBy GroupsAggregateMaxColumns = "modifiedBy"
	// max by modifiedTime
	GroupsAggregateMaxColumnsModifiedTime GroupsAggregateMaxColumns = "modifiedTime"
)

var AllGroupsAggregateMaxColumns = []GroupsAggregateMaxColumns{
	GroupsAggregateMaxColumnsID,
	GroupsAggregateMaxColumnsName,
	GroupsAggregateMaxColumnsCreatedBy,
	GroupsAggregateMaxColumnsCreatedTimestamp,
	GroupsAggregateMaxColumnsDescription,
	GroupsAggregateMaxColumnsGroupType,
	GroupsAggregateMaxColumnsModifiedBy,
	GroupsAggregateMaxColumnsModifiedTime,
}

func (e GroupsAggregateMaxColumns) IsValid() bool {
	switch e {
	case GroupsAggregateMaxColumnsID, GroupsAggregateMaxColumnsName, GroupsAggregateMaxColumnsCreatedBy, GroupsAggregateMaxColumnsCreatedTimestamp, GroupsAggregateMaxColumnsDescription, GroupsAggregateMaxColumnsGroupType, GroupsAggregateMaxColumnsModifiedBy, GroupsAggregateMaxColumnsModifiedTime:
		return true
	}
	return false
}

func (e GroupsAggregateMaxColumns) String() string {
	return string(e)
}

func (e *GroupsAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupsAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid groups_aggregate_max_columns", str)
	}
	return nil
}

func (e GroupsAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupsAggregateMinColumns string

const (
	// min by id
	GroupsAggregateMinColumnsID GroupsAggregateMinColumns = "id"
	// min by name
	GroupsAggregateMinColumnsName GroupsAggregateMinColumns = "name"
	// min by createdBy
	GroupsAggregateMinColumnsCreatedBy GroupsAggregateMinColumns = "createdBy"
	// min by createdTimestamp
	GroupsAggregateMinColumnsCreatedTimestamp GroupsAggregateMinColumns = "createdTimestamp"
	// min by description
	GroupsAggregateMinColumnsDescription GroupsAggregateMinColumns = "description"
	// min by groupType
	GroupsAggregateMinColumnsGroupType GroupsAggregateMinColumns = "groupType"
	// min by modifiedBy
	GroupsAggregateMinColumnsModifiedBy GroupsAggregateMinColumns = "modifiedBy"
	// min by modifiedTime
	GroupsAggregateMinColumnsModifiedTime GroupsAggregateMinColumns = "modifiedTime"
)

var AllGroupsAggregateMinColumns = []GroupsAggregateMinColumns{
	GroupsAggregateMinColumnsID,
	GroupsAggregateMinColumnsName,
	GroupsAggregateMinColumnsCreatedBy,
	GroupsAggregateMinColumnsCreatedTimestamp,
	GroupsAggregateMinColumnsDescription,
	GroupsAggregateMinColumnsGroupType,
	GroupsAggregateMinColumnsModifiedBy,
	GroupsAggregateMinColumnsModifiedTime,
}

func (e GroupsAggregateMinColumns) IsValid() bool {
	switch e {
	case GroupsAggregateMinColumnsID, GroupsAggregateMinColumnsName, GroupsAggregateMinColumnsCreatedBy, GroupsAggregateMinColumnsCreatedTimestamp, GroupsAggregateMinColumnsDescription, GroupsAggregateMinColumnsGroupType, GroupsAggregateMinColumnsModifiedBy, GroupsAggregateMinColumnsModifiedTime:
		return true
	}
	return false
}

func (e GroupsAggregateMinColumns) String() string {
	return string(e)
}

func (e *GroupsAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupsAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid groups_aggregate_min_columns", str)
	}
	return nil
}

func (e GroupsAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupsAggregateSumColumns string

const (
	// sum by createdTimestamp
	GroupsAggregateSumColumnsCreatedTimestamp GroupsAggregateSumColumns = "createdTimestamp"
	// sum by modifiedTime
	GroupsAggregateSumColumnsModifiedTime GroupsAggregateSumColumns = "modifiedTime"
)

var AllGroupsAggregateSumColumns = []GroupsAggregateSumColumns{
	GroupsAggregateSumColumnsCreatedTimestamp,
	GroupsAggregateSumColumnsModifiedTime,
}

func (e GroupsAggregateSumColumns) IsValid() bool {
	switch e {
	case GroupsAggregateSumColumnsCreatedTimestamp, GroupsAggregateSumColumnsModifiedTime:
		return true
	}
	return false
}

func (e GroupsAggregateSumColumns) String() string {
	return string(e)
}

func (e *GroupsAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupsAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid groups_aggregate_sum_columns", str)
	}
	return nil
}

func (e GroupsAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstalledSoftwareAggregateAvgColumns string

const (
	// avg by cveCount
	InstalledSoftwareAggregateAvgColumnsCveCount InstalledSoftwareAggregateAvgColumns = "cveCount"
)

var AllInstalledSoftwareAggregateAvgColumns = []InstalledSoftwareAggregateAvgColumns{
	InstalledSoftwareAggregateAvgColumnsCveCount,
}

func (e InstalledSoftwareAggregateAvgColumns) IsValid() bool {
	switch e {
	case InstalledSoftwareAggregateAvgColumnsCveCount:
		return true
	}
	return false
}

func (e InstalledSoftwareAggregateAvgColumns) String() string {
	return string(e)
}

func (e *InstalledSoftwareAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installedSoftware_aggregate_avg_columns", str)
	}
	return nil
}

func (e InstalledSoftwareAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstalledSoftwareAggregateColumns string

const (
	// groupBy by name
	InstalledSoftwareAggregateColumnsName InstalledSoftwareAggregateColumns = "name"
	// groupBy by version
	InstalledSoftwareAggregateColumnsVersion InstalledSoftwareAggregateColumns = "version"
	// groupBy by description
	InstalledSoftwareAggregateColumnsDescription InstalledSoftwareAggregateColumns = "description"
	// groupBy by vendor
	InstalledSoftwareAggregateColumnsVendor InstalledSoftwareAggregateColumns = "vendor"
	// groupBy by publisher
	InstalledSoftwareAggregateColumnsPublisher InstalledSoftwareAggregateColumns = "publisher"
	// groupBy by cveCount
	InstalledSoftwareAggregateColumnsCveCount InstalledSoftwareAggregateColumns = "cveCount"
	// groupBy by swLicense
	InstalledSoftwareAggregateColumnsSwLicense InstalledSoftwareAggregateColumns = "swLicense"
	// groupBy by path
	InstalledSoftwareAggregateColumnsPath InstalledSoftwareAggregateColumns = "path"
)

var AllInstalledSoftwareAggregateColumns = []InstalledSoftwareAggregateColumns{
	InstalledSoftwareAggregateColumnsName,
	InstalledSoftwareAggregateColumnsVersion,
	InstalledSoftwareAggregateColumnsDescription,
	InstalledSoftwareAggregateColumnsVendor,
	InstalledSoftwareAggregateColumnsPublisher,
	InstalledSoftwareAggregateColumnsCveCount,
	InstalledSoftwareAggregateColumnsSwLicense,
	InstalledSoftwareAggregateColumnsPath,
}

func (e InstalledSoftwareAggregateColumns) IsValid() bool {
	switch e {
	case InstalledSoftwareAggregateColumnsName, InstalledSoftwareAggregateColumnsVersion, InstalledSoftwareAggregateColumnsDescription, InstalledSoftwareAggregateColumnsVendor, InstalledSoftwareAggregateColumnsPublisher, InstalledSoftwareAggregateColumnsCveCount, InstalledSoftwareAggregateColumnsSwLicense, InstalledSoftwareAggregateColumnsPath:
		return true
	}
	return false
}

func (e InstalledSoftwareAggregateColumns) String() string {
	return string(e)
}

func (e *InstalledSoftwareAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installedSoftware_aggregate_columns", str)
	}
	return nil
}

func (e InstalledSoftwareAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstalledSoftwareAggregateMaxColumns string

const (
	// max by name
	InstalledSoftwareAggregateMaxColumnsName InstalledSoftwareAggregateMaxColumns = "name"
	// max by version
	InstalledSoftwareAggregateMaxColumnsVersion InstalledSoftwareAggregateMaxColumns = "version"
	// max by description
	InstalledSoftwareAggregateMaxColumnsDescription InstalledSoftwareAggregateMaxColumns = "description"
	// max by vendor
	InstalledSoftwareAggregateMaxColumnsVendor InstalledSoftwareAggregateMaxColumns = "vendor"
	// max by publisher
	InstalledSoftwareAggregateMaxColumnsPublisher InstalledSoftwareAggregateMaxColumns = "publisher"
	// max by cveCount
	InstalledSoftwareAggregateMaxColumnsCveCount InstalledSoftwareAggregateMaxColumns = "cveCount"
	// max by swLicense
	InstalledSoftwareAggregateMaxColumnsSwLicense InstalledSoftwareAggregateMaxColumns = "swLicense"
	// max by path
	InstalledSoftwareAggregateMaxColumnsPath InstalledSoftwareAggregateMaxColumns = "path"
)

var AllInstalledSoftwareAggregateMaxColumns = []InstalledSoftwareAggregateMaxColumns{
	InstalledSoftwareAggregateMaxColumnsName,
	InstalledSoftwareAggregateMaxColumnsVersion,
	InstalledSoftwareAggregateMaxColumnsDescription,
	InstalledSoftwareAggregateMaxColumnsVendor,
	InstalledSoftwareAggregateMaxColumnsPublisher,
	InstalledSoftwareAggregateMaxColumnsCveCount,
	InstalledSoftwareAggregateMaxColumnsSwLicense,
	InstalledSoftwareAggregateMaxColumnsPath,
}

func (e InstalledSoftwareAggregateMaxColumns) IsValid() bool {
	switch e {
	case InstalledSoftwareAggregateMaxColumnsName, InstalledSoftwareAggregateMaxColumnsVersion, InstalledSoftwareAggregateMaxColumnsDescription, InstalledSoftwareAggregateMaxColumnsVendor, InstalledSoftwareAggregateMaxColumnsPublisher, InstalledSoftwareAggregateMaxColumnsCveCount, InstalledSoftwareAggregateMaxColumnsSwLicense, InstalledSoftwareAggregateMaxColumnsPath:
		return true
	}
	return false
}

func (e InstalledSoftwareAggregateMaxColumns) String() string {
	return string(e)
}

func (e *InstalledSoftwareAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installedSoftware_aggregate_max_columns", str)
	}
	return nil
}

func (e InstalledSoftwareAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstalledSoftwareAggregateMinColumns string

const (
	// min by name
	InstalledSoftwareAggregateMinColumnsName InstalledSoftwareAggregateMinColumns = "name"
	// min by version
	InstalledSoftwareAggregateMinColumnsVersion InstalledSoftwareAggregateMinColumns = "version"
	// min by description
	InstalledSoftwareAggregateMinColumnsDescription InstalledSoftwareAggregateMinColumns = "description"
	// min by vendor
	InstalledSoftwareAggregateMinColumnsVendor InstalledSoftwareAggregateMinColumns = "vendor"
	// min by publisher
	InstalledSoftwareAggregateMinColumnsPublisher InstalledSoftwareAggregateMinColumns = "publisher"
	// min by cveCount
	InstalledSoftwareAggregateMinColumnsCveCount InstalledSoftwareAggregateMinColumns = "cveCount"
	// min by swLicense
	InstalledSoftwareAggregateMinColumnsSwLicense InstalledSoftwareAggregateMinColumns = "swLicense"
	// min by path
	InstalledSoftwareAggregateMinColumnsPath InstalledSoftwareAggregateMinColumns = "path"
)

var AllInstalledSoftwareAggregateMinColumns = []InstalledSoftwareAggregateMinColumns{
	InstalledSoftwareAggregateMinColumnsName,
	InstalledSoftwareAggregateMinColumnsVersion,
	InstalledSoftwareAggregateMinColumnsDescription,
	InstalledSoftwareAggregateMinColumnsVendor,
	InstalledSoftwareAggregateMinColumnsPublisher,
	InstalledSoftwareAggregateMinColumnsCveCount,
	InstalledSoftwareAggregateMinColumnsSwLicense,
	InstalledSoftwareAggregateMinColumnsPath,
}

func (e InstalledSoftwareAggregateMinColumns) IsValid() bool {
	switch e {
	case InstalledSoftwareAggregateMinColumnsName, InstalledSoftwareAggregateMinColumnsVersion, InstalledSoftwareAggregateMinColumnsDescription, InstalledSoftwareAggregateMinColumnsVendor, InstalledSoftwareAggregateMinColumnsPublisher, InstalledSoftwareAggregateMinColumnsCveCount, InstalledSoftwareAggregateMinColumnsSwLicense, InstalledSoftwareAggregateMinColumnsPath:
		return true
	}
	return false
}

func (e InstalledSoftwareAggregateMinColumns) String() string {
	return string(e)
}

func (e *InstalledSoftwareAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installedSoftware_aggregate_min_columns", str)
	}
	return nil
}

func (e InstalledSoftwareAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstalledSoftwareAggregateSumColumns string

const (
	// sum by cveCount
	InstalledSoftwareAggregateSumColumnsCveCount InstalledSoftwareAggregateSumColumns = "cveCount"
)

var AllInstalledSoftwareAggregateSumColumns = []InstalledSoftwareAggregateSumColumns{
	InstalledSoftwareAggregateSumColumnsCveCount,
}

func (e InstalledSoftwareAggregateSumColumns) IsValid() bool {
	switch e {
	case InstalledSoftwareAggregateSumColumnsCveCount:
		return true
	}
	return false
}

func (e InstalledSoftwareAggregateSumColumns) String() string {
	return string(e)
}

func (e *InstalledSoftwareAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installedSoftware_aggregate_sum_columns", str)
	}
	return nil
}

func (e InstalledSoftwareAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for InstalledSoftware
type InstalledSoftwareOrderBy string

const (
	// Order by name in an ascending order
	InstalledSoftwareOrderByNameAsc InstalledSoftwareOrderBy = "name_ASC"
	// Order by name in a descending order
	InstalledSoftwareOrderByNameDesc InstalledSoftwareOrderBy = "name_DESC"
	// Order by version in an ascending order
	InstalledSoftwareOrderByVersionAsc InstalledSoftwareOrderBy = "version_ASC"
	// Order by version in a descending order
	InstalledSoftwareOrderByVersionDesc InstalledSoftwareOrderBy = "version_DESC"
	// Order by description in an ascending order
	InstalledSoftwareOrderByDescriptionAsc InstalledSoftwareOrderBy = "description_ASC"
	// Order by description in a descending order
	InstalledSoftwareOrderByDescriptionDesc InstalledSoftwareOrderBy = "description_DESC"
	// Order by vendor in an ascending order
	InstalledSoftwareOrderByVendorAsc InstalledSoftwareOrderBy = "vendor_ASC"
	// Order by vendor in a descending order
	InstalledSoftwareOrderByVendorDesc InstalledSoftwareOrderBy = "vendor_DESC"
	// Order by publisher in an ascending order
	InstalledSoftwareOrderByPublisherAsc InstalledSoftwareOrderBy = "publisher_ASC"
	// Order by publisher in a descending order
	InstalledSoftwareOrderByPublisherDesc InstalledSoftwareOrderBy = "publisher_DESC"
	// Order by cveCount in an ascending order
	InstalledSoftwareOrderByCveCountAsc InstalledSoftwareOrderBy = "cveCount_ASC"
	// Order by cveCount in a descending order
	InstalledSoftwareOrderByCveCountDesc InstalledSoftwareOrderBy = "cveCount_DESC"
	// Order by swLicense in an ascending order
	InstalledSoftwareOrderBySwLicenseAsc InstalledSoftwareOrderBy = "swLicense_ASC"
	// Order by swLicense in a descending order
	InstalledSoftwareOrderBySwLicenseDesc InstalledSoftwareOrderBy = "swLicense_DESC"
	// Order by path in an ascending order
	InstalledSoftwareOrderByPathAsc InstalledSoftwareOrderBy = "path_ASC"
	// Order by path in a descending order
	InstalledSoftwareOrderByPathDesc InstalledSoftwareOrderBy = "path_DESC"
)

var AllInstalledSoftwareOrderBy = []InstalledSoftwareOrderBy{
	InstalledSoftwareOrderByNameAsc,
	InstalledSoftwareOrderByNameDesc,
	InstalledSoftwareOrderByVersionAsc,
	InstalledSoftwareOrderByVersionDesc,
	InstalledSoftwareOrderByDescriptionAsc,
	InstalledSoftwareOrderByDescriptionDesc,
	InstalledSoftwareOrderByVendorAsc,
	InstalledSoftwareOrderByVendorDesc,
	InstalledSoftwareOrderByPublisherAsc,
	InstalledSoftwareOrderByPublisherDesc,
	InstalledSoftwareOrderByCveCountAsc,
	InstalledSoftwareOrderByCveCountDesc,
	InstalledSoftwareOrderBySwLicenseAsc,
	InstalledSoftwareOrderBySwLicenseDesc,
	InstalledSoftwareOrderByPathAsc,
	InstalledSoftwareOrderByPathDesc,
}

func (e InstalledSoftwareOrderBy) IsValid() bool {
	switch e {
	case InstalledSoftwareOrderByNameAsc, InstalledSoftwareOrderByNameDesc, InstalledSoftwareOrderByVersionAsc, InstalledSoftwareOrderByVersionDesc, InstalledSoftwareOrderByDescriptionAsc, InstalledSoftwareOrderByDescriptionDesc, InstalledSoftwareOrderByVendorAsc, InstalledSoftwareOrderByVendorDesc, InstalledSoftwareOrderByPublisherAsc, InstalledSoftwareOrderByPublisherDesc, InstalledSoftwareOrderByCveCountAsc, InstalledSoftwareOrderByCveCountDesc, InstalledSoftwareOrderBySwLicenseAsc, InstalledSoftwareOrderBySwLicenseDesc, InstalledSoftwareOrderByPathAsc, InstalledSoftwareOrderByPathDesc:
		return true
	}
	return false
}

func (e InstalledSoftwareOrderBy) String() string {
	return string(e)
}

func (e *InstalledSoftwareOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstalledSoftwareOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid installed_software_order_by", str)
	}
	return nil
}

func (e InstalledSoftwareOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InterfacesAggregateColumns string

const (
	// groupBy by deviceId
	InterfacesAggregateColumnsDeviceID InterfacesAggregateColumns = "deviceId"
	// groupBy by macAddr
	InterfacesAggregateColumnsMacAddr InterfacesAggregateColumns = "macAddr"
)

var AllInterfacesAggregateColumns = []InterfacesAggregateColumns{
	InterfacesAggregateColumnsDeviceID,
	InterfacesAggregateColumnsMacAddr,
}

func (e InterfacesAggregateColumns) IsValid() bool {
	switch e {
	case InterfacesAggregateColumnsDeviceID, InterfacesAggregateColumnsMacAddr:
		return true
	}
	return false
}

func (e InterfacesAggregateColumns) String() string {
	return string(e)
}

func (e *InterfacesAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfacesAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid interfaces_aggregate_columns", str)
	}
	return nil
}

func (e InterfacesAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InterfacesAggregateMaxColumns string

const (
	// max by deviceId
	InterfacesAggregateMaxColumnsDeviceID InterfacesAggregateMaxColumns = "deviceId"
	// max by macAddr
	InterfacesAggregateMaxColumnsMacAddr InterfacesAggregateMaxColumns = "macAddr"
)

var AllInterfacesAggregateMaxColumns = []InterfacesAggregateMaxColumns{
	InterfacesAggregateMaxColumnsDeviceID,
	InterfacesAggregateMaxColumnsMacAddr,
}

func (e InterfacesAggregateMaxColumns) IsValid() bool {
	switch e {
	case InterfacesAggregateMaxColumnsDeviceID, InterfacesAggregateMaxColumnsMacAddr:
		return true
	}
	return false
}

func (e InterfacesAggregateMaxColumns) String() string {
	return string(e)
}

func (e *InterfacesAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfacesAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid interfaces_aggregate_max_columns", str)
	}
	return nil
}

func (e InterfacesAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InterfacesAggregateMinColumns string

const (
	// min by deviceId
	InterfacesAggregateMinColumnsDeviceID InterfacesAggregateMinColumns = "deviceId"
	// min by macAddr
	InterfacesAggregateMinColumnsMacAddr InterfacesAggregateMinColumns = "macAddr"
)

var AllInterfacesAggregateMinColumns = []InterfacesAggregateMinColumns{
	InterfacesAggregateMinColumnsDeviceID,
	InterfacesAggregateMinColumnsMacAddr,
}

func (e InterfacesAggregateMinColumns) IsValid() bool {
	switch e {
	case InterfacesAggregateMinColumnsDeviceID, InterfacesAggregateMinColumnsMacAddr:
		return true
	}
	return false
}

func (e InterfacesAggregateMinColumns) String() string {
	return string(e)
}

func (e *InterfacesAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfacesAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid interfaces_aggregate_min_columns", str)
	}
	return nil
}

func (e InterfacesAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for OperatingSystem
type OperatingSystemOrderBy string

const (
	// Order by type in an ascending order
	OperatingSystemOrderByTypeAsc OperatingSystemOrderBy = "type_ASC"
	// Order by type in a descending order
	OperatingSystemOrderByTypeDesc OperatingSystemOrderBy = "type_DESC"
	// Order by distribution in an ascending order
	OperatingSystemOrderByDistributionAsc OperatingSystemOrderBy = "distribution_ASC"
	// Order by distribution in a descending order
	OperatingSystemOrderByDistributionDesc OperatingSystemOrderBy = "distribution_DESC"
	// Order by architecture in an ascending order
	OperatingSystemOrderByArchitectureAsc OperatingSystemOrderBy = "architecture_ASC"
	// Order by architecture in a descending order
	OperatingSystemOrderByArchitectureDesc OperatingSystemOrderBy = "architecture_DESC"
	// Order by servicePack in an ascending order
	OperatingSystemOrderByServicePackAsc OperatingSystemOrderBy = "servicePack_ASC"
	// Order by servicePack in a descending order
	OperatingSystemOrderByServicePackDesc OperatingSystemOrderBy = "servicePack_DESC"
	// Order by installDate in an ascending order
	OperatingSystemOrderByInstallDateAsc OperatingSystemOrderBy = "installDate_ASC"
	// Order by installDate in a descending order
	OperatingSystemOrderByInstallDateDesc OperatingSystemOrderBy = "installDate_DESC"
	// Order by kernelVersion in an ascending order
	OperatingSystemOrderByKernelVersionAsc OperatingSystemOrderBy = "kernelVersion_ASC"
	// Order by kernelVersion in a descending order
	OperatingSystemOrderByKernelVersionDesc OperatingSystemOrderBy = "kernelVersion_DESC"
	// Order by codeName in an ascending order
	OperatingSystemOrderByCodeNameAsc OperatingSystemOrderBy = "codeName_ASC"
	// Order by codeName in a descending order
	OperatingSystemOrderByCodeNameDesc OperatingSystemOrderBy = "codeName_DESC"
	// Order by major in an ascending order
	OperatingSystemOrderByMajorAsc OperatingSystemOrderBy = "major_ASC"
	// Order by major in a descending order
	OperatingSystemOrderByMajorDesc OperatingSystemOrderBy = "major_DESC"
	// Order by minor in an ascending order
	OperatingSystemOrderByMinorAsc OperatingSystemOrderBy = "minor_ASC"
	// Order by minor in a descending order
	OperatingSystemOrderByMinorDesc OperatingSystemOrderBy = "minor_DESC"
	// Order by build in an ascending order
	OperatingSystemOrderByBuildAsc OperatingSystemOrderBy = "build_ASC"
	// Order by build in a descending order
	OperatingSystemOrderByBuildDesc OperatingSystemOrderBy = "build_DESC"
	// Order by RawName in an ascending order
	OperatingSystemOrderByRawNameAsc OperatingSystemOrderBy = "RawName_ASC"
	// Order by RawName in a descending order
	OperatingSystemOrderByRawNameDesc OperatingSystemOrderBy = "RawName_DESC"
)

var AllOperatingSystemOrderBy = []OperatingSystemOrderBy{
	OperatingSystemOrderByTypeAsc,
	OperatingSystemOrderByTypeDesc,
	OperatingSystemOrderByDistributionAsc,
	OperatingSystemOrderByDistributionDesc,
	OperatingSystemOrderByArchitectureAsc,
	OperatingSystemOrderByArchitectureDesc,
	OperatingSystemOrderByServicePackAsc,
	OperatingSystemOrderByServicePackDesc,
	OperatingSystemOrderByInstallDateAsc,
	OperatingSystemOrderByInstallDateDesc,
	OperatingSystemOrderByKernelVersionAsc,
	OperatingSystemOrderByKernelVersionDesc,
	OperatingSystemOrderByCodeNameAsc,
	OperatingSystemOrderByCodeNameDesc,
	OperatingSystemOrderByMajorAsc,
	OperatingSystemOrderByMajorDesc,
	OperatingSystemOrderByMinorAsc,
	OperatingSystemOrderByMinorDesc,
	OperatingSystemOrderByBuildAsc,
	OperatingSystemOrderByBuildDesc,
	OperatingSystemOrderByRawNameAsc,
	OperatingSystemOrderByRawNameDesc,
}

func (e OperatingSystemOrderBy) IsValid() bool {
	switch e {
	case OperatingSystemOrderByTypeAsc, OperatingSystemOrderByTypeDesc, OperatingSystemOrderByDistributionAsc, OperatingSystemOrderByDistributionDesc, OperatingSystemOrderByArchitectureAsc, OperatingSystemOrderByArchitectureDesc, OperatingSystemOrderByServicePackAsc, OperatingSystemOrderByServicePackDesc, OperatingSystemOrderByInstallDateAsc, OperatingSystemOrderByInstallDateDesc, OperatingSystemOrderByKernelVersionAsc, OperatingSystemOrderByKernelVersionDesc, OperatingSystemOrderByCodeNameAsc, OperatingSystemOrderByCodeNameDesc, OperatingSystemOrderByMajorAsc, OperatingSystemOrderByMajorDesc, OperatingSystemOrderByMinorAsc, OperatingSystemOrderByMinorDesc, OperatingSystemOrderByBuildAsc, OperatingSystemOrderByBuildDesc, OperatingSystemOrderByRawNameAsc, OperatingSystemOrderByRawNameDesc:
		return true
	}
	return false
}

func (e OperatingSystemOrderBy) String() string {
	return string(e)
}

func (e *OperatingSystemOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperatingSystemOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid operating_system_order_by", str)
	}
	return nil
}

func (e OperatingSystemOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PreventionSettingsAggregateColumns string

const (
	// groupBy by name
	PreventionSettingsAggregateColumnsName PreventionSettingsAggregateColumns = "name"
)

var AllPreventionSettingsAggregateColumns = []PreventionSettingsAggregateColumns{
	PreventionSettingsAggregateColumnsName,
}

func (e PreventionSettingsAggregateColumns) IsValid() bool {
	switch e {
	case PreventionSettingsAggregateColumnsName:
		return true
	}
	return false
}

func (e PreventionSettingsAggregateColumns) String() string {
	return string(e)
}

func (e *PreventionSettingsAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PreventionSettingsAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid preventionSettings_aggregate_columns", str)
	}
	return nil
}

func (e PreventionSettingsAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PreventionSettingsAggregateMaxColumns string

const (
	// max by name
	PreventionSettingsAggregateMaxColumnsName PreventionSettingsAggregateMaxColumns = "name"
)

var AllPreventionSettingsAggregateMaxColumns = []PreventionSettingsAggregateMaxColumns{
	PreventionSettingsAggregateMaxColumnsName,
}

func (e PreventionSettingsAggregateMaxColumns) IsValid() bool {
	switch e {
	case PreventionSettingsAggregateMaxColumnsName:
		return true
	}
	return false
}

func (e PreventionSettingsAggregateMaxColumns) String() string {
	return string(e)
}

func (e *PreventionSettingsAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PreventionSettingsAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid preventionSettings_aggregate_max_columns", str)
	}
	return nil
}

func (e PreventionSettingsAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PreventionSettingsAggregateMinColumns string

const (
	// min by name
	PreventionSettingsAggregateMinColumnsName PreventionSettingsAggregateMinColumns = "name"
)

var AllPreventionSettingsAggregateMinColumns = []PreventionSettingsAggregateMinColumns{
	PreventionSettingsAggregateMinColumnsName,
}

func (e PreventionSettingsAggregateMinColumns) IsValid() bool {
	switch e {
	case PreventionSettingsAggregateMinColumnsName:
		return true
	}
	return false
}

func (e PreventionSettingsAggregateMinColumns) String() string {
	return string(e)
}

func (e *PreventionSettingsAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PreventionSettingsAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid preventionSettings_aggregate_min_columns", str)
	}
	return nil
}

func (e PreventionSettingsAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SensorUpdateSettingsAggregateColumns string

const (
	// groupBy by build
	SensorUpdateSettingsAggregateColumnsBuild SensorUpdateSettingsAggregateColumns = "build"
)

var AllSensorUpdateSettingsAggregateColumns = []SensorUpdateSettingsAggregateColumns{
	SensorUpdateSettingsAggregateColumnsBuild,
}

func (e SensorUpdateSettingsAggregateColumns) IsValid() bool {
	switch e {
	case SensorUpdateSettingsAggregateColumnsBuild:
		return true
	}
	return false
}

func (e SensorUpdateSettingsAggregateColumns) String() string {
	return string(e)
}

func (e *SensorUpdateSettingsAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SensorUpdateSettingsAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sensorUpdateSettings_aggregate_columns", str)
	}
	return nil
}

func (e SensorUpdateSettingsAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SensorUpdateSettingsAggregateMaxColumns string

const (
	// max by build
	SensorUpdateSettingsAggregateMaxColumnsBuild SensorUpdateSettingsAggregateMaxColumns = "build"
)

var AllSensorUpdateSettingsAggregateMaxColumns = []SensorUpdateSettingsAggregateMaxColumns{
	SensorUpdateSettingsAggregateMaxColumnsBuild,
}

func (e SensorUpdateSettingsAggregateMaxColumns) IsValid() bool {
	switch e {
	case SensorUpdateSettingsAggregateMaxColumnsBuild:
		return true
	}
	return false
}

func (e SensorUpdateSettingsAggregateMaxColumns) String() string {
	return string(e)
}

func (e *SensorUpdateSettingsAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SensorUpdateSettingsAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sensorUpdateSettings_aggregate_max_columns", str)
	}
	return nil
}

func (e SensorUpdateSettingsAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SensorUpdateSettingsAggregateMinColumns string

const (
	// min by build
	SensorUpdateSettingsAggregateMinColumnsBuild SensorUpdateSettingsAggregateMinColumns = "build"
)

var AllSensorUpdateSettingsAggregateMinColumns = []SensorUpdateSettingsAggregateMinColumns{
	SensorUpdateSettingsAggregateMinColumnsBuild,
}

func (e SensorUpdateSettingsAggregateMinColumns) IsValid() bool {
	switch e {
	case SensorUpdateSettingsAggregateMinColumnsBuild:
		return true
	}
	return false
}

func (e SensorUpdateSettingsAggregateMinColumns) String() string {
	return string(e)
}

func (e *SensorUpdateSettingsAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SensorUpdateSettingsAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sensorUpdateSettings_aggregate_min_columns", str)
	}
	return nil
}

func (e SensorUpdateSettingsAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for Tag
type TagOrderBy string

const (
	// Order by name in an ascending order
	TagOrderByNameAsc TagOrderBy = "name_ASC"
	// Order by name in a descending order
	TagOrderByNameDesc TagOrderBy = "name_DESC"
	// Order by creator in an ascending order
	TagOrderByCreatorAsc TagOrderBy = "creator_ASC"
	// Order by creator in a descending order
	TagOrderByCreatorDesc TagOrderBy = "creator_DESC"
	// Order by level in an ascending order
	TagOrderByLevelAsc TagOrderBy = "level_ASC"
	// Order by level in a descending order
	TagOrderByLevelDesc TagOrderBy = "level_DESC"
)

var AllTagOrderBy = []TagOrderBy{
	TagOrderByNameAsc,
	TagOrderByNameDesc,
	TagOrderByCreatorAsc,
	TagOrderByCreatorDesc,
	TagOrderByLevelAsc,
	TagOrderByLevelDesc,
}

func (e TagOrderBy) IsValid() bool {
	switch e {
	case TagOrderByNameAsc, TagOrderByNameDesc, TagOrderByCreatorAsc, TagOrderByCreatorDesc, TagOrderByLevelAsc, TagOrderByLevelDesc:
		return true
	}
	return false
}

func (e TagOrderBy) String() string {
	return string(e)
}

func (e *TagOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tag_order_by", str)
	}
	return nil
}

func (e TagOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagsAggregateColumns string

const (
	// groupBy by name
	TagsAggregateColumnsName TagsAggregateColumns = "name"
	// groupBy by creator
	TagsAggregateColumnsCreator TagsAggregateColumns = "creator"
	// groupBy by level
	TagsAggregateColumnsLevel TagsAggregateColumns = "level"
)

var AllTagsAggregateColumns = []TagsAggregateColumns{
	TagsAggregateColumnsName,
	TagsAggregateColumnsCreator,
	TagsAggregateColumnsLevel,
}

func (e TagsAggregateColumns) IsValid() bool {
	switch e {
	case TagsAggregateColumnsName, TagsAggregateColumnsCreator, TagsAggregateColumnsLevel:
		return true
	}
	return false
}

func (e TagsAggregateColumns) String() string {
	return string(e)
}

func (e *TagsAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagsAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tags_aggregate_columns", str)
	}
	return nil
}

func (e TagsAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagsAggregateMaxColumns string

const (
	// max by name
	TagsAggregateMaxColumnsName TagsAggregateMaxColumns = "name"
	// max by creator
	TagsAggregateMaxColumnsCreator TagsAggregateMaxColumns = "creator"
	// max by level
	TagsAggregateMaxColumnsLevel TagsAggregateMaxColumns = "level"
)

var AllTagsAggregateMaxColumns = []TagsAggregateMaxColumns{
	TagsAggregateMaxColumnsName,
	TagsAggregateMaxColumnsCreator,
	TagsAggregateMaxColumnsLevel,
}

func (e TagsAggregateMaxColumns) IsValid() bool {
	switch e {
	case TagsAggregateMaxColumnsName, TagsAggregateMaxColumnsCreator, TagsAggregateMaxColumnsLevel:
		return true
	}
	return false
}

func (e TagsAggregateMaxColumns) String() string {
	return string(e)
}

func (e *TagsAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagsAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tags_aggregate_max_columns", str)
	}
	return nil
}

func (e TagsAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagsAggregateMinColumns string

const (
	// min by name
	TagsAggregateMinColumnsName TagsAggregateMinColumns = "name"
	// min by creator
	TagsAggregateMinColumnsCreator TagsAggregateMinColumns = "creator"
	// min by level
	TagsAggregateMinColumnsLevel TagsAggregateMinColumns = "level"
)

var AllTagsAggregateMinColumns = []TagsAggregateMinColumns{
	TagsAggregateMinColumnsName,
	TagsAggregateMinColumnsCreator,
	TagsAggregateMinColumnsLevel,
}

func (e TagsAggregateMinColumns) IsValid() bool {
	switch e {
	case TagsAggregateMinColumnsName, TagsAggregateMinColumnsCreator, TagsAggregateMinColumnsLevel:
		return true
	}
	return false
}

func (e TagsAggregateMinColumns) String() string {
	return string(e)
}

func (e *TagsAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagsAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tags_aggregate_min_columns", str)
	}
	return nil
}

func (e TagsAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order for User
type UserOrderBy string

const (
	// Order by fetchCycle in an ascending order
	UserOrderByFetchCycleAsc UserOrderBy = "fetchCycle_ASC"
	// Order by fetchCycle in a descending order
	UserOrderByFetchCycleDesc UserOrderBy = "fetchCycle_DESC"
	// Order by adapterCount in an ascending order
	UserOrderByAdapterCountAsc UserOrderBy = "adapterCount_ASC"
	// Order by adapterCount in a descending order
	UserOrderByAdapterCountDesc UserOrderBy = "adapterCount_DESC"
	// Order by lastSeen in an ascending order
	UserOrderByLastSeenAsc UserOrderBy = "lastSeen_ASC"
	// Order by lastSeen in a descending order
	UserOrderByLastSeenDesc UserOrderBy = "lastSeen_DESC"
)

var AllUserOrderBy = []UserOrderBy{
	UserOrderByFetchCycleAsc,
	UserOrderByFetchCycleDesc,
	UserOrderByAdapterCountAsc,
	UserOrderByAdapterCountDesc,
	UserOrderByLastSeenAsc,
	UserOrderByLastSeenDesc,
}

func (e UserOrderBy) IsValid() bool {
	switch e {
	case UserOrderByFetchCycleAsc, UserOrderByFetchCycleDesc, UserOrderByAdapterCountAsc, UserOrderByAdapterCountDesc, UserOrderByLastSeenAsc, UserOrderByLastSeenDesc:
		return true
	}
	return false
}

func (e UserOrderBy) String() string {
	return string(e)
}

func (e *UserOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid user_order_by", str)
	}
	return nil
}

func (e UserOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsersAggregateAvgColumns string

const (
	// avg by fetchCycle
	UsersAggregateAvgColumnsFetchCycle UsersAggregateAvgColumns = "fetchCycle"
	// avg by adapterCount
	UsersAggregateAvgColumnsAdapterCount UsersAggregateAvgColumns = "adapterCount"
	// avg by lastSeen
	UsersAggregateAvgColumnsLastSeen UsersAggregateAvgColumns = "lastSeen"
)

var AllUsersAggregateAvgColumns = []UsersAggregateAvgColumns{
	UsersAggregateAvgColumnsFetchCycle,
	UsersAggregateAvgColumnsAdapterCount,
	UsersAggregateAvgColumnsLastSeen,
}

func (e UsersAggregateAvgColumns) IsValid() bool {
	switch e {
	case UsersAggregateAvgColumnsFetchCycle, UsersAggregateAvgColumnsAdapterCount, UsersAggregateAvgColumnsLastSeen:
		return true
	}
	return false
}

func (e UsersAggregateAvgColumns) String() string {
	return string(e)
}

func (e *UsersAggregateAvgColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersAggregateAvgColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_aggregate_avg_columns", str)
	}
	return nil
}

func (e UsersAggregateAvgColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsersAggregateColumns string

const (
	// groupBy by id
	UsersAggregateColumnsID UsersAggregateColumns = "id"
	// groupBy by fetchCycle
	UsersAggregateColumnsFetchCycle UsersAggregateColumns = "fetchCycle"
	// groupBy by adapterCount
	UsersAggregateColumnsAdapterCount UsersAggregateColumns = "adapterCount"
	// groupBy by lastSeen
	UsersAggregateColumnsLastSeen UsersAggregateColumns = "lastSeen"
)

var AllUsersAggregateColumns = []UsersAggregateColumns{
	UsersAggregateColumnsID,
	UsersAggregateColumnsFetchCycle,
	UsersAggregateColumnsAdapterCount,
	UsersAggregateColumnsLastSeen,
}

func (e UsersAggregateColumns) IsValid() bool {
	switch e {
	case UsersAggregateColumnsID, UsersAggregateColumnsFetchCycle, UsersAggregateColumnsAdapterCount, UsersAggregateColumnsLastSeen:
		return true
	}
	return false
}

func (e UsersAggregateColumns) String() string {
	return string(e)
}

func (e *UsersAggregateColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersAggregateColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_aggregate_columns", str)
	}
	return nil
}

func (e UsersAggregateColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsersAggregateMaxColumns string

const (
	// max by id
	UsersAggregateMaxColumnsID UsersAggregateMaxColumns = "id"
	// max by fetchCycle
	UsersAggregateMaxColumnsFetchCycle UsersAggregateMaxColumns = "fetchCycle"
	// max by adapterCount
	UsersAggregateMaxColumnsAdapterCount UsersAggregateMaxColumns = "adapterCount"
	// max by lastSeen
	UsersAggregateMaxColumnsLastSeen UsersAggregateMaxColumns = "lastSeen"
)

var AllUsersAggregateMaxColumns = []UsersAggregateMaxColumns{
	UsersAggregateMaxColumnsID,
	UsersAggregateMaxColumnsFetchCycle,
	UsersAggregateMaxColumnsAdapterCount,
	UsersAggregateMaxColumnsLastSeen,
}

func (e UsersAggregateMaxColumns) IsValid() bool {
	switch e {
	case UsersAggregateMaxColumnsID, UsersAggregateMaxColumnsFetchCycle, UsersAggregateMaxColumnsAdapterCount, UsersAggregateMaxColumnsLastSeen:
		return true
	}
	return false
}

func (e UsersAggregateMaxColumns) String() string {
	return string(e)
}

func (e *UsersAggregateMaxColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersAggregateMaxColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_aggregate_max_columns", str)
	}
	return nil
}

func (e UsersAggregateMaxColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsersAggregateMinColumns string

const (
	// min by id
	UsersAggregateMinColumnsID UsersAggregateMinColumns = "id"
	// min by fetchCycle
	UsersAggregateMinColumnsFetchCycle UsersAggregateMinColumns = "fetchCycle"
	// min by adapterCount
	UsersAggregateMinColumnsAdapterCount UsersAggregateMinColumns = "adapterCount"
	// min by lastSeen
	UsersAggregateMinColumnsLastSeen UsersAggregateMinColumns = "lastSeen"
)

var AllUsersAggregateMinColumns = []UsersAggregateMinColumns{
	UsersAggregateMinColumnsID,
	UsersAggregateMinColumnsFetchCycle,
	UsersAggregateMinColumnsAdapterCount,
	UsersAggregateMinColumnsLastSeen,
}

func (e UsersAggregateMinColumns) IsValid() bool {
	switch e {
	case UsersAggregateMinColumnsID, UsersAggregateMinColumnsFetchCycle, UsersAggregateMinColumnsAdapterCount, UsersAggregateMinColumnsLastSeen:
		return true
	}
	return false
}

func (e UsersAggregateMinColumns) String() string {
	return string(e)
}

func (e *UsersAggregateMinColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersAggregateMinColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_aggregate_min_columns", str)
	}
	return nil
}

func (e UsersAggregateMinColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsersAggregateSumColumns string

const (
	// sum by fetchCycle
	UsersAggregateSumColumnsFetchCycle UsersAggregateSumColumns = "fetchCycle"
	// sum by adapterCount
	UsersAggregateSumColumnsAdapterCount UsersAggregateSumColumns = "adapterCount"
	// sum by lastSeen
	UsersAggregateSumColumnsLastSeen UsersAggregateSumColumns = "lastSeen"
)

var AllUsersAggregateSumColumns = []UsersAggregateSumColumns{
	UsersAggregateSumColumnsFetchCycle,
	UsersAggregateSumColumnsAdapterCount,
	UsersAggregateSumColumnsLastSeen,
}

func (e UsersAggregateSumColumns) IsValid() bool {
	switch e {
	case UsersAggregateSumColumnsFetchCycle, UsersAggregateSumColumnsAdapterCount, UsersAggregateSumColumnsLastSeen:
		return true
	}
	return false
}

func (e UsersAggregateSumColumns) String() string {
	return string(e)
}

func (e *UsersAggregateSumColumns) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersAggregateSumColumns(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_aggregate_sum_columns", str)
	}
	return nil
}

func (e UsersAggregateSumColumns) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
