// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bandicoot/internal"
	"bandicoot/pkg/domain"
	"bytes"
	"context"
	"errors"
	"fmt"
	"net"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/satori/go.uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AdapterDevice() AdapterDeviceResolver
	AdapterUser() AdapterUserResolver
	Device() DeviceResolver
	Query() QueryResolver
	User() UserResolver
}

type DirectiveRoot struct {
	GenerateInputs func(ctx context.Context, obj interface{}, next graphql.Resolver, where *string, orderBy *string) (res interface{}, err error)
	Jsonpath       func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string, depends []*string) (res interface{}, err error)
	Relation       func(ctx context.Context, obj interface{}, next graphql.Resolver, name string, fkName []string, relationFkName []string, relType string, manyToManyTableName *string, joinOn []string) (res interface{}, err error)
	ViewFunction   func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string, arguments []*string) (res interface{}, err error)
}

type ComplexityRoot struct {
	ActiveDirectoryData struct {
		AdAccountExpires          func(childComplexity int) int
		AdBadPasswordTime         func(childComplexity int) int
		AdBadPwdCount             func(childComplexity int) int
		AdCanonicalName           func(childComplexity int) int
		AdCn                      func(childComplexity int) int
		AdDisplayName             func(childComplexity int) int
		AdDistinguishedName       func(childComplexity int) int
		AdGUID                    func(childComplexity int) int
		AdIsCriticalSystemObject  func(childComplexity int) int
		AdLastLogoff              func(childComplexity int) int
		AdLastLogon               func(childComplexity int) int
		AdLastLogonTimestamp      func(childComplexity int) int
		AdManagedBy               func(childComplexity int) int
		AdMemberOf                func(childComplexity int) int
		AdMemberOfFull            func(childComplexity int) int
		AdMsdsAllowedToDelegateTo func(childComplexity int) int
		AdMsdsResultantPso        func(childComplexity int) int
		AdName                    func(childComplexity int) int
		AdObjectCategory          func(childComplexity int) int
		AdObjectClass             func(childComplexity int) int
		AdOrganizationalUnit      func(childComplexity int) int
		AdPasswordLastSet         func(childComplexity int) int
		AdPrimaryGroupDn          func(childComplexity int) int
		AdPrimaryGroupID          func(childComplexity int) int
		AdPwdMustChange           func(childComplexity int) int
		AdSAMAccountName          func(childComplexity int) int
		AdSid                     func(childComplexity int) int
		AdUserPrincipalName       func(childComplexity int) int
		AdUsnChanged              func(childComplexity int) int
		AdUsnCreated              func(childComplexity int) int
		AdWhenChanged             func(childComplexity int) int
		AdWhenCreated             func(childComplexity int) int
	}

	Adapter struct {
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		Properties func(childComplexity int) int
	}

	AdapterDevice struct {
		Adapter                    func(childComplexity int, where *AdapterBoolExp) int
		AdapterData                func(childComplexity int, where *AdapterDataBoolExp) int
		AdapterID                  func(childComplexity int) int
		AdapterName                func(childComplexity int) int
		AgentName                  func(childComplexity int) int
		AgentStatus                func(childComplexity int) int
		AgentVersion               func(childComplexity int) int
		BiosSerial                 func(childComplexity int) int
		BiosVersion                func(childComplexity int) int
		Data                       func(childComplexity int) int
		DeviceID                   func(childComplexity int) int
		DeviceUsers                func(childComplexity int, limit *int, offset *int, where *AdapterDeviceUserBoolExp) int
		Domain                     func(childComplexity int) int
		Family                     func(childComplexity int) int
		FetchCycle                 func(childComplexity int) int
		FetchTime                  func(childComplexity int) int
		FirewallRules              func(childComplexity int, limit *int, offset *int, where *FirewallRuleBoolExp) int
		FirewallRulesAggregate     func(childComplexity int, groupBy []FirewallRulesAggregateColumns, distinctOn []FirewallRulesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *FirewallRuleBoolExp) int
		Hostname                   func(childComplexity int) int
		ID                         func(childComplexity int) int
		InstalledSoftware          func(childComplexity int, limit *int, offset *int, where *InstalledSoftwareBoolExp) int
		InstalledSoftwareAggregate func(childComplexity int, groupBy []InstalledSoftwareAggregateColumns, distinctOn []InstalledSoftwareAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *InstalledSoftwareBoolExp) int
		Interfaces                 func(childComplexity int, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		InterfacesAggregate        func(childComplexity int, groupBy []InterfacesAggregateColumns, distinctOn []InterfacesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		LastSeen                   func(childComplexity int) int
		LastUsedUsers              func(childComplexity int) int
		LocalAdmins                func(childComplexity int, limit *int, offset *int, where *AdapterDeviceAdminBoolExp) int
		Manufacturer               func(childComplexity int) int
		Model                      func(childComplexity int) int
		Name                       func(childComplexity int) int
		Os                         func(childComplexity int, where *OperatingSystemBoolExp) int
		OsID                       func(childComplexity int) int
		PartOfDomain               func(childComplexity int) int
		PrettyID                   func(childComplexity int) int
		Serial                     func(childComplexity int) int
		Tags                       func(childComplexity int, limit *int, offset *int, where *TagBoolExp) int
		TagsAggregate              func(childComplexity int, groupBy []TagsAggregateColumns, distinctOn []TagsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *TagBoolExp) int
	}

	AdapterDeviceAdmin struct {
		Name func(childComplexity int) int
		Type func(childComplexity int) int
	}

	AdapterDeviceUser struct {
		DeviceID       func(childComplexity int) int
		Interpreter    func(childComplexity int) int
		IsAdmin        func(childComplexity int) int
		IsDisabled     func(childComplexity int) int
		IsLocal        func(childComplexity int) int
		LastUseDate    func(childComplexity int) int
		PasswordMaxAge func(childComplexity int) int
		Sid            func(childComplexity int) int
		UserDepartment func(childComplexity int) int
		Username       func(childComplexity int) int
	}

	AdapterUser struct {
		Adapter        func(childComplexity int, where *AdapterBoolExp) int
		AdapterData    func(childComplexity int, where *AdapterDataBoolExp) int
		AdapterID      func(childComplexity int) int
		AdapterName    func(childComplexity int) int
		Admin          func(childComplexity int) int
		Data           func(childComplexity int) int
		DelegatedAdmin func(childComplexity int) int
		Disabled       func(childComplexity int) int
		FetchCycle     func(childComplexity int) int
		FetchTime      func(childComplexity int) int
		FirstName      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastName       func(childComplexity int) int
		LastSeen       func(childComplexity int) int
		Local          func(childComplexity int) int
		Locked         func(childComplexity int) int
		Mail           func(childComplexity int) int
		MfaEnforced    func(childComplexity int) int
		MfaEnrolled    func(childComplexity int) int
		Suspended      func(childComplexity int) int
		UserID         func(childComplexity int) int
		Username       func(childComplexity int) int
	}

	CPU struct {
		Bitness      func(childComplexity int) int
		Cores        func(childComplexity int) int
		CoresThreads func(childComplexity int) int
		Family       func(childComplexity int) int
		Ghz          func(childComplexity int) int
		ID           func(childComplexity int) int
		Manfacturer  func(childComplexity int) int
		Name         func(childComplexity int) int
	}

	CrowdStrikeData struct {
		CsAgentVersion     func(childComplexity int) int
		ExternalIP         func(childComplexity int) int
		Groups             func(childComplexity int, limit *int, offset *int, where *CsGroupBoolExp) int
		GroupsAggregate    func(childComplexity int, groupBy []GroupsAggregateColumns, distinctOn []GroupsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsGroupBoolExp) int
		PreventionPolicy   func(childComplexity int, where *CsPolicyBoolExp) int
		SensorUpdatePolicy func(childComplexity int, where *CsGroupBoolExp) int
	}

	CylanceData struct {
		AgentVersion    func(childComplexity int) int
		DeviceState     func(childComplexity int) int
		IsSafe          func(childComplexity int) int
		PoliciesDetails func(childComplexity int) int
		PolicyID        func(childComplexity int) int
		PolicyName      func(childComplexity int) int
		TenantTag       func(childComplexity int) int
		ZoneNames       func(childComplexity int) int
	}

	Device struct {
		AdapterCount            func(childComplexity int) int
		AdapterDevices          func(childComplexity int, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		AdapterDevicesAggregate func(childComplexity int, groupBy []AdapterDevicesAggregateColumns, distinctOn []AdapterDevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		AdapterNames            func(childComplexity int) int
		CompatibilityAPI        func(childComplexity int) int
		FetchCycle              func(childComplexity int) int
		Hostnames               func(childComplexity int) int
		ID                      func(childComplexity int) int
		Interfaces              func(childComplexity int, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		InterfacesAggregate     func(childComplexity int, groupBy []InterfacesAggregateColumns, distinctOn []InterfacesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		LastSeen                func(childComplexity int) int
		Tags                    func(childComplexity int, limit *int, offset *int, where *TagBoolExp) int
		TagsAggregate           func(childComplexity int, groupBy []TagsAggregateColumns, distinctOn []TagsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *TagBoolExp) int
	}

	FirewallRule struct {
		Direction func(childComplexity int) int
		DstPort   func(childComplexity int) int
		Name      func(childComplexity int) int
		Protocol  func(childComplexity int) int
		Source    func(childComplexity int) int
		SrcPort   func(childComplexity int) int
		Target    func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	GCETagsAggregate struct {
		Avg      func(childComplexity int) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		GCETags  func(childComplexity int, limit *int, offset *int, where *GceTagsBoolExp) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []GCETagsAggregateMaxColumns) int
		Min      func(childComplexity int, column []GCETagsAggregateMinColumns) int
		Sum      func(childComplexity int) int
	}

	GceTags struct {
		GceKey   func(childComplexity int) int
		GceValue func(childComplexity int) int
	}

	GoogleCloudData struct {
		GCETags          func(childComplexity int, limit *int, offset *int, where *GceTagsBoolExp) int
		GCETagsAggregate func(childComplexity int, groupBy []GCETagsAggregateColumns, distinctOn []GCETagsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *GceTagsBoolExp) int
		ID               func(childComplexity int) int
		Image            func(childComplexity int) int
		Size             func(childComplexity int) int
	}

	InstalledSoftware struct {
		Architecture func(childComplexity int) int
		CveCount     func(childComplexity int) int
		Description  func(childComplexity int) int
		Name         func(childComplexity int) int
		Path         func(childComplexity int) int
		Publisher    func(childComplexity int) int
		SwLicense    func(childComplexity int) int
		Vendor       func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	NetworkInterface struct {
		DeviceID func(childComplexity int) int
		IPAddrs  func(childComplexity int) int
		MacAddr  func(childComplexity int) int
	}

	OperatingSystem struct {
		Architecture  func(childComplexity int) int
		Build         func(childComplexity int) int
		CodeName      func(childComplexity int) int
		Distribution  func(childComplexity int) int
		ID            func(childComplexity int) int
		InstallDate   func(childComplexity int) int
		KernelVersion func(childComplexity int) int
		Major         func(childComplexity int) int
		Minor         func(childComplexity int) int
		RawName       func(childComplexity int) int
		ServicePack   func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	Query struct {
		AdapterDevices          func(childComplexity int, limit *int, offset *int, where *AdapterDeviceBoolExp, orderBy []AdapterDeviceOrderBy) int
		AdapterDevicesAggregate func(childComplexity int, groupBy []AdapterDevicesAggregateColumns, distinctOn []AdapterDevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		AdapterUsers            func(childComplexity int, limit *int, offset *int, where *AdapterUserBoolExp, orderBy []AdapterUserOrderBy) int
		AdapterUsersAggregate   func(childComplexity int, groupBy []AdapterUsersAggregateColumns, distinctOn []AdapterUsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterUserBoolExp) int
		Devices                 func(childComplexity int, limit *int, offset *int, where *DeviceBoolExp, orderBy []DeviceOrderBy) int
		DevicesAggregate        func(childComplexity int, groupBy []DevicesAggregateColumns, distinctOn []DevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *DeviceBoolExp) int
		Users                   func(childComplexity int, limit *int, offset *int, where *UserBoolExp, orderBy []UserOrderBy) int
		UsersAggregate          func(childComplexity int, groupBy []UsersAggregateColumns, distinctOn []UsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *UserBoolExp) int
	}

	Storage struct {
		Description func(childComplexity int) int
		DeviceID    func(childComplexity int) int
		FreeSize    func(childComplexity int) int
		IsEncrypted func(childComplexity int) int
		Name        func(childComplexity int) int
		Path        func(childComplexity int) int
		TotalSize   func(childComplexity int) int
	}

	Tag struct {
		Creator func(childComplexity int) int
		Level   func(childComplexity int) int
		Name    func(childComplexity int) int
	}

	User struct {
		AdapterCount          func(childComplexity int) int
		AdapterNames          func(childComplexity int) int
		AdapterUsers          func(childComplexity int, limit *int, offset *int, where *AdapterUserBoolExp) int
		AdapterUsersAggregate func(childComplexity int, groupBy []AdapterUsersAggregateColumns, distinctOn []AdapterUsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterUserBoolExp) int
		CompatibilityAPI      func(childComplexity int) int
		FetchCycle            func(childComplexity int) int
		ID                    func(childComplexity int) int
		LastSeen              func(childComplexity int) int
		Usernames             func(childComplexity int) int
	}

	AdapterDevicesAggregate struct {
		AdapterDevices func(childComplexity int, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		Avg            func(childComplexity int, column []AdapterDevicesAggregateAvgColumns) int
		Count          func(childComplexity int) int
		Distinct       func(childComplexity int) int
		Group          func(childComplexity int) int
		Max            func(childComplexity int, column []AdapterDevicesAggregateMaxColumns) int
		Min            func(childComplexity int, column []AdapterDevicesAggregateMinColumns) int
		Sum            func(childComplexity int, column []AdapterDevicesAggregateSumColumns) int
	}

	AdapterUsersAggregate struct {
		AdapterUsers func(childComplexity int, limit *int, offset *int, where *AdapterUserBoolExp) int
		Avg          func(childComplexity int, column []AdapterUsersAggregateAvgColumns) int
		Count        func(childComplexity int) int
		Distinct     func(childComplexity int) int
		Group        func(childComplexity int) int
		Max          func(childComplexity int, column []AdapterUsersAggregateMaxColumns) int
		Min          func(childComplexity int, column []AdapterUsersAggregateMinColumns) int
		Sum          func(childComplexity int, column []AdapterUsersAggregateSumColumns) int
	}

	CsGroup struct {
		CreatedBy        func(childComplexity int) int
		CreatedTimestamp func(childComplexity int) int
		Description      func(childComplexity int) int
		GroupType        func(childComplexity int) int
		ID               func(childComplexity int) int
		ModifiedBy       func(childComplexity int) int
		ModifiedTime     func(childComplexity int) int
		Name             func(childComplexity int) int
	}

	CsPolicy struct {
		CreatedBy                     func(childComplexity int) int
		CreatedTime                   func(childComplexity int) int
		Description                   func(childComplexity int) int
		Enabled                       func(childComplexity int) int
		Groups                        func(childComplexity int, limit *int, offset *int, where *CsGroupBoolExp) int
		GroupsAggregate               func(childComplexity int, groupBy []GroupsAggregateColumns, distinctOn []GroupsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsGroupBoolExp) int
		Name                          func(childComplexity int) int
		PlatformName                  func(childComplexity int) int
		PreventionSettings            func(childComplexity int, limit *int, offset *int, where *CsPreventionSettingsBoolExp) int
		PreventionSettingsAggregate   func(childComplexity int, groupBy []PreventionSettingsAggregateColumns, distinctOn []PreventionSettingsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsPreventionSettingsBoolExp) int
		SensorUpdateSettings          func(childComplexity int, limit *int, offset *int, where *CsSensorUpdateSettingsBoolExp) int
		SensorUpdateSettingsAggregate func(childComplexity int, groupBy []SensorUpdateSettingsAggregateColumns, distinctOn []SensorUpdateSettingsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsSensorUpdateSettingsBoolExp) int
	}

	CsPolicySettings struct {
		Enabled func(childComplexity int) int
	}

	CsPreventionSettings struct {
		Name     func(childComplexity int) int
		Settings func(childComplexity int, limit *int, offset *int, where *CsPolicySettingsBoolExp) int
	}

	CsSensorUpdateSettings struct {
		Build func(childComplexity int) int
	}

	DevicesAggregate struct {
		Avg      func(childComplexity int, column []DevicesAggregateAvgColumns) int
		Count    func(childComplexity int) int
		Devices  func(childComplexity int, limit *int, offset *int, where *DeviceBoolExp) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []DevicesAggregateMaxColumns) int
		Min      func(childComplexity int, column []DevicesAggregateMinColumns) int
		Sum      func(childComplexity int, column []DevicesAggregateSumColumns) int
	}

	FirewallRulesAggregate struct {
		Avg           func(childComplexity int, column []FirewallRulesAggregateAvgColumns) int
		Count         func(childComplexity int) int
		Distinct      func(childComplexity int) int
		FirewallRules func(childComplexity int, limit *int, offset *int, where *FirewallRuleBoolExp) int
		Group         func(childComplexity int) int
		Max           func(childComplexity int, column []FirewallRulesAggregateMaxColumns) int
		Min           func(childComplexity int, column []FirewallRulesAggregateMinColumns) int
		Sum           func(childComplexity int, column []FirewallRulesAggregateSumColumns) int
	}

	GroupsAggregate struct {
		Avg      func(childComplexity int, column []GroupsAggregateAvgColumns) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Groups   func(childComplexity int, limit *int, offset *int, where *CsGroupBoolExp) int
		Max      func(childComplexity int, column []GroupsAggregateMaxColumns) int
		Min      func(childComplexity int, column []GroupsAggregateMinColumns) int
		Sum      func(childComplexity int, column []GroupsAggregateSumColumns) int
	}

	InstalledSoftwareAggregate struct {
		Avg               func(childComplexity int, column []InstalledSoftwareAggregateAvgColumns) int
		Count             func(childComplexity int) int
		Distinct          func(childComplexity int) int
		Group             func(childComplexity int) int
		InstalledSoftware func(childComplexity int, limit *int, offset *int, where *InstalledSoftwareBoolExp) int
		Max               func(childComplexity int, column []InstalledSoftwareAggregateMaxColumns) int
		Min               func(childComplexity int, column []InstalledSoftwareAggregateMinColumns) int
		Sum               func(childComplexity int, column []InstalledSoftwareAggregateSumColumns) int
	}

	InterfacesAggregate struct {
		Avg        func(childComplexity int) int
		Count      func(childComplexity int) int
		Distinct   func(childComplexity int) int
		Group      func(childComplexity int) int
		Interfaces func(childComplexity int, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		Max        func(childComplexity int, column []InterfacesAggregateMaxColumns) int
		Min        func(childComplexity int, column []InterfacesAggregateMinColumns) int
		Sum        func(childComplexity int) int
	}

	PreventionSettingsAggregate struct {
		Avg                func(childComplexity int) int
		Count              func(childComplexity int) int
		Distinct           func(childComplexity int) int
		Group              func(childComplexity int) int
		Max                func(childComplexity int, column []PreventionSettingsAggregateMaxColumns) int
		Min                func(childComplexity int, column []PreventionSettingsAggregateMinColumns) int
		PreventionSettings func(childComplexity int, limit *int, offset *int, where *CsPreventionSettingsBoolExp) int
		Sum                func(childComplexity int) int
	}

	SensorUpdateSettingsAggregate struct {
		Avg                  func(childComplexity int) int
		Count                func(childComplexity int) int
		Distinct             func(childComplexity int) int
		Group                func(childComplexity int) int
		Max                  func(childComplexity int, column []SensorUpdateSettingsAggregateMaxColumns) int
		Min                  func(childComplexity int, column []SensorUpdateSettingsAggregateMinColumns) int
		SensorUpdateSettings func(childComplexity int, limit *int, offset *int, where *CsSensorUpdateSettingsBoolExp) int
		Sum                  func(childComplexity int) int
	}

	TagsAggregate struct {
		Avg      func(childComplexity int) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []TagsAggregateMaxColumns) int
		Min      func(childComplexity int, column []TagsAggregateMinColumns) int
		Sum      func(childComplexity int) int
		Tags     func(childComplexity int, limit *int, offset *int, where *TagBoolExp) int
	}

	UsersAggregate struct {
		Avg      func(childComplexity int, column []UsersAggregateAvgColumns) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []UsersAggregateMaxColumns) int
		Min      func(childComplexity int, column []UsersAggregateMinColumns) int
		Sum      func(childComplexity int, column []UsersAggregateSumColumns) int
		Users    func(childComplexity int, limit *int, offset *int, where *UserBoolExp) int
	}
}

type AdapterDeviceResolver interface {
	AdapterData(ctx context.Context, obj *AdapterDevice, where *AdapterDataBoolExp) (AdapterData, error)
}
type AdapterUserResolver interface {
	AdapterData(ctx context.Context, obj *AdapterUser, where *AdapterDataBoolExp) (AdapterData, error)
}
type DeviceResolver interface {
	CompatibilityAPI(ctx context.Context, obj *Device) (map[string]interface{}, error)
}
type QueryResolver interface {
	AdapterDevices(ctx context.Context, limit *int, offset *int, where *AdapterDeviceBoolExp, orderBy []AdapterDeviceOrderBy) ([]AdapterDevice, error)
	Devices(ctx context.Context, limit *int, offset *int, where *DeviceBoolExp, orderBy []DeviceOrderBy) ([]Device, error)
	AdapterUsers(ctx context.Context, limit *int, offset *int, where *AdapterUserBoolExp, orderBy []AdapterUserOrderBy) ([]AdapterUser, error)
	Users(ctx context.Context, limit *int, offset *int, where *UserBoolExp, orderBy []UserOrderBy) ([]User, error)
	AdapterDevicesAggregate(ctx context.Context, groupBy []AdapterDevicesAggregateColumns, distinctOn []AdapterDevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterDeviceBoolExp) ([]AdapterDevicesAggregate, error)
	DevicesAggregate(ctx context.Context, groupBy []DevicesAggregateColumns, distinctOn []DevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *DeviceBoolExp) ([]DevicesAggregate, error)
	AdapterUsersAggregate(ctx context.Context, groupBy []AdapterUsersAggregateColumns, distinctOn []AdapterUsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterUserBoolExp) ([]AdapterUsersAggregate, error)
	UsersAggregate(ctx context.Context, groupBy []UsersAggregateColumns, distinctOn []UsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *UserBoolExp) ([]UsersAggregate, error)
}
type UserResolver interface {
	CompatibilityAPI(ctx context.Context, obj *User) (map[string]interface{}, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "ActiveDirectoryData.adAccountExpires":
		if e.complexity.ActiveDirectoryData.AdAccountExpires == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdAccountExpires(childComplexity), true

	case "ActiveDirectoryData.adBadPasswordTime":
		if e.complexity.ActiveDirectoryData.AdBadPasswordTime == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdBadPasswordTime(childComplexity), true

	case "ActiveDirectoryData.ad_bad_pwd_count":
		if e.complexity.ActiveDirectoryData.AdBadPwdCount == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdBadPwdCount(childComplexity), true

	case "ActiveDirectoryData.adCanonicalName":
		if e.complexity.ActiveDirectoryData.AdCanonicalName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdCanonicalName(childComplexity), true

	case "ActiveDirectoryData.adCn":
		if e.complexity.ActiveDirectoryData.AdCn == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdCn(childComplexity), true

	case "ActiveDirectoryData.adDisplayName":
		if e.complexity.ActiveDirectoryData.AdDisplayName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdDisplayName(childComplexity), true

	case "ActiveDirectoryData.adDistinguishedName":
		if e.complexity.ActiveDirectoryData.AdDistinguishedName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdDistinguishedName(childComplexity), true

	case "ActiveDirectoryData.adGuid":
		if e.complexity.ActiveDirectoryData.AdGUID == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdGUID(childComplexity), true

	case "ActiveDirectoryData.adIsCriticalSystemObject":
		if e.complexity.ActiveDirectoryData.AdIsCriticalSystemObject == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdIsCriticalSystemObject(childComplexity), true

	case "ActiveDirectoryData.adLastLogoff":
		if e.complexity.ActiveDirectoryData.AdLastLogoff == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdLastLogoff(childComplexity), true

	case "ActiveDirectoryData.adLastLogon":
		if e.complexity.ActiveDirectoryData.AdLastLogon == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdLastLogon(childComplexity), true

	case "ActiveDirectoryData.adLastLogonTimestamp":
		if e.complexity.ActiveDirectoryData.AdLastLogonTimestamp == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdLastLogonTimestamp(childComplexity), true

	case "ActiveDirectoryData.adManagedBy":
		if e.complexity.ActiveDirectoryData.AdManagedBy == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdManagedBy(childComplexity), true

	case "ActiveDirectoryData.adMemberOf":
		if e.complexity.ActiveDirectoryData.AdMemberOf == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMemberOf(childComplexity), true

	case "ActiveDirectoryData.adMemberOfFull":
		if e.complexity.ActiveDirectoryData.AdMemberOfFull == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMemberOfFull(childComplexity), true

	case "ActiveDirectoryData.adMsdsAllowedToDelegateTo":
		if e.complexity.ActiveDirectoryData.AdMsdsAllowedToDelegateTo == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMsdsAllowedToDelegateTo(childComplexity), true

	case "ActiveDirectoryData.adMsdsResultantPso":
		if e.complexity.ActiveDirectoryData.AdMsdsResultantPso == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMsdsResultantPso(childComplexity), true

	case "ActiveDirectoryData.adName":
		if e.complexity.ActiveDirectoryData.AdName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdName(childComplexity), true

	case "ActiveDirectoryData.adObjectCategory":
		if e.complexity.ActiveDirectoryData.AdObjectCategory == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdObjectCategory(childComplexity), true

	case "ActiveDirectoryData.adObjectClass":
		if e.complexity.ActiveDirectoryData.AdObjectClass == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdObjectClass(childComplexity), true

	case "ActiveDirectoryData.adOrganizationalUnit":
		if e.complexity.ActiveDirectoryData.AdOrganizationalUnit == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdOrganizationalUnit(childComplexity), true

	case "ActiveDirectoryData.adPasswordLastSet":
		if e.complexity.ActiveDirectoryData.AdPasswordLastSet == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPasswordLastSet(childComplexity), true

	case "ActiveDirectoryData.adPrimaryGroupDn":
		if e.complexity.ActiveDirectoryData.AdPrimaryGroupDn == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPrimaryGroupDn(childComplexity), true

	case "ActiveDirectoryData.adPrimaryGroupId":
		if e.complexity.ActiveDirectoryData.AdPrimaryGroupID == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPrimaryGroupID(childComplexity), true

	case "ActiveDirectoryData.adPwdMustChange":
		if e.complexity.ActiveDirectoryData.AdPwdMustChange == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPwdMustChange(childComplexity), true

	case "ActiveDirectoryData.adSAMAccountName":
		if e.complexity.ActiveDirectoryData.AdSAMAccountName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdSAMAccountName(childComplexity), true

	case "ActiveDirectoryData.adSid":
		if e.complexity.ActiveDirectoryData.AdSid == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdSid(childComplexity), true

	case "ActiveDirectoryData.adUserPrincipalName":
		if e.complexity.ActiveDirectoryData.AdUserPrincipalName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdUserPrincipalName(childComplexity), true

	case "ActiveDirectoryData.adUsnChanged":
		if e.complexity.ActiveDirectoryData.AdUsnChanged == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdUsnChanged(childComplexity), true

	case "ActiveDirectoryData.adUsnCreated":
		if e.complexity.ActiveDirectoryData.AdUsnCreated == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdUsnCreated(childComplexity), true

	case "ActiveDirectoryData.adWhenChanged":
		if e.complexity.ActiveDirectoryData.AdWhenChanged == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdWhenChanged(childComplexity), true

	case "ActiveDirectoryData.adWhenCreated":
		if e.complexity.ActiveDirectoryData.AdWhenCreated == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdWhenCreated(childComplexity), true

	case "Adapter.id":
		if e.complexity.Adapter.ID == nil {
			break
		}

		return e.complexity.Adapter.ID(childComplexity), true

	case "Adapter.name":
		if e.complexity.Adapter.Name == nil {
			break
		}

		return e.complexity.Adapter.Name(childComplexity), true

	case "Adapter.properties":
		if e.complexity.Adapter.Properties == nil {
			break
		}

		return e.complexity.Adapter.Properties(childComplexity), true

	case "AdapterDevice.adapter":
		if e.complexity.AdapterDevice.Adapter == nil {
			break
		}

		args, err := ec.field_AdapterDevice_adapter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Adapter(childComplexity, args["where"].(*AdapterBoolExp)), true

	case "AdapterDevice.adapterData":
		if e.complexity.AdapterDevice.AdapterData == nil {
			break
		}

		args, err := ec.field_AdapterDevice_adapterData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.AdapterData(childComplexity, args["where"].(*AdapterDataBoolExp)), true

	case "AdapterDevice.adapterId":
		if e.complexity.AdapterDevice.AdapterID == nil {
			break
		}

		return e.complexity.AdapterDevice.AdapterID(childComplexity), true

	case "AdapterDevice.adapterName":
		if e.complexity.AdapterDevice.AdapterName == nil {
			break
		}

		return e.complexity.AdapterDevice.AdapterName(childComplexity), true

	case "AdapterDevice.agentName":
		if e.complexity.AdapterDevice.AgentName == nil {
			break
		}

		return e.complexity.AdapterDevice.AgentName(childComplexity), true

	case "AdapterDevice.agentStatus":
		if e.complexity.AdapterDevice.AgentStatus == nil {
			break
		}

		return e.complexity.AdapterDevice.AgentStatus(childComplexity), true

	case "AdapterDevice.agentVersion":
		if e.complexity.AdapterDevice.AgentVersion == nil {
			break
		}

		return e.complexity.AdapterDevice.AgentVersion(childComplexity), true

	case "AdapterDevice.biosSerial":
		if e.complexity.AdapterDevice.BiosSerial == nil {
			break
		}

		return e.complexity.AdapterDevice.BiosSerial(childComplexity), true

	case "AdapterDevice.biosVersion":
		if e.complexity.AdapterDevice.BiosVersion == nil {
			break
		}

		return e.complexity.AdapterDevice.BiosVersion(childComplexity), true

	case "AdapterDevice.data":
		if e.complexity.AdapterDevice.Data == nil {
			break
		}

		return e.complexity.AdapterDevice.Data(childComplexity), true

	case "AdapterDevice.deviceId":
		if e.complexity.AdapterDevice.DeviceID == nil {
			break
		}

		return e.complexity.AdapterDevice.DeviceID(childComplexity), true

	case "AdapterDevice.deviceUsers":
		if e.complexity.AdapterDevice.DeviceUsers == nil {
			break
		}

		args, err := ec.field_AdapterDevice_deviceUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.DeviceUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceUserBoolExp)), true

	case "AdapterDevice.domain":
		if e.complexity.AdapterDevice.Domain == nil {
			break
		}

		return e.complexity.AdapterDevice.Domain(childComplexity), true

	case "AdapterDevice.family":
		if e.complexity.AdapterDevice.Family == nil {
			break
		}

		return e.complexity.AdapterDevice.Family(childComplexity), true

	case "AdapterDevice.fetchCycle":
		if e.complexity.AdapterDevice.FetchCycle == nil {
			break
		}

		return e.complexity.AdapterDevice.FetchCycle(childComplexity), true

	case "AdapterDevice.fetchTime":
		if e.complexity.AdapterDevice.FetchTime == nil {
			break
		}

		return e.complexity.AdapterDevice.FetchTime(childComplexity), true

	case "AdapterDevice.firewallRules":
		if e.complexity.AdapterDevice.FirewallRules == nil {
			break
		}

		args, err := ec.field_AdapterDevice_firewallRules_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.FirewallRules(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*FirewallRuleBoolExp)), true

	case "AdapterDevice.firewallRules_aggregate":
		if e.complexity.AdapterDevice.FirewallRulesAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_firewallRules_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.FirewallRulesAggregate(childComplexity, args["groupBy"].([]FirewallRulesAggregateColumns), args["distinctOn"].([]FirewallRulesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*FirewallRuleBoolExp)), true

	case "AdapterDevice.hostname":
		if e.complexity.AdapterDevice.Hostname == nil {
			break
		}

		return e.complexity.AdapterDevice.Hostname(childComplexity), true

	case "AdapterDevice.id":
		if e.complexity.AdapterDevice.ID == nil {
			break
		}

		return e.complexity.AdapterDevice.ID(childComplexity), true

	case "AdapterDevice.installedSoftware":
		if e.complexity.AdapterDevice.InstalledSoftware == nil {
			break
		}

		args, err := ec.field_AdapterDevice_installedSoftware_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.InstalledSoftware(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*InstalledSoftwareBoolExp)), true

	case "AdapterDevice.installedSoftware_aggregate":
		if e.complexity.AdapterDevice.InstalledSoftwareAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_installedSoftware_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.InstalledSoftwareAggregate(childComplexity, args["groupBy"].([]InstalledSoftwareAggregateColumns), args["distinctOn"].([]InstalledSoftwareAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*InstalledSoftwareBoolExp)), true

	case "AdapterDevice.interfaces":
		if e.complexity.AdapterDevice.Interfaces == nil {
			break
		}

		args, err := ec.field_AdapterDevice_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Interfaces(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "AdapterDevice.interfaces_aggregate":
		if e.complexity.AdapterDevice.InterfacesAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_interfaces_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.InterfacesAggregate(childComplexity, args["groupBy"].([]InterfacesAggregateColumns), args["distinctOn"].([]InterfacesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "AdapterDevice.lastSeen":
		if e.complexity.AdapterDevice.LastSeen == nil {
			break
		}

		return e.complexity.AdapterDevice.LastSeen(childComplexity), true

	case "AdapterDevice.lastUsedUsers":
		if e.complexity.AdapterDevice.LastUsedUsers == nil {
			break
		}

		return e.complexity.AdapterDevice.LastUsedUsers(childComplexity), true

	case "AdapterDevice.localAdmins":
		if e.complexity.AdapterDevice.LocalAdmins == nil {
			break
		}

		args, err := ec.field_AdapterDevice_localAdmins_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.LocalAdmins(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceAdminBoolExp)), true

	case "AdapterDevice.manufacturer":
		if e.complexity.AdapterDevice.Manufacturer == nil {
			break
		}

		return e.complexity.AdapterDevice.Manufacturer(childComplexity), true

	case "AdapterDevice.model":
		if e.complexity.AdapterDevice.Model == nil {
			break
		}

		return e.complexity.AdapterDevice.Model(childComplexity), true

	case "AdapterDevice.name":
		if e.complexity.AdapterDevice.Name == nil {
			break
		}

		return e.complexity.AdapterDevice.Name(childComplexity), true

	case "AdapterDevice.os":
		if e.complexity.AdapterDevice.Os == nil {
			break
		}

		args, err := ec.field_AdapterDevice_os_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Os(childComplexity, args["where"].(*OperatingSystemBoolExp)), true

	case "AdapterDevice.osId":
		if e.complexity.AdapterDevice.OsID == nil {
			break
		}

		return e.complexity.AdapterDevice.OsID(childComplexity), true

	case "AdapterDevice.partOfDomain":
		if e.complexity.AdapterDevice.PartOfDomain == nil {
			break
		}

		return e.complexity.AdapterDevice.PartOfDomain(childComplexity), true

	case "AdapterDevice.prettyId":
		if e.complexity.AdapterDevice.PrettyID == nil {
			break
		}

		return e.complexity.AdapterDevice.PrettyID(childComplexity), true

	case "AdapterDevice.serial":
		if e.complexity.AdapterDevice.Serial == nil {
			break
		}

		return e.complexity.AdapterDevice.Serial(childComplexity), true

	case "AdapterDevice.tags":
		if e.complexity.AdapterDevice.Tags == nil {
			break
		}

		args, err := ec.field_AdapterDevice_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Tags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "AdapterDevice.tags_aggregate":
		if e.complexity.AdapterDevice.TagsAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_tags_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.TagsAggregate(childComplexity, args["groupBy"].([]TagsAggregateColumns), args["distinctOn"].([]TagsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "AdapterDeviceAdmin.name":
		if e.complexity.AdapterDeviceAdmin.Name == nil {
			break
		}

		return e.complexity.AdapterDeviceAdmin.Name(childComplexity), true

	case "AdapterDeviceAdmin.type":
		if e.complexity.AdapterDeviceAdmin.Type == nil {
			break
		}

		return e.complexity.AdapterDeviceAdmin.Type(childComplexity), true

	case "AdapterDeviceUser.deviceId":
		if e.complexity.AdapterDeviceUser.DeviceID == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.DeviceID(childComplexity), true

	case "AdapterDeviceUser.interpreter":
		if e.complexity.AdapterDeviceUser.Interpreter == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.Interpreter(childComplexity), true

	case "AdapterDeviceUser.isAdmin":
		if e.complexity.AdapterDeviceUser.IsAdmin == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.IsAdmin(childComplexity), true

	case "AdapterDeviceUser.isDisabled":
		if e.complexity.AdapterDeviceUser.IsDisabled == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.IsDisabled(childComplexity), true

	case "AdapterDeviceUser.isLocal":
		if e.complexity.AdapterDeviceUser.IsLocal == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.IsLocal(childComplexity), true

	case "AdapterDeviceUser.lastUseDate":
		if e.complexity.AdapterDeviceUser.LastUseDate == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.LastUseDate(childComplexity), true

	case "AdapterDeviceUser.passwordMaxAge":
		if e.complexity.AdapterDeviceUser.PasswordMaxAge == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.PasswordMaxAge(childComplexity), true

	case "AdapterDeviceUser.sid":
		if e.complexity.AdapterDeviceUser.Sid == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.Sid(childComplexity), true

	case "AdapterDeviceUser.userDepartment":
		if e.complexity.AdapterDeviceUser.UserDepartment == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.UserDepartment(childComplexity), true

	case "AdapterDeviceUser.username":
		if e.complexity.AdapterDeviceUser.Username == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.Username(childComplexity), true

	case "AdapterUser.adapter":
		if e.complexity.AdapterUser.Adapter == nil {
			break
		}

		args, err := ec.field_AdapterUser_adapter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUser.Adapter(childComplexity, args["where"].(*AdapterBoolExp)), true

	case "AdapterUser.adapterData":
		if e.complexity.AdapterUser.AdapterData == nil {
			break
		}

		args, err := ec.field_AdapterUser_adapterData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUser.AdapterData(childComplexity, args["where"].(*AdapterDataBoolExp)), true

	case "AdapterUser.adapterId":
		if e.complexity.AdapterUser.AdapterID == nil {
			break
		}

		return e.complexity.AdapterUser.AdapterID(childComplexity), true

	case "AdapterUser.adapterName":
		if e.complexity.AdapterUser.AdapterName == nil {
			break
		}

		return e.complexity.AdapterUser.AdapterName(childComplexity), true

	case "AdapterUser.admin":
		if e.complexity.AdapterUser.Admin == nil {
			break
		}

		return e.complexity.AdapterUser.Admin(childComplexity), true

	case "AdapterUser.data":
		if e.complexity.AdapterUser.Data == nil {
			break
		}

		return e.complexity.AdapterUser.Data(childComplexity), true

	case "AdapterUser.delegated_admin":
		if e.complexity.AdapterUser.DelegatedAdmin == nil {
			break
		}

		return e.complexity.AdapterUser.DelegatedAdmin(childComplexity), true

	case "AdapterUser.disabled":
		if e.complexity.AdapterUser.Disabled == nil {
			break
		}

		return e.complexity.AdapterUser.Disabled(childComplexity), true

	case "AdapterUser.fetchCycle":
		if e.complexity.AdapterUser.FetchCycle == nil {
			break
		}

		return e.complexity.AdapterUser.FetchCycle(childComplexity), true

	case "AdapterUser.fetchTime":
		if e.complexity.AdapterUser.FetchTime == nil {
			break
		}

		return e.complexity.AdapterUser.FetchTime(childComplexity), true

	case "AdapterUser.firstName":
		if e.complexity.AdapterUser.FirstName == nil {
			break
		}

		return e.complexity.AdapterUser.FirstName(childComplexity), true

	case "AdapterUser.id":
		if e.complexity.AdapterUser.ID == nil {
			break
		}

		return e.complexity.AdapterUser.ID(childComplexity), true

	case "AdapterUser.lastName":
		if e.complexity.AdapterUser.LastName == nil {
			break
		}

		return e.complexity.AdapterUser.LastName(childComplexity), true

	case "AdapterUser.lastSeen":
		if e.complexity.AdapterUser.LastSeen == nil {
			break
		}

		return e.complexity.AdapterUser.LastSeen(childComplexity), true

	case "AdapterUser.local":
		if e.complexity.AdapterUser.Local == nil {
			break
		}

		return e.complexity.AdapterUser.Local(childComplexity), true

	case "AdapterUser.locked":
		if e.complexity.AdapterUser.Locked == nil {
			break
		}

		return e.complexity.AdapterUser.Locked(childComplexity), true

	case "AdapterUser.mail":
		if e.complexity.AdapterUser.Mail == nil {
			break
		}

		return e.complexity.AdapterUser.Mail(childComplexity), true

	case "AdapterUser.mfa_enforced":
		if e.complexity.AdapterUser.MfaEnforced == nil {
			break
		}

		return e.complexity.AdapterUser.MfaEnforced(childComplexity), true

	case "AdapterUser.mfa_enrolled":
		if e.complexity.AdapterUser.MfaEnrolled == nil {
			break
		}

		return e.complexity.AdapterUser.MfaEnrolled(childComplexity), true

	case "AdapterUser.suspended":
		if e.complexity.AdapterUser.Suspended == nil {
			break
		}

		return e.complexity.AdapterUser.Suspended(childComplexity), true

	case "AdapterUser.userId":
		if e.complexity.AdapterUser.UserID == nil {
			break
		}

		return e.complexity.AdapterUser.UserID(childComplexity), true

	case "AdapterUser.username":
		if e.complexity.AdapterUser.Username == nil {
			break
		}

		return e.complexity.AdapterUser.Username(childComplexity), true

	case "CPU.bitness":
		if e.complexity.CPU.Bitness == nil {
			break
		}

		return e.complexity.CPU.Bitness(childComplexity), true

	case "CPU.cores":
		if e.complexity.CPU.Cores == nil {
			break
		}

		return e.complexity.CPU.Cores(childComplexity), true

	case "CPU.coresThreads":
		if e.complexity.CPU.CoresThreads == nil {
			break
		}

		return e.complexity.CPU.CoresThreads(childComplexity), true

	case "CPU.family":
		if e.complexity.CPU.Family == nil {
			break
		}

		return e.complexity.CPU.Family(childComplexity), true

	case "CPU.ghz":
		if e.complexity.CPU.Ghz == nil {
			break
		}

		return e.complexity.CPU.Ghz(childComplexity), true

	case "CPU.id":
		if e.complexity.CPU.ID == nil {
			break
		}

		return e.complexity.CPU.ID(childComplexity), true

	case "CPU.manfacturer":
		if e.complexity.CPU.Manfacturer == nil {
			break
		}

		return e.complexity.CPU.Manfacturer(childComplexity), true

	case "CPU.name":
		if e.complexity.CPU.Name == nil {
			break
		}

		return e.complexity.CPU.Name(childComplexity), true

	case "CrowdStrikeData.csAgentVersion":
		if e.complexity.CrowdStrikeData.CsAgentVersion == nil {
			break
		}

		return e.complexity.CrowdStrikeData.CsAgentVersion(childComplexity), true

	case "CrowdStrikeData.externalIp":
		if e.complexity.CrowdStrikeData.ExternalIP == nil {
			break
		}

		return e.complexity.CrowdStrikeData.ExternalIP(childComplexity), true

	case "CrowdStrikeData.groups":
		if e.complexity.CrowdStrikeData.Groups == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_groups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.Groups(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "CrowdStrikeData.groups_aggregate":
		if e.complexity.CrowdStrikeData.GroupsAggregate == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_groups_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.GroupsAggregate(childComplexity, args["groupBy"].([]GroupsAggregateColumns), args["distinctOn"].([]GroupsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "CrowdStrikeData.preventionPolicy":
		if e.complexity.CrowdStrikeData.PreventionPolicy == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_preventionPolicy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.PreventionPolicy(childComplexity, args["where"].(*CsPolicyBoolExp)), true

	case "CrowdStrikeData.sensorUpdatePolicy":
		if e.complexity.CrowdStrikeData.SensorUpdatePolicy == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_sensorUpdatePolicy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.SensorUpdatePolicy(childComplexity, args["where"].(*CsGroupBoolExp)), true

	case "CylanceData.agentVersion":
		if e.complexity.CylanceData.AgentVersion == nil {
			break
		}

		return e.complexity.CylanceData.AgentVersion(childComplexity), true

	case "CylanceData.deviceState":
		if e.complexity.CylanceData.DeviceState == nil {
			break
		}

		return e.complexity.CylanceData.DeviceState(childComplexity), true

	case "CylanceData.isSafe":
		if e.complexity.CylanceData.IsSafe == nil {
			break
		}

		return e.complexity.CylanceData.IsSafe(childComplexity), true

	case "CylanceData.policiesDetails":
		if e.complexity.CylanceData.PoliciesDetails == nil {
			break
		}

		return e.complexity.CylanceData.PoliciesDetails(childComplexity), true

	case "CylanceData.policyId":
		if e.complexity.CylanceData.PolicyID == nil {
			break
		}

		return e.complexity.CylanceData.PolicyID(childComplexity), true

	case "CylanceData.policyName":
		if e.complexity.CylanceData.PolicyName == nil {
			break
		}

		return e.complexity.CylanceData.PolicyName(childComplexity), true

	case "CylanceData.tenantTag":
		if e.complexity.CylanceData.TenantTag == nil {
			break
		}

		return e.complexity.CylanceData.TenantTag(childComplexity), true

	case "CylanceData.zoneNames":
		if e.complexity.CylanceData.ZoneNames == nil {
			break
		}

		return e.complexity.CylanceData.ZoneNames(childComplexity), true

	case "Device.adapterCount":
		if e.complexity.Device.AdapterCount == nil {
			break
		}

		return e.complexity.Device.AdapterCount(childComplexity), true

	case "Device.adapterDevices":
		if e.complexity.Device.AdapterDevices == nil {
			break
		}

		args, err := ec.field_Device_adapterDevices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.AdapterDevices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "Device.adapterDevices_aggregate":
		if e.complexity.Device.AdapterDevicesAggregate == nil {
			break
		}

		args, err := ec.field_Device_adapterDevices_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.AdapterDevicesAggregate(childComplexity, args["groupBy"].([]AdapterDevicesAggregateColumns), args["distinctOn"].([]AdapterDevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "Device.adapterNames":
		if e.complexity.Device.AdapterNames == nil {
			break
		}

		return e.complexity.Device.AdapterNames(childComplexity), true

	case "Device._compatibilityAPI":
		if e.complexity.Device.CompatibilityAPI == nil {
			break
		}

		return e.complexity.Device.CompatibilityAPI(childComplexity), true

	case "Device.fetchCycle":
		if e.complexity.Device.FetchCycle == nil {
			break
		}

		return e.complexity.Device.FetchCycle(childComplexity), true

	case "Device.hostnames":
		if e.complexity.Device.Hostnames == nil {
			break
		}

		return e.complexity.Device.Hostnames(childComplexity), true

	case "Device.id":
		if e.complexity.Device.ID == nil {
			break
		}

		return e.complexity.Device.ID(childComplexity), true

	case "Device.interfaces":
		if e.complexity.Device.Interfaces == nil {
			break
		}

		args, err := ec.field_Device_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.Interfaces(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "Device.interfaces_aggregate":
		if e.complexity.Device.InterfacesAggregate == nil {
			break
		}

		args, err := ec.field_Device_interfaces_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.InterfacesAggregate(childComplexity, args["groupBy"].([]InterfacesAggregateColumns), args["distinctOn"].([]InterfacesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "Device.lastSeen":
		if e.complexity.Device.LastSeen == nil {
			break
		}

		return e.complexity.Device.LastSeen(childComplexity), true

	case "Device.tags":
		if e.complexity.Device.Tags == nil {
			break
		}

		args, err := ec.field_Device_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.Tags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "Device.tags_aggregate":
		if e.complexity.Device.TagsAggregate == nil {
			break
		}

		args, err := ec.field_Device_tags_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.TagsAggregate(childComplexity, args["groupBy"].([]TagsAggregateColumns), args["distinctOn"].([]TagsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "FirewallRule.direction":
		if e.complexity.FirewallRule.Direction == nil {
			break
		}

		return e.complexity.FirewallRule.Direction(childComplexity), true

	case "FirewallRule.dstPort":
		if e.complexity.FirewallRule.DstPort == nil {
			break
		}

		return e.complexity.FirewallRule.DstPort(childComplexity), true

	case "FirewallRule.name":
		if e.complexity.FirewallRule.Name == nil {
			break
		}

		return e.complexity.FirewallRule.Name(childComplexity), true

	case "FirewallRule.protocol":
		if e.complexity.FirewallRule.Protocol == nil {
			break
		}

		return e.complexity.FirewallRule.Protocol(childComplexity), true

	case "FirewallRule.source":
		if e.complexity.FirewallRule.Source == nil {
			break
		}

		return e.complexity.FirewallRule.Source(childComplexity), true

	case "FirewallRule.srcPort":
		if e.complexity.FirewallRule.SrcPort == nil {
			break
		}

		return e.complexity.FirewallRule.SrcPort(childComplexity), true

	case "FirewallRule.target":
		if e.complexity.FirewallRule.Target == nil {
			break
		}

		return e.complexity.FirewallRule.Target(childComplexity), true

	case "FirewallRule.type":
		if e.complexity.FirewallRule.Type == nil {
			break
		}

		return e.complexity.FirewallRule.Type(childComplexity), true

	case "GCETagsAggregate.avg":
		if e.complexity.GCETagsAggregate.Avg == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Avg(childComplexity), true

	case "GCETagsAggregate.count":
		if e.complexity.GCETagsAggregate.Count == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Count(childComplexity), true

	case "GCETagsAggregate.distinct":
		if e.complexity.GCETagsAggregate.Distinct == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Distinct(childComplexity), true

	case "GCETagsAggregate.GCETags":
		if e.complexity.GCETagsAggregate.GCETags == nil {
			break
		}

		args, err := ec.field_GCETagsAggregate_GCETags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GCETagsAggregate.GCETags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*GceTagsBoolExp)), true

	case "GCETagsAggregate.group":
		if e.complexity.GCETagsAggregate.Group == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Group(childComplexity), true

	case "GCETagsAggregate.max":
		if e.complexity.GCETagsAggregate.Max == nil {
			break
		}

		args, err := ec.field_GCETagsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GCETagsAggregate.Max(childComplexity, args["column"].([]GCETagsAggregateMaxColumns)), true

	case "GCETagsAggregate.min":
		if e.complexity.GCETagsAggregate.Min == nil {
			break
		}

		args, err := ec.field_GCETagsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GCETagsAggregate.Min(childComplexity, args["column"].([]GCETagsAggregateMinColumns)), true

	case "GCETagsAggregate.sum":
		if e.complexity.GCETagsAggregate.Sum == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Sum(childComplexity), true

	case "GceTags.gceKey":
		if e.complexity.GceTags.GceKey == nil {
			break
		}

		return e.complexity.GceTags.GceKey(childComplexity), true

	case "GceTags.gceValue":
		if e.complexity.GceTags.GceValue == nil {
			break
		}

		return e.complexity.GceTags.GceValue(childComplexity), true

	case "GoogleCloudData.GCETags":
		if e.complexity.GoogleCloudData.GCETags == nil {
			break
		}

		args, err := ec.field_GoogleCloudData_GCETags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GoogleCloudData.GCETags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*GceTagsBoolExp)), true

	case "GoogleCloudData.GCETags_aggregate":
		if e.complexity.GoogleCloudData.GCETagsAggregate == nil {
			break
		}

		args, err := ec.field_GoogleCloudData_GCETags_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GoogleCloudData.GCETagsAggregate(childComplexity, args["groupBy"].([]GCETagsAggregateColumns), args["distinctOn"].([]GCETagsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*GceTagsBoolExp)), true

	case "GoogleCloudData.Id":
		if e.complexity.GoogleCloudData.ID == nil {
			break
		}

		return e.complexity.GoogleCloudData.ID(childComplexity), true

	case "GoogleCloudData.Image":
		if e.complexity.GoogleCloudData.Image == nil {
			break
		}

		return e.complexity.GoogleCloudData.Image(childComplexity), true

	case "GoogleCloudData.Size":
		if e.complexity.GoogleCloudData.Size == nil {
			break
		}

		return e.complexity.GoogleCloudData.Size(childComplexity), true

	case "InstalledSoftware.architecture":
		if e.complexity.InstalledSoftware.Architecture == nil {
			break
		}

		return e.complexity.InstalledSoftware.Architecture(childComplexity), true

	case "InstalledSoftware.cveCount":
		if e.complexity.InstalledSoftware.CveCount == nil {
			break
		}

		return e.complexity.InstalledSoftware.CveCount(childComplexity), true

	case "InstalledSoftware.description":
		if e.complexity.InstalledSoftware.Description == nil {
			break
		}

		return e.complexity.InstalledSoftware.Description(childComplexity), true

	case "InstalledSoftware.name":
		if e.complexity.InstalledSoftware.Name == nil {
			break
		}

		return e.complexity.InstalledSoftware.Name(childComplexity), true

	case "InstalledSoftware.path":
		if e.complexity.InstalledSoftware.Path == nil {
			break
		}

		return e.complexity.InstalledSoftware.Path(childComplexity), true

	case "InstalledSoftware.publisher":
		if e.complexity.InstalledSoftware.Publisher == nil {
			break
		}

		return e.complexity.InstalledSoftware.Publisher(childComplexity), true

	case "InstalledSoftware.swLicense":
		if e.complexity.InstalledSoftware.SwLicense == nil {
			break
		}

		return e.complexity.InstalledSoftware.SwLicense(childComplexity), true

	case "InstalledSoftware.vendor":
		if e.complexity.InstalledSoftware.Vendor == nil {
			break
		}

		return e.complexity.InstalledSoftware.Vendor(childComplexity), true

	case "InstalledSoftware.version":
		if e.complexity.InstalledSoftware.Version == nil {
			break
		}

		return e.complexity.InstalledSoftware.Version(childComplexity), true

	case "NetworkInterface.deviceId":
		if e.complexity.NetworkInterface.DeviceID == nil {
			break
		}

		return e.complexity.NetworkInterface.DeviceID(childComplexity), true

	case "NetworkInterface.ipAddrs":
		if e.complexity.NetworkInterface.IPAddrs == nil {
			break
		}

		return e.complexity.NetworkInterface.IPAddrs(childComplexity), true

	case "NetworkInterface.macAddr":
		if e.complexity.NetworkInterface.MacAddr == nil {
			break
		}

		return e.complexity.NetworkInterface.MacAddr(childComplexity), true

	case "OperatingSystem.architecture":
		if e.complexity.OperatingSystem.Architecture == nil {
			break
		}

		return e.complexity.OperatingSystem.Architecture(childComplexity), true

	case "OperatingSystem.build":
		if e.complexity.OperatingSystem.Build == nil {
			break
		}

		return e.complexity.OperatingSystem.Build(childComplexity), true

	case "OperatingSystem.codeName":
		if e.complexity.OperatingSystem.CodeName == nil {
			break
		}

		return e.complexity.OperatingSystem.CodeName(childComplexity), true

	case "OperatingSystem.distribution":
		if e.complexity.OperatingSystem.Distribution == nil {
			break
		}

		return e.complexity.OperatingSystem.Distribution(childComplexity), true

	case "OperatingSystem.id":
		if e.complexity.OperatingSystem.ID == nil {
			break
		}

		return e.complexity.OperatingSystem.ID(childComplexity), true

	case "OperatingSystem.installDate":
		if e.complexity.OperatingSystem.InstallDate == nil {
			break
		}

		return e.complexity.OperatingSystem.InstallDate(childComplexity), true

	case "OperatingSystem.kernelVersion":
		if e.complexity.OperatingSystem.KernelVersion == nil {
			break
		}

		return e.complexity.OperatingSystem.KernelVersion(childComplexity), true

	case "OperatingSystem.major":
		if e.complexity.OperatingSystem.Major == nil {
			break
		}

		return e.complexity.OperatingSystem.Major(childComplexity), true

	case "OperatingSystem.minor":
		if e.complexity.OperatingSystem.Minor == nil {
			break
		}

		return e.complexity.OperatingSystem.Minor(childComplexity), true

	case "OperatingSystem.RawName":
		if e.complexity.OperatingSystem.RawName == nil {
			break
		}

		return e.complexity.OperatingSystem.RawName(childComplexity), true

	case "OperatingSystem.servicePack":
		if e.complexity.OperatingSystem.ServicePack == nil {
			break
		}

		return e.complexity.OperatingSystem.ServicePack(childComplexity), true

	case "OperatingSystem.type":
		if e.complexity.OperatingSystem.Type == nil {
			break
		}

		return e.complexity.OperatingSystem.Type(childComplexity), true

	case "Query.adapterDevices":
		if e.complexity.Query.AdapterDevices == nil {
			break
		}

		args, err := ec.field_Query_adapterDevices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterDevices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp), args["orderBy"].([]AdapterDeviceOrderBy)), true

	case "Query.adapterDevices_aggregate":
		if e.complexity.Query.AdapterDevicesAggregate == nil {
			break
		}

		args, err := ec.field_Query_adapterDevices_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterDevicesAggregate(childComplexity, args["groupBy"].([]AdapterDevicesAggregateColumns), args["distinctOn"].([]AdapterDevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "Query.adapterUsers":
		if e.complexity.Query.AdapterUsers == nil {
			break
		}

		args, err := ec.field_Query_adapterUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp), args["orderBy"].([]AdapterUserOrderBy)), true

	case "Query.adapterUsers_aggregate":
		if e.complexity.Query.AdapterUsersAggregate == nil {
			break
		}

		args, err := ec.field_Query_adapterUsers_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterUsersAggregate(childComplexity, args["groupBy"].([]AdapterUsersAggregateColumns), args["distinctOn"].([]AdapterUsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "Query.devices":
		if e.complexity.Query.Devices == nil {
			break
		}

		args, err := ec.field_Query_devices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Devices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp), args["orderBy"].([]DeviceOrderBy)), true

	case "Query.devices_aggregate":
		if e.complexity.Query.DevicesAggregate == nil {
			break
		}

		args, err := ec.field_Query_devices_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DevicesAggregate(childComplexity, args["groupBy"].([]DevicesAggregateColumns), args["distinctOn"].([]DevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp), args["orderBy"].([]UserOrderBy)), true

	case "Query.users_aggregate":
		if e.complexity.Query.UsersAggregate == nil {
			break
		}

		args, err := ec.field_Query_users_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UsersAggregate(childComplexity, args["groupBy"].([]UsersAggregateColumns), args["distinctOn"].([]UsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp)), true

	case "Storage.description":
		if e.complexity.Storage.Description == nil {
			break
		}

		return e.complexity.Storage.Description(childComplexity), true

	case "Storage.deviceId":
		if e.complexity.Storage.DeviceID == nil {
			break
		}

		return e.complexity.Storage.DeviceID(childComplexity), true

	case "Storage.freeSize":
		if e.complexity.Storage.FreeSize == nil {
			break
		}

		return e.complexity.Storage.FreeSize(childComplexity), true

	case "Storage.isEncrypted":
		if e.complexity.Storage.IsEncrypted == nil {
			break
		}

		return e.complexity.Storage.IsEncrypted(childComplexity), true

	case "Storage.name":
		if e.complexity.Storage.Name == nil {
			break
		}

		return e.complexity.Storage.Name(childComplexity), true

	case "Storage.path":
		if e.complexity.Storage.Path == nil {
			break
		}

		return e.complexity.Storage.Path(childComplexity), true

	case "Storage.totalSize":
		if e.complexity.Storage.TotalSize == nil {
			break
		}

		return e.complexity.Storage.TotalSize(childComplexity), true

	case "Tag.creator":
		if e.complexity.Tag.Creator == nil {
			break
		}

		return e.complexity.Tag.Creator(childComplexity), true

	case "Tag.level":
		if e.complexity.Tag.Level == nil {
			break
		}

		return e.complexity.Tag.Level(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "User.adapterCount":
		if e.complexity.User.AdapterCount == nil {
			break
		}

		return e.complexity.User.AdapterCount(childComplexity), true

	case "User.adapterNames":
		if e.complexity.User.AdapterNames == nil {
			break
		}

		return e.complexity.User.AdapterNames(childComplexity), true

	case "User.adapterUsers":
		if e.complexity.User.AdapterUsers == nil {
			break
		}

		args, err := ec.field_User_adapterUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.AdapterUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "User.adapterUsers_aggregate":
		if e.complexity.User.AdapterUsersAggregate == nil {
			break
		}

		args, err := ec.field_User_adapterUsers_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.AdapterUsersAggregate(childComplexity, args["groupBy"].([]AdapterUsersAggregateColumns), args["distinctOn"].([]AdapterUsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "User._compatibilityAPI":
		if e.complexity.User.CompatibilityAPI == nil {
			break
		}

		return e.complexity.User.CompatibilityAPI(childComplexity), true

	case "User.fetchCycle":
		if e.complexity.User.FetchCycle == nil {
			break
		}

		return e.complexity.User.FetchCycle(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lastSeen":
		if e.complexity.User.LastSeen == nil {
			break
		}

		return e.complexity.User.LastSeen(childComplexity), true

	case "User.usernames":
		if e.complexity.User.Usernames == nil {
			break
		}

		return e.complexity.User.Usernames(childComplexity), true

	case "adapterDevicesAggregate.adapterDevices":
		if e.complexity.AdapterDevicesAggregate.AdapterDevices == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_adapterDevices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.AdapterDevices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "adapterDevicesAggregate.avg":
		if e.complexity.AdapterDevicesAggregate.Avg == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Avg(childComplexity, args["column"].([]AdapterDevicesAggregateAvgColumns)), true

	case "adapterDevicesAggregate.count":
		if e.complexity.AdapterDevicesAggregate.Count == nil {
			break
		}

		return e.complexity.AdapterDevicesAggregate.Count(childComplexity), true

	case "adapterDevicesAggregate.distinct":
		if e.complexity.AdapterDevicesAggregate.Distinct == nil {
			break
		}

		return e.complexity.AdapterDevicesAggregate.Distinct(childComplexity), true

	case "adapterDevicesAggregate.group":
		if e.complexity.AdapterDevicesAggregate.Group == nil {
			break
		}

		return e.complexity.AdapterDevicesAggregate.Group(childComplexity), true

	case "adapterDevicesAggregate.max":
		if e.complexity.AdapterDevicesAggregate.Max == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Max(childComplexity, args["column"].([]AdapterDevicesAggregateMaxColumns)), true

	case "adapterDevicesAggregate.min":
		if e.complexity.AdapterDevicesAggregate.Min == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Min(childComplexity, args["column"].([]AdapterDevicesAggregateMinColumns)), true

	case "adapterDevicesAggregate.sum":
		if e.complexity.AdapterDevicesAggregate.Sum == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Sum(childComplexity, args["column"].([]AdapterDevicesAggregateSumColumns)), true

	case "adapterUsersAggregate.adapterUsers":
		if e.complexity.AdapterUsersAggregate.AdapterUsers == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_adapterUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.AdapterUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "adapterUsersAggregate.avg":
		if e.complexity.AdapterUsersAggregate.Avg == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Avg(childComplexity, args["column"].([]AdapterUsersAggregateAvgColumns)), true

	case "adapterUsersAggregate.count":
		if e.complexity.AdapterUsersAggregate.Count == nil {
			break
		}

		return e.complexity.AdapterUsersAggregate.Count(childComplexity), true

	case "adapterUsersAggregate.distinct":
		if e.complexity.AdapterUsersAggregate.Distinct == nil {
			break
		}

		return e.complexity.AdapterUsersAggregate.Distinct(childComplexity), true

	case "adapterUsersAggregate.group":
		if e.complexity.AdapterUsersAggregate.Group == nil {
			break
		}

		return e.complexity.AdapterUsersAggregate.Group(childComplexity), true

	case "adapterUsersAggregate.max":
		if e.complexity.AdapterUsersAggregate.Max == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Max(childComplexity, args["column"].([]AdapterUsersAggregateMaxColumns)), true

	case "adapterUsersAggregate.min":
		if e.complexity.AdapterUsersAggregate.Min == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Min(childComplexity, args["column"].([]AdapterUsersAggregateMinColumns)), true

	case "adapterUsersAggregate.sum":
		if e.complexity.AdapterUsersAggregate.Sum == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Sum(childComplexity, args["column"].([]AdapterUsersAggregateSumColumns)), true

	case "csGroup.createdBy":
		if e.complexity.CsGroup.CreatedBy == nil {
			break
		}

		return e.complexity.CsGroup.CreatedBy(childComplexity), true

	case "csGroup.createdTimestamp":
		if e.complexity.CsGroup.CreatedTimestamp == nil {
			break
		}

		return e.complexity.CsGroup.CreatedTimestamp(childComplexity), true

	case "csGroup.description":
		if e.complexity.CsGroup.Description == nil {
			break
		}

		return e.complexity.CsGroup.Description(childComplexity), true

	case "csGroup.groupType":
		if e.complexity.CsGroup.GroupType == nil {
			break
		}

		return e.complexity.CsGroup.GroupType(childComplexity), true

	case "csGroup.id":
		if e.complexity.CsGroup.ID == nil {
			break
		}

		return e.complexity.CsGroup.ID(childComplexity), true

	case "csGroup.modifiedBy":
		if e.complexity.CsGroup.ModifiedBy == nil {
			break
		}

		return e.complexity.CsGroup.ModifiedBy(childComplexity), true

	case "csGroup.modifiedTime":
		if e.complexity.CsGroup.ModifiedTime == nil {
			break
		}

		return e.complexity.CsGroup.ModifiedTime(childComplexity), true

	case "csGroup.name":
		if e.complexity.CsGroup.Name == nil {
			break
		}

		return e.complexity.CsGroup.Name(childComplexity), true

	case "csPolicy.createdBy":
		if e.complexity.CsPolicy.CreatedBy == nil {
			break
		}

		return e.complexity.CsPolicy.CreatedBy(childComplexity), true

	case "csPolicy.createdTime":
		if e.complexity.CsPolicy.CreatedTime == nil {
			break
		}

		return e.complexity.CsPolicy.CreatedTime(childComplexity), true

	case "csPolicy.description":
		if e.complexity.CsPolicy.Description == nil {
			break
		}

		return e.complexity.CsPolicy.Description(childComplexity), true

	case "csPolicy.enabled":
		if e.complexity.CsPolicy.Enabled == nil {
			break
		}

		return e.complexity.CsPolicy.Enabled(childComplexity), true

	case "csPolicy.groups":
		if e.complexity.CsPolicy.Groups == nil {
			break
		}

		args, err := ec.field_csPolicy_groups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.Groups(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "csPolicy.groups_aggregate":
		if e.complexity.CsPolicy.GroupsAggregate == nil {
			break
		}

		args, err := ec.field_csPolicy_groups_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.GroupsAggregate(childComplexity, args["groupBy"].([]GroupsAggregateColumns), args["distinctOn"].([]GroupsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "csPolicy.name":
		if e.complexity.CsPolicy.Name == nil {
			break
		}

		return e.complexity.CsPolicy.Name(childComplexity), true

	case "csPolicy.platformName":
		if e.complexity.CsPolicy.PlatformName == nil {
			break
		}

		return e.complexity.CsPolicy.PlatformName(childComplexity), true

	case "csPolicy.preventionSettings":
		if e.complexity.CsPolicy.PreventionSettings == nil {
			break
		}

		args, err := ec.field_csPolicy_preventionSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.PreventionSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPreventionSettingsBoolExp)), true

	case "csPolicy.preventionSettings_aggregate":
		if e.complexity.CsPolicy.PreventionSettingsAggregate == nil {
			break
		}

		args, err := ec.field_csPolicy_preventionSettings_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.PreventionSettingsAggregate(childComplexity, args["groupBy"].([]PreventionSettingsAggregateColumns), args["distinctOn"].([]PreventionSettingsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPreventionSettingsBoolExp)), true

	case "csPolicy.sensorUpdateSettings":
		if e.complexity.CsPolicy.SensorUpdateSettings == nil {
			break
		}

		args, err := ec.field_csPolicy_sensorUpdateSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.SensorUpdateSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsSensorUpdateSettingsBoolExp)), true

	case "csPolicy.sensorUpdateSettings_aggregate":
		if e.complexity.CsPolicy.SensorUpdateSettingsAggregate == nil {
			break
		}

		args, err := ec.field_csPolicy_sensorUpdateSettings_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.SensorUpdateSettingsAggregate(childComplexity, args["groupBy"].([]SensorUpdateSettingsAggregateColumns), args["distinctOn"].([]SensorUpdateSettingsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsSensorUpdateSettingsBoolExp)), true

	case "csPolicySettings.enabled":
		if e.complexity.CsPolicySettings.Enabled == nil {
			break
		}

		return e.complexity.CsPolicySettings.Enabled(childComplexity), true

	case "csPreventionSettings.name":
		if e.complexity.CsPreventionSettings.Name == nil {
			break
		}

		return e.complexity.CsPreventionSettings.Name(childComplexity), true

	case "csPreventionSettings.settings":
		if e.complexity.CsPreventionSettings.Settings == nil {
			break
		}

		args, err := ec.field_csPreventionSettings_settings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPreventionSettings.Settings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPolicySettingsBoolExp)), true

	case "csSensorUpdateSettings.build":
		if e.complexity.CsSensorUpdateSettings.Build == nil {
			break
		}

		return e.complexity.CsSensorUpdateSettings.Build(childComplexity), true

	case "devicesAggregate.avg":
		if e.complexity.DevicesAggregate.Avg == nil {
			break
		}

		args, err := ec.field_devicesAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Avg(childComplexity, args["column"].([]DevicesAggregateAvgColumns)), true

	case "devicesAggregate.count":
		if e.complexity.DevicesAggregate.Count == nil {
			break
		}

		return e.complexity.DevicesAggregate.Count(childComplexity), true

	case "devicesAggregate.devices":
		if e.complexity.DevicesAggregate.Devices == nil {
			break
		}

		args, err := ec.field_devicesAggregate_devices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Devices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp)), true

	case "devicesAggregate.distinct":
		if e.complexity.DevicesAggregate.Distinct == nil {
			break
		}

		return e.complexity.DevicesAggregate.Distinct(childComplexity), true

	case "devicesAggregate.group":
		if e.complexity.DevicesAggregate.Group == nil {
			break
		}

		return e.complexity.DevicesAggregate.Group(childComplexity), true

	case "devicesAggregate.max":
		if e.complexity.DevicesAggregate.Max == nil {
			break
		}

		args, err := ec.field_devicesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Max(childComplexity, args["column"].([]DevicesAggregateMaxColumns)), true

	case "devicesAggregate.min":
		if e.complexity.DevicesAggregate.Min == nil {
			break
		}

		args, err := ec.field_devicesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Min(childComplexity, args["column"].([]DevicesAggregateMinColumns)), true

	case "devicesAggregate.sum":
		if e.complexity.DevicesAggregate.Sum == nil {
			break
		}

		args, err := ec.field_devicesAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Sum(childComplexity, args["column"].([]DevicesAggregateSumColumns)), true

	case "firewallRulesAggregate.avg":
		if e.complexity.FirewallRulesAggregate.Avg == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Avg(childComplexity, args["column"].([]FirewallRulesAggregateAvgColumns)), true

	case "firewallRulesAggregate.count":
		if e.complexity.FirewallRulesAggregate.Count == nil {
			break
		}

		return e.complexity.FirewallRulesAggregate.Count(childComplexity), true

	case "firewallRulesAggregate.distinct":
		if e.complexity.FirewallRulesAggregate.Distinct == nil {
			break
		}

		return e.complexity.FirewallRulesAggregate.Distinct(childComplexity), true

	case "firewallRulesAggregate.firewallRules":
		if e.complexity.FirewallRulesAggregate.FirewallRules == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_firewallRules_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.FirewallRules(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*FirewallRuleBoolExp)), true

	case "firewallRulesAggregate.group":
		if e.complexity.FirewallRulesAggregate.Group == nil {
			break
		}

		return e.complexity.FirewallRulesAggregate.Group(childComplexity), true

	case "firewallRulesAggregate.max":
		if e.complexity.FirewallRulesAggregate.Max == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Max(childComplexity, args["column"].([]FirewallRulesAggregateMaxColumns)), true

	case "firewallRulesAggregate.min":
		if e.complexity.FirewallRulesAggregate.Min == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Min(childComplexity, args["column"].([]FirewallRulesAggregateMinColumns)), true

	case "firewallRulesAggregate.sum":
		if e.complexity.FirewallRulesAggregate.Sum == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Sum(childComplexity, args["column"].([]FirewallRulesAggregateSumColumns)), true

	case "groupsAggregate.avg":
		if e.complexity.GroupsAggregate.Avg == nil {
			break
		}

		args, err := ec.field_groupsAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Avg(childComplexity, args["column"].([]GroupsAggregateAvgColumns)), true

	case "groupsAggregate.count":
		if e.complexity.GroupsAggregate.Count == nil {
			break
		}

		return e.complexity.GroupsAggregate.Count(childComplexity), true

	case "groupsAggregate.distinct":
		if e.complexity.GroupsAggregate.Distinct == nil {
			break
		}

		return e.complexity.GroupsAggregate.Distinct(childComplexity), true

	case "groupsAggregate.group":
		if e.complexity.GroupsAggregate.Group == nil {
			break
		}

		return e.complexity.GroupsAggregate.Group(childComplexity), true

	case "groupsAggregate.groups":
		if e.complexity.GroupsAggregate.Groups == nil {
			break
		}

		args, err := ec.field_groupsAggregate_groups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Groups(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "groupsAggregate.max":
		if e.complexity.GroupsAggregate.Max == nil {
			break
		}

		args, err := ec.field_groupsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Max(childComplexity, args["column"].([]GroupsAggregateMaxColumns)), true

	case "groupsAggregate.min":
		if e.complexity.GroupsAggregate.Min == nil {
			break
		}

		args, err := ec.field_groupsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Min(childComplexity, args["column"].([]GroupsAggregateMinColumns)), true

	case "groupsAggregate.sum":
		if e.complexity.GroupsAggregate.Sum == nil {
			break
		}

		args, err := ec.field_groupsAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Sum(childComplexity, args["column"].([]GroupsAggregateSumColumns)), true

	case "installedSoftwareAggregate.avg":
		if e.complexity.InstalledSoftwareAggregate.Avg == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Avg(childComplexity, args["column"].([]InstalledSoftwareAggregateAvgColumns)), true

	case "installedSoftwareAggregate.count":
		if e.complexity.InstalledSoftwareAggregate.Count == nil {
			break
		}

		return e.complexity.InstalledSoftwareAggregate.Count(childComplexity), true

	case "installedSoftwareAggregate.distinct":
		if e.complexity.InstalledSoftwareAggregate.Distinct == nil {
			break
		}

		return e.complexity.InstalledSoftwareAggregate.Distinct(childComplexity), true

	case "installedSoftwareAggregate.group":
		if e.complexity.InstalledSoftwareAggregate.Group == nil {
			break
		}

		return e.complexity.InstalledSoftwareAggregate.Group(childComplexity), true

	case "installedSoftwareAggregate.installedSoftware":
		if e.complexity.InstalledSoftwareAggregate.InstalledSoftware == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_installedSoftware_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.InstalledSoftware(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*InstalledSoftwareBoolExp)), true

	case "installedSoftwareAggregate.max":
		if e.complexity.InstalledSoftwareAggregate.Max == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Max(childComplexity, args["column"].([]InstalledSoftwareAggregateMaxColumns)), true

	case "installedSoftwareAggregate.min":
		if e.complexity.InstalledSoftwareAggregate.Min == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Min(childComplexity, args["column"].([]InstalledSoftwareAggregateMinColumns)), true

	case "installedSoftwareAggregate.sum":
		if e.complexity.InstalledSoftwareAggregate.Sum == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Sum(childComplexity, args["column"].([]InstalledSoftwareAggregateSumColumns)), true

	case "interfacesAggregate.avg":
		if e.complexity.InterfacesAggregate.Avg == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Avg(childComplexity), true

	case "interfacesAggregate.count":
		if e.complexity.InterfacesAggregate.Count == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Count(childComplexity), true

	case "interfacesAggregate.distinct":
		if e.complexity.InterfacesAggregate.Distinct == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Distinct(childComplexity), true

	case "interfacesAggregate.group":
		if e.complexity.InterfacesAggregate.Group == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Group(childComplexity), true

	case "interfacesAggregate.interfaces":
		if e.complexity.InterfacesAggregate.Interfaces == nil {
			break
		}

		args, err := ec.field_interfacesAggregate_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfacesAggregate.Interfaces(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "interfacesAggregate.max":
		if e.complexity.InterfacesAggregate.Max == nil {
			break
		}

		args, err := ec.field_interfacesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfacesAggregate.Max(childComplexity, args["column"].([]InterfacesAggregateMaxColumns)), true

	case "interfacesAggregate.min":
		if e.complexity.InterfacesAggregate.Min == nil {
			break
		}

		args, err := ec.field_interfacesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfacesAggregate.Min(childComplexity, args["column"].([]InterfacesAggregateMinColumns)), true

	case "interfacesAggregate.sum":
		if e.complexity.InterfacesAggregate.Sum == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Sum(childComplexity), true

	case "preventionSettingsAggregate.avg":
		if e.complexity.PreventionSettingsAggregate.Avg == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Avg(childComplexity), true

	case "preventionSettingsAggregate.count":
		if e.complexity.PreventionSettingsAggregate.Count == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Count(childComplexity), true

	case "preventionSettingsAggregate.distinct":
		if e.complexity.PreventionSettingsAggregate.Distinct == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Distinct(childComplexity), true

	case "preventionSettingsAggregate.group":
		if e.complexity.PreventionSettingsAggregate.Group == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Group(childComplexity), true

	case "preventionSettingsAggregate.max":
		if e.complexity.PreventionSettingsAggregate.Max == nil {
			break
		}

		args, err := ec.field_preventionSettingsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PreventionSettingsAggregate.Max(childComplexity, args["column"].([]PreventionSettingsAggregateMaxColumns)), true

	case "preventionSettingsAggregate.min":
		if e.complexity.PreventionSettingsAggregate.Min == nil {
			break
		}

		args, err := ec.field_preventionSettingsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PreventionSettingsAggregate.Min(childComplexity, args["column"].([]PreventionSettingsAggregateMinColumns)), true

	case "preventionSettingsAggregate.preventionSettings":
		if e.complexity.PreventionSettingsAggregate.PreventionSettings == nil {
			break
		}

		args, err := ec.field_preventionSettingsAggregate_preventionSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PreventionSettingsAggregate.PreventionSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPreventionSettingsBoolExp)), true

	case "preventionSettingsAggregate.sum":
		if e.complexity.PreventionSettingsAggregate.Sum == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Sum(childComplexity), true

	case "sensorUpdateSettingsAggregate.avg":
		if e.complexity.SensorUpdateSettingsAggregate.Avg == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Avg(childComplexity), true

	case "sensorUpdateSettingsAggregate.count":
		if e.complexity.SensorUpdateSettingsAggregate.Count == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Count(childComplexity), true

	case "sensorUpdateSettingsAggregate.distinct":
		if e.complexity.SensorUpdateSettingsAggregate.Distinct == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Distinct(childComplexity), true

	case "sensorUpdateSettingsAggregate.group":
		if e.complexity.SensorUpdateSettingsAggregate.Group == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Group(childComplexity), true

	case "sensorUpdateSettingsAggregate.max":
		if e.complexity.SensorUpdateSettingsAggregate.Max == nil {
			break
		}

		args, err := ec.field_sensorUpdateSettingsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SensorUpdateSettingsAggregate.Max(childComplexity, args["column"].([]SensorUpdateSettingsAggregateMaxColumns)), true

	case "sensorUpdateSettingsAggregate.min":
		if e.complexity.SensorUpdateSettingsAggregate.Min == nil {
			break
		}

		args, err := ec.field_sensorUpdateSettingsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SensorUpdateSettingsAggregate.Min(childComplexity, args["column"].([]SensorUpdateSettingsAggregateMinColumns)), true

	case "sensorUpdateSettingsAggregate.sensorUpdateSettings":
		if e.complexity.SensorUpdateSettingsAggregate.SensorUpdateSettings == nil {
			break
		}

		args, err := ec.field_sensorUpdateSettingsAggregate_sensorUpdateSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SensorUpdateSettingsAggregate.SensorUpdateSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsSensorUpdateSettingsBoolExp)), true

	case "sensorUpdateSettingsAggregate.sum":
		if e.complexity.SensorUpdateSettingsAggregate.Sum == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Sum(childComplexity), true

	case "tagsAggregate.avg":
		if e.complexity.TagsAggregate.Avg == nil {
			break
		}

		return e.complexity.TagsAggregate.Avg(childComplexity), true

	case "tagsAggregate.count":
		if e.complexity.TagsAggregate.Count == nil {
			break
		}

		return e.complexity.TagsAggregate.Count(childComplexity), true

	case "tagsAggregate.distinct":
		if e.complexity.TagsAggregate.Distinct == nil {
			break
		}

		return e.complexity.TagsAggregate.Distinct(childComplexity), true

	case "tagsAggregate.group":
		if e.complexity.TagsAggregate.Group == nil {
			break
		}

		return e.complexity.TagsAggregate.Group(childComplexity), true

	case "tagsAggregate.max":
		if e.complexity.TagsAggregate.Max == nil {
			break
		}

		args, err := ec.field_tagsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagsAggregate.Max(childComplexity, args["column"].([]TagsAggregateMaxColumns)), true

	case "tagsAggregate.min":
		if e.complexity.TagsAggregate.Min == nil {
			break
		}

		args, err := ec.field_tagsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagsAggregate.Min(childComplexity, args["column"].([]TagsAggregateMinColumns)), true

	case "tagsAggregate.sum":
		if e.complexity.TagsAggregate.Sum == nil {
			break
		}

		return e.complexity.TagsAggregate.Sum(childComplexity), true

	case "tagsAggregate.tags":
		if e.complexity.TagsAggregate.Tags == nil {
			break
		}

		args, err := ec.field_tagsAggregate_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagsAggregate.Tags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "usersAggregate.avg":
		if e.complexity.UsersAggregate.Avg == nil {
			break
		}

		args, err := ec.field_usersAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Avg(childComplexity, args["column"].([]UsersAggregateAvgColumns)), true

	case "usersAggregate.count":
		if e.complexity.UsersAggregate.Count == nil {
			break
		}

		return e.complexity.UsersAggregate.Count(childComplexity), true

	case "usersAggregate.distinct":
		if e.complexity.UsersAggregate.Distinct == nil {
			break
		}

		return e.complexity.UsersAggregate.Distinct(childComplexity), true

	case "usersAggregate.group":
		if e.complexity.UsersAggregate.Group == nil {
			break
		}

		return e.complexity.UsersAggregate.Group(childComplexity), true

	case "usersAggregate.max":
		if e.complexity.UsersAggregate.Max == nil {
			break
		}

		args, err := ec.field_usersAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Max(childComplexity, args["column"].([]UsersAggregateMaxColumns)), true

	case "usersAggregate.min":
		if e.complexity.UsersAggregate.Min == nil {
			break
		}

		args, err := ec.field_usersAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Min(childComplexity, args["column"].([]UsersAggregateMinColumns)), true

	case "usersAggregate.sum":
		if e.complexity.UsersAggregate.Sum == nil {
			break
		}

		args, err := ec.field_usersAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Sum(childComplexity, args["column"].([]UsersAggregateSumColumns)), true

	case "usersAggregate.users":
		if e.complexity.UsersAggregate.Users == nil {
			break
		}

		args, err := ec.field_usersAggregate_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Users(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	&ast.Source{Name: "../../api/generated/augmented_schema.graphql", Input: `# Code generated by go generate; DO NOT EDIT THIS FILE. 
# This file was generated at 2020-03-11T10:47:43+02:00
directive @generateInputs(where: String, orderBy: String) on OBJECT | UNION
directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
directive @jsonpath(name: String, depends: [String]) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
directive @relation(name: String!, fkName: [String!]!, relationFkName: [String!]!, relType: RelationType!, manyToManyTableName: String, joinOn: [String!]) on FIELD_DEFINITION
directive @viewFunction(name: String, arguments: [String]) on FIELD_DEFINITION
enum AccessType {
	ALLOW
	DENY
}
type ActiveDirectoryData {
	"""
	AD Common Name (CN)
	"""
	adCn: String
	"""
	AD objectSid
	"""
	adSid: String
	"""
	AD objectGUID
	"""
	adGuid: String
	"""
	AD name
	"""
	adName: String
	"""
	AD SAMAccountName
	"""
	adSAMAccountName: String
	"""
	AD User Principal Name
	"""
	adUserPrincipalName: String
	"""
	AD displayName
	"""
	adDisplayName: String
	"""
	AD distinguishedName
	"""
	adDistinguishedName: String
	"""
	AD canonicalName
	"""
	adCanonicalName: String
	"""
	AD accountExpires
	"""
	adAccountExpires: Epoch
	"""
	AD objectClass
	"""
	adObjectClass: [String]
	"""
	AD objectCategory
	"""
	adObjectCategory: String
	"""
	AD Organizational Unit
	"""
	adOrganizationalUnit: [String]
	"""
	AD lastLogoff
	"""
	adLastLogoff: Time
	"""
	AD lastLogon
	"""
	adLastLogon: Time
	"""
	AD lastLogonTimestamp
	"""
	adLastLogonTimestamp: Time
	"""
	AD badPasswordTime
	"""
	adBadPasswordTime: Time
	"""
	AD badPwdCount
	"""
	ad_bad_pwd_count: Int
	"""
	AD managedBy
	"""
	adManagedBy: String
	"""
	AD pwdLastSet
	"""
	adPasswordLastSet: Time
	"""
	AD Primary group ID
	"""
	adPrimaryGroupId: Int
	"""
	AD Primary group ID
	"""
	adPrimaryGroupDn: String
	"""
	AD memberOf
	"""
	adMemberOf: [String]
	"""
	AD memberOf (nested full list)
	"""
	adMemberOfFull: [String]
	"""
	AD uSNChanged
	"""
	adUsnChanged: Int
	"""
	AD uSNCreated
	"""
	adUsnCreated: Int
	"""
	AD whenChanged
	"""
	adWhenChanged: Time
	"""
	AD whenCreated
	"""
	adWhenCreated: Time
	"""
	AD isCriticalSystemObject
	"""
	adIsCriticalSystemObject: Boolean
	"""
	AD msDS-AllowedToDelegateTo
	"""
	adMsdsAllowedToDelegateTo: [String]
	"""
	AD Password Must Change
	"""
	adPwdMustChange: Boolean
	"""
	AD Resultant Password Settings Object
	"""
	adMsdsResultantPso: String
}
type Adapter @generateInputs(where: "adapter_bool_exp", orderBy: "adapter_order_by") {
	id: AdapterType!
	name: String
	properties: [String]
}
union AdapterData @generateInputs(where: "adapter_data_bool_exp", orderBy: "adapter_data_order_by") = ActiveDirectoryData | CylanceData | CrowdStrikeData
type AdapterDevice @generateInputs(where: "adapter_device_bool_exp", orderBy: "adapter_device_order_by") {
	"""
	Unique id of adapter device
	"""
	id: UUID!
	"""
	Cycle adapter device was fetched
	"""
	fetchCycle: Int!
	"""
	Idadas of adapter that fetched this device
	"""
	adapterId: AdapterType!
	adapter("""
	filter the rows returned
	"""
	where: adapter_bool_exp): Adapter @relation(name: "adapters", fkName: ["adapterId"], relationFkName: ["id"], relType: ONE_TO_ONE)
	"""
	Name of adapter that fetched this advice
	"""
	adapterName: String
	"""
	Correlated device id
	"""
	deviceId: UUID!
	"""
	Unique data returned by adapter on this device
	"""
	adapterData("""
	filter the rows returned
	"""
	where: adapter_data_bool_exp): AdapterData @jsonpath(name: "data", depends: ["adapterId"]) @goField(forceResolver: true, name: "adapterData")
	"""
	Data returned by this adapter as a json mappping
	"""
	data: Map
	"""
	Time adapter was requested to fetch device by axonius
	"""
	fetchTime: Epoch
	"""
	hostname of device
	"""
	hostname: String
	"""
	name given to device by the adapter
	"""
	name: String
	"""
	Last time device was seen by adapter in Unix time
	"""
	lastSeen: Epoch
	osId: UUID!
	"""
	Operating system adapter device is running on
	"""
	os("""
	filter the rows returned
	"""
	where: operating_system_bool_exp): OperatingSystem @relation(name: "operating_systems", fkName: ["osId"], relationFkName: ["id"], relType: ONE_TO_ONE)
	"""
	Pertty id given to adapter device when axonius created it
	"""
	prettyId: String
	tags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [Tag] @relation(name: "adapter_device_tags", fkName: ["id"], relationFkName: ["adapter_device_id"], relType: MANY_TO_MANY, manyToManyTableName: "tags", joinOn: ["name"])
	interfaces("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [NetworkInterface!] @relation(name: "network_interfaces", fkName: ["id","fetch_cycle"], relationFkName: ["deviceId","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	List of uses who last used the device
	"""
	lastUsedUsers: [String]
	"""
	Name of domain this adapter device belongs too
	"""
	domain: String
	"""
	Whether this adapter device is part of the domain
	"""
	partOfDomain: Boolean
	"""
	Users known by this device
	"""
	deviceUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_user_bool_exp): [AdapterDeviceUser] @jsonpath(name: "deviceUsers")
	"""
	local admins known by this device
	"""
	localAdmins("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_admin_bool_exp): [AdapterDeviceAdmin] @jsonpath(name: "localAdmins")
	"""
	Firewall rules defined on this adapter device
	"""
	firewallRules("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: firewall_rule_bool_exp): [FirewallRule] @relation(name: "adapter_device_firewall_rules", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "firewall_rules", joinOn: ["name"])
	"""
	Software installed on this device
	"""
	installedSoftware("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: installed_software_bool_exp): [InstalledSoftware] @relation(name: "adapter_device_installed_software", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "installed_software", joinOn: ["name","version"])
	agentVersion: String
	agentStatus: String
	agentName: String
	model: String
	manufacturer: String
	serial: String
	family: String
	biosVersion: String
	biosSerial: String
	"""
	Returns aggregate of tags
	"""
	tags_aggregate("""
	group by columns
	"""
	groupBy: [tags_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [tags_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [tagsAggregate!] @relation(name: "adapter_device_tags", fkName: ["id"], relationFkName: ["adapter_device_id"], relType: MANY_TO_MANY, manyToManyTableName: "tags", joinOn: ["name"])
	"""
	Returns aggregate of interfaces
	"""
	interfaces_aggregate("""
	group by columns
	"""
	groupBy: [interfaces_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [interfaces_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [interfacesAggregate!] @relation(name: "network_interfaces", fkName: ["id","fetch_cycle"], relationFkName: ["deviceId","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	Returns aggregate of firewallRules
	"""
	firewallRules_aggregate("""
	group by columns
	"""
	groupBy: [firewallRules_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [firewallRules_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: firewall_rule_bool_exp): [firewallRulesAggregate!] @relation(name: "adapter_device_firewall_rules", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "firewall_rules", joinOn: ["name"])
	"""
	Returns aggregate of installedSoftware
	"""
	installedSoftware_aggregate("""
	group by columns
	"""
	groupBy: [installedSoftware_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [installedSoftware_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: installed_software_bool_exp): [installedSoftwareAggregate!] @relation(name: "adapter_device_installed_software", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "installed_software", joinOn: ["name","version"])
}
type AdapterDeviceAdmin @generateInputs(where: "adapter_device_admin_bool_exp", orderBy: "adapter_device_admin_order_by") {
	name: String
	type: AdminType
}
"""
User known by an adapter device
"""
type AdapterDeviceUser @generateInputs(where: "adapter_device_user_bool_exp", orderBy: "adapter_device_user_order_by") {
	deviceId: UUID
	sid: String
	username: String
	lastUseDate: Epoch
	isLocal: Boolean
	isDisabled: Boolean
	isAdmin: Boolean
	userDepartment: Boolean
	passwordMaxAge: Int
	interpreter: String
}
enum AdapterType @goModel(model: "bandicoot/pkg/domain.AdapterType") {
	UNKNOWN
	CUSTOM
	ABSOLUTE
	ACTIVE_DIRECTORY
	AIRWATCH
	AIRWAVE
	ALERTLOGIC
	ALIBABA
	ANSIBLE_TOWER
	AQUA
	ARISTA_EOS
	ARMIS
	ARSENAL
	ARUBA
	AUTOMOX
	AWS
	AZURE_AD
	AZURE
	BAMBOOHR
	BIGFIX
	BIGFIX_INVENTORY
	BITDEFENDER
	BITLOCKER
	BITSIGHT
	BLACKBERRY_UEM
	BLUECAT
	BOMGAR
	CA_CMDB
	CA_SPECTRUM
	CARBONBLACK_DEFENSE
	CARBONBLACK_RESPONSE
	CENSYS
	CHECKPOINTR90
	CHEF
	CHERWELL
	CISCO
	CISCO_AMP
	CISCO_FIREPOWER_MANAGEMENT_CENTER
	CISCO_ISE
	CISCO_MERAKI
	CISCO_PRIME
	CISCO_STEALTHWATCH
	CISCO_UCM
	CISCO_UCSM
	CISCO_UMBERELLA
	CLAROTY
	CLEARPASS
	CLOUDFLARE
	CLOUD_PASSAGE
	CODE42
	COUNTER_ACT
	CROWD_STRIKE
	CSC_GLOBAL
	CSV
	CYBEREASON
	CYCOGNITO
	CYLANCE
	CYNET
	DATADOG
	DATTO
	DEEP_SECURITY
	DEFENDER_ATP
	DESKTOP_CENTRAL
	DEVICE42
	DIGICERT_CERTCENTRAL
	DIVVY_CLOUD
	DROPBOX
	DRUVA
	DUO
	DYNATRACE
	ECLYPSIUM
	EDGESSCAN
	ENDGAME
	ENSILO
	EPO
	ESET
	ESX
	F5_ICONTROL
	FIRE_EYE_HX
	FORCEPOINT
	FOREMAN
	FORTIGATE
	FRESH_SERVICE
	GCE
	GITHUB
	GOOGLE_BIG_QUERY
	GOOGLE_MDM
	GOTOASSIST
	GURDICORE
	GUARDIUM
	HASHICORP
	HAVEIBEENPWNED
	HP_NNMI
	HYPER_V
	IBM_TIVOLI_TADDM
	ICINGA
	IGAR
	ILLUSIVE
	IMPERVA
	INDEGY
	INFINITE_SLEEP
	INFOBLOX
	IVANTI_SM
	JAMF
	JSON
	JSON_FILE
	JUMPCLOUD
	JUNIPER
	JUNOS
	KASEYA
	KASPERSKY_SC
	LANDESK
	LANSWEEPER
	LIBERNMS
	LINUX_SSH
	LOGRYTHM
	MAAS360
	MALWAREBYTES
	MASSCAN
	MEDIGATE
	MEN_AND_MICE
	MINERVA
	MOBI_CONTROL
	MOBILE_IRON
	MSSQL
	NESSUS
	NESSUS_CSV
	NETBOX
	NETBRAIN
	NETSKOPE
	NEXPOSE
	NIMBUL
	NMAP
	NUTANIX
	OBSERVEIT
	OBSERVIUM
	OFFICE_SCAN
	OKTA
	OMNIVISTA
	OPENSTACK
	OPSWAT
	ORACLE_CLOUD
	ORACLE_VM
	ORCA
	PACKETFENCE
	PALOALTO_CORTEX
	PALOALTO_PANORAMA
	PALOALTO_XDR
	PKWARE
	PREEMPT
	PROMISEC
	PROXMOX
	PUPPET
	QCORE
	QUALYS
	QUEST_KACE
	RANDORI
	REDCANARY
	REDCLOAK
	REDSEAL
	RISK_IQ
	RIVERBED
	RUMBLE
	SALTSTACK
	SALTSTACK_ENTERPRISE
	SAMANGE
	SCCM
	SCEP
	SECDO
	SENTINELONE
	SERVICENOW
	SHOADAN
	SIGNALSCIENCES
	SKYBOX
	SNIPEIT
	SNOW
	SOFTLAYER
	SOLARWINDS_ORION
	SOPHOS
	SPACEWALK
	SPECOPS
	SPLUNK
	STRESSTEST
	SYMANTEC
	SYMANTEC_ALTIRIS
	SYMANTEC_CCS
	SYMANTEC_CLOUD_WORKLOAD
	SYMANTEC_DLP
	SYMANTEC_SEP_CLOUD
	SYSAID
	TANIUM
	TENABLE_IO
	TENABLE_SECURITY_CENTER
	TORIIHQ
	TRAIANA_LAB_MACHINES
	TRIPWIRE_ENTERPRISE
	TRUEFORT
	TWISTLOCK
	UNIFI
	VCLOUD_DIRECTOR
	WAZUH
	WEBROOT
	WEBSCAN
	WSUS
	ZABBIX
	ZSCALER
}
type AdapterUser @generateInputs(where: "adapter_user_bool_exp", orderBy: "adapter_user_order_by") {
	"""
	Unique id of adapter device
	"""
	id: UUID!
	"""
	Cycle adapter device was fetched
	"""
	fetchCycle: Int!
	"""
	Id of adapter that fetched this device
	"""
	adapterId: AdapterType!
	adapter("""
	filter the rows returned
	"""
	where: adapter_bool_exp): Adapter @relation(name: "adapters", fkName: ["adapterId"], relationFkName: ["id"], relType: ONE_TO_ONE)
	"""
	Name of adapter that fetched this advice
	"""
	adapterName: String
	"""
	Correlated device id
	"""
	userId: UUID!
	"""
	Unique data returned by adapter on this device
	"""
	adapterData("""
	filter the rows returned
	"""
	where: adapter_data_bool_exp): AdapterData @jsonpath(name: "data", depends: ["adapterId"]) @goField(forceResolver: true, name: "adapterData")
	"""
	Data returned by this adapter as a json mappping
	"""
	data: Map
	"""
	Time adapter was requested to fetch device by axonius
	"""
	fetchTime: Epoch
	"""
	Last time device was seen by adapter in Unix time
	"""
	lastSeen: Epoch
	"""
	Username
	"""
	username: String
	"""
	User first name
	"""
	firstName: String
	"""
	User last name
	"""
	lastName: String
	"""
	User email account
	"""
	mail: String
	"""
	User account has admin privileges
	"""
	admin: Boolean
	"""
	User entity is local 
	"""
	local: Boolean
	"""
	User account is a delegated admin
	"""
	delegated_admin: Boolean
	"""
	User account has multi-factor authentication enforced
	"""
	mfa_enforced: Boolean
	"""
	User account is enrollled in multi-factor authenticaton
	"""
	mfa_enrolled: Boolean
	"""
	User account is suspended
	"""
	suspended: Boolean
	"""
	User account has been locked
	"""
	locked: Boolean
	"""
	User account has been disabled
	"""
	disabled: Boolean
}
enum AdminType {
	ADMIN_USER
	GROUP_MEMBERSHIP
}
interface Aggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min: Map
	max: Map
}
enum AggregateOrdering {
	count_ASC
	count_DESC
	sum_ASC
	sum_DESC
	avg_ASC
	avg_DESC
	min_ASC
	min_DESC
	max_ASC
	max_DESC
}
enum Architecture {
	X86
	X64
	MIPS
	ALPHA
	ARM
	POWER_PC
	IA64
}
"""
IPv4 and IPv6 networks
"""
scalar CIDR
type CPU {
	id: Int!
	name: String!
	manfacturer: String
	bitness: Int
	family: String
	"""
	Core count of CPU
	"""
	cores: Int
	coresThreads: Int
	ghz: Float
}
type CrowdStrikeData {
	externalIp: String
	groups("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [csGroup]
	preventionPolicy("""
	filter the rows returned
	"""
	where: cs_policy_bool_exp): csPolicy
	sensorUpdatePolicy("""
	filter the rows returned
	"""
	where: cs_group_bool_exp): csGroup
	csAgentVersion: String
	"""
	Returns aggregate of groups
	"""
	groups_aggregate("""
	group by columns
	"""
	groupBy: [groups_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [groups_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [groupsAggregate!]
}
type CylanceData {
	isSafe: String
	deviceState: CylanceDeviceState
	policyId: String
	policyName: String
	policiesDetails: [String]
	tenantTag: String
	zoneNames: [String]
	agentVersion: String
}
enum CylanceDeviceState {
	ONLINE
	OFFLINE
}
"""
Device aggregates one or more adapter device that were correlated
"""
type Device @generateInputs(where: "device_bool_exp", orderBy: "device_order_by") {
	"""
	Unique ID of correlated device
	"""
	id: UUID!
	"""
	Fetch cycle this device was collected
	"""
	fetchCycle: Int!
	"""
	Count of adapters that are correlated to this device
	"""
	adapterCount: Int!
	"""
	Names of adapters that are correlated to this device
	"""
	adapterNames: [String!]
	"""
	Unique hostnames given to device by all adapters
	"""
	hostnames: [String!]
	"""
	Last time device was seen by one of the adapters
	"""
	lastSeen: Epoch
	"""
	Adapter devices that are correlated to this device
	"""
	adapterDevices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [AdapterDevice!] @relation(name: "adapter_devices", fkName: ["id","fetch_cycle"], relationFkName: ["device_id","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	Unique set of network interfaces collected by all adapter devices
	"""
	interfaces("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [NetworkInterface!] @viewFunction(name: "device_network_interfaces", arguments: ["id","fetch_cycle"])
	"""
	Unique set tags given to all adapter devices
	"""
	tags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [Tag!] @viewFunction(name: "device_tags", arguments: ["id","fetch_cycle"])
	"""
	Allows transformation of queried data to API v1
	"""
	_compatibilityAPI: Map @goField(forceResolver: true, name: "compatabilityAPI") @deprecated
	"""
	Returns aggregate of adapterDevices
	"""
	adapterDevices_aggregate("""
	group by columns
	"""
	groupBy: [adapterDevices_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterDevices_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [adapterDevicesAggregate!] @relation(name: "adapter_devices", fkName: ["id","fetch_cycle"], relationFkName: ["device_id","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	Returns aggregate of interfaces
	"""
	interfaces_aggregate("""
	group by columns
	"""
	groupBy: [interfaces_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [interfaces_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [interfacesAggregate!] @viewFunction(name: "device_network_interfaces", arguments: ["id","fetch_cycle"])
	"""
	Returns aggregate of tags
	"""
	tags_aggregate("""
	group by columns
	"""
	groupBy: [tags_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [tags_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [tagsAggregate!] @viewFunction(name: "device_tags", arguments: ["id","fetch_cycle"])
}
enum Direction {
	INGRESS
	EGRESS
}
"""
Unix Time (also known as Epoch time) is a system for describing a point in time.
It is the number of seconds that have elapsed since the Unix epoch, that is the time 00:00:00 UTC on 1 January 1970,
minus leap seconds.
"""
scalar Epoch
type FirewallRule @generateInputs(where: "firewall_rule_bool_exp", orderBy: "firewall_rule_order_by") {
	name: String
	source: String
	type: AccessType
	direction: Direction
	target: String
	protocol: String
	srcPort: Int
	dstPort: Int
}
type GCETagsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [GCETags_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [GCETags_aggregate_max_columns!]!): Map
	GCETags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: gce_tags_bool_exp): [GceTags]
}
enum GCETags_aggregate_columns {
	"""
	groupBy by gceKey
	"""
	gceKey
	"""
	groupBy by gceValue
	"""
	gceValue
}
enum GCETags_aggregate_max_columns {
	"""
	max by gceKey
	"""
	gceKey
	"""
	max by gceValue
	"""
	gceValue
}
enum GCETags_aggregate_min_columns {
	"""
	min by gceKey
	"""
	gceKey
	"""
	min by gceValue
	"""
	gceValue
}
type GceTags @generateInputs(where: "gce_tags_bool_exp", orderBy: "gce_tags_order_by") {
	gceKey: String
	gceValue: String
}
type GoogleCloudData {
	Id: String
	Size: String
	Image: String
	GCETags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: gce_tags_bool_exp): [GceTags]
	"""
	Returns aggregate of GCETags
	"""
	GCETags_aggregate("""
	group by columns
	"""
	groupBy: [GCETags_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [GCETags_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: gce_tags_bool_exp): [GCETagsAggregate!]
}
scalar IP
enum IPFamily {
	V4
	V6
}
type InstalledSoftware @generateInputs(where: "installed_software_bool_exp", orderBy: "installed_software_order_by") {
	"""
	Software Name
	"""
	name: String
	"""
	Software Version
	"""
	version: String
	architecture: Architecture
	description: String
	"""
	Software Vendor
	"""
	vendor: String
	publisher: String
	cveCount: Int
	swLicense: String
	path: String
}
"""
A media access control address (MAC address) is a unique identifier assigned to a network interface controller (NIC)
for use as a network address in communications within a network segment.
"""
scalar Mac
"""
JavaScript Object Notation (JSON) is an open-standard file format or data interchange format
that uses human-readable text to transmit data objects consisting of attribute–value pairs and array data types
(or any other serializable value)
"""
scalar Map
type NetworkInterface @generateInputs(where: "network_interface_bool_exp", orderBy: "networkInterface_order_by") {
	deviceId: UUID
	macAddr: Mac
	ipAddrs: [IP!]
}
"""
Operating System is the system installed on an adapter device
"""
type OperatingSystem @generateInputs(where: "operating_system_bool_exp", orderBy: "operating_system_order_by") {
	id: UUID!
	type: String
	distribution: String
	architecture: Int
	servicePack: String
	installDate: Epoch
	kernelVersion: String
	codeName: String
	major: Int
	minor: Int
	build: String
	RawName: String
}
enum OsTypes {
	WINDOWS
	LINUX
	OS_X
	IOS
	AIR_OS
	ANDROID
	FREE_BSD
	VMWARE
	CISCO
	MIKROTIK
	VXWORKS
	F5_NETWORKS_BIG_IP
	SOLARIS
	AIX
	PRINTER
	PLAYSTATION
	CHECKPOINT
	ARISTA
}
type Query {
	adapterDevices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [adapter_device_order_by!]): [AdapterDevice!]!
	devices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: device_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [device_order_by!]): [Device!]!
	adapterUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [adapter_user_order_by!]): [AdapterUser!]!
	users("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: user_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [user_order_by!]): [User!]!
	"""
	Returns aggregate of adapterDevices
	"""
	adapterDevices_aggregate("""
	group by columns
	"""
	groupBy: [adapterDevices_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterDevices_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [adapterDevicesAggregate!]
	"""
	Returns aggregate of devices
	"""
	devices_aggregate("""
	group by columns
	"""
	groupBy: [devices_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [devices_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: device_bool_exp): [devicesAggregate!]
	"""
	Returns aggregate of adapterUsers
	"""
	adapterUsers_aggregate("""
	group by columns
	"""
	groupBy: [adapterUsers_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterUsers_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [adapterUsersAggregate!]
	"""
	Returns aggregate of users
	"""
	users_aggregate("""
	group by columns
	"""
	groupBy: [users_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [users_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: user_bool_exp): [usersAggregate!]
}
enum RelationType {
	ONE_TO_ONE
	ONE_TO_MANY
	MANY_TO_MANY
}
type Storage {
	deviceId: UUID!
	"""
	Path
	"""
	path: String!
	"""
	Device Name
	"""
	name: String!
	"""
	Size (GB)
	"""
	totalSize: Float!
	"""
	Size (GB)
	"""
	freeSize: Float!
	"""
	Whether drive is encrypted or not
	"""
	isEncrypted: Boolean!
	"""
	Descirption of device
	"""
	description: String
}
type Tag @generateInputs(where: "tag_bool_exp", orderBy: "tag_order_by") {
	name: String!
	creator: String!
	level: String!
}
scalar Time
scalar UUID
type User @generateInputs(where: "user_bool_exp", orderBy: "user_order_by") {
	id: UUID!
	fetchCycle: Int!
	adapterCount: Int!
	adapterNames: [String!]
	usernames: [String!]
	lastSeen: Epoch
	adapterUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [AdapterUser!] @relation(name: "adapter_users", fkName: ["id","fetch_cycle"], relationFkName: ["user_id","fetch_cycle"], relType: ONE_TO_MANY)
	_compatibilityAPI: Map @goField(forceResolver: true, name: "compatabilityAPI")
	"""
	Returns aggregate of adapterUsers
	"""
	adapterUsers_aggregate("""
	group by columns
	"""
	groupBy: [adapterUsers_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterUsers_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [adapterUsersAggregate!] @relation(name: "adapter_users", fkName: ["id","fetch_cycle"], relationFkName: ["user_id","fetch_cycle"], relType: ONE_TO_MANY)
}
type adapterDevicesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_max_columns!]!): Map
	"""
	Adapter devices that are correlated to this device
	"""
	adapterDevices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [AdapterDevice] @relation(name: "adapter_devices", fkName: ["id","fetch_cycle"], relationFkName: ["device_id","fetch_cycle"], relType: ONE_TO_MANY)
}
enum adapterDevices_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by fetchTime
	"""
	fetchTime
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum adapterDevices_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterName
	"""
	adapterName
	"""
	groupBy by deviceId
	"""
	deviceId
	"""
	groupBy by fetchTime
	"""
	fetchTime
	"""
	groupBy by hostname
	"""
	hostname
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by lastSeen
	"""
	lastSeen
	"""
	groupBy by osId
	"""
	osId
	"""
	groupBy by prettyId
	"""
	prettyId
	"""
	groupBy by domain
	"""
	domain
	"""
	groupBy by agentVersion
	"""
	agentVersion
	"""
	groupBy by agentStatus
	"""
	agentStatus
	"""
	groupBy by agentName
	"""
	agentName
	"""
	groupBy by model
	"""
	model
	"""
	groupBy by manufacturer
	"""
	manufacturer
	"""
	groupBy by serial
	"""
	serial
	"""
	groupBy by family
	"""
	family
	"""
	groupBy by biosVersion
	"""
	biosVersion
	"""
	groupBy by biosSerial
	"""
	biosSerial
}
enum adapterDevices_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterName
	"""
	adapterName
	"""
	max by deviceId
	"""
	deviceId
	"""
	max by fetchTime
	"""
	fetchTime
	"""
	max by hostname
	"""
	hostname
	"""
	max by name
	"""
	name
	"""
	max by lastSeen
	"""
	lastSeen
	"""
	max by osId
	"""
	osId
	"""
	max by prettyId
	"""
	prettyId
	"""
	max by domain
	"""
	domain
	"""
	max by agentVersion
	"""
	agentVersion
	"""
	max by agentStatus
	"""
	agentStatus
	"""
	max by agentName
	"""
	agentName
	"""
	max by model
	"""
	model
	"""
	max by manufacturer
	"""
	manufacturer
	"""
	max by serial
	"""
	serial
	"""
	max by family
	"""
	family
	"""
	max by biosVersion
	"""
	biosVersion
	"""
	max by biosSerial
	"""
	biosSerial
}
enum adapterDevices_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterName
	"""
	adapterName
	"""
	min by deviceId
	"""
	deviceId
	"""
	min by fetchTime
	"""
	fetchTime
	"""
	min by hostname
	"""
	hostname
	"""
	min by name
	"""
	name
	"""
	min by lastSeen
	"""
	lastSeen
	"""
	min by osId
	"""
	osId
	"""
	min by prettyId
	"""
	prettyId
	"""
	min by domain
	"""
	domain
	"""
	min by agentVersion
	"""
	agentVersion
	"""
	min by agentStatus
	"""
	agentStatus
	"""
	min by agentName
	"""
	agentName
	"""
	min by model
	"""
	model
	"""
	min by manufacturer
	"""
	manufacturer
	"""
	min by serial
	"""
	serial
	"""
	min by family
	"""
	family
	"""
	min by biosVersion
	"""
	biosVersion
	"""
	min by biosSerial
	"""
	biosSerial
}
enum adapterDevices_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by fetchTime
	"""
	fetchTime
	"""
	sum by lastSeen
	"""
	lastSeen
}
type adapterUsersAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_max_columns!]!): Map
	adapterUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [AdapterUser] @relation(name: "adapter_users", fkName: ["id","fetch_cycle"], relationFkName: ["user_id","fetch_cycle"], relType: ONE_TO_MANY)
}
enum adapterUsers_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by fetchTime
	"""
	fetchTime
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum adapterUsers_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterName
	"""
	adapterName
	"""
	groupBy by userId
	"""
	userId
	"""
	groupBy by fetchTime
	"""
	fetchTime
	"""
	groupBy by lastSeen
	"""
	lastSeen
	"""
	groupBy by username
	"""
	username
	"""
	groupBy by firstName
	"""
	firstName
	"""
	groupBy by lastName
	"""
	lastName
	"""
	groupBy by mail
	"""
	mail
}
enum adapterUsers_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterName
	"""
	adapterName
	"""
	max by userId
	"""
	userId
	"""
	max by fetchTime
	"""
	fetchTime
	"""
	max by lastSeen
	"""
	lastSeen
	"""
	max by username
	"""
	username
	"""
	max by firstName
	"""
	firstName
	"""
	max by lastName
	"""
	lastName
	"""
	max by mail
	"""
	mail
}
enum adapterUsers_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterName
	"""
	adapterName
	"""
	min by userId
	"""
	userId
	"""
	min by fetchTime
	"""
	fetchTime
	"""
	min by lastSeen
	"""
	lastSeen
	"""
	min by username
	"""
	username
	"""
	min by firstName
	"""
	firstName
	"""
	min by lastName
	"""
	lastName
	"""
	min by mail
	"""
	mail
}
enum adapterUsers_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by fetchTime
	"""
	fetchTime
	"""
	sum by lastSeen
	"""
	lastSeen
}
"""
Boolean filter expression for Adapter
"""
input adapter_bool_exp {
	"""
	eq comparison operator
	"""
	id_eq: AdapterType
	"""
	neq comparison operator
	"""
	id_neq: AdapterType
	"""
	in comparison operator
	"""
	id_in: [AdapterType]
	"""
	not_in comparison operator
	"""
	id_not_in: [AdapterType]
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	contains comparison operator
	"""
	properties_contains: [String]
	"""
	contained_by comparison operator
	"""
	properties_contained_by: [String]
	"""
	overlap comparison operator
	"""
	properties_overlap: [String]
	"""
	size comparison operator
	"""
	properties_size: Int
	"""
	contains_regex comparison operator
	"""
	properties_contains_regex: String
	AND: [adapter_bool_exp!]
	OR: [adapter_bool_exp!]
	NOT: [adapter_bool_exp!]
}
"""
Boolean filter expression for AdapterData
"""
input adapter_data_bool_exp {
	"""
	exists comparison operator
	"""
	adCn_exists: Boolean
	"""
	not comparison operator
	"""
	adCn_not: String
	"""
	eq comparison operator
	"""
	adCn_eq: String
	"""
	neq comparison operator
	"""
	adCn_neq: String
	"""
	in comparison operator
	"""
	adCn_in: [String]
	"""
	not_in comparison operator
	"""
	adCn_not_in: [String]
	"""
	like comparison operator
	"""
	adCn_like: String
	"""
	not_like comparison operator
	"""
	adCn_not_like: String
	"""
	ilike comparison operator
	"""
	adCn_ilike: String
	"""
	not_ilike comparison operator
	"""
	adCn_not_ilike: String
	"""
	suffix comparison operator
	"""
	adCn_suffix: String
	"""
	prefix comparison operator
	"""
	adCn_prefix: String
	"""
	exists comparison operator
	"""
	adSid_exists: Boolean
	"""
	not comparison operator
	"""
	adSid_not: String
	"""
	eq comparison operator
	"""
	adSid_eq: String
	"""
	neq comparison operator
	"""
	adSid_neq: String
	"""
	in comparison operator
	"""
	adSid_in: [String]
	"""
	not_in comparison operator
	"""
	adSid_not_in: [String]
	"""
	like comparison operator
	"""
	adSid_like: String
	"""
	not_like comparison operator
	"""
	adSid_not_like: String
	"""
	ilike comparison operator
	"""
	adSid_ilike: String
	"""
	not_ilike comparison operator
	"""
	adSid_not_ilike: String
	"""
	suffix comparison operator
	"""
	adSid_suffix: String
	"""
	prefix comparison operator
	"""
	adSid_prefix: String
	"""
	exists comparison operator
	"""
	adGuid_exists: Boolean
	"""
	not comparison operator
	"""
	adGuid_not: String
	"""
	eq comparison operator
	"""
	adGuid_eq: String
	"""
	neq comparison operator
	"""
	adGuid_neq: String
	"""
	in comparison operator
	"""
	adGuid_in: [String]
	"""
	not_in comparison operator
	"""
	adGuid_not_in: [String]
	"""
	like comparison operator
	"""
	adGuid_like: String
	"""
	not_like comparison operator
	"""
	adGuid_not_like: String
	"""
	ilike comparison operator
	"""
	adGuid_ilike: String
	"""
	not_ilike comparison operator
	"""
	adGuid_not_ilike: String
	"""
	suffix comparison operator
	"""
	adGuid_suffix: String
	"""
	prefix comparison operator
	"""
	adGuid_prefix: String
	"""
	exists comparison operator
	"""
	adName_exists: Boolean
	"""
	not comparison operator
	"""
	adName_not: String
	"""
	eq comparison operator
	"""
	adName_eq: String
	"""
	neq comparison operator
	"""
	adName_neq: String
	"""
	in comparison operator
	"""
	adName_in: [String]
	"""
	not_in comparison operator
	"""
	adName_not_in: [String]
	"""
	like comparison operator
	"""
	adName_like: String
	"""
	not_like comparison operator
	"""
	adName_not_like: String
	"""
	ilike comparison operator
	"""
	adName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adName_suffix: String
	"""
	prefix comparison operator
	"""
	adName_prefix: String
	"""
	exists comparison operator
	"""
	adSAMAccountName_exists: Boolean
	"""
	not comparison operator
	"""
	adSAMAccountName_not: String
	"""
	eq comparison operator
	"""
	adSAMAccountName_eq: String
	"""
	neq comparison operator
	"""
	adSAMAccountName_neq: String
	"""
	in comparison operator
	"""
	adSAMAccountName_in: [String]
	"""
	not_in comparison operator
	"""
	adSAMAccountName_not_in: [String]
	"""
	like comparison operator
	"""
	adSAMAccountName_like: String
	"""
	not_like comparison operator
	"""
	adSAMAccountName_not_like: String
	"""
	ilike comparison operator
	"""
	adSAMAccountName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adSAMAccountName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adSAMAccountName_suffix: String
	"""
	prefix comparison operator
	"""
	adSAMAccountName_prefix: String
	"""
	exists comparison operator
	"""
	adUserPrincipalName_exists: Boolean
	"""
	not comparison operator
	"""
	adUserPrincipalName_not: String
	"""
	eq comparison operator
	"""
	adUserPrincipalName_eq: String
	"""
	neq comparison operator
	"""
	adUserPrincipalName_neq: String
	"""
	in comparison operator
	"""
	adUserPrincipalName_in: [String]
	"""
	not_in comparison operator
	"""
	adUserPrincipalName_not_in: [String]
	"""
	like comparison operator
	"""
	adUserPrincipalName_like: String
	"""
	not_like comparison operator
	"""
	adUserPrincipalName_not_like: String
	"""
	ilike comparison operator
	"""
	adUserPrincipalName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adUserPrincipalName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adUserPrincipalName_suffix: String
	"""
	prefix comparison operator
	"""
	adUserPrincipalName_prefix: String
	"""
	exists comparison operator
	"""
	adDisplayName_exists: Boolean
	"""
	not comparison operator
	"""
	adDisplayName_not: String
	"""
	eq comparison operator
	"""
	adDisplayName_eq: String
	"""
	neq comparison operator
	"""
	adDisplayName_neq: String
	"""
	in comparison operator
	"""
	adDisplayName_in: [String]
	"""
	not_in comparison operator
	"""
	adDisplayName_not_in: [String]
	"""
	like comparison operator
	"""
	adDisplayName_like: String
	"""
	not_like comparison operator
	"""
	adDisplayName_not_like: String
	"""
	ilike comparison operator
	"""
	adDisplayName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adDisplayName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adDisplayName_suffix: String
	"""
	prefix comparison operator
	"""
	adDisplayName_prefix: String
	"""
	exists comparison operator
	"""
	adDistinguishedName_exists: Boolean
	"""
	not comparison operator
	"""
	adDistinguishedName_not: String
	"""
	eq comparison operator
	"""
	adDistinguishedName_eq: String
	"""
	neq comparison operator
	"""
	adDistinguishedName_neq: String
	"""
	in comparison operator
	"""
	adDistinguishedName_in: [String]
	"""
	not_in comparison operator
	"""
	adDistinguishedName_not_in: [String]
	"""
	like comparison operator
	"""
	adDistinguishedName_like: String
	"""
	not_like comparison operator
	"""
	adDistinguishedName_not_like: String
	"""
	ilike comparison operator
	"""
	adDistinguishedName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adDistinguishedName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adDistinguishedName_suffix: String
	"""
	prefix comparison operator
	"""
	adDistinguishedName_prefix: String
	"""
	exists comparison operator
	"""
	adCanonicalName_exists: Boolean
	"""
	not comparison operator
	"""
	adCanonicalName_not: String
	"""
	eq comparison operator
	"""
	adCanonicalName_eq: String
	"""
	neq comparison operator
	"""
	adCanonicalName_neq: String
	"""
	in comparison operator
	"""
	adCanonicalName_in: [String]
	"""
	not_in comparison operator
	"""
	adCanonicalName_not_in: [String]
	"""
	like comparison operator
	"""
	adCanonicalName_like: String
	"""
	not_like comparison operator
	"""
	adCanonicalName_not_like: String
	"""
	ilike comparison operator
	"""
	adCanonicalName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adCanonicalName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adCanonicalName_suffix: String
	"""
	prefix comparison operator
	"""
	adCanonicalName_prefix: String
	"""
	exists comparison operator
	"""
	adAccountExpires_exists: Boolean
	"""
	eq comparison operator
	"""
	adAccountExpires_eq: Epoch
	"""
	neq comparison operator
	"""
	adAccountExpires_neq: Epoch
	"""
	in comparison operator
	"""
	adAccountExpires_in: [Epoch]
	"""
	not_in comparison operator
	"""
	adAccountExpires_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	adAccountExpires_gt: Epoch
	"""
	gte comparison operator
	"""
	adAccountExpires_gte: Epoch
	"""
	lt comparison operator
	"""
	adAccountExpires_lt: Epoch
	"""
	lte comparison operator
	"""
	adAccountExpires_lte: Epoch
	"""
	days comparison operator
	"""
	adAccountExpires_days: Int
	"""
	contains comparison operator
	"""
	adObjectClass_contains: [String]
	"""
	contained_by comparison operator
	"""
	adObjectClass_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adObjectClass_overlap: [String]
	"""
	size comparison operator
	"""
	adObjectClass_size: Int
	"""
	contains_regex comparison operator
	"""
	adObjectClass_contains_regex: String
	"""
	exists comparison operator
	"""
	adObjectCategory_exists: Boolean
	"""
	not comparison operator
	"""
	adObjectCategory_not: String
	"""
	eq comparison operator
	"""
	adObjectCategory_eq: String
	"""
	neq comparison operator
	"""
	adObjectCategory_neq: String
	"""
	in comparison operator
	"""
	adObjectCategory_in: [String]
	"""
	not_in comparison operator
	"""
	adObjectCategory_not_in: [String]
	"""
	like comparison operator
	"""
	adObjectCategory_like: String
	"""
	not_like comparison operator
	"""
	adObjectCategory_not_like: String
	"""
	ilike comparison operator
	"""
	adObjectCategory_ilike: String
	"""
	not_ilike comparison operator
	"""
	adObjectCategory_not_ilike: String
	"""
	suffix comparison operator
	"""
	adObjectCategory_suffix: String
	"""
	prefix comparison operator
	"""
	adObjectCategory_prefix: String
	"""
	contains comparison operator
	"""
	adOrganizationalUnit_contains: [String]
	"""
	contained_by comparison operator
	"""
	adOrganizationalUnit_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adOrganizationalUnit_overlap: [String]
	"""
	size comparison operator
	"""
	adOrganizationalUnit_size: Int
	"""
	contains_regex comparison operator
	"""
	adOrganizationalUnit_contains_regex: String
	"""
	exists comparison operator
	"""
	adLastLogoff_exists: Boolean
	"""
	eq comparison operator
	"""
	adLastLogoff_eq: Time
	"""
	neq comparison operator
	"""
	adLastLogoff_neq: Time
	"""
	in comparison operator
	"""
	adLastLogoff_in: [Time]
	"""
	not_in comparison operator
	"""
	adLastLogoff_not_in: [Time]
	"""
	gt comparison operator
	"""
	adLastLogoff_gt: Time
	"""
	gte comparison operator
	"""
	adLastLogoff_gte: Time
	"""
	lt comparison operator
	"""
	adLastLogoff_lt: Time
	"""
	lte comparison operator
	"""
	adLastLogoff_lte: Time
	"""
	days comparison operator
	"""
	adLastLogoff_days: Int
	"""
	exists comparison operator
	"""
	adLastLogon_exists: Boolean
	"""
	eq comparison operator
	"""
	adLastLogon_eq: Time
	"""
	neq comparison operator
	"""
	adLastLogon_neq: Time
	"""
	in comparison operator
	"""
	adLastLogon_in: [Time]
	"""
	not_in comparison operator
	"""
	adLastLogon_not_in: [Time]
	"""
	gt comparison operator
	"""
	adLastLogon_gt: Time
	"""
	gte comparison operator
	"""
	adLastLogon_gte: Time
	"""
	lt comparison operator
	"""
	adLastLogon_lt: Time
	"""
	lte comparison operator
	"""
	adLastLogon_lte: Time
	"""
	days comparison operator
	"""
	adLastLogon_days: Int
	"""
	exists comparison operator
	"""
	adLastLogonTimestamp_exists: Boolean
	"""
	eq comparison operator
	"""
	adLastLogonTimestamp_eq: Time
	"""
	neq comparison operator
	"""
	adLastLogonTimestamp_neq: Time
	"""
	in comparison operator
	"""
	adLastLogonTimestamp_in: [Time]
	"""
	not_in comparison operator
	"""
	adLastLogonTimestamp_not_in: [Time]
	"""
	gt comparison operator
	"""
	adLastLogonTimestamp_gt: Time
	"""
	gte comparison operator
	"""
	adLastLogonTimestamp_gte: Time
	"""
	lt comparison operator
	"""
	adLastLogonTimestamp_lt: Time
	"""
	lte comparison operator
	"""
	adLastLogonTimestamp_lte: Time
	"""
	days comparison operator
	"""
	adLastLogonTimestamp_days: Int
	"""
	exists comparison operator
	"""
	adBadPasswordTime_exists: Boolean
	"""
	eq comparison operator
	"""
	adBadPasswordTime_eq: Time
	"""
	neq comparison operator
	"""
	adBadPasswordTime_neq: Time
	"""
	in comparison operator
	"""
	adBadPasswordTime_in: [Time]
	"""
	not_in comparison operator
	"""
	adBadPasswordTime_not_in: [Time]
	"""
	gt comparison operator
	"""
	adBadPasswordTime_gt: Time
	"""
	gte comparison operator
	"""
	adBadPasswordTime_gte: Time
	"""
	lt comparison operator
	"""
	adBadPasswordTime_lt: Time
	"""
	lte comparison operator
	"""
	adBadPasswordTime_lte: Time
	"""
	days comparison operator
	"""
	adBadPasswordTime_days: Int
	"""
	exists comparison operator
	"""
	ad_bad_pwd_count_exists: Boolean
	"""
	eq comparison operator
	"""
	ad_bad_pwd_count_eq: Int
	"""
	neq comparison operator
	"""
	ad_bad_pwd_count_neq: Int
	"""
	in comparison operator
	"""
	ad_bad_pwd_count_in: [Int]
	"""
	not_in comparison operator
	"""
	ad_bad_pwd_count_not_in: [Int]
	"""
	gt comparison operator
	"""
	ad_bad_pwd_count_gt: Int
	"""
	gte comparison operator
	"""
	ad_bad_pwd_count_gte: Int
	"""
	lt comparison operator
	"""
	ad_bad_pwd_count_lt: Int
	"""
	lte comparison operator
	"""
	ad_bad_pwd_count_lte: Int
	"""
	exists comparison operator
	"""
	adManagedBy_exists: Boolean
	"""
	not comparison operator
	"""
	adManagedBy_not: String
	"""
	eq comparison operator
	"""
	adManagedBy_eq: String
	"""
	neq comparison operator
	"""
	adManagedBy_neq: String
	"""
	in comparison operator
	"""
	adManagedBy_in: [String]
	"""
	not_in comparison operator
	"""
	adManagedBy_not_in: [String]
	"""
	like comparison operator
	"""
	adManagedBy_like: String
	"""
	not_like comparison operator
	"""
	adManagedBy_not_like: String
	"""
	ilike comparison operator
	"""
	adManagedBy_ilike: String
	"""
	not_ilike comparison operator
	"""
	adManagedBy_not_ilike: String
	"""
	suffix comparison operator
	"""
	adManagedBy_suffix: String
	"""
	prefix comparison operator
	"""
	adManagedBy_prefix: String
	"""
	exists comparison operator
	"""
	adPasswordLastSet_exists: Boolean
	"""
	eq comparison operator
	"""
	adPasswordLastSet_eq: Time
	"""
	neq comparison operator
	"""
	adPasswordLastSet_neq: Time
	"""
	in comparison operator
	"""
	adPasswordLastSet_in: [Time]
	"""
	not_in comparison operator
	"""
	adPasswordLastSet_not_in: [Time]
	"""
	gt comparison operator
	"""
	adPasswordLastSet_gt: Time
	"""
	gte comparison operator
	"""
	adPasswordLastSet_gte: Time
	"""
	lt comparison operator
	"""
	adPasswordLastSet_lt: Time
	"""
	lte comparison operator
	"""
	adPasswordLastSet_lte: Time
	"""
	days comparison operator
	"""
	adPasswordLastSet_days: Int
	"""
	exists comparison operator
	"""
	adPrimaryGroupId_exists: Boolean
	"""
	eq comparison operator
	"""
	adPrimaryGroupId_eq: Int
	"""
	neq comparison operator
	"""
	adPrimaryGroupId_neq: Int
	"""
	in comparison operator
	"""
	adPrimaryGroupId_in: [Int]
	"""
	not_in comparison operator
	"""
	adPrimaryGroupId_not_in: [Int]
	"""
	gt comparison operator
	"""
	adPrimaryGroupId_gt: Int
	"""
	gte comparison operator
	"""
	adPrimaryGroupId_gte: Int
	"""
	lt comparison operator
	"""
	adPrimaryGroupId_lt: Int
	"""
	lte comparison operator
	"""
	adPrimaryGroupId_lte: Int
	"""
	exists comparison operator
	"""
	adPrimaryGroupDn_exists: Boolean
	"""
	not comparison operator
	"""
	adPrimaryGroupDn_not: String
	"""
	eq comparison operator
	"""
	adPrimaryGroupDn_eq: String
	"""
	neq comparison operator
	"""
	adPrimaryGroupDn_neq: String
	"""
	in comparison operator
	"""
	adPrimaryGroupDn_in: [String]
	"""
	not_in comparison operator
	"""
	adPrimaryGroupDn_not_in: [String]
	"""
	like comparison operator
	"""
	adPrimaryGroupDn_like: String
	"""
	not_like comparison operator
	"""
	adPrimaryGroupDn_not_like: String
	"""
	ilike comparison operator
	"""
	adPrimaryGroupDn_ilike: String
	"""
	not_ilike comparison operator
	"""
	adPrimaryGroupDn_not_ilike: String
	"""
	suffix comparison operator
	"""
	adPrimaryGroupDn_suffix: String
	"""
	prefix comparison operator
	"""
	adPrimaryGroupDn_prefix: String
	"""
	contains comparison operator
	"""
	adMemberOf_contains: [String]
	"""
	contained_by comparison operator
	"""
	adMemberOf_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adMemberOf_overlap: [String]
	"""
	size comparison operator
	"""
	adMemberOf_size: Int
	"""
	contains_regex comparison operator
	"""
	adMemberOf_contains_regex: String
	"""
	contains comparison operator
	"""
	adMemberOfFull_contains: [String]
	"""
	contained_by comparison operator
	"""
	adMemberOfFull_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adMemberOfFull_overlap: [String]
	"""
	size comparison operator
	"""
	adMemberOfFull_size: Int
	"""
	contains_regex comparison operator
	"""
	adMemberOfFull_contains_regex: String
	"""
	exists comparison operator
	"""
	adUsnChanged_exists: Boolean
	"""
	eq comparison operator
	"""
	adUsnChanged_eq: Int
	"""
	neq comparison operator
	"""
	adUsnChanged_neq: Int
	"""
	in comparison operator
	"""
	adUsnChanged_in: [Int]
	"""
	not_in comparison operator
	"""
	adUsnChanged_not_in: [Int]
	"""
	gt comparison operator
	"""
	adUsnChanged_gt: Int
	"""
	gte comparison operator
	"""
	adUsnChanged_gte: Int
	"""
	lt comparison operator
	"""
	adUsnChanged_lt: Int
	"""
	lte comparison operator
	"""
	adUsnChanged_lte: Int
	"""
	exists comparison operator
	"""
	adUsnCreated_exists: Boolean
	"""
	eq comparison operator
	"""
	adUsnCreated_eq: Int
	"""
	neq comparison operator
	"""
	adUsnCreated_neq: Int
	"""
	in comparison operator
	"""
	adUsnCreated_in: [Int]
	"""
	not_in comparison operator
	"""
	adUsnCreated_not_in: [Int]
	"""
	gt comparison operator
	"""
	adUsnCreated_gt: Int
	"""
	gte comparison operator
	"""
	adUsnCreated_gte: Int
	"""
	lt comparison operator
	"""
	adUsnCreated_lt: Int
	"""
	lte comparison operator
	"""
	adUsnCreated_lte: Int
	"""
	exists comparison operator
	"""
	adWhenChanged_exists: Boolean
	"""
	eq comparison operator
	"""
	adWhenChanged_eq: Time
	"""
	neq comparison operator
	"""
	adWhenChanged_neq: Time
	"""
	in comparison operator
	"""
	adWhenChanged_in: [Time]
	"""
	not_in comparison operator
	"""
	adWhenChanged_not_in: [Time]
	"""
	gt comparison operator
	"""
	adWhenChanged_gt: Time
	"""
	gte comparison operator
	"""
	adWhenChanged_gte: Time
	"""
	lt comparison operator
	"""
	adWhenChanged_lt: Time
	"""
	lte comparison operator
	"""
	adWhenChanged_lte: Time
	"""
	days comparison operator
	"""
	adWhenChanged_days: Int
	"""
	exists comparison operator
	"""
	adWhenCreated_exists: Boolean
	"""
	eq comparison operator
	"""
	adWhenCreated_eq: Time
	"""
	neq comparison operator
	"""
	adWhenCreated_neq: Time
	"""
	in comparison operator
	"""
	adWhenCreated_in: [Time]
	"""
	not_in comparison operator
	"""
	adWhenCreated_not_in: [Time]
	"""
	gt comparison operator
	"""
	adWhenCreated_gt: Time
	"""
	gte comparison operator
	"""
	adWhenCreated_gte: Time
	"""
	lt comparison operator
	"""
	adWhenCreated_lt: Time
	"""
	lte comparison operator
	"""
	adWhenCreated_lte: Time
	"""
	days comparison operator
	"""
	adWhenCreated_days: Int
	"""
	exists comparison operator
	"""
	adIsCriticalSystemObject_exists: Boolean
	"""
	eq comparison operator
	"""
	adIsCriticalSystemObject_eq: Boolean
	"""
	neq comparison operator
	"""
	adIsCriticalSystemObject_neq: Boolean
	"""
	contains comparison operator
	"""
	adMsdsAllowedToDelegateTo_contains: [String]
	"""
	contained_by comparison operator
	"""
	adMsdsAllowedToDelegateTo_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adMsdsAllowedToDelegateTo_overlap: [String]
	"""
	size comparison operator
	"""
	adMsdsAllowedToDelegateTo_size: Int
	"""
	contains_regex comparison operator
	"""
	adMsdsAllowedToDelegateTo_contains_regex: String
	"""
	exists comparison operator
	"""
	adPwdMustChange_exists: Boolean
	"""
	eq comparison operator
	"""
	adPwdMustChange_eq: Boolean
	"""
	neq comparison operator
	"""
	adPwdMustChange_neq: Boolean
	"""
	exists comparison operator
	"""
	adMsdsResultantPso_exists: Boolean
	"""
	not comparison operator
	"""
	adMsdsResultantPso_not: String
	"""
	eq comparison operator
	"""
	adMsdsResultantPso_eq: String
	"""
	neq comparison operator
	"""
	adMsdsResultantPso_neq: String
	"""
	in comparison operator
	"""
	adMsdsResultantPso_in: [String]
	"""
	not_in comparison operator
	"""
	adMsdsResultantPso_not_in: [String]
	"""
	like comparison operator
	"""
	adMsdsResultantPso_like: String
	"""
	not_like comparison operator
	"""
	adMsdsResultantPso_not_like: String
	"""
	ilike comparison operator
	"""
	adMsdsResultantPso_ilike: String
	"""
	not_ilike comparison operator
	"""
	adMsdsResultantPso_not_ilike: String
	"""
	suffix comparison operator
	"""
	adMsdsResultantPso_suffix: String
	"""
	prefix comparison operator
	"""
	adMsdsResultantPso_prefix: String
	"""
	exists comparison operator
	"""
	isSafe_exists: Boolean
	"""
	not comparison operator
	"""
	isSafe_not: String
	"""
	eq comparison operator
	"""
	isSafe_eq: String
	"""
	neq comparison operator
	"""
	isSafe_neq: String
	"""
	in comparison operator
	"""
	isSafe_in: [String]
	"""
	not_in comparison operator
	"""
	isSafe_not_in: [String]
	"""
	like comparison operator
	"""
	isSafe_like: String
	"""
	not_like comparison operator
	"""
	isSafe_not_like: String
	"""
	ilike comparison operator
	"""
	isSafe_ilike: String
	"""
	not_ilike comparison operator
	"""
	isSafe_not_ilike: String
	"""
	suffix comparison operator
	"""
	isSafe_suffix: String
	"""
	prefix comparison operator
	"""
	isSafe_prefix: String
	"""
	eq comparison operator
	"""
	deviceState_eq: CylanceDeviceState
	"""
	neq comparison operator
	"""
	deviceState_neq: CylanceDeviceState
	"""
	in comparison operator
	"""
	deviceState_in: [CylanceDeviceState]
	"""
	not_in comparison operator
	"""
	deviceState_not_in: [CylanceDeviceState]
	"""
	exists comparison operator
	"""
	policyId_exists: Boolean
	"""
	not comparison operator
	"""
	policyId_not: String
	"""
	eq comparison operator
	"""
	policyId_eq: String
	"""
	neq comparison operator
	"""
	policyId_neq: String
	"""
	in comparison operator
	"""
	policyId_in: [String]
	"""
	not_in comparison operator
	"""
	policyId_not_in: [String]
	"""
	like comparison operator
	"""
	policyId_like: String
	"""
	not_like comparison operator
	"""
	policyId_not_like: String
	"""
	ilike comparison operator
	"""
	policyId_ilike: String
	"""
	not_ilike comparison operator
	"""
	policyId_not_ilike: String
	"""
	suffix comparison operator
	"""
	policyId_suffix: String
	"""
	prefix comparison operator
	"""
	policyId_prefix: String
	"""
	exists comparison operator
	"""
	policyName_exists: Boolean
	"""
	not comparison operator
	"""
	policyName_not: String
	"""
	eq comparison operator
	"""
	policyName_eq: String
	"""
	neq comparison operator
	"""
	policyName_neq: String
	"""
	in comparison operator
	"""
	policyName_in: [String]
	"""
	not_in comparison operator
	"""
	policyName_not_in: [String]
	"""
	like comparison operator
	"""
	policyName_like: String
	"""
	not_like comparison operator
	"""
	policyName_not_like: String
	"""
	ilike comparison operator
	"""
	policyName_ilike: String
	"""
	not_ilike comparison operator
	"""
	policyName_not_ilike: String
	"""
	suffix comparison operator
	"""
	policyName_suffix: String
	"""
	prefix comparison operator
	"""
	policyName_prefix: String
	"""
	contains comparison operator
	"""
	policiesDetails_contains: [String]
	"""
	contained_by comparison operator
	"""
	policiesDetails_contained_by: [String]
	"""
	overlap comparison operator
	"""
	policiesDetails_overlap: [String]
	"""
	size comparison operator
	"""
	policiesDetails_size: Int
	"""
	contains_regex comparison operator
	"""
	policiesDetails_contains_regex: String
	"""
	exists comparison operator
	"""
	tenantTag_exists: Boolean
	"""
	not comparison operator
	"""
	tenantTag_not: String
	"""
	eq comparison operator
	"""
	tenantTag_eq: String
	"""
	neq comparison operator
	"""
	tenantTag_neq: String
	"""
	in comparison operator
	"""
	tenantTag_in: [String]
	"""
	not_in comparison operator
	"""
	tenantTag_not_in: [String]
	"""
	like comparison operator
	"""
	tenantTag_like: String
	"""
	not_like comparison operator
	"""
	tenantTag_not_like: String
	"""
	ilike comparison operator
	"""
	tenantTag_ilike: String
	"""
	not_ilike comparison operator
	"""
	tenantTag_not_ilike: String
	"""
	suffix comparison operator
	"""
	tenantTag_suffix: String
	"""
	prefix comparison operator
	"""
	tenantTag_prefix: String
	"""
	contains comparison operator
	"""
	zoneNames_contains: [String]
	"""
	contained_by comparison operator
	"""
	zoneNames_contained_by: [String]
	"""
	overlap comparison operator
	"""
	zoneNames_overlap: [String]
	"""
	size comparison operator
	"""
	zoneNames_size: Int
	"""
	contains_regex comparison operator
	"""
	zoneNames_contains_regex: String
	"""
	exists comparison operator
	"""
	agentVersion_exists: Boolean
	"""
	not comparison operator
	"""
	agentVersion_not: String
	"""
	eq comparison operator
	"""
	agentVersion_eq: String
	"""
	neq comparison operator
	"""
	agentVersion_neq: String
	"""
	in comparison operator
	"""
	agentVersion_in: [String]
	"""
	not_in comparison operator
	"""
	agentVersion_not_in: [String]
	"""
	like comparison operator
	"""
	agentVersion_like: String
	"""
	not_like comparison operator
	"""
	agentVersion_not_like: String
	"""
	ilike comparison operator
	"""
	agentVersion_ilike: String
	"""
	not_ilike comparison operator
	"""
	agentVersion_not_ilike: String
	"""
	suffix comparison operator
	"""
	agentVersion_suffix: String
	"""
	prefix comparison operator
	"""
	agentVersion_prefix: String
	"""
	exists comparison operator
	"""
	externalIp_exists: Boolean
	"""
	not comparison operator
	"""
	externalIp_not: String
	"""
	eq comparison operator
	"""
	externalIp_eq: String
	"""
	neq comparison operator
	"""
	externalIp_neq: String
	"""
	in comparison operator
	"""
	externalIp_in: [String]
	"""
	not_in comparison operator
	"""
	externalIp_not_in: [String]
	"""
	like comparison operator
	"""
	externalIp_like: String
	"""
	not_like comparison operator
	"""
	externalIp_not_like: String
	"""
	ilike comparison operator
	"""
	externalIp_ilike: String
	"""
	not_ilike comparison operator
	"""
	externalIp_not_ilike: String
	"""
	suffix comparison operator
	"""
	externalIp_suffix: String
	"""
	prefix comparison operator
	"""
	externalIp_prefix: String
	"""
	filter by groups
	"""
	groups: cs_group_bool_exp
	"""
	filter by preventionPolicy
	"""
	preventionPolicy: cs_policy_bool_exp
	"""
	filter by sensorUpdatePolicy
	"""
	sensorUpdatePolicy: cs_group_bool_exp
	"""
	exists comparison operator
	"""
	csAgentVersion_exists: Boolean
	"""
	not comparison operator
	"""
	csAgentVersion_not: String
	"""
	eq comparison operator
	"""
	csAgentVersion_eq: String
	"""
	neq comparison operator
	"""
	csAgentVersion_neq: String
	"""
	in comparison operator
	"""
	csAgentVersion_in: [String]
	"""
	not_in comparison operator
	"""
	csAgentVersion_not_in: [String]
	"""
	like comparison operator
	"""
	csAgentVersion_like: String
	"""
	not_like comparison operator
	"""
	csAgentVersion_not_like: String
	"""
	ilike comparison operator
	"""
	csAgentVersion_ilike: String
	"""
	not_ilike comparison operator
	"""
	csAgentVersion_not_ilike: String
	"""
	suffix comparison operator
	"""
	csAgentVersion_suffix: String
	"""
	prefix comparison operator
	"""
	csAgentVersion_prefix: String
	AND: [adapter_data_bool_exp!]
	OR: [adapter_data_bool_exp!]
	NOT: [adapter_data_bool_exp!]
}
"""
Boolean filter expression for AdapterDeviceAdmin
"""
input adapter_device_admin_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	eq comparison operator
	"""
	type_eq: AdminType
	"""
	neq comparison operator
	"""
	type_neq: AdminType
	"""
	in comparison operator
	"""
	type_in: [AdminType]
	"""
	not_in comparison operator
	"""
	type_not_in: [AdminType]
	AND: [adapter_device_admin_bool_exp!]
	OR: [adapter_device_admin_bool_exp!]
	NOT: [adapter_device_admin_bool_exp!]
}
"""
Order for AdapterDeviceAdmin
"""
enum adapter_device_admin_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
}
"""
Boolean filter expression for AdapterDevice
"""
input adapter_device_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	eq comparison operator
	"""
	id_eq: UUID
	"""
	neq comparison operator
	"""
	id_neq: UUID
	"""
	in comparison operator
	"""
	id_in: [UUID]
	"""
	not_in comparison operator
	"""
	id_not_in: [UUID]
	"""
	gt comparison operator
	"""
	id_gt: UUID
	"""
	gte comparison operator
	"""
	id_gte: UUID
	"""
	lt comparison operator
	"""
	id_lt: UUID
	"""
	lte comparison operator
	"""
	id_lte: UUID
	"""
	exists comparison operator
	"""
	fetchCycle_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchCycle_eq: Int
	"""
	neq comparison operator
	"""
	fetchCycle_neq: Int
	"""
	in comparison operator
	"""
	fetchCycle_in: [Int]
	"""
	not_in comparison operator
	"""
	fetchCycle_not_in: [Int]
	"""
	gt comparison operator
	"""
	fetchCycle_gt: Int
	"""
	gte comparison operator
	"""
	fetchCycle_gte: Int
	"""
	lt comparison operator
	"""
	fetchCycle_lt: Int
	"""
	lte comparison operator
	"""
	fetchCycle_lte: Int
	"""
	eq comparison operator
	"""
	adapterId_eq: AdapterType
	"""
	neq comparison operator
	"""
	adapterId_neq: AdapterType
	"""
	in comparison operator
	"""
	adapterId_in: [AdapterType]
	"""
	not_in comparison operator
	"""
	adapterId_not_in: [AdapterType]
	"""
	filter by adapter
	"""
	adapter: adapter_bool_exp
	"""
	exists comparison operator
	"""
	adapterName_exists: Boolean
	"""
	not comparison operator
	"""
	adapterName_not: String
	"""
	eq comparison operator
	"""
	adapterName_eq: String
	"""
	neq comparison operator
	"""
	adapterName_neq: String
	"""
	in comparison operator
	"""
	adapterName_in: [String]
	"""
	not_in comparison operator
	"""
	adapterName_not_in: [String]
	"""
	like comparison operator
	"""
	adapterName_like: String
	"""
	not_like comparison operator
	"""
	adapterName_not_like: String
	"""
	ilike comparison operator
	"""
	adapterName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adapterName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adapterName_suffix: String
	"""
	prefix comparison operator
	"""
	adapterName_prefix: String
	"""
	exists comparison operator
	"""
	deviceId_exists: Boolean
	"""
	eq comparison operator
	"""
	deviceId_eq: UUID
	"""
	neq comparison operator
	"""
	deviceId_neq: UUID
	"""
	in comparison operator
	"""
	deviceId_in: [UUID]
	"""
	not_in comparison operator
	"""
	deviceId_not_in: [UUID]
	"""
	gt comparison operator
	"""
	deviceId_gt: UUID
	"""
	gte comparison operator
	"""
	deviceId_gte: UUID
	"""
	lt comparison operator
	"""
	deviceId_lt: UUID
	"""
	lte comparison operator
	"""
	deviceId_lte: UUID
	"""
	filter by adapterData
	"""
	adapterData: adapter_data_bool_exp
	"""
	exists comparison operator
	"""
	fetchTime_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchTime_eq: Epoch
	"""
	neq comparison operator
	"""
	fetchTime_neq: Epoch
	"""
	in comparison operator
	"""
	fetchTime_in: [Epoch]
	"""
	not_in comparison operator
	"""
	fetchTime_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	fetchTime_gt: Epoch
	"""
	gte comparison operator
	"""
	fetchTime_gte: Epoch
	"""
	lt comparison operator
	"""
	fetchTime_lt: Epoch
	"""
	lte comparison operator
	"""
	fetchTime_lte: Epoch
	"""
	days comparison operator
	"""
	fetchTime_days: Int
	"""
	exists comparison operator
	"""
	hostname_exists: Boolean
	"""
	not comparison operator
	"""
	hostname_not: String
	"""
	eq comparison operator
	"""
	hostname_eq: String
	"""
	neq comparison operator
	"""
	hostname_neq: String
	"""
	in comparison operator
	"""
	hostname_in: [String]
	"""
	not_in comparison operator
	"""
	hostname_not_in: [String]
	"""
	like comparison operator
	"""
	hostname_like: String
	"""
	not_like comparison operator
	"""
	hostname_not_like: String
	"""
	ilike comparison operator
	"""
	hostname_ilike: String
	"""
	not_ilike comparison operator
	"""
	hostname_not_ilike: String
	"""
	suffix comparison operator
	"""
	hostname_suffix: String
	"""
	prefix comparison operator
	"""
	hostname_prefix: String
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	lastSeen_exists: Boolean
	"""
	eq comparison operator
	"""
	lastSeen_eq: Epoch
	"""
	neq comparison operator
	"""
	lastSeen_neq: Epoch
	"""
	in comparison operator
	"""
	lastSeen_in: [Epoch]
	"""
	not_in comparison operator
	"""
	lastSeen_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	lastSeen_gt: Epoch
	"""
	gte comparison operator
	"""
	lastSeen_gte: Epoch
	"""
	lt comparison operator
	"""
	lastSeen_lt: Epoch
	"""
	lte comparison operator
	"""
	lastSeen_lte: Epoch
	"""
	days comparison operator
	"""
	lastSeen_days: Int
	"""
	exists comparison operator
	"""
	osId_exists: Boolean
	"""
	eq comparison operator
	"""
	osId_eq: UUID
	"""
	neq comparison operator
	"""
	osId_neq: UUID
	"""
	in comparison operator
	"""
	osId_in: [UUID]
	"""
	not_in comparison operator
	"""
	osId_not_in: [UUID]
	"""
	gt comparison operator
	"""
	osId_gt: UUID
	"""
	gte comparison operator
	"""
	osId_gte: UUID
	"""
	lt comparison operator
	"""
	osId_lt: UUID
	"""
	lte comparison operator
	"""
	osId_lte: UUID
	"""
	filter by os
	"""
	os: operating_system_bool_exp
	"""
	exists comparison operator
	"""
	prettyId_exists: Boolean
	"""
	not comparison operator
	"""
	prettyId_not: String
	"""
	eq comparison operator
	"""
	prettyId_eq: String
	"""
	neq comparison operator
	"""
	prettyId_neq: String
	"""
	in comparison operator
	"""
	prettyId_in: [String]
	"""
	not_in comparison operator
	"""
	prettyId_not_in: [String]
	"""
	like comparison operator
	"""
	prettyId_like: String
	"""
	not_like comparison operator
	"""
	prettyId_not_like: String
	"""
	ilike comparison operator
	"""
	prettyId_ilike: String
	"""
	not_ilike comparison operator
	"""
	prettyId_not_ilike: String
	"""
	suffix comparison operator
	"""
	prettyId_suffix: String
	"""
	prefix comparison operator
	"""
	prettyId_prefix: String
	"""
	filter by tags
	"""
	tags: tag_bool_exp
	"""
	filter by interfaces
	"""
	interfaces: network_interface_bool_exp
	"""
	contains comparison operator
	"""
	lastUsedUsers_contains: [String]
	"""
	contained_by comparison operator
	"""
	lastUsedUsers_contained_by: [String]
	"""
	overlap comparison operator
	"""
	lastUsedUsers_overlap: [String]
	"""
	size comparison operator
	"""
	lastUsedUsers_size: Int
	"""
	contains_regex comparison operator
	"""
	lastUsedUsers_contains_regex: String
	"""
	exists comparison operator
	"""
	domain_exists: Boolean
	"""
	not comparison operator
	"""
	domain_not: String
	"""
	eq comparison operator
	"""
	domain_eq: String
	"""
	neq comparison operator
	"""
	domain_neq: String
	"""
	in comparison operator
	"""
	domain_in: [String]
	"""
	not_in comparison operator
	"""
	domain_not_in: [String]
	"""
	like comparison operator
	"""
	domain_like: String
	"""
	not_like comparison operator
	"""
	domain_not_like: String
	"""
	ilike comparison operator
	"""
	domain_ilike: String
	"""
	not_ilike comparison operator
	"""
	domain_not_ilike: String
	"""
	suffix comparison operator
	"""
	domain_suffix: String
	"""
	prefix comparison operator
	"""
	domain_prefix: String
	"""
	exists comparison operator
	"""
	partOfDomain_exists: Boolean
	"""
	eq comparison operator
	"""
	partOfDomain_eq: Boolean
	"""
	neq comparison operator
	"""
	partOfDomain_neq: Boolean
	"""
	filter by deviceUsers
	"""
	deviceUsers: adapter_device_user_bool_exp
	"""
	filter by localAdmins
	"""
	localAdmins: adapter_device_admin_bool_exp
	"""
	filter by firewallRules
	"""
	firewallRules: firewall_rule_bool_exp
	"""
	filter by installedSoftware
	"""
	installedSoftware: installed_software_bool_exp
	"""
	exists comparison operator
	"""
	agentVersion_exists: Boolean
	"""
	not comparison operator
	"""
	agentVersion_not: String
	"""
	eq comparison operator
	"""
	agentVersion_eq: String
	"""
	neq comparison operator
	"""
	agentVersion_neq: String
	"""
	in comparison operator
	"""
	agentVersion_in: [String]
	"""
	not_in comparison operator
	"""
	agentVersion_not_in: [String]
	"""
	like comparison operator
	"""
	agentVersion_like: String
	"""
	not_like comparison operator
	"""
	agentVersion_not_like: String
	"""
	ilike comparison operator
	"""
	agentVersion_ilike: String
	"""
	not_ilike comparison operator
	"""
	agentVersion_not_ilike: String
	"""
	suffix comparison operator
	"""
	agentVersion_suffix: String
	"""
	prefix comparison operator
	"""
	agentVersion_prefix: String
	"""
	exists comparison operator
	"""
	agentStatus_exists: Boolean
	"""
	not comparison operator
	"""
	agentStatus_not: String
	"""
	eq comparison operator
	"""
	agentStatus_eq: String
	"""
	neq comparison operator
	"""
	agentStatus_neq: String
	"""
	in comparison operator
	"""
	agentStatus_in: [String]
	"""
	not_in comparison operator
	"""
	agentStatus_not_in: [String]
	"""
	like comparison operator
	"""
	agentStatus_like: String
	"""
	not_like comparison operator
	"""
	agentStatus_not_like: String
	"""
	ilike comparison operator
	"""
	agentStatus_ilike: String
	"""
	not_ilike comparison operator
	"""
	agentStatus_not_ilike: String
	"""
	suffix comparison operator
	"""
	agentStatus_suffix: String
	"""
	prefix comparison operator
	"""
	agentStatus_prefix: String
	"""
	exists comparison operator
	"""
	agentName_exists: Boolean
	"""
	not comparison operator
	"""
	agentName_not: String
	"""
	eq comparison operator
	"""
	agentName_eq: String
	"""
	neq comparison operator
	"""
	agentName_neq: String
	"""
	in comparison operator
	"""
	agentName_in: [String]
	"""
	not_in comparison operator
	"""
	agentName_not_in: [String]
	"""
	like comparison operator
	"""
	agentName_like: String
	"""
	not_like comparison operator
	"""
	agentName_not_like: String
	"""
	ilike comparison operator
	"""
	agentName_ilike: String
	"""
	not_ilike comparison operator
	"""
	agentName_not_ilike: String
	"""
	suffix comparison operator
	"""
	agentName_suffix: String
	"""
	prefix comparison operator
	"""
	agentName_prefix: String
	"""
	exists comparison operator
	"""
	model_exists: Boolean
	"""
	not comparison operator
	"""
	model_not: String
	"""
	eq comparison operator
	"""
	model_eq: String
	"""
	neq comparison operator
	"""
	model_neq: String
	"""
	in comparison operator
	"""
	model_in: [String]
	"""
	not_in comparison operator
	"""
	model_not_in: [String]
	"""
	like comparison operator
	"""
	model_like: String
	"""
	not_like comparison operator
	"""
	model_not_like: String
	"""
	ilike comparison operator
	"""
	model_ilike: String
	"""
	not_ilike comparison operator
	"""
	model_not_ilike: String
	"""
	suffix comparison operator
	"""
	model_suffix: String
	"""
	prefix comparison operator
	"""
	model_prefix: String
	"""
	exists comparison operator
	"""
	manufacturer_exists: Boolean
	"""
	not comparison operator
	"""
	manufacturer_not: String
	"""
	eq comparison operator
	"""
	manufacturer_eq: String
	"""
	neq comparison operator
	"""
	manufacturer_neq: String
	"""
	in comparison operator
	"""
	manufacturer_in: [String]
	"""
	not_in comparison operator
	"""
	manufacturer_not_in: [String]
	"""
	like comparison operator
	"""
	manufacturer_like: String
	"""
	not_like comparison operator
	"""
	manufacturer_not_like: String
	"""
	ilike comparison operator
	"""
	manufacturer_ilike: String
	"""
	not_ilike comparison operator
	"""
	manufacturer_not_ilike: String
	"""
	suffix comparison operator
	"""
	manufacturer_suffix: String
	"""
	prefix comparison operator
	"""
	manufacturer_prefix: String
	"""
	exists comparison operator
	"""
	serial_exists: Boolean
	"""
	not comparison operator
	"""
	serial_not: String
	"""
	eq comparison operator
	"""
	serial_eq: String
	"""
	neq comparison operator
	"""
	serial_neq: String
	"""
	in comparison operator
	"""
	serial_in: [String]
	"""
	not_in comparison operator
	"""
	serial_not_in: [String]
	"""
	like comparison operator
	"""
	serial_like: String
	"""
	not_like comparison operator
	"""
	serial_not_like: String
	"""
	ilike comparison operator
	"""
	serial_ilike: String
	"""
	not_ilike comparison operator
	"""
	serial_not_ilike: String
	"""
	suffix comparison operator
	"""
	serial_suffix: String
	"""
	prefix comparison operator
	"""
	serial_prefix: String
	"""
	exists comparison operator
	"""
	family_exists: Boolean
	"""
	not comparison operator
	"""
	family_not: String
	"""
	eq comparison operator
	"""
	family_eq: String
	"""
	neq comparison operator
	"""
	family_neq: String
	"""
	in comparison operator
	"""
	family_in: [String]
	"""
	not_in comparison operator
	"""
	family_not_in: [String]
	"""
	like comparison operator
	"""
	family_like: String
	"""
	not_like comparison operator
	"""
	family_not_like: String
	"""
	ilike comparison operator
	"""
	family_ilike: String
	"""
	not_ilike comparison operator
	"""
	family_not_ilike: String
	"""
	suffix comparison operator
	"""
	family_suffix: String
	"""
	prefix comparison operator
	"""
	family_prefix: String
	"""
	exists comparison operator
	"""
	biosVersion_exists: Boolean
	"""
	not comparison operator
	"""
	biosVersion_not: String
	"""
	eq comparison operator
	"""
	biosVersion_eq: String
	"""
	neq comparison operator
	"""
	biosVersion_neq: String
	"""
	in comparison operator
	"""
	biosVersion_in: [String]
	"""
	not_in comparison operator
	"""
	biosVersion_not_in: [String]
	"""
	like comparison operator
	"""
	biosVersion_like: String
	"""
	not_like comparison operator
	"""
	biosVersion_not_like: String
	"""
	ilike comparison operator
	"""
	biosVersion_ilike: String
	"""
	not_ilike comparison operator
	"""
	biosVersion_not_ilike: String
	"""
	suffix comparison operator
	"""
	biosVersion_suffix: String
	"""
	prefix comparison operator
	"""
	biosVersion_prefix: String
	"""
	exists comparison operator
	"""
	biosSerial_exists: Boolean
	"""
	not comparison operator
	"""
	biosSerial_not: String
	"""
	eq comparison operator
	"""
	biosSerial_eq: String
	"""
	neq comparison operator
	"""
	biosSerial_neq: String
	"""
	in comparison operator
	"""
	biosSerial_in: [String]
	"""
	not_in comparison operator
	"""
	biosSerial_not_in: [String]
	"""
	like comparison operator
	"""
	biosSerial_like: String
	"""
	not_like comparison operator
	"""
	biosSerial_not_like: String
	"""
	ilike comparison operator
	"""
	biosSerial_ilike: String
	"""
	not_ilike comparison operator
	"""
	biosSerial_not_ilike: String
	"""
	suffix comparison operator
	"""
	biosSerial_suffix: String
	"""
	prefix comparison operator
	"""
	biosSerial_prefix: String
	AND: [adapter_device_bool_exp!]
	OR: [adapter_device_bool_exp!]
	NOT: [adapter_device_bool_exp!]
}
"""
Order for AdapterDevice
"""
enum adapter_device_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterName in an ascending order
	"""
	adapterName_ASC
	"""
	Order by adapterName in a descending order
	"""
	adapterName_DESC
	"""
	Order by fetchTime in an ascending order
	"""
	fetchTime_ASC
	"""
	Order by fetchTime in a descending order
	"""
	fetchTime_DESC
	"""
	Order by hostname in an ascending order
	"""
	hostname_ASC
	"""
	Order by hostname in a descending order
	"""
	hostname_DESC
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
	"""
	Order by prettyId in an ascending order
	"""
	prettyId_ASC
	"""
	Order by prettyId in a descending order
	"""
	prettyId_DESC
	"""
	Order by domain in an ascending order
	"""
	domain_ASC
	"""
	Order by domain in a descending order
	"""
	domain_DESC
	"""
	Order by agentVersion in an ascending order
	"""
	agentVersion_ASC
	"""
	Order by agentVersion in a descending order
	"""
	agentVersion_DESC
	"""
	Order by agentStatus in an ascending order
	"""
	agentStatus_ASC
	"""
	Order by agentStatus in a descending order
	"""
	agentStatus_DESC
	"""
	Order by agentName in an ascending order
	"""
	agentName_ASC
	"""
	Order by agentName in a descending order
	"""
	agentName_DESC
	"""
	Order by model in an ascending order
	"""
	model_ASC
	"""
	Order by model in a descending order
	"""
	model_DESC
	"""
	Order by manufacturer in an ascending order
	"""
	manufacturer_ASC
	"""
	Order by manufacturer in a descending order
	"""
	manufacturer_DESC
	"""
	Order by serial in an ascending order
	"""
	serial_ASC
	"""
	Order by serial in a descending order
	"""
	serial_DESC
	"""
	Order by family in an ascending order
	"""
	family_ASC
	"""
	Order by family in a descending order
	"""
	family_DESC
	"""
	Order by biosVersion in an ascending order
	"""
	biosVersion_ASC
	"""
	Order by biosVersion in a descending order
	"""
	biosVersion_DESC
	"""
	Order by biosSerial in an ascending order
	"""
	biosSerial_ASC
	"""
	Order by biosSerial in a descending order
	"""
	biosSerial_DESC
}
"""
Boolean filter expression for AdapterDeviceUser
"""
input adapter_device_user_bool_exp {
	"""
	exists comparison operator
	"""
	deviceId_exists: Boolean
	"""
	eq comparison operator
	"""
	deviceId_eq: UUID
	"""
	neq comparison operator
	"""
	deviceId_neq: UUID
	"""
	in comparison operator
	"""
	deviceId_in: [UUID]
	"""
	not_in comparison operator
	"""
	deviceId_not_in: [UUID]
	"""
	gt comparison operator
	"""
	deviceId_gt: UUID
	"""
	gte comparison operator
	"""
	deviceId_gte: UUID
	"""
	lt comparison operator
	"""
	deviceId_lt: UUID
	"""
	lte comparison operator
	"""
	deviceId_lte: UUID
	"""
	exists comparison operator
	"""
	sid_exists: Boolean
	"""
	not comparison operator
	"""
	sid_not: String
	"""
	eq comparison operator
	"""
	sid_eq: String
	"""
	neq comparison operator
	"""
	sid_neq: String
	"""
	in comparison operator
	"""
	sid_in: [String]
	"""
	not_in comparison operator
	"""
	sid_not_in: [String]
	"""
	like comparison operator
	"""
	sid_like: String
	"""
	not_like comparison operator
	"""
	sid_not_like: String
	"""
	ilike comparison operator
	"""
	sid_ilike: String
	"""
	not_ilike comparison operator
	"""
	sid_not_ilike: String
	"""
	suffix comparison operator
	"""
	sid_suffix: String
	"""
	prefix comparison operator
	"""
	sid_prefix: String
	"""
	exists comparison operator
	"""
	username_exists: Boolean
	"""
	not comparison operator
	"""
	username_not: String
	"""
	eq comparison operator
	"""
	username_eq: String
	"""
	neq comparison operator
	"""
	username_neq: String
	"""
	in comparison operator
	"""
	username_in: [String]
	"""
	not_in comparison operator
	"""
	username_not_in: [String]
	"""
	like comparison operator
	"""
	username_like: String
	"""
	not_like comparison operator
	"""
	username_not_like: String
	"""
	ilike comparison operator
	"""
	username_ilike: String
	"""
	not_ilike comparison operator
	"""
	username_not_ilike: String
	"""
	suffix comparison operator
	"""
	username_suffix: String
	"""
	prefix comparison operator
	"""
	username_prefix: String
	"""
	exists comparison operator
	"""
	lastUseDate_exists: Boolean
	"""
	eq comparison operator
	"""
	lastUseDate_eq: Epoch
	"""
	neq comparison operator
	"""
	lastUseDate_neq: Epoch
	"""
	in comparison operator
	"""
	lastUseDate_in: [Epoch]
	"""
	not_in comparison operator
	"""
	lastUseDate_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	lastUseDate_gt: Epoch
	"""
	gte comparison operator
	"""
	lastUseDate_gte: Epoch
	"""
	lt comparison operator
	"""
	lastUseDate_lt: Epoch
	"""
	lte comparison operator
	"""
	lastUseDate_lte: Epoch
	"""
	days comparison operator
	"""
	lastUseDate_days: Int
	"""
	exists comparison operator
	"""
	isLocal_exists: Boolean
	"""
	eq comparison operator
	"""
	isLocal_eq: Boolean
	"""
	neq comparison operator
	"""
	isLocal_neq: Boolean
	"""
	exists comparison operator
	"""
	isDisabled_exists: Boolean
	"""
	eq comparison operator
	"""
	isDisabled_eq: Boolean
	"""
	neq comparison operator
	"""
	isDisabled_neq: Boolean
	"""
	exists comparison operator
	"""
	isAdmin_exists: Boolean
	"""
	eq comparison operator
	"""
	isAdmin_eq: Boolean
	"""
	neq comparison operator
	"""
	isAdmin_neq: Boolean
	"""
	exists comparison operator
	"""
	userDepartment_exists: Boolean
	"""
	eq comparison operator
	"""
	userDepartment_eq: Boolean
	"""
	neq comparison operator
	"""
	userDepartment_neq: Boolean
	"""
	exists comparison operator
	"""
	passwordMaxAge_exists: Boolean
	"""
	eq comparison operator
	"""
	passwordMaxAge_eq: Int
	"""
	neq comparison operator
	"""
	passwordMaxAge_neq: Int
	"""
	in comparison operator
	"""
	passwordMaxAge_in: [Int]
	"""
	not_in comparison operator
	"""
	passwordMaxAge_not_in: [Int]
	"""
	gt comparison operator
	"""
	passwordMaxAge_gt: Int
	"""
	gte comparison operator
	"""
	passwordMaxAge_gte: Int
	"""
	lt comparison operator
	"""
	passwordMaxAge_lt: Int
	"""
	lte comparison operator
	"""
	passwordMaxAge_lte: Int
	"""
	exists comparison operator
	"""
	interpreter_exists: Boolean
	"""
	not comparison operator
	"""
	interpreter_not: String
	"""
	eq comparison operator
	"""
	interpreter_eq: String
	"""
	neq comparison operator
	"""
	interpreter_neq: String
	"""
	in comparison operator
	"""
	interpreter_in: [String]
	"""
	not_in comparison operator
	"""
	interpreter_not_in: [String]
	"""
	like comparison operator
	"""
	interpreter_like: String
	"""
	not_like comparison operator
	"""
	interpreter_not_like: String
	"""
	ilike comparison operator
	"""
	interpreter_ilike: String
	"""
	not_ilike comparison operator
	"""
	interpreter_not_ilike: String
	"""
	suffix comparison operator
	"""
	interpreter_suffix: String
	"""
	prefix comparison operator
	"""
	interpreter_prefix: String
	AND: [adapter_device_user_bool_exp!]
	OR: [adapter_device_user_bool_exp!]
	NOT: [adapter_device_user_bool_exp!]
}
"""
Order for AdapterDeviceUser
"""
enum adapter_device_user_order_by {
	"""
	Order by sid in an ascending order
	"""
	sid_ASC
	"""
	Order by sid in a descending order
	"""
	sid_DESC
	"""
	Order by username in an ascending order
	"""
	username_ASC
	"""
	Order by username in a descending order
	"""
	username_DESC
	"""
	Order by lastUseDate in an ascending order
	"""
	lastUseDate_ASC
	"""
	Order by lastUseDate in a descending order
	"""
	lastUseDate_DESC
	"""
	Order by passwordMaxAge in an ascending order
	"""
	passwordMaxAge_ASC
	"""
	Order by passwordMaxAge in a descending order
	"""
	passwordMaxAge_DESC
	"""
	Order by interpreter in an ascending order
	"""
	interpreter_ASC
	"""
	Order by interpreter in a descending order
	"""
	interpreter_DESC
}
"""
Order for Adapter
"""
enum adapter_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
}
"""
Boolean filter expression for AdapterUser
"""
input adapter_user_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	eq comparison operator
	"""
	id_eq: UUID
	"""
	neq comparison operator
	"""
	id_neq: UUID
	"""
	in comparison operator
	"""
	id_in: [UUID]
	"""
	not_in comparison operator
	"""
	id_not_in: [UUID]
	"""
	gt comparison operator
	"""
	id_gt: UUID
	"""
	gte comparison operator
	"""
	id_gte: UUID
	"""
	lt comparison operator
	"""
	id_lt: UUID
	"""
	lte comparison operator
	"""
	id_lte: UUID
	"""
	exists comparison operator
	"""
	fetchCycle_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchCycle_eq: Int
	"""
	neq comparison operator
	"""
	fetchCycle_neq: Int
	"""
	in comparison operator
	"""
	fetchCycle_in: [Int]
	"""
	not_in comparison operator
	"""
	fetchCycle_not_in: [Int]
	"""
	gt comparison operator
	"""
	fetchCycle_gt: Int
	"""
	gte comparison operator
	"""
	fetchCycle_gte: Int
	"""
	lt comparison operator
	"""
	fetchCycle_lt: Int
	"""
	lte comparison operator
	"""
	fetchCycle_lte: Int
	"""
	eq comparison operator
	"""
	adapterId_eq: AdapterType
	"""
	neq comparison operator
	"""
	adapterId_neq: AdapterType
	"""
	in comparison operator
	"""
	adapterId_in: [AdapterType]
	"""
	not_in comparison operator
	"""
	adapterId_not_in: [AdapterType]
	"""
	filter by adapter
	"""
	adapter: adapter_bool_exp
	"""
	exists comparison operator
	"""
	adapterName_exists: Boolean
	"""
	not comparison operator
	"""
	adapterName_not: String
	"""
	eq comparison operator
	"""
	adapterName_eq: String
	"""
	neq comparison operator
	"""
	adapterName_neq: String
	"""
	in comparison operator
	"""
	adapterName_in: [String]
	"""
	not_in comparison operator
	"""
	adapterName_not_in: [String]
	"""
	like comparison operator
	"""
	adapterName_like: String
	"""
	not_like comparison operator
	"""
	adapterName_not_like: String
	"""
	ilike comparison operator
	"""
	adapterName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adapterName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adapterName_suffix: String
	"""
	prefix comparison operator
	"""
	adapterName_prefix: String
	"""
	exists comparison operator
	"""
	userId_exists: Boolean
	"""
	eq comparison operator
	"""
	userId_eq: UUID
	"""
	neq comparison operator
	"""
	userId_neq: UUID
	"""
	in comparison operator
	"""
	userId_in: [UUID]
	"""
	not_in comparison operator
	"""
	userId_not_in: [UUID]
	"""
	gt comparison operator
	"""
	userId_gt: UUID
	"""
	gte comparison operator
	"""
	userId_gte: UUID
	"""
	lt comparison operator
	"""
	userId_lt: UUID
	"""
	lte comparison operator
	"""
	userId_lte: UUID
	"""
	filter by adapterData
	"""
	adapterData: adapter_data_bool_exp
	"""
	exists comparison operator
	"""
	fetchTime_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchTime_eq: Epoch
	"""
	neq comparison operator
	"""
	fetchTime_neq: Epoch
	"""
	in comparison operator
	"""
	fetchTime_in: [Epoch]
	"""
	not_in comparison operator
	"""
	fetchTime_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	fetchTime_gt: Epoch
	"""
	gte comparison operator
	"""
	fetchTime_gte: Epoch
	"""
	lt comparison operator
	"""
	fetchTime_lt: Epoch
	"""
	lte comparison operator
	"""
	fetchTime_lte: Epoch
	"""
	days comparison operator
	"""
	fetchTime_days: Int
	"""
	exists comparison operator
	"""
	lastSeen_exists: Boolean
	"""
	eq comparison operator
	"""
	lastSeen_eq: Epoch
	"""
	neq comparison operator
	"""
	lastSeen_neq: Epoch
	"""
	in comparison operator
	"""
	lastSeen_in: [Epoch]
	"""
	not_in comparison operator
	"""
	lastSeen_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	lastSeen_gt: Epoch
	"""
	gte comparison operator
	"""
	lastSeen_gte: Epoch
	"""
	lt comparison operator
	"""
	lastSeen_lt: Epoch
	"""
	lte comparison operator
	"""
	lastSeen_lte: Epoch
	"""
	days comparison operator
	"""
	lastSeen_days: Int
	"""
	exists comparison operator
	"""
	username_exists: Boolean
	"""
	not comparison operator
	"""
	username_not: String
	"""
	eq comparison operator
	"""
	username_eq: String
	"""
	neq comparison operator
	"""
	username_neq: String
	"""
	in comparison operator
	"""
	username_in: [String]
	"""
	not_in comparison operator
	"""
	username_not_in: [String]
	"""
	like comparison operator
	"""
	username_like: String
	"""
	not_like comparison operator
	"""
	username_not_like: String
	"""
	ilike comparison operator
	"""
	username_ilike: String
	"""
	not_ilike comparison operator
	"""
	username_not_ilike: String
	"""
	suffix comparison operator
	"""
	username_suffix: String
	"""
	prefix comparison operator
	"""
	username_prefix: String
	"""
	exists comparison operator
	"""
	firstName_exists: Boolean
	"""
	not comparison operator
	"""
	firstName_not: String
	"""
	eq comparison operator
	"""
	firstName_eq: String
	"""
	neq comparison operator
	"""
	firstName_neq: String
	"""
	in comparison operator
	"""
	firstName_in: [String]
	"""
	not_in comparison operator
	"""
	firstName_not_in: [String]
	"""
	like comparison operator
	"""
	firstName_like: String
	"""
	not_like comparison operator
	"""
	firstName_not_like: String
	"""
	ilike comparison operator
	"""
	firstName_ilike: String
	"""
	not_ilike comparison operator
	"""
	firstName_not_ilike: String
	"""
	suffix comparison operator
	"""
	firstName_suffix: String
	"""
	prefix comparison operator
	"""
	firstName_prefix: String
	"""
	exists comparison operator
	"""
	lastName_exists: Boolean
	"""
	not comparison operator
	"""
	lastName_not: String
	"""
	eq comparison operator
	"""
	lastName_eq: String
	"""
	neq comparison operator
	"""
	lastName_neq: String
	"""
	in comparison operator
	"""
	lastName_in: [String]
	"""
	not_in comparison operator
	"""
	lastName_not_in: [String]
	"""
	like comparison operator
	"""
	lastName_like: String
	"""
	not_like comparison operator
	"""
	lastName_not_like: String
	"""
	ilike comparison operator
	"""
	lastName_ilike: String
	"""
	not_ilike comparison operator
	"""
	lastName_not_ilike: String
	"""
	suffix comparison operator
	"""
	lastName_suffix: String
	"""
	prefix comparison operator
	"""
	lastName_prefix: String
	"""
	exists comparison operator
	"""
	mail_exists: Boolean
	"""
	not comparison operator
	"""
	mail_not: String
	"""
	eq comparison operator
	"""
	mail_eq: String
	"""
	neq comparison operator
	"""
	mail_neq: String
	"""
	in comparison operator
	"""
	mail_in: [String]
	"""
	not_in comparison operator
	"""
	mail_not_in: [String]
	"""
	like comparison operator
	"""
	mail_like: String
	"""
	not_like comparison operator
	"""
	mail_not_like: String
	"""
	ilike comparison operator
	"""
	mail_ilike: String
	"""
	not_ilike comparison operator
	"""
	mail_not_ilike: String
	"""
	suffix comparison operator
	"""
	mail_suffix: String
	"""
	prefix comparison operator
	"""
	mail_prefix: String
	"""
	exists comparison operator
	"""
	admin_exists: Boolean
	"""
	eq comparison operator
	"""
	admin_eq: Boolean
	"""
	neq comparison operator
	"""
	admin_neq: Boolean
	"""
	exists comparison operator
	"""
	local_exists: Boolean
	"""
	eq comparison operator
	"""
	local_eq: Boolean
	"""
	neq comparison operator
	"""
	local_neq: Boolean
	"""
	exists comparison operator
	"""
	delegated_admin_exists: Boolean
	"""
	eq comparison operator
	"""
	delegated_admin_eq: Boolean
	"""
	neq comparison operator
	"""
	delegated_admin_neq: Boolean
	"""
	exists comparison operator
	"""
	mfa_enforced_exists: Boolean
	"""
	eq comparison operator
	"""
	mfa_enforced_eq: Boolean
	"""
	neq comparison operator
	"""
	mfa_enforced_neq: Boolean
	"""
	exists comparison operator
	"""
	mfa_enrolled_exists: Boolean
	"""
	eq comparison operator
	"""
	mfa_enrolled_eq: Boolean
	"""
	neq comparison operator
	"""
	mfa_enrolled_neq: Boolean
	"""
	exists comparison operator
	"""
	suspended_exists: Boolean
	"""
	eq comparison operator
	"""
	suspended_eq: Boolean
	"""
	neq comparison operator
	"""
	suspended_neq: Boolean
	"""
	exists comparison operator
	"""
	locked_exists: Boolean
	"""
	eq comparison operator
	"""
	locked_eq: Boolean
	"""
	neq comparison operator
	"""
	locked_neq: Boolean
	"""
	exists comparison operator
	"""
	disabled_exists: Boolean
	"""
	eq comparison operator
	"""
	disabled_eq: Boolean
	"""
	neq comparison operator
	"""
	disabled_neq: Boolean
	AND: [adapter_user_bool_exp!]
	OR: [adapter_user_bool_exp!]
	NOT: [adapter_user_bool_exp!]
}
"""
Order for AdapterUser
"""
enum adapter_user_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterName in an ascending order
	"""
	adapterName_ASC
	"""
	Order by adapterName in a descending order
	"""
	adapterName_DESC
	"""
	Order by fetchTime in an ascending order
	"""
	fetchTime_ASC
	"""
	Order by fetchTime in a descending order
	"""
	fetchTime_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
	"""
	Order by username in an ascending order
	"""
	username_ASC
	"""
	Order by username in a descending order
	"""
	username_DESC
	"""
	Order by firstName in an ascending order
	"""
	firstName_ASC
	"""
	Order by firstName in a descending order
	"""
	firstName_DESC
	"""
	Order by lastName in an ascending order
	"""
	lastName_ASC
	"""
	Order by lastName in a descending order
	"""
	lastName_DESC
	"""
	Order by mail in an ascending order
	"""
	mail_ASC
	"""
	Order by mail in a descending order
	"""
	mail_DESC
}
type csGroup @generateInputs(where: "cs_group_bool_exp", orderBy: "cs_group_order_by") {
	id: String
	name: String
	createdBy: String
	createdTimestamp: Epoch
	description: String
	groupType: String
	modifiedBy: String
	modifiedTime: Epoch
}
type csPolicy @generateInputs(where: "cs_policy_bool_exp", orderBy: "cs_policy_order_by") {
	name: String
	description: String
	platformName: String
	groups("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [csGroup]
	enabled: Boolean
	createdBy: String
	createdTime: Epoch
	preventionSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_prevention_settings_bool_exp): [csPreventionSettings]
	sensorUpdateSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_sensor_update_settings_bool_exp): [csSensorUpdateSettings]
	"""
	Returns aggregate of groups
	"""
	groups_aggregate("""
	group by columns
	"""
	groupBy: [groups_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [groups_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [groupsAggregate!]
	"""
	Returns aggregate of preventionSettings
	"""
	preventionSettings_aggregate("""
	group by columns
	"""
	groupBy: [preventionSettings_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [preventionSettings_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_prevention_settings_bool_exp): [preventionSettingsAggregate!]
	"""
	Returns aggregate of sensorUpdateSettings
	"""
	sensorUpdateSettings_aggregate("""
	group by columns
	"""
	groupBy: [sensorUpdateSettings_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [sensorUpdateSettings_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_sensor_update_settings_bool_exp): [sensorUpdateSettingsAggregate!]
}
type csPolicySettings @generateInputs(where: "cs_policy_settings_bool_exp", orderBy: "cs_policy_settings_order_by") {
	enabled: Boolean
}
type csPreventionSettings @generateInputs(where: "cs_prevention_settings_bool_exp", orderBy: "cs_prevention_settings_order_by") {
	name: String
	settings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_policy_settings_bool_exp): [csPolicySettings]
}
type csSensorUpdateSettings @generateInputs(where: "cs_sensor_update_settings_bool_exp", orderBy: "cs_sensor_update_settings_order_by") {
	build: String
}
"""
Boolean filter expression for csGroup
"""
input cs_group_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	not comparison operator
	"""
	id_not: String
	"""
	eq comparison operator
	"""
	id_eq: String
	"""
	neq comparison operator
	"""
	id_neq: String
	"""
	in comparison operator
	"""
	id_in: [String]
	"""
	not_in comparison operator
	"""
	id_not_in: [String]
	"""
	like comparison operator
	"""
	id_like: String
	"""
	not_like comparison operator
	"""
	id_not_like: String
	"""
	ilike comparison operator
	"""
	id_ilike: String
	"""
	not_ilike comparison operator
	"""
	id_not_ilike: String
	"""
	suffix comparison operator
	"""
	id_suffix: String
	"""
	prefix comparison operator
	"""
	id_prefix: String
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	createdBy_exists: Boolean
	"""
	not comparison operator
	"""
	createdBy_not: String
	"""
	eq comparison operator
	"""
	createdBy_eq: String
	"""
	neq comparison operator
	"""
	createdBy_neq: String
	"""
	in comparison operator
	"""
	createdBy_in: [String]
	"""
	not_in comparison operator
	"""
	createdBy_not_in: [String]
	"""
	like comparison operator
	"""
	createdBy_like: String
	"""
	not_like comparison operator
	"""
	createdBy_not_like: String
	"""
	ilike comparison operator
	"""
	createdBy_ilike: String
	"""
	not_ilike comparison operator
	"""
	createdBy_not_ilike: String
	"""
	suffix comparison operator
	"""
	createdBy_suffix: String
	"""
	prefix comparison operator
	"""
	createdBy_prefix: String
	"""
	exists comparison operator
	"""
	createdTimestamp_exists: Boolean
	"""
	eq comparison operator
	"""
	createdTimestamp_eq: Epoch
	"""
	neq comparison operator
	"""
	createdTimestamp_neq: Epoch
	"""
	in comparison operator
	"""
	createdTimestamp_in: [Epoch]
	"""
	not_in comparison operator
	"""
	createdTimestamp_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	createdTimestamp_gt: Epoch
	"""
	gte comparison operator
	"""
	createdTimestamp_gte: Epoch
	"""
	lt comparison operator
	"""
	createdTimestamp_lt: Epoch
	"""
	lte comparison operator
	"""
	createdTimestamp_lte: Epoch
	"""
	days comparison operator
	"""
	createdTimestamp_days: Int
	"""
	exists comparison operator
	"""
	description_exists: Boolean
	"""
	not comparison operator
	"""
	description_not: String
	"""
	eq comparison operator
	"""
	description_eq: String
	"""
	neq comparison operator
	"""
	description_neq: String
	"""
	in comparison operator
	"""
	description_in: [String]
	"""
	not_in comparison operator
	"""
	description_not_in: [String]
	"""
	like comparison operator
	"""
	description_like: String
	"""
	not_like comparison operator
	"""
	description_not_like: String
	"""
	ilike comparison operator
	"""
	description_ilike: String
	"""
	not_ilike comparison operator
	"""
	description_not_ilike: String
	"""
	suffix comparison operator
	"""
	description_suffix: String
	"""
	prefix comparison operator
	"""
	description_prefix: String
	"""
	exists comparison operator
	"""
	groupType_exists: Boolean
	"""
	not comparison operator
	"""
	groupType_not: String
	"""
	eq comparison operator
	"""
	groupType_eq: String
	"""
	neq comparison operator
	"""
	groupType_neq: String
	"""
	in comparison operator
	"""
	groupType_in: [String]
	"""
	not_in comparison operator
	"""
	groupType_not_in: [String]
	"""
	like comparison operator
	"""
	groupType_like: String
	"""
	not_like comparison operator
	"""
	groupType_not_like: String
	"""
	ilike comparison operator
	"""
	groupType_ilike: String
	"""
	not_ilike comparison operator
	"""
	groupType_not_ilike: String
	"""
	suffix comparison operator
	"""
	groupType_suffix: String
	"""
	prefix comparison operator
	"""
	groupType_prefix: String
	"""
	exists comparison operator
	"""
	modifiedBy_exists: Boolean
	"""
	not comparison operator
	"""
	modifiedBy_not: String
	"""
	eq comparison operator
	"""
	modifiedBy_eq: String
	"""
	neq comparison operator
	"""
	modifiedBy_neq: String
	"""
	in comparison operator
	"""
	modifiedBy_in: [String]
	"""
	not_in comparison operator
	"""
	modifiedBy_not_in: [String]
	"""
	like comparison operator
	"""
	modifiedBy_like: String
	"""
	not_like comparison operator
	"""
	modifiedBy_not_like: String
	"""
	ilike comparison operator
	"""
	modifiedBy_ilike: String
	"""
	not_ilike comparison operator
	"""
	modifiedBy_not_ilike: String
	"""
	suffix comparison operator
	"""
	modifiedBy_suffix: String
	"""
	prefix comparison operator
	"""
	modifiedBy_prefix: String
	"""
	exists comparison operator
	"""
	modifiedTime_exists: Boolean
	"""
	eq comparison operator
	"""
	modifiedTime_eq: Epoch
	"""
	neq comparison operator
	"""
	modifiedTime_neq: Epoch
	"""
	in comparison operator
	"""
	modifiedTime_in: [Epoch]
	"""
	not_in comparison operator
	"""
	modifiedTime_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	modifiedTime_gt: Epoch
	"""
	gte comparison operator
	"""
	modifiedTime_gte: Epoch
	"""
	lt comparison operator
	"""
	modifiedTime_lt: Epoch
	"""
	lte comparison operator
	"""
	modifiedTime_lte: Epoch
	"""
	days comparison operator
	"""
	modifiedTime_days: Int
	AND: [cs_group_bool_exp!]
	OR: [cs_group_bool_exp!]
	NOT: [cs_group_bool_exp!]
}
"""
Order for csGroup
"""
enum cs_group_order_by {
	"""
	Order by id in an ascending order
	"""
	id_ASC
	"""
	Order by id in a descending order
	"""
	id_DESC
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by createdBy in an ascending order
	"""
	createdBy_ASC
	"""
	Order by createdBy in a descending order
	"""
	createdBy_DESC
	"""
	Order by createdTimestamp in an ascending order
	"""
	createdTimestamp_ASC
	"""
	Order by createdTimestamp in a descending order
	"""
	createdTimestamp_DESC
	"""
	Order by description in an ascending order
	"""
	description_ASC
	"""
	Order by description in a descending order
	"""
	description_DESC
	"""
	Order by groupType in an ascending order
	"""
	groupType_ASC
	"""
	Order by groupType in a descending order
	"""
	groupType_DESC
	"""
	Order by modifiedBy in an ascending order
	"""
	modifiedBy_ASC
	"""
	Order by modifiedBy in a descending order
	"""
	modifiedBy_DESC
	"""
	Order by modifiedTime in an ascending order
	"""
	modifiedTime_ASC
	"""
	Order by modifiedTime in a descending order
	"""
	modifiedTime_DESC
}
"""
Boolean filter expression for csPolicy
"""
input cs_policy_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	description_exists: Boolean
	"""
	not comparison operator
	"""
	description_not: String
	"""
	eq comparison operator
	"""
	description_eq: String
	"""
	neq comparison operator
	"""
	description_neq: String
	"""
	in comparison operator
	"""
	description_in: [String]
	"""
	not_in comparison operator
	"""
	description_not_in: [String]
	"""
	like comparison operator
	"""
	description_like: String
	"""
	not_like comparison operator
	"""
	description_not_like: String
	"""
	ilike comparison operator
	"""
	description_ilike: String
	"""
	not_ilike comparison operator
	"""
	description_not_ilike: String
	"""
	suffix comparison operator
	"""
	description_suffix: String
	"""
	prefix comparison operator
	"""
	description_prefix: String
	"""
	exists comparison operator
	"""
	platformName_exists: Boolean
	"""
	not comparison operator
	"""
	platformName_not: String
	"""
	eq comparison operator
	"""
	platformName_eq: String
	"""
	neq comparison operator
	"""
	platformName_neq: String
	"""
	in comparison operator
	"""
	platformName_in: [String]
	"""
	not_in comparison operator
	"""
	platformName_not_in: [String]
	"""
	like comparison operator
	"""
	platformName_like: String
	"""
	not_like comparison operator
	"""
	platformName_not_like: String
	"""
	ilike comparison operator
	"""
	platformName_ilike: String
	"""
	not_ilike comparison operator
	"""
	platformName_not_ilike: String
	"""
	suffix comparison operator
	"""
	platformName_suffix: String
	"""
	prefix comparison operator
	"""
	platformName_prefix: String
	"""
	filter by groups
	"""
	groups: cs_group_bool_exp
	"""
	exists comparison operator
	"""
	enabled_exists: Boolean
	"""
	eq comparison operator
	"""
	enabled_eq: Boolean
	"""
	neq comparison operator
	"""
	enabled_neq: Boolean
	"""
	exists comparison operator
	"""
	createdBy_exists: Boolean
	"""
	not comparison operator
	"""
	createdBy_not: String
	"""
	eq comparison operator
	"""
	createdBy_eq: String
	"""
	neq comparison operator
	"""
	createdBy_neq: String
	"""
	in comparison operator
	"""
	createdBy_in: [String]
	"""
	not_in comparison operator
	"""
	createdBy_not_in: [String]
	"""
	like comparison operator
	"""
	createdBy_like: String
	"""
	not_like comparison operator
	"""
	createdBy_not_like: String
	"""
	ilike comparison operator
	"""
	createdBy_ilike: String
	"""
	not_ilike comparison operator
	"""
	createdBy_not_ilike: String
	"""
	suffix comparison operator
	"""
	createdBy_suffix: String
	"""
	prefix comparison operator
	"""
	createdBy_prefix: String
	"""
	exists comparison operator
	"""
	createdTime_exists: Boolean
	"""
	eq comparison operator
	"""
	createdTime_eq: Epoch
	"""
	neq comparison operator
	"""
	createdTime_neq: Epoch
	"""
	in comparison operator
	"""
	createdTime_in: [Epoch]
	"""
	not_in comparison operator
	"""
	createdTime_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	createdTime_gt: Epoch
	"""
	gte comparison operator
	"""
	createdTime_gte: Epoch
	"""
	lt comparison operator
	"""
	createdTime_lt: Epoch
	"""
	lte comparison operator
	"""
	createdTime_lte: Epoch
	"""
	days comparison operator
	"""
	createdTime_days: Int
	"""
	filter by preventionSettings
	"""
	preventionSettings: cs_prevention_settings_bool_exp
	"""
	filter by sensorUpdateSettings
	"""
	sensorUpdateSettings: cs_sensor_update_settings_bool_exp
	AND: [cs_policy_bool_exp!]
	OR: [cs_policy_bool_exp!]
	NOT: [cs_policy_bool_exp!]
}
"""
Order for csPolicy
"""
enum cs_policy_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by description in an ascending order
	"""
	description_ASC
	"""
	Order by description in a descending order
	"""
	description_DESC
	"""
	Order by platformName in an ascending order
	"""
	platformName_ASC
	"""
	Order by platformName in a descending order
	"""
	platformName_DESC
	"""
	Order by createdBy in an ascending order
	"""
	createdBy_ASC
	"""
	Order by createdBy in a descending order
	"""
	createdBy_DESC
	"""
	Order by createdTime in an ascending order
	"""
	createdTime_ASC
	"""
	Order by createdTime in a descending order
	"""
	createdTime_DESC
}
"""
Boolean filter expression for csPolicySettings
"""
input cs_policy_settings_bool_exp {
	"""
	exists comparison operator
	"""
	enabled_exists: Boolean
	"""
	eq comparison operator
	"""
	enabled_eq: Boolean
	"""
	neq comparison operator
	"""
	enabled_neq: Boolean
	AND: [cs_policy_settings_bool_exp!]
	OR: [cs_policy_settings_bool_exp!]
	NOT: [cs_policy_settings_bool_exp!]
}
"""
Boolean filter expression for csPreventionSettings
"""
input cs_prevention_settings_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	filter by settings
	"""
	settings: cs_policy_settings_bool_exp
	AND: [cs_prevention_settings_bool_exp!]
	OR: [cs_prevention_settings_bool_exp!]
	NOT: [cs_prevention_settings_bool_exp!]
}
"""
Order for csPreventionSettings
"""
enum cs_prevention_settings_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
}
"""
Boolean filter expression for csSensorUpdateSettings
"""
input cs_sensor_update_settings_bool_exp {
	"""
	exists comparison operator
	"""
	build_exists: Boolean
	"""
	not comparison operator
	"""
	build_not: String
	"""
	eq comparison operator
	"""
	build_eq: String
	"""
	neq comparison operator
	"""
	build_neq: String
	"""
	in comparison operator
	"""
	build_in: [String]
	"""
	not_in comparison operator
	"""
	build_not_in: [String]
	"""
	like comparison operator
	"""
	build_like: String
	"""
	not_like comparison operator
	"""
	build_not_like: String
	"""
	ilike comparison operator
	"""
	build_ilike: String
	"""
	not_ilike comparison operator
	"""
	build_not_ilike: String
	"""
	suffix comparison operator
	"""
	build_suffix: String
	"""
	prefix comparison operator
	"""
	build_prefix: String
	AND: [cs_sensor_update_settings_bool_exp!]
	OR: [cs_sensor_update_settings_bool_exp!]
	NOT: [cs_sensor_update_settings_bool_exp!]
}
"""
Order for csSensorUpdateSettings
"""
enum cs_sensor_update_settings_order_by {
	"""
	Order by build in an ascending order
	"""
	build_ASC
	"""
	Order by build in a descending order
	"""
	build_DESC
}
"""
Boolean filter expression for Device
"""
input device_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	eq comparison operator
	"""
	id_eq: UUID
	"""
	neq comparison operator
	"""
	id_neq: UUID
	"""
	in comparison operator
	"""
	id_in: [UUID]
	"""
	not_in comparison operator
	"""
	id_not_in: [UUID]
	"""
	gt comparison operator
	"""
	id_gt: UUID
	"""
	gte comparison operator
	"""
	id_gte: UUID
	"""
	lt comparison operator
	"""
	id_lt: UUID
	"""
	lte comparison operator
	"""
	id_lte: UUID
	"""
	exists comparison operator
	"""
	fetchCycle_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchCycle_eq: Int
	"""
	neq comparison operator
	"""
	fetchCycle_neq: Int
	"""
	in comparison operator
	"""
	fetchCycle_in: [Int]
	"""
	not_in comparison operator
	"""
	fetchCycle_not_in: [Int]
	"""
	gt comparison operator
	"""
	fetchCycle_gt: Int
	"""
	gte comparison operator
	"""
	fetchCycle_gte: Int
	"""
	lt comparison operator
	"""
	fetchCycle_lt: Int
	"""
	lte comparison operator
	"""
	fetchCycle_lte: Int
	"""
	exists comparison operator
	"""
	adapterCount_exists: Boolean
	"""
	eq comparison operator
	"""
	adapterCount_eq: Int
	"""
	neq comparison operator
	"""
	adapterCount_neq: Int
	"""
	in comparison operator
	"""
	adapterCount_in: [Int]
	"""
	not_in comparison operator
	"""
	adapterCount_not_in: [Int]
	"""
	gt comparison operator
	"""
	adapterCount_gt: Int
	"""
	gte comparison operator
	"""
	adapterCount_gte: Int
	"""
	lt comparison operator
	"""
	adapterCount_lt: Int
	"""
	lte comparison operator
	"""
	adapterCount_lte: Int
	"""
	contains comparison operator
	"""
	adapterNames_contains: [String]
	"""
	contained_by comparison operator
	"""
	adapterNames_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adapterNames_overlap: [String]
	"""
	size comparison operator
	"""
	adapterNames_size: Int
	"""
	contains_regex comparison operator
	"""
	adapterNames_contains_regex: String
	"""
	contains comparison operator
	"""
	hostnames_contains: [String]
	"""
	contained_by comparison operator
	"""
	hostnames_contained_by: [String]
	"""
	overlap comparison operator
	"""
	hostnames_overlap: [String]
	"""
	size comparison operator
	"""
	hostnames_size: Int
	"""
	contains_regex comparison operator
	"""
	hostnames_contains_regex: String
	"""
	exists comparison operator
	"""
	lastSeen_exists: Boolean
	"""
	eq comparison operator
	"""
	lastSeen_eq: Epoch
	"""
	neq comparison operator
	"""
	lastSeen_neq: Epoch
	"""
	in comparison operator
	"""
	lastSeen_in: [Epoch]
	"""
	not_in comparison operator
	"""
	lastSeen_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	lastSeen_gt: Epoch
	"""
	gte comparison operator
	"""
	lastSeen_gte: Epoch
	"""
	lt comparison operator
	"""
	lastSeen_lt: Epoch
	"""
	lte comparison operator
	"""
	lastSeen_lte: Epoch
	"""
	days comparison operator
	"""
	lastSeen_days: Int
	"""
	filter by adapterDevices
	"""
	adapterDevices: adapter_device_bool_exp
	"""
	filter by interfaces
	"""
	interfaces: network_interface_bool_exp
	"""
	filter by tags
	"""
	tags: tag_bool_exp
	AND: [device_bool_exp!]
	OR: [device_bool_exp!]
	NOT: [device_bool_exp!]
}
"""
Order for Device
"""
enum device_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterCount in an ascending order
	"""
	adapterCount_ASC
	"""
	Order by adapterCount in a descending order
	"""
	adapterCount_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
}
type devicesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_max_columns!]!): Map
	devices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: device_bool_exp): [Device]
}
enum devices_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by adapterCount
	"""
	adapterCount
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterCount
	"""
	adapterCount
	"""
	groupBy by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterCount
	"""
	adapterCount
	"""
	max by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterCount
	"""
	adapterCount
	"""
	min by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by adapterCount
	"""
	adapterCount
	"""
	sum by lastSeen
	"""
	lastSeen
}
type firewallRulesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_max_columns!]!): Map
	"""
	Firewall rules defined on this adapter device
	"""
	firewallRules("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: firewall_rule_bool_exp): [FirewallRule] @relation(name: "adapter_device_firewall_rules", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "firewall_rules", joinOn: ["name"])
}
enum firewallRules_aggregate_avg_columns {
	"""
	avg by srcPort
	"""
	srcPort
	"""
	avg by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_columns {
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by source
	"""
	source
	"""
	groupBy by target
	"""
	target
	"""
	groupBy by protocol
	"""
	protocol
	"""
	groupBy by srcPort
	"""
	srcPort
	"""
	groupBy by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_max_columns {
	"""
	max by name
	"""
	name
	"""
	max by source
	"""
	source
	"""
	max by target
	"""
	target
	"""
	max by protocol
	"""
	protocol
	"""
	max by srcPort
	"""
	srcPort
	"""
	max by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_min_columns {
	"""
	min by name
	"""
	name
	"""
	min by source
	"""
	source
	"""
	min by target
	"""
	target
	"""
	min by protocol
	"""
	protocol
	"""
	min by srcPort
	"""
	srcPort
	"""
	min by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_sum_columns {
	"""
	sum by srcPort
	"""
	srcPort
	"""
	sum by dstPort
	"""
	dstPort
}
"""
Boolean filter expression for FirewallRule
"""
input firewall_rule_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	source_exists: Boolean
	"""
	not comparison operator
	"""
	source_not: String
	"""
	eq comparison operator
	"""
	source_eq: String
	"""
	neq comparison operator
	"""
	source_neq: String
	"""
	in comparison operator
	"""
	source_in: [String]
	"""
	not_in comparison operator
	"""
	source_not_in: [String]
	"""
	like comparison operator
	"""
	source_like: String
	"""
	not_like comparison operator
	"""
	source_not_like: String
	"""
	ilike comparison operator
	"""
	source_ilike: String
	"""
	not_ilike comparison operator
	"""
	source_not_ilike: String
	"""
	suffix comparison operator
	"""
	source_suffix: String
	"""
	prefix comparison operator
	"""
	source_prefix: String
	"""
	eq comparison operator
	"""
	type_eq: AccessType
	"""
	neq comparison operator
	"""
	type_neq: AccessType
	"""
	in comparison operator
	"""
	type_in: [AccessType]
	"""
	not_in comparison operator
	"""
	type_not_in: [AccessType]
	"""
	eq comparison operator
	"""
	direction_eq: Direction
	"""
	neq comparison operator
	"""
	direction_neq: Direction
	"""
	in comparison operator
	"""
	direction_in: [Direction]
	"""
	not_in comparison operator
	"""
	direction_not_in: [Direction]
	"""
	exists comparison operator
	"""
	target_exists: Boolean
	"""
	not comparison operator
	"""
	target_not: String
	"""
	eq comparison operator
	"""
	target_eq: String
	"""
	neq comparison operator
	"""
	target_neq: String
	"""
	in comparison operator
	"""
	target_in: [String]
	"""
	not_in comparison operator
	"""
	target_not_in: [String]
	"""
	like comparison operator
	"""
	target_like: String
	"""
	not_like comparison operator
	"""
	target_not_like: String
	"""
	ilike comparison operator
	"""
	target_ilike: String
	"""
	not_ilike comparison operator
	"""
	target_not_ilike: String
	"""
	suffix comparison operator
	"""
	target_suffix: String
	"""
	prefix comparison operator
	"""
	target_prefix: String
	"""
	exists comparison operator
	"""
	protocol_exists: Boolean
	"""
	not comparison operator
	"""
	protocol_not: String
	"""
	eq comparison operator
	"""
	protocol_eq: String
	"""
	neq comparison operator
	"""
	protocol_neq: String
	"""
	in comparison operator
	"""
	protocol_in: [String]
	"""
	not_in comparison operator
	"""
	protocol_not_in: [String]
	"""
	like comparison operator
	"""
	protocol_like: String
	"""
	not_like comparison operator
	"""
	protocol_not_like: String
	"""
	ilike comparison operator
	"""
	protocol_ilike: String
	"""
	not_ilike comparison operator
	"""
	protocol_not_ilike: String
	"""
	suffix comparison operator
	"""
	protocol_suffix: String
	"""
	prefix comparison operator
	"""
	protocol_prefix: String
	"""
	exists comparison operator
	"""
	srcPort_exists: Boolean
	"""
	eq comparison operator
	"""
	srcPort_eq: Int
	"""
	neq comparison operator
	"""
	srcPort_neq: Int
	"""
	in comparison operator
	"""
	srcPort_in: [Int]
	"""
	not_in comparison operator
	"""
	srcPort_not_in: [Int]
	"""
	gt comparison operator
	"""
	srcPort_gt: Int
	"""
	gte comparison operator
	"""
	srcPort_gte: Int
	"""
	lt comparison operator
	"""
	srcPort_lt: Int
	"""
	lte comparison operator
	"""
	srcPort_lte: Int
	"""
	exists comparison operator
	"""
	dstPort_exists: Boolean
	"""
	eq comparison operator
	"""
	dstPort_eq: Int
	"""
	neq comparison operator
	"""
	dstPort_neq: Int
	"""
	in comparison operator
	"""
	dstPort_in: [Int]
	"""
	not_in comparison operator
	"""
	dstPort_not_in: [Int]
	"""
	gt comparison operator
	"""
	dstPort_gt: Int
	"""
	gte comparison operator
	"""
	dstPort_gte: Int
	"""
	lt comparison operator
	"""
	dstPort_lt: Int
	"""
	lte comparison operator
	"""
	dstPort_lte: Int
	AND: [firewall_rule_bool_exp!]
	OR: [firewall_rule_bool_exp!]
	NOT: [firewall_rule_bool_exp!]
}
"""
Order for FirewallRule
"""
enum firewall_rule_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by source in an ascending order
	"""
	source_ASC
	"""
	Order by source in a descending order
	"""
	source_DESC
	"""
	Order by target in an ascending order
	"""
	target_ASC
	"""
	Order by target in a descending order
	"""
	target_DESC
	"""
	Order by protocol in an ascending order
	"""
	protocol_ASC
	"""
	Order by protocol in a descending order
	"""
	protocol_DESC
	"""
	Order by srcPort in an ascending order
	"""
	srcPort_ASC
	"""
	Order by srcPort in a descending order
	"""
	srcPort_DESC
	"""
	Order by dstPort in an ascending order
	"""
	dstPort_ASC
	"""
	Order by dstPort in a descending order
	"""
	dstPort_DESC
}
"""
Boolean filter expression for GceTags
"""
input gce_tags_bool_exp {
	"""
	exists comparison operator
	"""
	gceKey_exists: Boolean
	"""
	not comparison operator
	"""
	gceKey_not: String
	"""
	eq comparison operator
	"""
	gceKey_eq: String
	"""
	neq comparison operator
	"""
	gceKey_neq: String
	"""
	in comparison operator
	"""
	gceKey_in: [String]
	"""
	not_in comparison operator
	"""
	gceKey_not_in: [String]
	"""
	like comparison operator
	"""
	gceKey_like: String
	"""
	not_like comparison operator
	"""
	gceKey_not_like: String
	"""
	ilike comparison operator
	"""
	gceKey_ilike: String
	"""
	not_ilike comparison operator
	"""
	gceKey_not_ilike: String
	"""
	suffix comparison operator
	"""
	gceKey_suffix: String
	"""
	prefix comparison operator
	"""
	gceKey_prefix: String
	"""
	exists comparison operator
	"""
	gceValue_exists: Boolean
	"""
	not comparison operator
	"""
	gceValue_not: String
	"""
	eq comparison operator
	"""
	gceValue_eq: String
	"""
	neq comparison operator
	"""
	gceValue_neq: String
	"""
	in comparison operator
	"""
	gceValue_in: [String]
	"""
	not_in comparison operator
	"""
	gceValue_not_in: [String]
	"""
	like comparison operator
	"""
	gceValue_like: String
	"""
	not_like comparison operator
	"""
	gceValue_not_like: String
	"""
	ilike comparison operator
	"""
	gceValue_ilike: String
	"""
	not_ilike comparison operator
	"""
	gceValue_not_ilike: String
	"""
	suffix comparison operator
	"""
	gceValue_suffix: String
	"""
	prefix comparison operator
	"""
	gceValue_prefix: String
	AND: [gce_tags_bool_exp!]
	OR: [gce_tags_bool_exp!]
	NOT: [gce_tags_bool_exp!]
}
"""
Order for GceTags
"""
enum gce_tags_order_by {
	"""
	Order by gceKey in an ascending order
	"""
	gceKey_ASC
	"""
	Order by gceKey in a descending order
	"""
	gceKey_DESC
	"""
	Order by gceValue in an ascending order
	"""
	gceValue_ASC
	"""
	Order by gceValue in a descending order
	"""
	gceValue_DESC
}
type groupsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_max_columns!]!): Map
	groups("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [csGroup]
}
enum groups_aggregate_avg_columns {
	"""
	avg by createdTimestamp
	"""
	createdTimestamp
	"""
	avg by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by createdBy
	"""
	createdBy
	"""
	groupBy by createdTimestamp
	"""
	createdTimestamp
	"""
	groupBy by description
	"""
	description
	"""
	groupBy by groupType
	"""
	groupType
	"""
	groupBy by modifiedBy
	"""
	modifiedBy
	"""
	groupBy by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by name
	"""
	name
	"""
	max by createdBy
	"""
	createdBy
	"""
	max by createdTimestamp
	"""
	createdTimestamp
	"""
	max by description
	"""
	description
	"""
	max by groupType
	"""
	groupType
	"""
	max by modifiedBy
	"""
	modifiedBy
	"""
	max by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by name
	"""
	name
	"""
	min by createdBy
	"""
	createdBy
	"""
	min by createdTimestamp
	"""
	createdTimestamp
	"""
	min by description
	"""
	description
	"""
	min by groupType
	"""
	groupType
	"""
	min by modifiedBy
	"""
	modifiedBy
	"""
	min by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_sum_columns {
	"""
	sum by createdTimestamp
	"""
	createdTimestamp
	"""
	sum by modifiedTime
	"""
	modifiedTime
}
type installedSoftwareAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_max_columns!]!): Map
	"""
	Software installed on this device
	"""
	installedSoftware("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: installed_software_bool_exp): [InstalledSoftware] @relation(name: "adapter_device_installed_software", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "installed_software", joinOn: ["name","version"])
}
enum installedSoftware_aggregate_avg_columns {
	"""
	avg by cveCount
	"""
	cveCount
}
enum installedSoftware_aggregate_columns {
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by version
	"""
	version
	"""
	groupBy by description
	"""
	description
	"""
	groupBy by vendor
	"""
	vendor
	"""
	groupBy by publisher
	"""
	publisher
	"""
	groupBy by cveCount
	"""
	cveCount
	"""
	groupBy by swLicense
	"""
	swLicense
	"""
	groupBy by path
	"""
	path
}
enum installedSoftware_aggregate_max_columns {
	"""
	max by name
	"""
	name
	"""
	max by version
	"""
	version
	"""
	max by description
	"""
	description
	"""
	max by vendor
	"""
	vendor
	"""
	max by publisher
	"""
	publisher
	"""
	max by cveCount
	"""
	cveCount
	"""
	max by swLicense
	"""
	swLicense
	"""
	max by path
	"""
	path
}
enum installedSoftware_aggregate_min_columns {
	"""
	min by name
	"""
	name
	"""
	min by version
	"""
	version
	"""
	min by description
	"""
	description
	"""
	min by vendor
	"""
	vendor
	"""
	min by publisher
	"""
	publisher
	"""
	min by cveCount
	"""
	cveCount
	"""
	min by swLicense
	"""
	swLicense
	"""
	min by path
	"""
	path
}
enum installedSoftware_aggregate_sum_columns {
	"""
	sum by cveCount
	"""
	cveCount
}
"""
Boolean filter expression for InstalledSoftware
"""
input installed_software_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	version_exists: Boolean
	"""
	not comparison operator
	"""
	version_not: String
	"""
	eq comparison operator
	"""
	version_eq: String
	"""
	neq comparison operator
	"""
	version_neq: String
	"""
	in comparison operator
	"""
	version_in: [String]
	"""
	not_in comparison operator
	"""
	version_not_in: [String]
	"""
	like comparison operator
	"""
	version_like: String
	"""
	not_like comparison operator
	"""
	version_not_like: String
	"""
	ilike comparison operator
	"""
	version_ilike: String
	"""
	not_ilike comparison operator
	"""
	version_not_ilike: String
	"""
	suffix comparison operator
	"""
	version_suffix: String
	"""
	prefix comparison operator
	"""
	version_prefix: String
	"""
	eq comparison operator
	"""
	architecture_eq: Architecture
	"""
	neq comparison operator
	"""
	architecture_neq: Architecture
	"""
	in comparison operator
	"""
	architecture_in: [Architecture]
	"""
	not_in comparison operator
	"""
	architecture_not_in: [Architecture]
	"""
	exists comparison operator
	"""
	description_exists: Boolean
	"""
	not comparison operator
	"""
	description_not: String
	"""
	eq comparison operator
	"""
	description_eq: String
	"""
	neq comparison operator
	"""
	description_neq: String
	"""
	in comparison operator
	"""
	description_in: [String]
	"""
	not_in comparison operator
	"""
	description_not_in: [String]
	"""
	like comparison operator
	"""
	description_like: String
	"""
	not_like comparison operator
	"""
	description_not_like: String
	"""
	ilike comparison operator
	"""
	description_ilike: String
	"""
	not_ilike comparison operator
	"""
	description_not_ilike: String
	"""
	suffix comparison operator
	"""
	description_suffix: String
	"""
	prefix comparison operator
	"""
	description_prefix: String
	"""
	exists comparison operator
	"""
	vendor_exists: Boolean
	"""
	not comparison operator
	"""
	vendor_not: String
	"""
	eq comparison operator
	"""
	vendor_eq: String
	"""
	neq comparison operator
	"""
	vendor_neq: String
	"""
	in comparison operator
	"""
	vendor_in: [String]
	"""
	not_in comparison operator
	"""
	vendor_not_in: [String]
	"""
	like comparison operator
	"""
	vendor_like: String
	"""
	not_like comparison operator
	"""
	vendor_not_like: String
	"""
	ilike comparison operator
	"""
	vendor_ilike: String
	"""
	not_ilike comparison operator
	"""
	vendor_not_ilike: String
	"""
	suffix comparison operator
	"""
	vendor_suffix: String
	"""
	prefix comparison operator
	"""
	vendor_prefix: String
	"""
	exists comparison operator
	"""
	publisher_exists: Boolean
	"""
	not comparison operator
	"""
	publisher_not: String
	"""
	eq comparison operator
	"""
	publisher_eq: String
	"""
	neq comparison operator
	"""
	publisher_neq: String
	"""
	in comparison operator
	"""
	publisher_in: [String]
	"""
	not_in comparison operator
	"""
	publisher_not_in: [String]
	"""
	like comparison operator
	"""
	publisher_like: String
	"""
	not_like comparison operator
	"""
	publisher_not_like: String
	"""
	ilike comparison operator
	"""
	publisher_ilike: String
	"""
	not_ilike comparison operator
	"""
	publisher_not_ilike: String
	"""
	suffix comparison operator
	"""
	publisher_suffix: String
	"""
	prefix comparison operator
	"""
	publisher_prefix: String
	"""
	exists comparison operator
	"""
	cveCount_exists: Boolean
	"""
	eq comparison operator
	"""
	cveCount_eq: Int
	"""
	neq comparison operator
	"""
	cveCount_neq: Int
	"""
	in comparison operator
	"""
	cveCount_in: [Int]
	"""
	not_in comparison operator
	"""
	cveCount_not_in: [Int]
	"""
	gt comparison operator
	"""
	cveCount_gt: Int
	"""
	gte comparison operator
	"""
	cveCount_gte: Int
	"""
	lt comparison operator
	"""
	cveCount_lt: Int
	"""
	lte comparison operator
	"""
	cveCount_lte: Int
	"""
	exists comparison operator
	"""
	swLicense_exists: Boolean
	"""
	not comparison operator
	"""
	swLicense_not: String
	"""
	eq comparison operator
	"""
	swLicense_eq: String
	"""
	neq comparison operator
	"""
	swLicense_neq: String
	"""
	in comparison operator
	"""
	swLicense_in: [String]
	"""
	not_in comparison operator
	"""
	swLicense_not_in: [String]
	"""
	like comparison operator
	"""
	swLicense_like: String
	"""
	not_like comparison operator
	"""
	swLicense_not_like: String
	"""
	ilike comparison operator
	"""
	swLicense_ilike: String
	"""
	not_ilike comparison operator
	"""
	swLicense_not_ilike: String
	"""
	suffix comparison operator
	"""
	swLicense_suffix: String
	"""
	prefix comparison operator
	"""
	swLicense_prefix: String
	"""
	exists comparison operator
	"""
	path_exists: Boolean
	"""
	not comparison operator
	"""
	path_not: String
	"""
	eq comparison operator
	"""
	path_eq: String
	"""
	neq comparison operator
	"""
	path_neq: String
	"""
	in comparison operator
	"""
	path_in: [String]
	"""
	not_in comparison operator
	"""
	path_not_in: [String]
	"""
	like comparison operator
	"""
	path_like: String
	"""
	not_like comparison operator
	"""
	path_not_like: String
	"""
	ilike comparison operator
	"""
	path_ilike: String
	"""
	not_ilike comparison operator
	"""
	path_not_ilike: String
	"""
	suffix comparison operator
	"""
	path_suffix: String
	"""
	prefix comparison operator
	"""
	path_prefix: String
	AND: [installed_software_bool_exp!]
	OR: [installed_software_bool_exp!]
	NOT: [installed_software_bool_exp!]
}
"""
Order for InstalledSoftware
"""
enum installed_software_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by version in an ascending order
	"""
	version_ASC
	"""
	Order by version in a descending order
	"""
	version_DESC
	"""
	Order by description in an ascending order
	"""
	description_ASC
	"""
	Order by description in a descending order
	"""
	description_DESC
	"""
	Order by vendor in an ascending order
	"""
	vendor_ASC
	"""
	Order by vendor in a descending order
	"""
	vendor_DESC
	"""
	Order by publisher in an ascending order
	"""
	publisher_ASC
	"""
	Order by publisher in a descending order
	"""
	publisher_DESC
	"""
	Order by cveCount in an ascending order
	"""
	cveCount_ASC
	"""
	Order by cveCount in a descending order
	"""
	cveCount_DESC
	"""
	Order by swLicense in an ascending order
	"""
	swLicense_ASC
	"""
	Order by swLicense in a descending order
	"""
	swLicense_DESC
	"""
	Order by path in an ascending order
	"""
	path_ASC
	"""
	Order by path in a descending order
	"""
	path_DESC
}
type interfacesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [interfaces_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [interfaces_aggregate_max_columns!]!): Map
	interfaces("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [NetworkInterface] @relation(name: "network_interfaces", fkName: ["id","fetch_cycle"], relationFkName: ["deviceId","fetch_cycle"], relType: ONE_TO_MANY)
}
enum interfaces_aggregate_columns {
	"""
	groupBy by deviceId
	"""
	deviceId
	"""
	groupBy by macAddr
	"""
	macAddr
}
enum interfaces_aggregate_max_columns {
	"""
	max by deviceId
	"""
	deviceId
	"""
	max by macAddr
	"""
	macAddr
}
enum interfaces_aggregate_min_columns {
	"""
	min by deviceId
	"""
	deviceId
	"""
	min by macAddr
	"""
	macAddr
}
"""
Boolean filter expression for NetworkInterface
"""
input network_interface_bool_exp {
	"""
	exists comparison operator
	"""
	deviceId_exists: Boolean
	"""
	eq comparison operator
	"""
	deviceId_eq: UUID
	"""
	neq comparison operator
	"""
	deviceId_neq: UUID
	"""
	in comparison operator
	"""
	deviceId_in: [UUID]
	"""
	not_in comparison operator
	"""
	deviceId_not_in: [UUID]
	"""
	gt comparison operator
	"""
	deviceId_gt: UUID
	"""
	gte comparison operator
	"""
	deviceId_gte: UUID
	"""
	lt comparison operator
	"""
	deviceId_lt: UUID
	"""
	lte comparison operator
	"""
	deviceId_lte: UUID
	"""
	exists comparison operator
	"""
	macAddr_exists: Boolean
	"""
	eq comparison operator
	"""
	macAddr_eq: Mac
	"""
	neq comparison operator
	"""
	macAddr_neq: Mac
	"""
	in comparison operator
	"""
	macAddr_in: [Mac]
	"""
	not_in comparison operator
	"""
	macAddr_not_in: [Mac]
	"""
	contains comparison operator
	"""
	ipAddrs_contains: [IP]
	"""
	contained_by comparison operator
	"""
	ipAddrs_contained_by: [IP]
	"""
	overlap comparison operator
	"""
	ipAddrs_overlap: [IP]
	"""
	size comparison operator
	"""
	ipAddrs_size: Int
	"""
	in_subnet comparison operator
	"""
	ipAddrs_in_subnet: CIDR
	"""
	ip_family comparison operator
	"""
	ipAddrs_ip_family: IPFamily
	AND: [network_interface_bool_exp!]
	OR: [network_interface_bool_exp!]
	NOT: [network_interface_bool_exp!]
}
"""
Boolean filter expression for OperatingSystem
"""
input operating_system_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	eq comparison operator
	"""
	id_eq: UUID
	"""
	neq comparison operator
	"""
	id_neq: UUID
	"""
	in comparison operator
	"""
	id_in: [UUID]
	"""
	not_in comparison operator
	"""
	id_not_in: [UUID]
	"""
	gt comparison operator
	"""
	id_gt: UUID
	"""
	gte comparison operator
	"""
	id_gte: UUID
	"""
	lt comparison operator
	"""
	id_lt: UUID
	"""
	lte comparison operator
	"""
	id_lte: UUID
	"""
	exists comparison operator
	"""
	type_exists: Boolean
	"""
	not comparison operator
	"""
	type_not: String
	"""
	eq comparison operator
	"""
	type_eq: String
	"""
	neq comparison operator
	"""
	type_neq: String
	"""
	in comparison operator
	"""
	type_in: [String]
	"""
	not_in comparison operator
	"""
	type_not_in: [String]
	"""
	like comparison operator
	"""
	type_like: String
	"""
	not_like comparison operator
	"""
	type_not_like: String
	"""
	ilike comparison operator
	"""
	type_ilike: String
	"""
	not_ilike comparison operator
	"""
	type_not_ilike: String
	"""
	suffix comparison operator
	"""
	type_suffix: String
	"""
	prefix comparison operator
	"""
	type_prefix: String
	"""
	exists comparison operator
	"""
	distribution_exists: Boolean
	"""
	not comparison operator
	"""
	distribution_not: String
	"""
	eq comparison operator
	"""
	distribution_eq: String
	"""
	neq comparison operator
	"""
	distribution_neq: String
	"""
	in comparison operator
	"""
	distribution_in: [String]
	"""
	not_in comparison operator
	"""
	distribution_not_in: [String]
	"""
	like comparison operator
	"""
	distribution_like: String
	"""
	not_like comparison operator
	"""
	distribution_not_like: String
	"""
	ilike comparison operator
	"""
	distribution_ilike: String
	"""
	not_ilike comparison operator
	"""
	distribution_not_ilike: String
	"""
	suffix comparison operator
	"""
	distribution_suffix: String
	"""
	prefix comparison operator
	"""
	distribution_prefix: String
	"""
	exists comparison operator
	"""
	architecture_exists: Boolean
	"""
	eq comparison operator
	"""
	architecture_eq: Int
	"""
	neq comparison operator
	"""
	architecture_neq: Int
	"""
	in comparison operator
	"""
	architecture_in: [Int]
	"""
	not_in comparison operator
	"""
	architecture_not_in: [Int]
	"""
	gt comparison operator
	"""
	architecture_gt: Int
	"""
	gte comparison operator
	"""
	architecture_gte: Int
	"""
	lt comparison operator
	"""
	architecture_lt: Int
	"""
	lte comparison operator
	"""
	architecture_lte: Int
	"""
	exists comparison operator
	"""
	servicePack_exists: Boolean
	"""
	not comparison operator
	"""
	servicePack_not: String
	"""
	eq comparison operator
	"""
	servicePack_eq: String
	"""
	neq comparison operator
	"""
	servicePack_neq: String
	"""
	in comparison operator
	"""
	servicePack_in: [String]
	"""
	not_in comparison operator
	"""
	servicePack_not_in: [String]
	"""
	like comparison operator
	"""
	servicePack_like: String
	"""
	not_like comparison operator
	"""
	servicePack_not_like: String
	"""
	ilike comparison operator
	"""
	servicePack_ilike: String
	"""
	not_ilike comparison operator
	"""
	servicePack_not_ilike: String
	"""
	suffix comparison operator
	"""
	servicePack_suffix: String
	"""
	prefix comparison operator
	"""
	servicePack_prefix: String
	"""
	exists comparison operator
	"""
	installDate_exists: Boolean
	"""
	eq comparison operator
	"""
	installDate_eq: Epoch
	"""
	neq comparison operator
	"""
	installDate_neq: Epoch
	"""
	in comparison operator
	"""
	installDate_in: [Epoch]
	"""
	not_in comparison operator
	"""
	installDate_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	installDate_gt: Epoch
	"""
	gte comparison operator
	"""
	installDate_gte: Epoch
	"""
	lt comparison operator
	"""
	installDate_lt: Epoch
	"""
	lte comparison operator
	"""
	installDate_lte: Epoch
	"""
	days comparison operator
	"""
	installDate_days: Int
	"""
	exists comparison operator
	"""
	kernelVersion_exists: Boolean
	"""
	not comparison operator
	"""
	kernelVersion_not: String
	"""
	eq comparison operator
	"""
	kernelVersion_eq: String
	"""
	neq comparison operator
	"""
	kernelVersion_neq: String
	"""
	in comparison operator
	"""
	kernelVersion_in: [String]
	"""
	not_in comparison operator
	"""
	kernelVersion_not_in: [String]
	"""
	like comparison operator
	"""
	kernelVersion_like: String
	"""
	not_like comparison operator
	"""
	kernelVersion_not_like: String
	"""
	ilike comparison operator
	"""
	kernelVersion_ilike: String
	"""
	not_ilike comparison operator
	"""
	kernelVersion_not_ilike: String
	"""
	suffix comparison operator
	"""
	kernelVersion_suffix: String
	"""
	prefix comparison operator
	"""
	kernelVersion_prefix: String
	"""
	exists comparison operator
	"""
	codeName_exists: Boolean
	"""
	not comparison operator
	"""
	codeName_not: String
	"""
	eq comparison operator
	"""
	codeName_eq: String
	"""
	neq comparison operator
	"""
	codeName_neq: String
	"""
	in comparison operator
	"""
	codeName_in: [String]
	"""
	not_in comparison operator
	"""
	codeName_not_in: [String]
	"""
	like comparison operator
	"""
	codeName_like: String
	"""
	not_like comparison operator
	"""
	codeName_not_like: String
	"""
	ilike comparison operator
	"""
	codeName_ilike: String
	"""
	not_ilike comparison operator
	"""
	codeName_not_ilike: String
	"""
	suffix comparison operator
	"""
	codeName_suffix: String
	"""
	prefix comparison operator
	"""
	codeName_prefix: String
	"""
	exists comparison operator
	"""
	major_exists: Boolean
	"""
	eq comparison operator
	"""
	major_eq: Int
	"""
	neq comparison operator
	"""
	major_neq: Int
	"""
	in comparison operator
	"""
	major_in: [Int]
	"""
	not_in comparison operator
	"""
	major_not_in: [Int]
	"""
	gt comparison operator
	"""
	major_gt: Int
	"""
	gte comparison operator
	"""
	major_gte: Int
	"""
	lt comparison operator
	"""
	major_lt: Int
	"""
	lte comparison operator
	"""
	major_lte: Int
	"""
	exists comparison operator
	"""
	minor_exists: Boolean
	"""
	eq comparison operator
	"""
	minor_eq: Int
	"""
	neq comparison operator
	"""
	minor_neq: Int
	"""
	in comparison operator
	"""
	minor_in: [Int]
	"""
	not_in comparison operator
	"""
	minor_not_in: [Int]
	"""
	gt comparison operator
	"""
	minor_gt: Int
	"""
	gte comparison operator
	"""
	minor_gte: Int
	"""
	lt comparison operator
	"""
	minor_lt: Int
	"""
	lte comparison operator
	"""
	minor_lte: Int
	"""
	exists comparison operator
	"""
	build_exists: Boolean
	"""
	not comparison operator
	"""
	build_not: String
	"""
	eq comparison operator
	"""
	build_eq: String
	"""
	neq comparison operator
	"""
	build_neq: String
	"""
	in comparison operator
	"""
	build_in: [String]
	"""
	not_in comparison operator
	"""
	build_not_in: [String]
	"""
	like comparison operator
	"""
	build_like: String
	"""
	not_like comparison operator
	"""
	build_not_like: String
	"""
	ilike comparison operator
	"""
	build_ilike: String
	"""
	not_ilike comparison operator
	"""
	build_not_ilike: String
	"""
	suffix comparison operator
	"""
	build_suffix: String
	"""
	prefix comparison operator
	"""
	build_prefix: String
	"""
	exists comparison operator
	"""
	RawName_exists: Boolean
	"""
	not comparison operator
	"""
	RawName_not: String
	"""
	eq comparison operator
	"""
	RawName_eq: String
	"""
	neq comparison operator
	"""
	RawName_neq: String
	"""
	in comparison operator
	"""
	RawName_in: [String]
	"""
	not_in comparison operator
	"""
	RawName_not_in: [String]
	"""
	like comparison operator
	"""
	RawName_like: String
	"""
	not_like comparison operator
	"""
	RawName_not_like: String
	"""
	ilike comparison operator
	"""
	RawName_ilike: String
	"""
	not_ilike comparison operator
	"""
	RawName_not_ilike: String
	"""
	suffix comparison operator
	"""
	RawName_suffix: String
	"""
	prefix comparison operator
	"""
	RawName_prefix: String
	AND: [operating_system_bool_exp!]
	OR: [operating_system_bool_exp!]
	NOT: [operating_system_bool_exp!]
}
"""
Order for OperatingSystem
"""
enum operating_system_order_by {
	"""
	Order by type in an ascending order
	"""
	type_ASC
	"""
	Order by type in a descending order
	"""
	type_DESC
	"""
	Order by distribution in an ascending order
	"""
	distribution_ASC
	"""
	Order by distribution in a descending order
	"""
	distribution_DESC
	"""
	Order by architecture in an ascending order
	"""
	architecture_ASC
	"""
	Order by architecture in a descending order
	"""
	architecture_DESC
	"""
	Order by servicePack in an ascending order
	"""
	servicePack_ASC
	"""
	Order by servicePack in a descending order
	"""
	servicePack_DESC
	"""
	Order by installDate in an ascending order
	"""
	installDate_ASC
	"""
	Order by installDate in a descending order
	"""
	installDate_DESC
	"""
	Order by kernelVersion in an ascending order
	"""
	kernelVersion_ASC
	"""
	Order by kernelVersion in a descending order
	"""
	kernelVersion_DESC
	"""
	Order by codeName in an ascending order
	"""
	codeName_ASC
	"""
	Order by codeName in a descending order
	"""
	codeName_DESC
	"""
	Order by major in an ascending order
	"""
	major_ASC
	"""
	Order by major in a descending order
	"""
	major_DESC
	"""
	Order by minor in an ascending order
	"""
	minor_ASC
	"""
	Order by minor in a descending order
	"""
	minor_DESC
	"""
	Order by build in an ascending order
	"""
	build_ASC
	"""
	Order by build in a descending order
	"""
	build_DESC
	"""
	Order by RawName in an ascending order
	"""
	RawName_ASC
	"""
	Order by RawName in a descending order
	"""
	RawName_DESC
}
type preventionSettingsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [preventionSettings_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [preventionSettings_aggregate_max_columns!]!): Map
	preventionSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_prevention_settings_bool_exp): [csPreventionSettings]
}
enum preventionSettings_aggregate_columns {
	"""
	groupBy by name
	"""
	name
}
enum preventionSettings_aggregate_max_columns {
	"""
	max by name
	"""
	name
}
enum preventionSettings_aggregate_min_columns {
	"""
	min by name
	"""
	name
}
type sensorUpdateSettingsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [sensorUpdateSettings_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [sensorUpdateSettings_aggregate_max_columns!]!): Map
	sensorUpdateSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_sensor_update_settings_bool_exp): [csSensorUpdateSettings]
}
enum sensorUpdateSettings_aggregate_columns {
	"""
	groupBy by build
	"""
	build
}
enum sensorUpdateSettings_aggregate_max_columns {
	"""
	max by build
	"""
	build
}
enum sensorUpdateSettings_aggregate_min_columns {
	"""
	min by build
	"""
	build
}
"""
Boolean filter expression for Tag
"""
input tag_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	creator_exists: Boolean
	"""
	not comparison operator
	"""
	creator_not: String
	"""
	eq comparison operator
	"""
	creator_eq: String
	"""
	neq comparison operator
	"""
	creator_neq: String
	"""
	in comparison operator
	"""
	creator_in: [String]
	"""
	not_in comparison operator
	"""
	creator_not_in: [String]
	"""
	like comparison operator
	"""
	creator_like: String
	"""
	not_like comparison operator
	"""
	creator_not_like: String
	"""
	ilike comparison operator
	"""
	creator_ilike: String
	"""
	not_ilike comparison operator
	"""
	creator_not_ilike: String
	"""
	suffix comparison operator
	"""
	creator_suffix: String
	"""
	prefix comparison operator
	"""
	creator_prefix: String
	"""
	exists comparison operator
	"""
	level_exists: Boolean
	"""
	not comparison operator
	"""
	level_not: String
	"""
	eq comparison operator
	"""
	level_eq: String
	"""
	neq comparison operator
	"""
	level_neq: String
	"""
	in comparison operator
	"""
	level_in: [String]
	"""
	not_in comparison operator
	"""
	level_not_in: [String]
	"""
	like comparison operator
	"""
	level_like: String
	"""
	not_like comparison operator
	"""
	level_not_like: String
	"""
	ilike comparison operator
	"""
	level_ilike: String
	"""
	not_ilike comparison operator
	"""
	level_not_ilike: String
	"""
	suffix comparison operator
	"""
	level_suffix: String
	"""
	prefix comparison operator
	"""
	level_prefix: String
	AND: [tag_bool_exp!]
	OR: [tag_bool_exp!]
	NOT: [tag_bool_exp!]
}
"""
Order for Tag
"""
enum tag_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by creator in an ascending order
	"""
	creator_ASC
	"""
	Order by creator in a descending order
	"""
	creator_DESC
	"""
	Order by level in an ascending order
	"""
	level_ASC
	"""
	Order by level in a descending order
	"""
	level_DESC
}
type tagsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [tags_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [tags_aggregate_max_columns!]!): Map
	tags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [Tag] @relation(name: "adapter_device_tags", fkName: ["id"], relationFkName: ["adapter_device_id"], relType: MANY_TO_MANY, manyToManyTableName: "tags", joinOn: ["name"])
}
enum tags_aggregate_columns {
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by creator
	"""
	creator
	"""
	groupBy by level
	"""
	level
}
enum tags_aggregate_max_columns {
	"""
	max by name
	"""
	name
	"""
	max by creator
	"""
	creator
	"""
	max by level
	"""
	level
}
enum tags_aggregate_min_columns {
	"""
	min by name
	"""
	name
	"""
	min by creator
	"""
	creator
	"""
	min by level
	"""
	level
}
"""
Boolean filter expression for User
"""
input user_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	eq comparison operator
	"""
	id_eq: UUID
	"""
	neq comparison operator
	"""
	id_neq: UUID
	"""
	in comparison operator
	"""
	id_in: [UUID]
	"""
	not_in comparison operator
	"""
	id_not_in: [UUID]
	"""
	gt comparison operator
	"""
	id_gt: UUID
	"""
	gte comparison operator
	"""
	id_gte: UUID
	"""
	lt comparison operator
	"""
	id_lt: UUID
	"""
	lte comparison operator
	"""
	id_lte: UUID
	"""
	exists comparison operator
	"""
	fetchCycle_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchCycle_eq: Int
	"""
	neq comparison operator
	"""
	fetchCycle_neq: Int
	"""
	in comparison operator
	"""
	fetchCycle_in: [Int]
	"""
	not_in comparison operator
	"""
	fetchCycle_not_in: [Int]
	"""
	gt comparison operator
	"""
	fetchCycle_gt: Int
	"""
	gte comparison operator
	"""
	fetchCycle_gte: Int
	"""
	lt comparison operator
	"""
	fetchCycle_lt: Int
	"""
	lte comparison operator
	"""
	fetchCycle_lte: Int
	"""
	exists comparison operator
	"""
	adapterCount_exists: Boolean
	"""
	eq comparison operator
	"""
	adapterCount_eq: Int
	"""
	neq comparison operator
	"""
	adapterCount_neq: Int
	"""
	in comparison operator
	"""
	adapterCount_in: [Int]
	"""
	not_in comparison operator
	"""
	adapterCount_not_in: [Int]
	"""
	gt comparison operator
	"""
	adapterCount_gt: Int
	"""
	gte comparison operator
	"""
	adapterCount_gte: Int
	"""
	lt comparison operator
	"""
	adapterCount_lt: Int
	"""
	lte comparison operator
	"""
	adapterCount_lte: Int
	"""
	contains comparison operator
	"""
	adapterNames_contains: [String]
	"""
	contained_by comparison operator
	"""
	adapterNames_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adapterNames_overlap: [String]
	"""
	size comparison operator
	"""
	adapterNames_size: Int
	"""
	contains_regex comparison operator
	"""
	adapterNames_contains_regex: String
	"""
	contains comparison operator
	"""
	usernames_contains: [String]
	"""
	contained_by comparison operator
	"""
	usernames_contained_by: [String]
	"""
	overlap comparison operator
	"""
	usernames_overlap: [String]
	"""
	size comparison operator
	"""
	usernames_size: Int
	"""
	contains_regex comparison operator
	"""
	usernames_contains_regex: String
	"""
	exists comparison operator
	"""
	lastSeen_exists: Boolean
	"""
	eq comparison operator
	"""
	lastSeen_eq: Epoch
	"""
	neq comparison operator
	"""
	lastSeen_neq: Epoch
	"""
	in comparison operator
	"""
	lastSeen_in: [Epoch]
	"""
	not_in comparison operator
	"""
	lastSeen_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	lastSeen_gt: Epoch
	"""
	gte comparison operator
	"""
	lastSeen_gte: Epoch
	"""
	lt comparison operator
	"""
	lastSeen_lt: Epoch
	"""
	lte comparison operator
	"""
	lastSeen_lte: Epoch
	"""
	days comparison operator
	"""
	lastSeen_days: Int
	"""
	filter by adapterUsers
	"""
	adapterUsers: adapter_user_bool_exp
	AND: [user_bool_exp!]
	OR: [user_bool_exp!]
	NOT: [user_bool_exp!]
}
"""
Order for User
"""
enum user_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterCount in an ascending order
	"""
	adapterCount_ASC
	"""
	Order by adapterCount in a descending order
	"""
	adapterCount_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
}
type usersAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_max_columns!]!): Map
	users("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: user_bool_exp): [User]
}
enum users_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by adapterCount
	"""
	adapterCount
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum users_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterCount
	"""
	adapterCount
	"""
	groupBy by lastSeen
	"""
	lastSeen
}
enum users_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterCount
	"""
	adapterCount
	"""
	max by lastSeen
	"""
	lastSeen
}
enum users_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterCount
	"""
	adapterCount
	"""
	min by lastSeen
	"""
	lastSeen
}
enum users_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by adapterCount
	"""
	adapterCount
	"""
	sum by lastSeen
	"""
	lastSeen
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_generateInputs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	return args, nil
}

func (ec *executionContext) dir_jsonpath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []*string
	if tmp, ok := rawArgs["depends"]; ok {
		arg1, err = ec.unmarshalOString2ᚕᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["depends"] = arg1
	return args, nil
}

func (ec *executionContext) dir_relation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["fkName"]; ok {
		arg1, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fkName"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["relationFkName"]; ok {
		arg2, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["relationFkName"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["relType"]; ok {
		arg3, err = ec.unmarshalNRelationType2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["relType"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["manyToManyTableName"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["manyToManyTableName"] = arg4
	var arg5 []string
	if tmp, ok := rawArgs["joinOn"]; ok {
		arg5, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["joinOn"] = arg5
	return args, nil
}

func (ec *executionContext) dir_viewFunction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []*string
	if tmp, ok := rawArgs["arguments"]; ok {
		arg1, err = ec.unmarshalOString2ᚕᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["arguments"] = arg1
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_adapterData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterDataBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_data_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDataBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_adapter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_deviceUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_user_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_firewallRules_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOfirewallRules_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []FirewallRulesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOfirewallRules_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *FirewallRuleBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOfirewall_rule_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐFirewallRuleBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_firewallRules_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *FirewallRuleBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOfirewall_rule_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐFirewallRuleBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_installedSoftware_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOinstalledSoftware_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []InstalledSoftwareAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOinstalledSoftware_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *InstalledSoftwareBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOinstalled_software_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_installedSoftware_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *InstalledSoftwareBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOinstalled_software_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_interfaces_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOinterfaces_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOinterfaces_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOnetwork_interface_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOnetwork_interface_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_localAdmins_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceAdminBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_admin_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceAdminBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_os_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *OperatingSystemBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOoperating_system_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐOperatingSystemBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_tags_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOtags_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []TagsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOtags_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOtag_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_tags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOtag_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterUser_adapterData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterDataBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_data_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDataBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterUser_adapter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_groups_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOgroups_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []GroupsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOgroups_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_group_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_groups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_group_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_preventionPolicy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CsPolicyBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOcs_policy_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsPolicyBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_sensorUpdatePolicy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOcs_group_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Device_adapterDevices_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterDevices_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterDevices_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_device_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Device_adapterDevices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_Device_interfaces_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOinterfaces_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOinterfaces_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOnetwork_interface_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Device_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOnetwork_interface_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_Device_tags_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOtags_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []TagsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOtags_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOtag_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Device_tags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOtag_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_GCETagsAggregate_GCETags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *GceTagsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOgce_tags_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐGceTagsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_GCETagsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GCETagsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNGCETags_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_GCETagsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GCETagsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNGCETags_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_GoogleCloudData_GCETags_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GCETagsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOGCETags_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []GCETagsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOGCETags_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *GceTagsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOgce_tags_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐGceTagsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_GoogleCloudData_GCETags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *GceTagsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOgce_tags_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐGceTagsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_adapterDevices_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterDevices_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterDevices_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_device_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_adapterDevices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []AdapterDeviceOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOadapter_device_order_by2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceOrderByᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_adapterUsers_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterUsers_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterUsers_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_user_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_adapterUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_user_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []AdapterUserOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOadapter_user_order_by2ᚕbandicootᚋpkgᚋgqlᚐAdapterUserOrderByᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_devices_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOdevices_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []DevicesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOdevices_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *DeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOdevice_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_devices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *DeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOdevice_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []DeviceOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOdevice_order_by2ᚕbandicootᚋpkgᚋgqlᚐDeviceOrderByᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_users_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOusers_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []UsersAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOusers_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *UserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOuser_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *UserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOuser_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []UserOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOuser_order_by2ᚕbandicootᚋpkgᚋgqlᚐUserOrderByᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_User_adapterUsers_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterUsers_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterUsers_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_user_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_User_adapterUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_user_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_adapterDevices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateAvgColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateSumColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_adapterUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_user_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateAvgColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateSumColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_csPolicy_groups_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOgroups_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []GroupsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOgroups_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_group_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_csPolicy_groups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_group_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_csPolicy_preventionSettings_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []PreventionSettingsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOpreventionSettings_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []PreventionSettingsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOpreventionSettings_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsPreventionSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_prevention_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_csPolicy_preventionSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsPreventionSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_prevention_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_csPolicy_sensorUpdateSettings_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []SensorUpdateSettingsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOsensorUpdateSettings_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []SensorUpdateSettingsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOsensorUpdateSettings_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsSensorUpdateSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_csPolicy_sensorUpdateSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsSensorUpdateSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_csPreventionSettings_settings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsPolicySettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_policy_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsPolicySettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateAvgColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_devices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *DeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOdevice_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateSumColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateAvgColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_firewallRules_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *FirewallRuleBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOfirewall_rule_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐFirewallRuleBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateSumColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateAvgColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_groups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_group_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateSumColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateAvgColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_installedSoftware_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *InstalledSoftwareBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOinstalled_software_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateSumColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_interfacesAggregate_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOnetwork_interface_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_interfacesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinterfaces_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_interfacesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinterfaces_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_preventionSettingsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []PreventionSettingsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNpreventionSettings_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_preventionSettingsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []PreventionSettingsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNpreventionSettings_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_preventionSettingsAggregate_preventionSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsPreventionSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_prevention_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_sensorUpdateSettingsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []SensorUpdateSettingsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNsensorUpdateSettings_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_sensorUpdateSettingsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []SensorUpdateSettingsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNsensorUpdateSettings_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_sensorUpdateSettingsAggregate_sensorUpdateSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsSensorUpdateSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_tagsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNtags_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_tagsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNtags_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_tagsAggregate_tags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOtag_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_usersAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateAvgColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateMaxColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateMinColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateSumColumnsᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *UserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOuser_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ActiveDirectoryData_adCn(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdCn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adSid(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdSid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adGuid(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdGUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adSAMAccountName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdSAMAccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adUserPrincipalName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdUserPrincipalName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adDisplayName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adDistinguishedName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdDistinguishedName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adCanonicalName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdCanonicalName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adAccountExpires(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdAccountExpires, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adObjectClass(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdObjectClass, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adObjectCategory(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdObjectCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adOrganizationalUnit(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdOrganizationalUnit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adLastLogoff(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdLastLogoff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adLastLogon(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdLastLogon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adLastLogonTimestamp(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdLastLogonTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adBadPasswordTime(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdBadPasswordTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_ad_bad_pwd_count(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdBadPwdCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adManagedBy(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdManagedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPasswordLastSet(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPasswordLastSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPrimaryGroupId(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPrimaryGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPrimaryGroupDn(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPrimaryGroupDn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMemberOf(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMemberOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMemberOfFull(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMemberOfFull, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adUsnChanged(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdUsnChanged, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adUsnCreated(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdUsnCreated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adWhenChanged(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdWhenChanged, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adWhenCreated(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdWhenCreated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adIsCriticalSystemObject(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdIsCriticalSystemObject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMsdsAllowedToDelegateTo(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMsdsAllowedToDelegateTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPwdMustChange(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPwdMustChange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMsdsResultantPso(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMsdsResultantPso, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Adapter_id(ctx context.Context, field graphql.CollectedField, obj *Adapter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Adapter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domain.AdapterType)
	fc.Result = res
	return ec.marshalNAdapterType2bandicootᚋpkgᚋdomainᚐAdapterType(ctx, field.Selections, res)
}

func (ec *executionContext) _Adapter_name(ctx context.Context, field graphql.CollectedField, obj *Adapter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Adapter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Adapter_properties(ctx context.Context, field graphql.CollectedField, obj *Adapter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Adapter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_id(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapterId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domain.AdapterType)
	fc.Result = res
	return ec.marshalNAdapterType2bandicootᚋpkgᚋdomainᚐAdapterType(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapter(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_adapter_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Adapter, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapters")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_ONE")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Adapter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bandicoot/pkg/gql.Adapter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Adapter)
	fc.Result = res
	return ec.marshalOAdapter2ᚖbandicootᚋpkgᚋgqlᚐAdapter(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapterName(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_deviceId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapterData(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_adapterData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.AdapterDevice().AdapterData(rctx, obj, args["where"].(*AdapterDataBoolExp))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "data")
			if err != nil {
				return nil, err
			}
			depends, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, depends)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(AdapterData); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bandicoot/pkg/gql.AdapterData`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(AdapterData)
	fc.Result = res
	return ec.marshalOAdapterData2bandicootᚋpkgᚋgqlᚐAdapterData(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_data(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_fetchTime(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_hostname(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_name(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_lastSeen(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_osId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OsID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_os(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_os_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Os, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "operating_systems")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"osId"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_ONE")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*OperatingSystem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bandicoot/pkg/gql.OperatingSystem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*OperatingSystem)
	fc.Result = res
	return ec.marshalOOperatingSystem2ᚖbandicootᚋpkgᚋgqlᚐOperatingSystem(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_prettyId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrettyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_tags(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_tags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tags, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_tags")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"adapter_device_id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2ᚖstring(ctx, "tags")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalOTag2ᚕᚖbandicootᚋpkgᚋgqlᚐTag(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_interfaces(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Interfaces, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"deviceId", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]NetworkInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.NetworkInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]NetworkInterface)
	fc.Result = res
	return ec.marshalONetworkInterface2ᚕbandicootᚋpkgᚋgqlᚐNetworkInterfaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_lastUsedUsers(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUsedUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_domain(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_partOfDomain(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartOfDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_deviceUsers(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_deviceUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DeviceUsers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "deviceUsers")
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AdapterDeviceUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.AdapterDeviceUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterDeviceUser)
	fc.Result = res
	return ec.marshalOAdapterDeviceUser2ᚕᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceUser(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_localAdmins(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_localAdmins_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LocalAdmins, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "localAdmins")
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AdapterDeviceAdmin); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.AdapterDeviceAdmin`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterDeviceAdmin)
	fc.Result = res
	return ec.marshalOAdapterDeviceAdmin2ᚕᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceAdmin(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_firewallRules(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_firewallRules_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FirewallRules, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_firewall_rules")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2ᚖstring(ctx, "firewall_rules")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*FirewallRule); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.FirewallRule`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FirewallRule)
	fc.Result = res
	return ec.marshalOFirewallRule2ᚕᚖbandicootᚋpkgᚋgqlᚐFirewallRule(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_installedSoftware(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_installedSoftware_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InstalledSoftware, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_installed_software")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2ᚖstring(ctx, "installed_software")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"name", "version"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InstalledSoftware); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.InstalledSoftware`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*InstalledSoftware)
	fc.Result = res
	return ec.marshalOInstalledSoftware2ᚕᚖbandicootᚋpkgᚋgqlᚐInstalledSoftware(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_agentVersion(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_agentStatus(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_agentName(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_model(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_manufacturer(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manufacturer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_serial(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Serial, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_family(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Family, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_biosVersion(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BiosVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_biosSerial(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BiosSerial, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_tags_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_tags_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TagsAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_tags")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"adapter_device_id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2ᚖstring(ctx, "tags")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]TagsAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.TagsAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]TagsAggregate)
	fc.Result = res
	return ec.marshalOtagsAggregate2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_interfaces_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_interfaces_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InterfacesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"deviceId", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]InterfacesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.InterfacesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]InterfacesAggregate)
	fc.Result = res
	return ec.marshalOinterfacesAggregate2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_firewallRules_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_firewallRules_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FirewallRulesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_firewall_rules")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2ᚖstring(ctx, "firewall_rules")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]FirewallRulesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.FirewallRulesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]FirewallRulesAggregate)
	fc.Result = res
	return ec.marshalOfirewallRulesAggregate2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_installedSoftware_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_installedSoftware_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InstalledSoftwareAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_installed_software")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2ᚖstring(ctx, "installed_software")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"name", "version"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]InstalledSoftwareAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.InstalledSoftwareAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]InstalledSoftwareAggregate)
	fc.Result = res
	return ec.marshalOinstalledSoftwareAggregate2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceAdmin_name(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceAdmin_type(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AdminType)
	fc.Result = res
	return ec.marshalOAdminType2ᚖbandicootᚋpkgᚋgqlᚐAdminType(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_deviceId(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_sid(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_username(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_lastUseDate(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUseDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_isLocal(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsLocal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_isDisabled(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_isAdmin(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAdmin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_userDepartment(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserDepartment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_passwordMaxAge(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PasswordMaxAge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_interpreter(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interpreter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_id(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapterId(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domain.AdapterType)
	fc.Result = res
	return ec.marshalNAdapterType2bandicootᚋpkgᚋdomainᚐAdapterType(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapter(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterUser_adapter_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Adapter, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapters")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_ONE")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Adapter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bandicoot/pkg/gql.Adapter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Adapter)
	fc.Result = res
	return ec.marshalOAdapter2ᚖbandicootᚋpkgᚋgqlᚐAdapter(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapterName(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_userId(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapterData(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterUser_adapterData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.AdapterUser().AdapterData(rctx, obj, args["where"].(*AdapterDataBoolExp))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "data")
			if err != nil {
				return nil, err
			}
			depends, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, depends)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(AdapterData); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bandicoot/pkg/gql.AdapterData`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(AdapterData)
	fc.Result = res
	return ec.marshalOAdapterData2bandicootᚋpkgᚋgqlᚐAdapterData(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_data(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_fetchTime(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_lastSeen(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_username(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_firstName(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_lastName(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_mail(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_admin(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_local(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Local, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_delegated_admin(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DelegatedAdmin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_mfa_enforced(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MfaEnforced, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_mfa_enrolled(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MfaEnrolled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_suspended(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suspended, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_locked(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_disabled(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_id(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_name(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_manfacturer(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manfacturer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_bitness(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bitness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_family(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Family, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_cores(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cores, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_coresThreads(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoresThreads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_ghz(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ghz, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_externalIp(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_groups(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_groups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2ᚕᚖbandicootᚋpkgᚋgqlᚐCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_preventionPolicy(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_preventionPolicy_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CsPolicy)
	fc.Result = res
	return ec.marshalOcsPolicy2ᚖbandicootᚋpkgᚋgqlᚐCsPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_sensorUpdatePolicy(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_sensorUpdatePolicy_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdatePolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2ᚖbandicootᚋpkgᚋgqlᚐCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_csAgentVersion(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CsAgentVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_groups_aggregate(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_groups_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]GroupsAggregate)
	fc.Result = res
	return ec.marshalOgroupsAggregate2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_isSafe(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSafe, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_deviceState(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CylanceDeviceState)
	fc.Result = res
	return ec.marshalOCylanceDeviceState2ᚖbandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_policyId(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PolicyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_policyName(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PolicyName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_policiesDetails(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PoliciesDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_tenantTag(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantTag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_zoneNames(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZoneNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_agentVersion(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_id(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterCount(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterNames(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_hostnames(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostnames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_lastSeen(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterDevices(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_adapterDevices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterDevices, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_devices")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterDevice); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterDevice`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterDevice)
	fc.Result = res
	return ec.marshalOAdapterDevice2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_interfaces(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Interfaces, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "device_network_interfaces")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]NetworkInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.NetworkInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]NetworkInterface)
	fc.Result = res
	return ec.marshalONetworkInterface2ᚕbandicootᚋpkgᚋgqlᚐNetworkInterfaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_tags(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_tags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tags, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "device_tags")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Tag)
	fc.Result = res
	return ec.marshalOTag2ᚕbandicootᚋpkgᚋgqlᚐTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Device__compatibilityAPI(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Device().CompatibilityAPI(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterDevices_aggregate(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_adapterDevices_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterDevicesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_devices")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterDevicesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterDevicesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterDevicesAggregate)
	fc.Result = res
	return ec.marshalOadapterDevicesAggregate2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_interfaces_aggregate(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_interfaces_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InterfacesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "device_network_interfaces")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]InterfacesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.InterfacesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]InterfacesAggregate)
	fc.Result = res
	return ec.marshalOinterfacesAggregate2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_tags_aggregate(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_tags_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TagsAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "device_tags")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]TagsAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.TagsAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]TagsAggregate)
	fc.Result = res
	return ec.marshalOtagsAggregate2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_name(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_source(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_type(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AccessType)
	fc.Result = res
	return ec.marshalOAccessType2ᚖbandicootᚋpkgᚋgqlᚐAccessType(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_direction(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Direction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Direction)
	fc.Result = res
	return ec.marshalODirection2ᚖbandicootᚋpkgᚋgqlᚐDirection(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_target(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_protocol(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_srcPort(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SrcPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_dstPort(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DstPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GCETagsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GCETagsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_GCETags(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GCETagsAggregate_GCETags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCETags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*GceTags)
	fc.Result = res
	return ec.marshalOGceTags2ᚕᚖbandicootᚋpkgᚋgqlᚐGceTags(ctx, field.Selections, res)
}

func (ec *executionContext) _GceTags_gceKey(ctx context.Context, field graphql.CollectedField, obj *GceTags) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GceTags",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GceKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GceTags_gceValue(ctx context.Context, field graphql.CollectedField, obj *GceTags) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GceTags",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GceValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_Id(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_Size(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_Image(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_GCETags(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GoogleCloudData_GCETags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCETags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*GceTags)
	fc.Result = res
	return ec.marshalOGceTags2ᚕᚖbandicootᚋpkgᚋgqlᚐGceTags(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_GCETags_aggregate(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GoogleCloudData_GCETags_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCETagsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]GCETagsAggregate)
	fc.Result = res
	return ec.marshalOGCETagsAggregate2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_name(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_version(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_architecture(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Architecture)
	fc.Result = res
	return ec.marshalOArchitecture2ᚖbandicootᚋpkgᚋgqlᚐArchitecture(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_description(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_vendor(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vendor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_publisher(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Publisher, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_cveCount(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CveCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_swLicense(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SwLicense, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_path(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_deviceId(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_macAddr(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MacAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOMac2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_ipAddrs(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddrs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]net.IP)
	fc.Result = res
	return ec.marshalOIP2ᚕnetᚐIPᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_id(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_type(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_distribution(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distribution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_architecture(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_servicePack(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServicePack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_installDate(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstallDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_kernelVersion(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KernelVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_codeName(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CodeName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_major(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Major, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_minor(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Minor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_build(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_RawName(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterDevices(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterDevices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterDevices(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp), args["orderBy"].([]AdapterDeviceOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]AdapterDevice)
	fc.Result = res
	return ec.marshalNAdapterDevice2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_devices(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_devices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Devices(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp), args["orderBy"].([]DeviceOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Device)
	fc.Result = res
	return ec.marshalNDevice2ᚕbandicootᚋpkgᚋgqlᚐDeviceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterUsers(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp), args["orderBy"].([]AdapterUserOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]AdapterUser)
	fc.Result = res
	return ec.marshalNAdapterUser2ᚕbandicootᚋpkgᚋgqlᚐAdapterUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_users_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp), args["orderBy"].([]UserOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]User)
	fc.Result = res
	return ec.marshalNUser2ᚕbandicootᚋpkgᚋgqlᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterDevices_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterDevices_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterDevicesAggregate(rctx, args["groupBy"].([]AdapterDevicesAggregateColumns), args["distinctOn"].([]AdapterDevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterDevicesAggregate)
	fc.Result = res
	return ec.marshalOadapterDevicesAggregate2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_devices_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_devices_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DevicesAggregate(rctx, args["groupBy"].([]DevicesAggregateColumns), args["distinctOn"].([]DevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]DevicesAggregate)
	fc.Result = res
	return ec.marshalOdevicesAggregate2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterUsers_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterUsers_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterUsersAggregate(rctx, args["groupBy"].([]AdapterUsersAggregateColumns), args["distinctOn"].([]AdapterUsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterUsersAggregate)
	fc.Result = res
	return ec.marshalOadapterUsersAggregate2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_users_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_users_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UsersAggregate(rctx, args["groupBy"].([]UsersAggregateColumns), args["distinctOn"].([]UsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]UsersAggregate)
	fc.Result = res
	return ec.marshalOusersAggregate2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_deviceId(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_path(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_name(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_totalSize(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_freeSize(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FreeSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_isEncrypted(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsEncrypted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_description(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Tag_name(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Tag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Tag_creator(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Tag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Tag_level(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Tag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _User_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterCount(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterNames(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _User_usernames(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Usernames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _User_lastSeen(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterUsers(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_User_adapterUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterUsers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_users")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"user_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterUser)
	fc.Result = res
	return ec.marshalOAdapterUser2ᚕbandicootᚋpkgᚋgqlᚐAdapterUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _User__compatibilityAPI(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().CompatibilityAPI(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterUsers_aggregate(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_User_adapterUsers_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterUsersAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_users")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"user_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterUsersAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterUsersAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterUsersAggregate)
	fc.Result = res
	return ec.marshalOadapterUsersAggregate2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_adapterDevices(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_adapterDevices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterDevices, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_devices")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AdapterDevice); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.AdapterDevice`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterDevice)
	fc.Result = res
	return ec.marshalOAdapterDevice2ᚕᚖbandicootᚋpkgᚋgqlᚐAdapterDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_group(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_count(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_min(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_max(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_adapterUsers(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_adapterUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterUsers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_users")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"user_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AdapterUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.AdapterUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterUser)
	fc.Result = res
	return ec.marshalOAdapterUser2ᚕᚖbandicootᚋpkgᚋgqlᚐAdapterUser(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_id(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_name(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_createdBy(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_createdTimestamp(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_description(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_groupType(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_modifiedBy(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_modifiedTime(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_name(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_description(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_platformName(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlatformName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_groups(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_groups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2ᚕᚖbandicootᚋpkgᚋgqlᚐCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_enabled(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_createdBy(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_createdTime(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_preventionSettings(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_preventionSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsPreventionSettings)
	fc.Result = res
	return ec.marshalOcsPreventionSettings2ᚕᚖbandicootᚋpkgᚋgqlᚐCsPreventionSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_sensorUpdateSettings(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_sensorUpdateSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdateSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsSensorUpdateSettings)
	fc.Result = res
	return ec.marshalOcsSensorUpdateSettings2ᚕᚖbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_groups_aggregate(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_groups_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]GroupsAggregate)
	fc.Result = res
	return ec.marshalOgroupsAggregate2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_preventionSettings_aggregate(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_preventionSettings_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionSettingsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]PreventionSettingsAggregate)
	fc.Result = res
	return ec.marshalOpreventionSettingsAggregate2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_sensorUpdateSettings_aggregate(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_sensorUpdateSettings_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdateSettingsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]SensorUpdateSettingsAggregate)
	fc.Result = res
	return ec.marshalOsensorUpdateSettingsAggregate2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicySettings_enabled(ctx context.Context, field graphql.CollectedField, obj *CsPolicySettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicySettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _csPreventionSettings_name(ctx context.Context, field graphql.CollectedField, obj *CsPreventionSettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPreventionSettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _csPreventionSettings_settings(ctx context.Context, field graphql.CollectedField, obj *CsPreventionSettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPreventionSettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPreventionSettings_settings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Settings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsPolicySettings)
	fc.Result = res
	return ec.marshalOcsPolicySettings2ᚕᚖbandicootᚋpkgᚋgqlᚐCsPolicySettings(ctx, field.Selections, res)
}

func (ec *executionContext) _csSensorUpdateSettings_build(ctx context.Context, field graphql.CollectedField, obj *CsSensorUpdateSettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csSensorUpdateSettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_devices(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_devices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Devices, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Device)
	fc.Result = res
	return ec.marshalODevice2ᚕᚖbandicootᚋpkgᚋgqlᚐDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_firewallRules(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_firewallRules_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FirewallRules, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_firewall_rules")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2ᚖstring(ctx, "firewall_rules")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*FirewallRule); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.FirewallRule`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FirewallRule)
	fc.Result = res
	return ec.marshalOFirewallRule2ᚕᚖbandicootᚋpkgᚋgqlᚐFirewallRule(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_groups(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_groups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2ᚕᚖbandicootᚋpkgᚋgqlᚐCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_group(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_count(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_min(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_max(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_installedSoftware(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_installedSoftware_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InstalledSoftware, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_installed_software")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2ᚖstring(ctx, "installed_software")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"name", "version"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InstalledSoftware); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.InstalledSoftware`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*InstalledSoftware)
	fc.Result = res
	return ec.marshalOInstalledSoftware2ᚕᚖbandicootᚋpkgᚋgqlᚐInstalledSoftware(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_interfacesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_interfacesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_interfaces(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_interfacesAggregate_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Interfaces, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"deviceId", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*NetworkInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.NetworkInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*NetworkInterface)
	fc.Result = res
	return ec.marshalONetworkInterface2ᚕᚖbandicootᚋpkgᚋgqlᚐNetworkInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_preventionSettingsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_preventionSettingsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_preventionSettings(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_preventionSettingsAggregate_preventionSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsPreventionSettings)
	fc.Result = res
	return ec.marshalOcsPreventionSettings2ᚕᚖbandicootᚋpkgᚋgqlᚐCsPreventionSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_sensorUpdateSettingsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_sensorUpdateSettingsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_sensorUpdateSettings(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_sensorUpdateSettingsAggregate_sensorUpdateSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdateSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsSensorUpdateSettings)
	fc.Result = res
	return ec.marshalOcsSensorUpdateSettings2ᚕᚖbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_tagsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_tagsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_tags(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_tagsAggregate_tags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tags, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_tags")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"adapter_device_id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2ᚖstring(ctx, "tags")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalOTag2ᚕᚖbandicootᚋpkgᚋgqlᚐTag(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_group(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_count(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_min(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_max(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_users(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_users_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*User)
	fc.Result = res
	return ec.marshalOUser2ᚕᚖbandicootᚋpkgᚋgqlᚐUser(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputadapter_bool_exp(ctx context.Context, obj interface{}) (AdapterBoolExp, error) {
	var it AdapterBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOAdapterType2ᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOAdapterType2ᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOAdapterType2ᚕᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOAdapterType2ᚕᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties_contains":
			var err error
			it.PropertiesContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties_contained_by":
			var err error
			it.PropertiesContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties_overlap":
			var err error
			it.PropertiesOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties_size":
			var err error
			it.PropertiesSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties_contains_regex":
			var err error
			it.PropertiesContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_data_bool_exp(ctx context.Context, obj interface{}) (AdapterDataBoolExp, error) {
	var it AdapterDataBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "adCn_exists":
			var err error
			it.AdCnExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_not":
			var err error
			it.AdCnNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_eq":
			var err error
			it.AdCnEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_neq":
			var err error
			it.AdCnNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_in":
			var err error
			it.AdCnIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_not_in":
			var err error
			it.AdCnNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_like":
			var err error
			it.AdCnLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_not_like":
			var err error
			it.AdCnNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_ilike":
			var err error
			it.AdCnIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_not_ilike":
			var err error
			it.AdCnNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_suffix":
			var err error
			it.AdCnSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_prefix":
			var err error
			it.AdCnPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_exists":
			var err error
			it.AdSidExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_not":
			var err error
			it.AdSidNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_eq":
			var err error
			it.AdSidEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_neq":
			var err error
			it.AdSidNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_in":
			var err error
			it.AdSidIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_not_in":
			var err error
			it.AdSidNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_like":
			var err error
			it.AdSidLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_not_like":
			var err error
			it.AdSidNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_ilike":
			var err error
			it.AdSidIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_not_ilike":
			var err error
			it.AdSidNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_suffix":
			var err error
			it.AdSidSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_prefix":
			var err error
			it.AdSidPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_exists":
			var err error
			it.AdGUIDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_not":
			var err error
			it.AdGUIDNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_eq":
			var err error
			it.AdGUIDEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_neq":
			var err error
			it.AdGUIDNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_in":
			var err error
			it.AdGUIDIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_not_in":
			var err error
			it.AdGUIDNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_like":
			var err error
			it.AdGUIDLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_not_like":
			var err error
			it.AdGUIDNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_ilike":
			var err error
			it.AdGUIDIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_not_ilike":
			var err error
			it.AdGUIDNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_suffix":
			var err error
			it.AdGUIDSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_prefix":
			var err error
			it.AdGUIDPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_exists":
			var err error
			it.AdNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_not":
			var err error
			it.AdNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_eq":
			var err error
			it.AdNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_neq":
			var err error
			it.AdNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_in":
			var err error
			it.AdNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_not_in":
			var err error
			it.AdNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_like":
			var err error
			it.AdNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_not_like":
			var err error
			it.AdNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_ilike":
			var err error
			it.AdNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_not_ilike":
			var err error
			it.AdNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_suffix":
			var err error
			it.AdNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_prefix":
			var err error
			it.AdNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_exists":
			var err error
			it.AdSAMAccountNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_not":
			var err error
			it.AdSAMAccountNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_eq":
			var err error
			it.AdSAMAccountNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_neq":
			var err error
			it.AdSAMAccountNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_in":
			var err error
			it.AdSAMAccountNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_not_in":
			var err error
			it.AdSAMAccountNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_like":
			var err error
			it.AdSAMAccountNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_not_like":
			var err error
			it.AdSAMAccountNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_ilike":
			var err error
			it.AdSAMAccountNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_not_ilike":
			var err error
			it.AdSAMAccountNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_suffix":
			var err error
			it.AdSAMAccountNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_prefix":
			var err error
			it.AdSAMAccountNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_exists":
			var err error
			it.AdUserPrincipalNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_not":
			var err error
			it.AdUserPrincipalNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_eq":
			var err error
			it.AdUserPrincipalNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_neq":
			var err error
			it.AdUserPrincipalNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_in":
			var err error
			it.AdUserPrincipalNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_not_in":
			var err error
			it.AdUserPrincipalNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_like":
			var err error
			it.AdUserPrincipalNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_not_like":
			var err error
			it.AdUserPrincipalNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_ilike":
			var err error
			it.AdUserPrincipalNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_not_ilike":
			var err error
			it.AdUserPrincipalNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_suffix":
			var err error
			it.AdUserPrincipalNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_prefix":
			var err error
			it.AdUserPrincipalNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_exists":
			var err error
			it.AdDisplayNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_not":
			var err error
			it.AdDisplayNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_eq":
			var err error
			it.AdDisplayNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_neq":
			var err error
			it.AdDisplayNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_in":
			var err error
			it.AdDisplayNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_not_in":
			var err error
			it.AdDisplayNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_like":
			var err error
			it.AdDisplayNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_not_like":
			var err error
			it.AdDisplayNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_ilike":
			var err error
			it.AdDisplayNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_not_ilike":
			var err error
			it.AdDisplayNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_suffix":
			var err error
			it.AdDisplayNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_prefix":
			var err error
			it.AdDisplayNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_exists":
			var err error
			it.AdDistinguishedNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_not":
			var err error
			it.AdDistinguishedNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_eq":
			var err error
			it.AdDistinguishedNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_neq":
			var err error
			it.AdDistinguishedNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_in":
			var err error
			it.AdDistinguishedNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_not_in":
			var err error
			it.AdDistinguishedNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_like":
			var err error
			it.AdDistinguishedNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_not_like":
			var err error
			it.AdDistinguishedNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_ilike":
			var err error
			it.AdDistinguishedNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_not_ilike":
			var err error
			it.AdDistinguishedNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_suffix":
			var err error
			it.AdDistinguishedNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_prefix":
			var err error
			it.AdDistinguishedNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_exists":
			var err error
			it.AdCanonicalNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_not":
			var err error
			it.AdCanonicalNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_eq":
			var err error
			it.AdCanonicalNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_neq":
			var err error
			it.AdCanonicalNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_in":
			var err error
			it.AdCanonicalNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_not_in":
			var err error
			it.AdCanonicalNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_like":
			var err error
			it.AdCanonicalNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_not_like":
			var err error
			it.AdCanonicalNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_ilike":
			var err error
			it.AdCanonicalNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_not_ilike":
			var err error
			it.AdCanonicalNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_suffix":
			var err error
			it.AdCanonicalNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_prefix":
			var err error
			it.AdCanonicalNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_exists":
			var err error
			it.AdAccountExpiresExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_eq":
			var err error
			it.AdAccountExpiresEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_neq":
			var err error
			it.AdAccountExpiresNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_in":
			var err error
			it.AdAccountExpiresIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_not_in":
			var err error
			it.AdAccountExpiresNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_gt":
			var err error
			it.AdAccountExpiresGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_gte":
			var err error
			it.AdAccountExpiresGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_lt":
			var err error
			it.AdAccountExpiresLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_lte":
			var err error
			it.AdAccountExpiresLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_days":
			var err error
			it.AdAccountExpiresDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectClass_contains":
			var err error
			it.AdObjectClassContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectClass_contained_by":
			var err error
			it.AdObjectClassContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectClass_overlap":
			var err error
			it.AdObjectClassOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectClass_size":
			var err error
			it.AdObjectClassSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectClass_contains_regex":
			var err error
			it.AdObjectClassContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_exists":
			var err error
			it.AdObjectCategoryExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_not":
			var err error
			it.AdObjectCategoryNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_eq":
			var err error
			it.AdObjectCategoryEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_neq":
			var err error
			it.AdObjectCategoryNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_in":
			var err error
			it.AdObjectCategoryIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_not_in":
			var err error
			it.AdObjectCategoryNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_like":
			var err error
			it.AdObjectCategoryLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_not_like":
			var err error
			it.AdObjectCategoryNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_ilike":
			var err error
			it.AdObjectCategoryIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_not_ilike":
			var err error
			it.AdObjectCategoryNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_suffix":
			var err error
			it.AdObjectCategorySuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_prefix":
			var err error
			it.AdObjectCategoryPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adOrganizationalUnit_contains":
			var err error
			it.AdOrganizationalUnitContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adOrganizationalUnit_contained_by":
			var err error
			it.AdOrganizationalUnitContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adOrganizationalUnit_overlap":
			var err error
			it.AdOrganizationalUnitOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adOrganizationalUnit_size":
			var err error
			it.AdOrganizationalUnitSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adOrganizationalUnit_contains_regex":
			var err error
			it.AdOrganizationalUnitContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_exists":
			var err error
			it.AdLastLogoffExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_eq":
			var err error
			it.AdLastLogoffEq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_neq":
			var err error
			it.AdLastLogoffNeq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_in":
			var err error
			it.AdLastLogoffIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_not_in":
			var err error
			it.AdLastLogoffNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_gt":
			var err error
			it.AdLastLogoffGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_gte":
			var err error
			it.AdLastLogoffGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_lt":
			var err error
			it.AdLastLogoffLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_lte":
			var err error
			it.AdLastLogoffLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_days":
			var err error
			it.AdLastLogoffDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_exists":
			var err error
			it.AdLastLogonExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_eq":
			var err error
			it.AdLastLogonEq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_neq":
			var err error
			it.AdLastLogonNeq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_in":
			var err error
			it.AdLastLogonIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_not_in":
			var err error
			it.AdLastLogonNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_gt":
			var err error
			it.AdLastLogonGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_gte":
			var err error
			it.AdLastLogonGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_lt":
			var err error
			it.AdLastLogonLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_lte":
			var err error
			it.AdLastLogonLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_days":
			var err error
			it.AdLastLogonDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_exists":
			var err error
			it.AdLastLogonTimestampExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_eq":
			var err error
			it.AdLastLogonTimestampEq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_neq":
			var err error
			it.AdLastLogonTimestampNeq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_in":
			var err error
			it.AdLastLogonTimestampIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_not_in":
			var err error
			it.AdLastLogonTimestampNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_gt":
			var err error
			it.AdLastLogonTimestampGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_gte":
			var err error
			it.AdLastLogonTimestampGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_lt":
			var err error
			it.AdLastLogonTimestampLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_lte":
			var err error
			it.AdLastLogonTimestampLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_days":
			var err error
			it.AdLastLogonTimestampDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_exists":
			var err error
			it.AdBadPasswordTimeExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_eq":
			var err error
			it.AdBadPasswordTimeEq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_neq":
			var err error
			it.AdBadPasswordTimeNeq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_in":
			var err error
			it.AdBadPasswordTimeIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_not_in":
			var err error
			it.AdBadPasswordTimeNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_gt":
			var err error
			it.AdBadPasswordTimeGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_gte":
			var err error
			it.AdBadPasswordTimeGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_lt":
			var err error
			it.AdBadPasswordTimeLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_lte":
			var err error
			it.AdBadPasswordTimeLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_days":
			var err error
			it.AdBadPasswordTimeDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_exists":
			var err error
			it.AdBadPwdCountExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_eq":
			var err error
			it.AdBadPwdCountEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_neq":
			var err error
			it.AdBadPwdCountNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_in":
			var err error
			it.AdBadPwdCountIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_not_in":
			var err error
			it.AdBadPwdCountNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_gt":
			var err error
			it.AdBadPwdCountGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_gte":
			var err error
			it.AdBadPwdCountGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_lt":
			var err error
			it.AdBadPwdCountLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_lte":
			var err error
			it.AdBadPwdCountLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_exists":
			var err error
			it.AdManagedByExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_not":
			var err error
			it.AdManagedByNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_eq":
			var err error
			it.AdManagedByEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_neq":
			var err error
			it.AdManagedByNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_in":
			var err error
			it.AdManagedByIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_not_in":
			var err error
			it.AdManagedByNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_like":
			var err error
			it.AdManagedByLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_not_like":
			var err error
			it.AdManagedByNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_ilike":
			var err error
			it.AdManagedByIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_not_ilike":
			var err error
			it.AdManagedByNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_suffix":
			var err error
			it.AdManagedBySuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_prefix":
			var err error
			it.AdManagedByPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_exists":
			var err error
			it.AdPasswordLastSetExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_eq":
			var err error
			it.AdPasswordLastSetEq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_neq":
			var err error
			it.AdPasswordLastSetNeq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_in":
			var err error
			it.AdPasswordLastSetIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_not_in":
			var err error
			it.AdPasswordLastSetNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_gt":
			var err error
			it.AdPasswordLastSetGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_gte":
			var err error
			it.AdPasswordLastSetGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_lt":
			var err error
			it.AdPasswordLastSetLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_lte":
			var err error
			it.AdPasswordLastSetLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_days":
			var err error
			it.AdPasswordLastSetDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_exists":
			var err error
			it.AdPrimaryGroupIDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_eq":
			var err error
			it.AdPrimaryGroupIDEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_neq":
			var err error
			it.AdPrimaryGroupIDNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_in":
			var err error
			it.AdPrimaryGroupIDIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_not_in":
			var err error
			it.AdPrimaryGroupIDNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_gt":
			var err error
			it.AdPrimaryGroupIDGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_gte":
			var err error
			it.AdPrimaryGroupIDGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_lt":
			var err error
			it.AdPrimaryGroupIDLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_lte":
			var err error
			it.AdPrimaryGroupIDLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_exists":
			var err error
			it.AdPrimaryGroupDnExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_not":
			var err error
			it.AdPrimaryGroupDnNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_eq":
			var err error
			it.AdPrimaryGroupDnEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_neq":
			var err error
			it.AdPrimaryGroupDnNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_in":
			var err error
			it.AdPrimaryGroupDnIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_not_in":
			var err error
			it.AdPrimaryGroupDnNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_like":
			var err error
			it.AdPrimaryGroupDnLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_not_like":
			var err error
			it.AdPrimaryGroupDnNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_ilike":
			var err error
			it.AdPrimaryGroupDnIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_not_ilike":
			var err error
			it.AdPrimaryGroupDnNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_suffix":
			var err error
			it.AdPrimaryGroupDnSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_prefix":
			var err error
			it.AdPrimaryGroupDnPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOf_contains":
			var err error
			it.AdMemberOfContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOf_contained_by":
			var err error
			it.AdMemberOfContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOf_overlap":
			var err error
			it.AdMemberOfOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOf_size":
			var err error
			it.AdMemberOfSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOf_contains_regex":
			var err error
			it.AdMemberOfContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOfFull_contains":
			var err error
			it.AdMemberOfFullContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOfFull_contained_by":
			var err error
			it.AdMemberOfFullContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOfFull_overlap":
			var err error
			it.AdMemberOfFullOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOfFull_size":
			var err error
			it.AdMemberOfFullSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOfFull_contains_regex":
			var err error
			it.AdMemberOfFullContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_exists":
			var err error
			it.AdUsnChangedExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_eq":
			var err error
			it.AdUsnChangedEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_neq":
			var err error
			it.AdUsnChangedNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_in":
			var err error
			it.AdUsnChangedIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_not_in":
			var err error
			it.AdUsnChangedNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_gt":
			var err error
			it.AdUsnChangedGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_gte":
			var err error
			it.AdUsnChangedGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_lt":
			var err error
			it.AdUsnChangedLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_lte":
			var err error
			it.AdUsnChangedLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_exists":
			var err error
			it.AdUsnCreatedExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_eq":
			var err error
			it.AdUsnCreatedEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_neq":
			var err error
			it.AdUsnCreatedNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_in":
			var err error
			it.AdUsnCreatedIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_not_in":
			var err error
			it.AdUsnCreatedNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_gt":
			var err error
			it.AdUsnCreatedGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_gte":
			var err error
			it.AdUsnCreatedGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_lt":
			var err error
			it.AdUsnCreatedLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_lte":
			var err error
			it.AdUsnCreatedLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_exists":
			var err error
			it.AdWhenChangedExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_eq":
			var err error
			it.AdWhenChangedEq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_neq":
			var err error
			it.AdWhenChangedNeq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_in":
			var err error
			it.AdWhenChangedIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_not_in":
			var err error
			it.AdWhenChangedNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_gt":
			var err error
			it.AdWhenChangedGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_gte":
			var err error
			it.AdWhenChangedGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_lt":
			var err error
			it.AdWhenChangedLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_lte":
			var err error
			it.AdWhenChangedLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_days":
			var err error
			it.AdWhenChangedDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_exists":
			var err error
			it.AdWhenCreatedExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_eq":
			var err error
			it.AdWhenCreatedEq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_neq":
			var err error
			it.AdWhenCreatedNeq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_in":
			var err error
			it.AdWhenCreatedIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_not_in":
			var err error
			it.AdWhenCreatedNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_gt":
			var err error
			it.AdWhenCreatedGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_gte":
			var err error
			it.AdWhenCreatedGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_lt":
			var err error
			it.AdWhenCreatedLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_lte":
			var err error
			it.AdWhenCreatedLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_days":
			var err error
			it.AdWhenCreatedDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adIsCriticalSystemObject_exists":
			var err error
			it.AdIsCriticalSystemObjectExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adIsCriticalSystemObject_eq":
			var err error
			it.AdIsCriticalSystemObjectEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adIsCriticalSystemObject_neq":
			var err error
			it.AdIsCriticalSystemObjectNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsAllowedToDelegateTo_contains":
			var err error
			it.AdMsdsAllowedToDelegateToContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsAllowedToDelegateTo_contained_by":
			var err error
			it.AdMsdsAllowedToDelegateToContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsAllowedToDelegateTo_overlap":
			var err error
			it.AdMsdsAllowedToDelegateToOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsAllowedToDelegateTo_size":
			var err error
			it.AdMsdsAllowedToDelegateToSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsAllowedToDelegateTo_contains_regex":
			var err error
			it.AdMsdsAllowedToDelegateToContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPwdMustChange_exists":
			var err error
			it.AdPwdMustChangeExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPwdMustChange_eq":
			var err error
			it.AdPwdMustChangeEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPwdMustChange_neq":
			var err error
			it.AdPwdMustChangeNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_exists":
			var err error
			it.AdMsdsResultantPsoExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_not":
			var err error
			it.AdMsdsResultantPsoNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_eq":
			var err error
			it.AdMsdsResultantPsoEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_neq":
			var err error
			it.AdMsdsResultantPsoNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_in":
			var err error
			it.AdMsdsResultantPsoIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_not_in":
			var err error
			it.AdMsdsResultantPsoNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_like":
			var err error
			it.AdMsdsResultantPsoLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_not_like":
			var err error
			it.AdMsdsResultantPsoNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_ilike":
			var err error
			it.AdMsdsResultantPsoIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_not_ilike":
			var err error
			it.AdMsdsResultantPsoNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_suffix":
			var err error
			it.AdMsdsResultantPsoSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_prefix":
			var err error
			it.AdMsdsResultantPsoPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_exists":
			var err error
			it.IsSafeExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_not":
			var err error
			it.IsSafeNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_eq":
			var err error
			it.IsSafeEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_neq":
			var err error
			it.IsSafeNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_in":
			var err error
			it.IsSafeIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_not_in":
			var err error
			it.IsSafeNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_like":
			var err error
			it.IsSafeLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_not_like":
			var err error
			it.IsSafeNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_ilike":
			var err error
			it.IsSafeIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_not_ilike":
			var err error
			it.IsSafeNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_suffix":
			var err error
			it.IsSafeSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_prefix":
			var err error
			it.IsSafePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceState_eq":
			var err error
			it.DeviceStateEq, err = ec.unmarshalOCylanceDeviceState2ᚖbandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceState_neq":
			var err error
			it.DeviceStateNeq, err = ec.unmarshalOCylanceDeviceState2ᚖbandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceState_in":
			var err error
			it.DeviceStateIn, err = ec.unmarshalOCylanceDeviceState2ᚕᚖbandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceState_not_in":
			var err error
			it.DeviceStateNotIn, err = ec.unmarshalOCylanceDeviceState2ᚕᚖbandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_exists":
			var err error
			it.PolicyIDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_not":
			var err error
			it.PolicyIDNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_eq":
			var err error
			it.PolicyIDEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_neq":
			var err error
			it.PolicyIDNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_in":
			var err error
			it.PolicyIDIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_not_in":
			var err error
			it.PolicyIDNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_like":
			var err error
			it.PolicyIDLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_not_like":
			var err error
			it.PolicyIDNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_ilike":
			var err error
			it.PolicyIDIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_not_ilike":
			var err error
			it.PolicyIDNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_suffix":
			var err error
			it.PolicyIDSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_prefix":
			var err error
			it.PolicyIDPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_exists":
			var err error
			it.PolicyNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_not":
			var err error
			it.PolicyNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_eq":
			var err error
			it.PolicyNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_neq":
			var err error
			it.PolicyNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_in":
			var err error
			it.PolicyNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_not_in":
			var err error
			it.PolicyNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_like":
			var err error
			it.PolicyNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_not_like":
			var err error
			it.PolicyNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_ilike":
			var err error
			it.PolicyNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_not_ilike":
			var err error
			it.PolicyNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_suffix":
			var err error
			it.PolicyNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_prefix":
			var err error
			it.PolicyNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policiesDetails_contains":
			var err error
			it.PoliciesDetailsContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policiesDetails_contained_by":
			var err error
			it.PoliciesDetailsContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policiesDetails_overlap":
			var err error
			it.PoliciesDetailsOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "policiesDetails_size":
			var err error
			it.PoliciesDetailsSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "policiesDetails_contains_regex":
			var err error
			it.PoliciesDetailsContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_exists":
			var err error
			it.TenantTagExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_not":
			var err error
			it.TenantTagNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_eq":
			var err error
			it.TenantTagEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_neq":
			var err error
			it.TenantTagNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_in":
			var err error
			it.TenantTagIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_not_in":
			var err error
			it.TenantTagNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_like":
			var err error
			it.TenantTagLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_not_like":
			var err error
			it.TenantTagNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_ilike":
			var err error
			it.TenantTagIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_not_ilike":
			var err error
			it.TenantTagNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_suffix":
			var err error
			it.TenantTagSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_prefix":
			var err error
			it.TenantTagPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "zoneNames_contains":
			var err error
			it.ZoneNamesContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "zoneNames_contained_by":
			var err error
			it.ZoneNamesContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "zoneNames_overlap":
			var err error
			it.ZoneNamesOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "zoneNames_size":
			var err error
			it.ZoneNamesSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "zoneNames_contains_regex":
			var err error
			it.ZoneNamesContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_exists":
			var err error
			it.AgentVersionExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not":
			var err error
			it.AgentVersionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_eq":
			var err error
			it.AgentVersionEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_neq":
			var err error
			it.AgentVersionNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_in":
			var err error
			it.AgentVersionIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_in":
			var err error
			it.AgentVersionNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_like":
			var err error
			it.AgentVersionLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_like":
			var err error
			it.AgentVersionNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_ilike":
			var err error
			it.AgentVersionIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_ilike":
			var err error
			it.AgentVersionNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_suffix":
			var err error
			it.AgentVersionSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_prefix":
			var err error
			it.AgentVersionPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_exists":
			var err error
			it.ExternalIPExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_not":
			var err error
			it.ExternalIPNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_eq":
			var err error
			it.ExternalIPEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_neq":
			var err error
			it.ExternalIPNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_in":
			var err error
			it.ExternalIPIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_not_in":
			var err error
			it.ExternalIPNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_like":
			var err error
			it.ExternalIPLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_not_like":
			var err error
			it.ExternalIPNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_ilike":
			var err error
			it.ExternalIPIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_not_ilike":
			var err error
			it.ExternalIPNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_suffix":
			var err error
			it.ExternalIPSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_prefix":
			var err error
			it.ExternalIPPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groups":
			var err error
			it.Groups, err = ec.unmarshalOcs_group_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "preventionPolicy":
			var err error
			it.PreventionPolicy, err = ec.unmarshalOcs_policy_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsPolicyBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "sensorUpdatePolicy":
			var err error
			it.SensorUpdatePolicy, err = ec.unmarshalOcs_group_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_exists":
			var err error
			it.CsAgentVersionExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_not":
			var err error
			it.CsAgentVersionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_eq":
			var err error
			it.CsAgentVersionEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_neq":
			var err error
			it.CsAgentVersionNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_in":
			var err error
			it.CsAgentVersionIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_not_in":
			var err error
			it.CsAgentVersionNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_like":
			var err error
			it.CsAgentVersionLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_not_like":
			var err error
			it.CsAgentVersionNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_ilike":
			var err error
			it.CsAgentVersionIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_not_ilike":
			var err error
			it.CsAgentVersionNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_suffix":
			var err error
			it.CsAgentVersionSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_prefix":
			var err error
			it.CsAgentVersionPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_data_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDataBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_data_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDataBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_data_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDataBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_device_admin_bool_exp(ctx context.Context, obj interface{}) (AdapterDeviceAdminBoolExp, error) {
	var it AdapterDeviceAdminBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_eq":
			var err error
			it.TypeEq, err = ec.unmarshalOAdminType2ᚖbandicootᚋpkgᚋgqlᚐAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_neq":
			var err error
			it.TypeNeq, err = ec.unmarshalOAdminType2ᚖbandicootᚋpkgᚋgqlᚐAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_in":
			var err error
			it.TypeIn, err = ec.unmarshalOAdminType2ᚕᚖbandicootᚋpkgᚋgqlᚐAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not_in":
			var err error
			it.TypeNotIn, err = ec.unmarshalOAdminType2ᚕᚖbandicootᚋpkgᚋgqlᚐAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_device_admin_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceAdminBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_device_admin_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceAdminBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_device_admin_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceAdminBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_device_bool_exp(ctx context.Context, obj interface{}) (AdapterDeviceBoolExp, error) {
	var it AdapterDeviceBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_exists":
			var err error
			it.FetchCycleExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_eq":
			var err error
			it.FetchCycleEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_neq":
			var err error
			it.FetchCycleNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_in":
			var err error
			it.FetchCycleIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_not_in":
			var err error
			it.FetchCycleNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gt":
			var err error
			it.FetchCycleGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gte":
			var err error
			it.FetchCycleGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lt":
			var err error
			it.FetchCycleLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lte":
			var err error
			it.FetchCycleLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_eq":
			var err error
			it.AdapterIDEq, err = ec.unmarshalOAdapterType2ᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_neq":
			var err error
			it.AdapterIDNeq, err = ec.unmarshalOAdapterType2ᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_in":
			var err error
			it.AdapterIDIn, err = ec.unmarshalOAdapterType2ᚕᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_not_in":
			var err error
			it.AdapterIDNotIn, err = ec.unmarshalOAdapterType2ᚕᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapter":
			var err error
			it.Adapter, err = ec.unmarshalOadapter_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_exists":
			var err error
			it.AdapterNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not":
			var err error
			it.AdapterNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_eq":
			var err error
			it.AdapterNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_neq":
			var err error
			it.AdapterNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_in":
			var err error
			it.AdapterNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_in":
			var err error
			it.AdapterNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_like":
			var err error
			it.AdapterNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_like":
			var err error
			it.AdapterNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_ilike":
			var err error
			it.AdapterNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_ilike":
			var err error
			it.AdapterNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_suffix":
			var err error
			it.AdapterNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_prefix":
			var err error
			it.AdapterNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_exists":
			var err error
			it.DeviceIDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_eq":
			var err error
			it.DeviceIDEq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_neq":
			var err error
			it.DeviceIDNeq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_in":
			var err error
			it.DeviceIDIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_not_in":
			var err error
			it.DeviceIDNotIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gt":
			var err error
			it.DeviceIDGt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gte":
			var err error
			it.DeviceIDGte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lt":
			var err error
			it.DeviceIDLt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lte":
			var err error
			it.DeviceIDLte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterData":
			var err error
			it.AdapterData, err = ec.unmarshalOadapter_data_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_exists":
			var err error
			it.FetchTimeExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_eq":
			var err error
			it.FetchTimeEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_neq":
			var err error
			it.FetchTimeNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_in":
			var err error
			it.FetchTimeIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_not_in":
			var err error
			it.FetchTimeNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_gt":
			var err error
			it.FetchTimeGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_gte":
			var err error
			it.FetchTimeGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_lt":
			var err error
			it.FetchTimeLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_lte":
			var err error
			it.FetchTimeLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_days":
			var err error
			it.FetchTimeDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_exists":
			var err error
			it.HostnameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_not":
			var err error
			it.HostnameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_eq":
			var err error
			it.HostnameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_neq":
			var err error
			it.HostnameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_in":
			var err error
			it.HostnameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_not_in":
			var err error
			it.HostnameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_like":
			var err error
			it.HostnameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_not_like":
			var err error
			it.HostnameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_ilike":
			var err error
			it.HostnameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_not_ilike":
			var err error
			it.HostnameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_suffix":
			var err error
			it.HostnameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_prefix":
			var err error
			it.HostnamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_exists":
			var err error
			it.LastSeenExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_eq":
			var err error
			it.LastSeenEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_neq":
			var err error
			it.LastSeenNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_in":
			var err error
			it.LastSeenIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_not_in":
			var err error
			it.LastSeenNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gt":
			var err error
			it.LastSeenGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gte":
			var err error
			it.LastSeenGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lt":
			var err error
			it.LastSeenLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lte":
			var err error
			it.LastSeenLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_days":
			var err error
			it.LastSeenDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_exists":
			var err error
			it.OsIDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_eq":
			var err error
			it.OsIDEq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_neq":
			var err error
			it.OsIDNeq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_in":
			var err error
			it.OsIDIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_not_in":
			var err error
			it.OsIDNotIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_gt":
			var err error
			it.OsIDGt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_gte":
			var err error
			it.OsIDGte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_lt":
			var err error
			it.OsIDLt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_lte":
			var err error
			it.OsIDLte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "os":
			var err error
			it.Os, err = ec.unmarshalOoperating_system_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐOperatingSystemBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_exists":
			var err error
			it.PrettyIDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_not":
			var err error
			it.PrettyIDNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_eq":
			var err error
			it.PrettyIDEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_neq":
			var err error
			it.PrettyIDNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_in":
			var err error
			it.PrettyIDIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_not_in":
			var err error
			it.PrettyIDNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_like":
			var err error
			it.PrettyIDLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_not_like":
			var err error
			it.PrettyIDNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_ilike":
			var err error
			it.PrettyIDIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_not_ilike":
			var err error
			it.PrettyIDNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_suffix":
			var err error
			it.PrettyIDSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_prefix":
			var err error
			it.PrettyIDPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOtag_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "interfaces":
			var err error
			it.Interfaces, err = ec.unmarshalOnetwork_interface_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUsedUsers_contains":
			var err error
			it.LastUsedUsersContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUsedUsers_contained_by":
			var err error
			it.LastUsedUsersContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUsedUsers_overlap":
			var err error
			it.LastUsedUsersOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUsedUsers_size":
			var err error
			it.LastUsedUsersSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUsedUsers_contains_regex":
			var err error
			it.LastUsedUsersContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_exists":
			var err error
			it.DomainExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_not":
			var err error
			it.DomainNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_eq":
			var err error
			it.DomainEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_neq":
			var err error
			it.DomainNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_in":
			var err error
			it.DomainIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_not_in":
			var err error
			it.DomainNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_like":
			var err error
			it.DomainLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_not_like":
			var err error
			it.DomainNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_ilike":
			var err error
			it.DomainIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_not_ilike":
			var err error
			it.DomainNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_suffix":
			var err error
			it.DomainSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_prefix":
			var err error
			it.DomainPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "partOfDomain_exists":
			var err error
			it.PartOfDomainExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "partOfDomain_eq":
			var err error
			it.PartOfDomainEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "partOfDomain_neq":
			var err error
			it.PartOfDomainNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceUsers":
			var err error
			it.DeviceUsers, err = ec.unmarshalOadapter_device_user_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "localAdmins":
			var err error
			it.LocalAdmins, err = ec.unmarshalOadapter_device_admin_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceAdminBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "firewallRules":
			var err error
			it.FirewallRules, err = ec.unmarshalOfirewall_rule_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐFirewallRuleBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "installedSoftware":
			var err error
			it.InstalledSoftware, err = ec.unmarshalOinstalled_software_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_exists":
			var err error
			it.AgentVersionExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not":
			var err error
			it.AgentVersionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_eq":
			var err error
			it.AgentVersionEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_neq":
			var err error
			it.AgentVersionNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_in":
			var err error
			it.AgentVersionIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_in":
			var err error
			it.AgentVersionNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_like":
			var err error
			it.AgentVersionLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_like":
			var err error
			it.AgentVersionNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_ilike":
			var err error
			it.AgentVersionIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_ilike":
			var err error
			it.AgentVersionNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_suffix":
			var err error
			it.AgentVersionSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_prefix":
			var err error
			it.AgentVersionPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_exists":
			var err error
			it.AgentStatusExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_not":
			var err error
			it.AgentStatusNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_eq":
			var err error
			it.AgentStatusEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_neq":
			var err error
			it.AgentStatusNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_in":
			var err error
			it.AgentStatusIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_not_in":
			var err error
			it.AgentStatusNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_like":
			var err error
			it.AgentStatusLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_not_like":
			var err error
			it.AgentStatusNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_ilike":
			var err error
			it.AgentStatusIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_not_ilike":
			var err error
			it.AgentStatusNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_suffix":
			var err error
			it.AgentStatusSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_prefix":
			var err error
			it.AgentStatusPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_exists":
			var err error
			it.AgentNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_not":
			var err error
			it.AgentNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_eq":
			var err error
			it.AgentNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_neq":
			var err error
			it.AgentNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_in":
			var err error
			it.AgentNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_not_in":
			var err error
			it.AgentNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_like":
			var err error
			it.AgentNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_not_like":
			var err error
			it.AgentNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_ilike":
			var err error
			it.AgentNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_not_ilike":
			var err error
			it.AgentNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_suffix":
			var err error
			it.AgentNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_prefix":
			var err error
			it.AgentNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_exists":
			var err error
			it.ModelExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_not":
			var err error
			it.ModelNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_eq":
			var err error
			it.ModelEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_neq":
			var err error
			it.ModelNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_in":
			var err error
			it.ModelIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_not_in":
			var err error
			it.ModelNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_like":
			var err error
			it.ModelLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_not_like":
			var err error
			it.ModelNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_ilike":
			var err error
			it.ModelIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_not_ilike":
			var err error
			it.ModelNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_suffix":
			var err error
			it.ModelSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_prefix":
			var err error
			it.ModelPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_exists":
			var err error
			it.ManufacturerExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_not":
			var err error
			it.ManufacturerNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_eq":
			var err error
			it.ManufacturerEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_neq":
			var err error
			it.ManufacturerNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_in":
			var err error
			it.ManufacturerIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_not_in":
			var err error
			it.ManufacturerNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_like":
			var err error
			it.ManufacturerLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_not_like":
			var err error
			it.ManufacturerNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_ilike":
			var err error
			it.ManufacturerIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_not_ilike":
			var err error
			it.ManufacturerNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_suffix":
			var err error
			it.ManufacturerSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_prefix":
			var err error
			it.ManufacturerPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_exists":
			var err error
			it.SerialExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_not":
			var err error
			it.SerialNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_eq":
			var err error
			it.SerialEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_neq":
			var err error
			it.SerialNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_in":
			var err error
			it.SerialIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_not_in":
			var err error
			it.SerialNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_like":
			var err error
			it.SerialLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_not_like":
			var err error
			it.SerialNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_ilike":
			var err error
			it.SerialIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_not_ilike":
			var err error
			it.SerialNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_suffix":
			var err error
			it.SerialSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_prefix":
			var err error
			it.SerialPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_exists":
			var err error
			it.FamilyExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_not":
			var err error
			it.FamilyNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_eq":
			var err error
			it.FamilyEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_neq":
			var err error
			it.FamilyNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_in":
			var err error
			it.FamilyIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_not_in":
			var err error
			it.FamilyNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_like":
			var err error
			it.FamilyLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_not_like":
			var err error
			it.FamilyNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_ilike":
			var err error
			it.FamilyIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_not_ilike":
			var err error
			it.FamilyNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_suffix":
			var err error
			it.FamilySuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_prefix":
			var err error
			it.FamilyPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_exists":
			var err error
			it.BiosVersionExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_not":
			var err error
			it.BiosVersionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_eq":
			var err error
			it.BiosVersionEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_neq":
			var err error
			it.BiosVersionNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_in":
			var err error
			it.BiosVersionIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_not_in":
			var err error
			it.BiosVersionNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_like":
			var err error
			it.BiosVersionLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_not_like":
			var err error
			it.BiosVersionNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_ilike":
			var err error
			it.BiosVersionIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_not_ilike":
			var err error
			it.BiosVersionNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_suffix":
			var err error
			it.BiosVersionSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_prefix":
			var err error
			it.BiosVersionPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_exists":
			var err error
			it.BiosSerialExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_not":
			var err error
			it.BiosSerialNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_eq":
			var err error
			it.BiosSerialEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_neq":
			var err error
			it.BiosSerialNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_in":
			var err error
			it.BiosSerialIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_not_in":
			var err error
			it.BiosSerialNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_like":
			var err error
			it.BiosSerialLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_not_like":
			var err error
			it.BiosSerialNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_ilike":
			var err error
			it.BiosSerialIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_not_ilike":
			var err error
			it.BiosSerialNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_suffix":
			var err error
			it.BiosSerialSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_prefix":
			var err error
			it.BiosSerialPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_device_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_device_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_device_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_device_user_bool_exp(ctx context.Context, obj interface{}) (AdapterDeviceUserBoolExp, error) {
	var it AdapterDeviceUserBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "deviceId_exists":
			var err error
			it.DeviceIDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_eq":
			var err error
			it.DeviceIDEq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_neq":
			var err error
			it.DeviceIDNeq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_in":
			var err error
			it.DeviceIDIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_not_in":
			var err error
			it.DeviceIDNotIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gt":
			var err error
			it.DeviceIDGt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gte":
			var err error
			it.DeviceIDGte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lt":
			var err error
			it.DeviceIDLt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lte":
			var err error
			it.DeviceIDLte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_exists":
			var err error
			it.SidExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_not":
			var err error
			it.SidNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_eq":
			var err error
			it.SidEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_neq":
			var err error
			it.SidNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_in":
			var err error
			it.SidIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_not_in":
			var err error
			it.SidNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_like":
			var err error
			it.SidLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_not_like":
			var err error
			it.SidNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_ilike":
			var err error
			it.SidIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_not_ilike":
			var err error
			it.SidNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_suffix":
			var err error
			it.SidSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_prefix":
			var err error
			it.SidPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_exists":
			var err error
			it.UsernameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not":
			var err error
			it.UsernameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_eq":
			var err error
			it.UsernameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_neq":
			var err error
			it.UsernameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_in":
			var err error
			it.UsernameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_in":
			var err error
			it.UsernameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_like":
			var err error
			it.UsernameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_like":
			var err error
			it.UsernameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_ilike":
			var err error
			it.UsernameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_ilike":
			var err error
			it.UsernameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_suffix":
			var err error
			it.UsernameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_prefix":
			var err error
			it.UsernamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_exists":
			var err error
			it.LastUseDateExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_eq":
			var err error
			it.LastUseDateEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_neq":
			var err error
			it.LastUseDateNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_in":
			var err error
			it.LastUseDateIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_not_in":
			var err error
			it.LastUseDateNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_gt":
			var err error
			it.LastUseDateGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_gte":
			var err error
			it.LastUseDateGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_lt":
			var err error
			it.LastUseDateLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_lte":
			var err error
			it.LastUseDateLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_days":
			var err error
			it.LastUseDateDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "isLocal_exists":
			var err error
			it.IsLocalExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isLocal_eq":
			var err error
			it.IsLocalEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isLocal_neq":
			var err error
			it.IsLocalNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isDisabled_exists":
			var err error
			it.IsDisabledExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isDisabled_eq":
			var err error
			it.IsDisabledEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isDisabled_neq":
			var err error
			it.IsDisabledNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAdmin_exists":
			var err error
			it.IsAdminExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAdmin_eq":
			var err error
			it.IsAdminEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAdmin_neq":
			var err error
			it.IsAdminNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "userDepartment_exists":
			var err error
			it.UserDepartmentExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "userDepartment_eq":
			var err error
			it.UserDepartmentEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "userDepartment_neq":
			var err error
			it.UserDepartmentNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_exists":
			var err error
			it.PasswordMaxAgeExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_eq":
			var err error
			it.PasswordMaxAgeEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_neq":
			var err error
			it.PasswordMaxAgeNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_in":
			var err error
			it.PasswordMaxAgeIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_not_in":
			var err error
			it.PasswordMaxAgeNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_gt":
			var err error
			it.PasswordMaxAgeGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_gte":
			var err error
			it.PasswordMaxAgeGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_lt":
			var err error
			it.PasswordMaxAgeLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_lte":
			var err error
			it.PasswordMaxAgeLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_exists":
			var err error
			it.InterpreterExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_not":
			var err error
			it.InterpreterNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_eq":
			var err error
			it.InterpreterEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_neq":
			var err error
			it.InterpreterNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_in":
			var err error
			it.InterpreterIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_not_in":
			var err error
			it.InterpreterNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_like":
			var err error
			it.InterpreterLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_not_like":
			var err error
			it.InterpreterNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_ilike":
			var err error
			it.InterpreterIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_not_ilike":
			var err error
			it.InterpreterNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_suffix":
			var err error
			it.InterpreterSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_prefix":
			var err error
			it.InterpreterPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_device_user_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceUserBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_device_user_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceUserBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_device_user_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceUserBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_user_bool_exp(ctx context.Context, obj interface{}) (AdapterUserBoolExp, error) {
	var it AdapterUserBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_exists":
			var err error
			it.FetchCycleExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_eq":
			var err error
			it.FetchCycleEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_neq":
			var err error
			it.FetchCycleNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_in":
			var err error
			it.FetchCycleIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_not_in":
			var err error
			it.FetchCycleNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gt":
			var err error
			it.FetchCycleGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gte":
			var err error
			it.FetchCycleGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lt":
			var err error
			it.FetchCycleLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lte":
			var err error
			it.FetchCycleLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_eq":
			var err error
			it.AdapterIDEq, err = ec.unmarshalOAdapterType2ᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_neq":
			var err error
			it.AdapterIDNeq, err = ec.unmarshalOAdapterType2ᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_in":
			var err error
			it.AdapterIDIn, err = ec.unmarshalOAdapterType2ᚕᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_not_in":
			var err error
			it.AdapterIDNotIn, err = ec.unmarshalOAdapterType2ᚕᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapter":
			var err error
			it.Adapter, err = ec.unmarshalOadapter_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_exists":
			var err error
			it.AdapterNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not":
			var err error
			it.AdapterNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_eq":
			var err error
			it.AdapterNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_neq":
			var err error
			it.AdapterNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_in":
			var err error
			it.AdapterNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_in":
			var err error
			it.AdapterNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_like":
			var err error
			it.AdapterNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_like":
			var err error
			it.AdapterNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_ilike":
			var err error
			it.AdapterNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_ilike":
			var err error
			it.AdapterNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_suffix":
			var err error
			it.AdapterNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_prefix":
			var err error
			it.AdapterNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_exists":
			var err error
			it.UserIDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_eq":
			var err error
			it.UserIDEq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_neq":
			var err error
			it.UserIDNeq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_in":
			var err error
			it.UserIDIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_not_in":
			var err error
			it.UserIDNotIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_gt":
			var err error
			it.UserIDGt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_gte":
			var err error
			it.UserIDGte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_lt":
			var err error
			it.UserIDLt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_lte":
			var err error
			it.UserIDLte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterData":
			var err error
			it.AdapterData, err = ec.unmarshalOadapter_data_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_exists":
			var err error
			it.FetchTimeExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_eq":
			var err error
			it.FetchTimeEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_neq":
			var err error
			it.FetchTimeNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_in":
			var err error
			it.FetchTimeIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_not_in":
			var err error
			it.FetchTimeNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_gt":
			var err error
			it.FetchTimeGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_gte":
			var err error
			it.FetchTimeGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_lt":
			var err error
			it.FetchTimeLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_lte":
			var err error
			it.FetchTimeLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_days":
			var err error
			it.FetchTimeDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_exists":
			var err error
			it.LastSeenExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_eq":
			var err error
			it.LastSeenEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_neq":
			var err error
			it.LastSeenNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_in":
			var err error
			it.LastSeenIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_not_in":
			var err error
			it.LastSeenNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gt":
			var err error
			it.LastSeenGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gte":
			var err error
			it.LastSeenGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lt":
			var err error
			it.LastSeenLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lte":
			var err error
			it.LastSeenLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_days":
			var err error
			it.LastSeenDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_exists":
			var err error
			it.UsernameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not":
			var err error
			it.UsernameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_eq":
			var err error
			it.UsernameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_neq":
			var err error
			it.UsernameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_in":
			var err error
			it.UsernameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_in":
			var err error
			it.UsernameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_like":
			var err error
			it.UsernameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_like":
			var err error
			it.UsernameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_ilike":
			var err error
			it.UsernameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_ilike":
			var err error
			it.UsernameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_suffix":
			var err error
			it.UsernameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_prefix":
			var err error
			it.UsernamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_exists":
			var err error
			it.FirstNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_not":
			var err error
			it.FirstNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_eq":
			var err error
			it.FirstNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_neq":
			var err error
			it.FirstNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_in":
			var err error
			it.FirstNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_not_in":
			var err error
			it.FirstNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_like":
			var err error
			it.FirstNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_not_like":
			var err error
			it.FirstNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_ilike":
			var err error
			it.FirstNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_not_ilike":
			var err error
			it.FirstNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_suffix":
			var err error
			it.FirstNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_prefix":
			var err error
			it.FirstNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_exists":
			var err error
			it.LastNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_not":
			var err error
			it.LastNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_eq":
			var err error
			it.LastNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_neq":
			var err error
			it.LastNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_in":
			var err error
			it.LastNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_not_in":
			var err error
			it.LastNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_like":
			var err error
			it.LastNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_not_like":
			var err error
			it.LastNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_ilike":
			var err error
			it.LastNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_not_ilike":
			var err error
			it.LastNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_suffix":
			var err error
			it.LastNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_prefix":
			var err error
			it.LastNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_exists":
			var err error
			it.MailExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_not":
			var err error
			it.MailNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_eq":
			var err error
			it.MailEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_neq":
			var err error
			it.MailNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_in":
			var err error
			it.MailIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_not_in":
			var err error
			it.MailNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_like":
			var err error
			it.MailLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_not_like":
			var err error
			it.MailNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_ilike":
			var err error
			it.MailIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_not_ilike":
			var err error
			it.MailNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_suffix":
			var err error
			it.MailSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_prefix":
			var err error
			it.MailPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "admin_exists":
			var err error
			it.AdminExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "admin_eq":
			var err error
			it.AdminEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "admin_neq":
			var err error
			it.AdminNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "local_exists":
			var err error
			it.LocalExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "local_eq":
			var err error
			it.LocalEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "local_neq":
			var err error
			it.LocalNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "delegated_admin_exists":
			var err error
			it.DelegatedAdminExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "delegated_admin_eq":
			var err error
			it.DelegatedAdminEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "delegated_admin_neq":
			var err error
			it.DelegatedAdminNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enforced_exists":
			var err error
			it.MfaEnforcedExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enforced_eq":
			var err error
			it.MfaEnforcedEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enforced_neq":
			var err error
			it.MfaEnforcedNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enrolled_exists":
			var err error
			it.MfaEnrolledExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enrolled_eq":
			var err error
			it.MfaEnrolledEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enrolled_neq":
			var err error
			it.MfaEnrolledNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "suspended_exists":
			var err error
			it.SuspendedExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "suspended_eq":
			var err error
			it.SuspendedEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "suspended_neq":
			var err error
			it.SuspendedNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "locked_exists":
			var err error
			it.LockedExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "locked_eq":
			var err error
			it.LockedEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "locked_neq":
			var err error
			it.LockedNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "disabled_exists":
			var err error
			it.DisabledExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "disabled_eq":
			var err error
			it.DisabledEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "disabled_neq":
			var err error
			it.DisabledNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_user_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterUserBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_user_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterUserBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_user_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterUserBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_group_bool_exp(ctx context.Context, obj interface{}) (CsGroupBoolExp, error) {
	var it CsGroupBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not":
			var err error
			it.IDNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_like":
			var err error
			it.IDLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_like":
			var err error
			it.IDNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ilike":
			var err error
			it.IDIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_ilike":
			var err error
			it.IDNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_suffix":
			var err error
			it.IDSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_prefix":
			var err error
			it.IDPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_exists":
			var err error
			it.CreatedByExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not":
			var err error
			it.CreatedByNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_eq":
			var err error
			it.CreatedByEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_neq":
			var err error
			it.CreatedByNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_in":
			var err error
			it.CreatedByIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_in":
			var err error
			it.CreatedByNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_like":
			var err error
			it.CreatedByLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_like":
			var err error
			it.CreatedByNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_ilike":
			var err error
			it.CreatedByIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_ilike":
			var err error
			it.CreatedByNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_suffix":
			var err error
			it.CreatedBySuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_prefix":
			var err error
			it.CreatedByPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_exists":
			var err error
			it.CreatedTimestampExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_eq":
			var err error
			it.CreatedTimestampEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_neq":
			var err error
			it.CreatedTimestampNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_in":
			var err error
			it.CreatedTimestampIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_not_in":
			var err error
			it.CreatedTimestampNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_gt":
			var err error
			it.CreatedTimestampGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_gte":
			var err error
			it.CreatedTimestampGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_lt":
			var err error
			it.CreatedTimestampLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_lte":
			var err error
			it.CreatedTimestampLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_days":
			var err error
			it.CreatedTimestampDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_exists":
			var err error
			it.DescriptionExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not":
			var err error
			it.DescriptionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_eq":
			var err error
			it.DescriptionEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_neq":
			var err error
			it.DescriptionNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_in":
			var err error
			it.DescriptionIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_in":
			var err error
			it.DescriptionNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_like":
			var err error
			it.DescriptionLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_like":
			var err error
			it.DescriptionNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_ilike":
			var err error
			it.DescriptionIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_ilike":
			var err error
			it.DescriptionNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_suffix":
			var err error
			it.DescriptionSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_prefix":
			var err error
			it.DescriptionPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_exists":
			var err error
			it.GroupTypeExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_not":
			var err error
			it.GroupTypeNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_eq":
			var err error
			it.GroupTypeEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_neq":
			var err error
			it.GroupTypeNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_in":
			var err error
			it.GroupTypeIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_not_in":
			var err error
			it.GroupTypeNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_like":
			var err error
			it.GroupTypeLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_not_like":
			var err error
			it.GroupTypeNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_ilike":
			var err error
			it.GroupTypeIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_not_ilike":
			var err error
			it.GroupTypeNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_suffix":
			var err error
			it.GroupTypeSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_prefix":
			var err error
			it.GroupTypePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_exists":
			var err error
			it.ModifiedByExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_not":
			var err error
			it.ModifiedByNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_eq":
			var err error
			it.ModifiedByEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_neq":
			var err error
			it.ModifiedByNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_in":
			var err error
			it.ModifiedByIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_not_in":
			var err error
			it.ModifiedByNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_like":
			var err error
			it.ModifiedByLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_not_like":
			var err error
			it.ModifiedByNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_ilike":
			var err error
			it.ModifiedByIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_not_ilike":
			var err error
			it.ModifiedByNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_suffix":
			var err error
			it.ModifiedBySuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_prefix":
			var err error
			it.ModifiedByPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_exists":
			var err error
			it.ModifiedTimeExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_eq":
			var err error
			it.ModifiedTimeEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_neq":
			var err error
			it.ModifiedTimeNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_in":
			var err error
			it.ModifiedTimeIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_not_in":
			var err error
			it.ModifiedTimeNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_gt":
			var err error
			it.ModifiedTimeGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_gte":
			var err error
			it.ModifiedTimeGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_lt":
			var err error
			it.ModifiedTimeLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_lte":
			var err error
			it.ModifiedTimeLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_days":
			var err error
			it.ModifiedTimeDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_group_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsGroupBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_group_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsGroupBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_group_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsGroupBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_policy_bool_exp(ctx context.Context, obj interface{}) (CsPolicyBoolExp, error) {
	var it CsPolicyBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_exists":
			var err error
			it.DescriptionExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not":
			var err error
			it.DescriptionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_eq":
			var err error
			it.DescriptionEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_neq":
			var err error
			it.DescriptionNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_in":
			var err error
			it.DescriptionIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_in":
			var err error
			it.DescriptionNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_like":
			var err error
			it.DescriptionLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_like":
			var err error
			it.DescriptionNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_ilike":
			var err error
			it.DescriptionIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_ilike":
			var err error
			it.DescriptionNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_suffix":
			var err error
			it.DescriptionSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_prefix":
			var err error
			it.DescriptionPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_exists":
			var err error
			it.PlatformNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_not":
			var err error
			it.PlatformNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_eq":
			var err error
			it.PlatformNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_neq":
			var err error
			it.PlatformNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_in":
			var err error
			it.PlatformNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_not_in":
			var err error
			it.PlatformNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_like":
			var err error
			it.PlatformNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_not_like":
			var err error
			it.PlatformNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_ilike":
			var err error
			it.PlatformNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_not_ilike":
			var err error
			it.PlatformNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_suffix":
			var err error
			it.PlatformNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_prefix":
			var err error
			it.PlatformNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groups":
			var err error
			it.Groups, err = ec.unmarshalOcs_group_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "enabled_exists":
			var err error
			it.EnabledExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "enabled_eq":
			var err error
			it.EnabledEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "enabled_neq":
			var err error
			it.EnabledNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_exists":
			var err error
			it.CreatedByExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not":
			var err error
			it.CreatedByNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_eq":
			var err error
			it.CreatedByEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_neq":
			var err error
			it.CreatedByNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_in":
			var err error
			it.CreatedByIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_in":
			var err error
			it.CreatedByNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_like":
			var err error
			it.CreatedByLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_like":
			var err error
			it.CreatedByNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_ilike":
			var err error
			it.CreatedByIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_ilike":
			var err error
			it.CreatedByNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_suffix":
			var err error
			it.CreatedBySuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_prefix":
			var err error
			it.CreatedByPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_exists":
			var err error
			it.CreatedTimeExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_eq":
			var err error
			it.CreatedTimeEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_neq":
			var err error
			it.CreatedTimeNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_in":
			var err error
			it.CreatedTimeIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_not_in":
			var err error
			it.CreatedTimeNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_gt":
			var err error
			it.CreatedTimeGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_gte":
			var err error
			it.CreatedTimeGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_lt":
			var err error
			it.CreatedTimeLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_lte":
			var err error
			it.CreatedTimeLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_days":
			var err error
			it.CreatedTimeDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "preventionSettings":
			var err error
			it.PreventionSettings, err = ec.unmarshalOcs_prevention_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "sensorUpdateSettings":
			var err error
			it.SensorUpdateSettings, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_policy_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPolicyBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_policy_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPolicyBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_policy_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPolicyBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_policy_settings_bool_exp(ctx context.Context, obj interface{}) (CsPolicySettingsBoolExp, error) {
	var it CsPolicySettingsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "enabled_exists":
			var err error
			it.EnabledExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "enabled_eq":
			var err error
			it.EnabledEq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "enabled_neq":
			var err error
			it.EnabledNeq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_policy_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPolicySettingsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_policy_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPolicySettingsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_policy_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPolicySettingsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_prevention_settings_bool_exp(ctx context.Context, obj interface{}) (CsPreventionSettingsBoolExp, error) {
	var it CsPreventionSettingsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "settings":
			var err error
			it.Settings, err = ec.unmarshalOcs_policy_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsPolicySettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_prevention_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_prevention_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_prevention_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_sensor_update_settings_bool_exp(ctx context.Context, obj interface{}) (CsSensorUpdateSettingsBoolExp, error) {
	var it CsSensorUpdateSettingsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "build_exists":
			var err error
			it.BuildExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not":
			var err error
			it.BuildNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_eq":
			var err error
			it.BuildEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_neq":
			var err error
			it.BuildNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_in":
			var err error
			it.BuildIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_in":
			var err error
			it.BuildNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_like":
			var err error
			it.BuildLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_like":
			var err error
			it.BuildNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_ilike":
			var err error
			it.BuildIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_ilike":
			var err error
			it.BuildNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_suffix":
			var err error
			it.BuildSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_prefix":
			var err error
			it.BuildPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputdevice_bool_exp(ctx context.Context, obj interface{}) (DeviceBoolExp, error) {
	var it DeviceBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_exists":
			var err error
			it.FetchCycleExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_eq":
			var err error
			it.FetchCycleEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_neq":
			var err error
			it.FetchCycleNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_in":
			var err error
			it.FetchCycleIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_not_in":
			var err error
			it.FetchCycleNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gt":
			var err error
			it.FetchCycleGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gte":
			var err error
			it.FetchCycleGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lt":
			var err error
			it.FetchCycleLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lte":
			var err error
			it.FetchCycleLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_exists":
			var err error
			it.AdapterCountExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_eq":
			var err error
			it.AdapterCountEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_neq":
			var err error
			it.AdapterCountNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_in":
			var err error
			it.AdapterCountIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_not_in":
			var err error
			it.AdapterCountNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_gt":
			var err error
			it.AdapterCountGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_gte":
			var err error
			it.AdapterCountGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_lt":
			var err error
			it.AdapterCountLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_lte":
			var err error
			it.AdapterCountLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contains":
			var err error
			it.AdapterNamesContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contained_by":
			var err error
			it.AdapterNamesContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_overlap":
			var err error
			it.AdapterNamesOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_size":
			var err error
			it.AdapterNamesSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contains_regex":
			var err error
			it.AdapterNamesContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostnames_contains":
			var err error
			it.HostnamesContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostnames_contained_by":
			var err error
			it.HostnamesContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostnames_overlap":
			var err error
			it.HostnamesOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostnames_size":
			var err error
			it.HostnamesSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostnames_contains_regex":
			var err error
			it.HostnamesContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_exists":
			var err error
			it.LastSeenExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_eq":
			var err error
			it.LastSeenEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_neq":
			var err error
			it.LastSeenNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_in":
			var err error
			it.LastSeenIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_not_in":
			var err error
			it.LastSeenNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gt":
			var err error
			it.LastSeenGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gte":
			var err error
			it.LastSeenGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lt":
			var err error
			it.LastSeenLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lte":
			var err error
			it.LastSeenLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_days":
			var err error
			it.LastSeenDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterDevices":
			var err error
			it.AdapterDevices, err = ec.unmarshalOadapter_device_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "interfaces":
			var err error
			it.Interfaces, err = ec.unmarshalOnetwork_interface_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOtag_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOdevice_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐDeviceBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOdevice_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐDeviceBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOdevice_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐDeviceBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputfirewall_rule_bool_exp(ctx context.Context, obj interface{}) (FirewallRuleBoolExp, error) {
	var it FirewallRuleBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_exists":
			var err error
			it.SourceExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_not":
			var err error
			it.SourceNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_eq":
			var err error
			it.SourceEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_neq":
			var err error
			it.SourceNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_in":
			var err error
			it.SourceIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_not_in":
			var err error
			it.SourceNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_like":
			var err error
			it.SourceLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_not_like":
			var err error
			it.SourceNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_ilike":
			var err error
			it.SourceIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_not_ilike":
			var err error
			it.SourceNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_suffix":
			var err error
			it.SourceSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_prefix":
			var err error
			it.SourcePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_eq":
			var err error
			it.TypeEq, err = ec.unmarshalOAccessType2ᚖbandicootᚋpkgᚋgqlᚐAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_neq":
			var err error
			it.TypeNeq, err = ec.unmarshalOAccessType2ᚖbandicootᚋpkgᚋgqlᚐAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_in":
			var err error
			it.TypeIn, err = ec.unmarshalOAccessType2ᚕᚖbandicootᚋpkgᚋgqlᚐAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not_in":
			var err error
			it.TypeNotIn, err = ec.unmarshalOAccessType2ᚕᚖbandicootᚋpkgᚋgqlᚐAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		case "direction_eq":
			var err error
			it.DirectionEq, err = ec.unmarshalODirection2ᚖbandicootᚋpkgᚋgqlᚐDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "direction_neq":
			var err error
			it.DirectionNeq, err = ec.unmarshalODirection2ᚖbandicootᚋpkgᚋgqlᚐDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "direction_in":
			var err error
			it.DirectionIn, err = ec.unmarshalODirection2ᚕᚖbandicootᚋpkgᚋgqlᚐDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "direction_not_in":
			var err error
			it.DirectionNotIn, err = ec.unmarshalODirection2ᚕᚖbandicootᚋpkgᚋgqlᚐDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_exists":
			var err error
			it.TargetExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_not":
			var err error
			it.TargetNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_eq":
			var err error
			it.TargetEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_neq":
			var err error
			it.TargetNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_in":
			var err error
			it.TargetIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_not_in":
			var err error
			it.TargetNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_like":
			var err error
			it.TargetLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_not_like":
			var err error
			it.TargetNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_ilike":
			var err error
			it.TargetIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_not_ilike":
			var err error
			it.TargetNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_suffix":
			var err error
			it.TargetSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_prefix":
			var err error
			it.TargetPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_exists":
			var err error
			it.ProtocolExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_not":
			var err error
			it.ProtocolNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_eq":
			var err error
			it.ProtocolEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_neq":
			var err error
			it.ProtocolNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_in":
			var err error
			it.ProtocolIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_not_in":
			var err error
			it.ProtocolNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_like":
			var err error
			it.ProtocolLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_not_like":
			var err error
			it.ProtocolNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_ilike":
			var err error
			it.ProtocolIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_not_ilike":
			var err error
			it.ProtocolNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_suffix":
			var err error
			it.ProtocolSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_prefix":
			var err error
			it.ProtocolPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_exists":
			var err error
			it.SrcPortExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_eq":
			var err error
			it.SrcPortEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_neq":
			var err error
			it.SrcPortNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_in":
			var err error
			it.SrcPortIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_not_in":
			var err error
			it.SrcPortNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_gt":
			var err error
			it.SrcPortGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_gte":
			var err error
			it.SrcPortGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_lt":
			var err error
			it.SrcPortLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_lte":
			var err error
			it.SrcPortLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_exists":
			var err error
			it.DstPortExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_eq":
			var err error
			it.DstPortEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_neq":
			var err error
			it.DstPortNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_in":
			var err error
			it.DstPortIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_not_in":
			var err error
			it.DstPortNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_gt":
			var err error
			it.DstPortGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_gte":
			var err error
			it.DstPortGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_lt":
			var err error
			it.DstPortLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_lte":
			var err error
			it.DstPortLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOfirewall_rule_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐFirewallRuleBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOfirewall_rule_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐFirewallRuleBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOfirewall_rule_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐFirewallRuleBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputgce_tags_bool_exp(ctx context.Context, obj interface{}) (GceTagsBoolExp, error) {
	var it GceTagsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "gceKey_exists":
			var err error
			it.GceKeyExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_not":
			var err error
			it.GceKeyNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_eq":
			var err error
			it.GceKeyEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_neq":
			var err error
			it.GceKeyNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_in":
			var err error
			it.GceKeyIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_not_in":
			var err error
			it.GceKeyNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_like":
			var err error
			it.GceKeyLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_not_like":
			var err error
			it.GceKeyNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_ilike":
			var err error
			it.GceKeyIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_not_ilike":
			var err error
			it.GceKeyNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_suffix":
			var err error
			it.GceKeySuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_prefix":
			var err error
			it.GceKeyPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_exists":
			var err error
			it.GceValueExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_not":
			var err error
			it.GceValueNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_eq":
			var err error
			it.GceValueEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_neq":
			var err error
			it.GceValueNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_in":
			var err error
			it.GceValueIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_not_in":
			var err error
			it.GceValueNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_like":
			var err error
			it.GceValueLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_not_like":
			var err error
			it.GceValueNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_ilike":
			var err error
			it.GceValueIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_not_ilike":
			var err error
			it.GceValueNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_suffix":
			var err error
			it.GceValueSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_prefix":
			var err error
			it.GceValuePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOgce_tags_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐGceTagsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOgce_tags_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐGceTagsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOgce_tags_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐGceTagsBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputinstalled_software_bool_exp(ctx context.Context, obj interface{}) (InstalledSoftwareBoolExp, error) {
	var it InstalledSoftwareBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_exists":
			var err error
			it.VersionExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_not":
			var err error
			it.VersionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_eq":
			var err error
			it.VersionEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_neq":
			var err error
			it.VersionNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_in":
			var err error
			it.VersionIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_not_in":
			var err error
			it.VersionNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_like":
			var err error
			it.VersionLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_not_like":
			var err error
			it.VersionNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_ilike":
			var err error
			it.VersionIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_not_ilike":
			var err error
			it.VersionNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_suffix":
			var err error
			it.VersionSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_prefix":
			var err error
			it.VersionPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_eq":
			var err error
			it.ArchitectureEq, err = ec.unmarshalOArchitecture2ᚖbandicootᚋpkgᚋgqlᚐArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_neq":
			var err error
			it.ArchitectureNeq, err = ec.unmarshalOArchitecture2ᚖbandicootᚋpkgᚋgqlᚐArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_in":
			var err error
			it.ArchitectureIn, err = ec.unmarshalOArchitecture2ᚕᚖbandicootᚋpkgᚋgqlᚐArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_not_in":
			var err error
			it.ArchitectureNotIn, err = ec.unmarshalOArchitecture2ᚕᚖbandicootᚋpkgᚋgqlᚐArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_exists":
			var err error
			it.DescriptionExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not":
			var err error
			it.DescriptionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_eq":
			var err error
			it.DescriptionEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_neq":
			var err error
			it.DescriptionNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_in":
			var err error
			it.DescriptionIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_in":
			var err error
			it.DescriptionNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_like":
			var err error
			it.DescriptionLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_like":
			var err error
			it.DescriptionNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_ilike":
			var err error
			it.DescriptionIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_ilike":
			var err error
			it.DescriptionNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_suffix":
			var err error
			it.DescriptionSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_prefix":
			var err error
			it.DescriptionPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_exists":
			var err error
			it.VendorExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_not":
			var err error
			it.VendorNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_eq":
			var err error
			it.VendorEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_neq":
			var err error
			it.VendorNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_in":
			var err error
			it.VendorIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_not_in":
			var err error
			it.VendorNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_like":
			var err error
			it.VendorLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_not_like":
			var err error
			it.VendorNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_ilike":
			var err error
			it.VendorIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_not_ilike":
			var err error
			it.VendorNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_suffix":
			var err error
			it.VendorSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_prefix":
			var err error
			it.VendorPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_exists":
			var err error
			it.PublisherExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_not":
			var err error
			it.PublisherNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_eq":
			var err error
			it.PublisherEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_neq":
			var err error
			it.PublisherNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_in":
			var err error
			it.PublisherIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_not_in":
			var err error
			it.PublisherNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_like":
			var err error
			it.PublisherLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_not_like":
			var err error
			it.PublisherNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_ilike":
			var err error
			it.PublisherIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_not_ilike":
			var err error
			it.PublisherNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_suffix":
			var err error
			it.PublisherSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_prefix":
			var err error
			it.PublisherPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_exists":
			var err error
			it.CveCountExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_eq":
			var err error
			it.CveCountEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_neq":
			var err error
			it.CveCountNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_in":
			var err error
			it.CveCountIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_not_in":
			var err error
			it.CveCountNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_gt":
			var err error
			it.CveCountGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_gte":
			var err error
			it.CveCountGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_lt":
			var err error
			it.CveCountLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_lte":
			var err error
			it.CveCountLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_exists":
			var err error
			it.SwLicenseExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_not":
			var err error
			it.SwLicenseNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_eq":
			var err error
			it.SwLicenseEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_neq":
			var err error
			it.SwLicenseNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_in":
			var err error
			it.SwLicenseIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_not_in":
			var err error
			it.SwLicenseNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_like":
			var err error
			it.SwLicenseLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_not_like":
			var err error
			it.SwLicenseNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_ilike":
			var err error
			it.SwLicenseIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_not_ilike":
			var err error
			it.SwLicenseNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_suffix":
			var err error
			it.SwLicenseSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_prefix":
			var err error
			it.SwLicensePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_exists":
			var err error
			it.PathExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_not":
			var err error
			it.PathNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_eq":
			var err error
			it.PathEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_neq":
			var err error
			it.PathNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_in":
			var err error
			it.PathIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_not_in":
			var err error
			it.PathNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_like":
			var err error
			it.PathLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_not_like":
			var err error
			it.PathNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_ilike":
			var err error
			it.PathIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_not_ilike":
			var err error
			it.PathNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_suffix":
			var err error
			it.PathSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_prefix":
			var err error
			it.PathPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOinstalled_software_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOinstalled_software_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOinstalled_software_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputnetwork_interface_bool_exp(ctx context.Context, obj interface{}) (NetworkInterfaceBoolExp, error) {
	var it NetworkInterfaceBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "deviceId_exists":
			var err error
			it.DeviceIDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_eq":
			var err error
			it.DeviceIDEq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_neq":
			var err error
			it.DeviceIDNeq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_in":
			var err error
			it.DeviceIDIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_not_in":
			var err error
			it.DeviceIDNotIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gt":
			var err error
			it.DeviceIDGt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gte":
			var err error
			it.DeviceIDGte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lt":
			var err error
			it.DeviceIDLt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lte":
			var err error
			it.DeviceIDLte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "macAddr_exists":
			var err error
			it.MacAddrExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "macAddr_eq":
			var err error
			it.MacAddrEq, err = ec.unmarshalOMac2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "macAddr_neq":
			var err error
			it.MacAddrNeq, err = ec.unmarshalOMac2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "macAddr_in":
			var err error
			it.MacAddrIn, err = ec.unmarshalOMac2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "macAddr_not_in":
			var err error
			it.MacAddrNotIn, err = ec.unmarshalOMac2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_contains":
			var err error
			it.IPAddrsContains, err = ec.unmarshalOIP2ᚕᚖnetᚐIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_contained_by":
			var err error
			it.IPAddrsContainedBy, err = ec.unmarshalOIP2ᚕᚖnetᚐIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_overlap":
			var err error
			it.IPAddrsOverlap, err = ec.unmarshalOIP2ᚕᚖnetᚐIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_size":
			var err error
			it.IPAddrsSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_in_subnet":
			var err error
			it.IPAddrsInSubnet, err = ec.unmarshalOCIDR2ᚖnetᚐIPNet(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_ip_family":
			var err error
			it.IPAddrsIPFamily, err = ec.unmarshalOIPFamily2ᚖbandicootᚋpkgᚋgqlᚐIPFamily(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOnetwork_interface_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOnetwork_interface_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOnetwork_interface_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputoperating_system_bool_exp(ctx context.Context, obj interface{}) (OperatingSystemBoolExp, error) {
	var it OperatingSystemBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_exists":
			var err error
			it.TypeExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not":
			var err error
			it.TypeNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_eq":
			var err error
			it.TypeEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_neq":
			var err error
			it.TypeNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_in":
			var err error
			it.TypeIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not_in":
			var err error
			it.TypeNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_like":
			var err error
			it.TypeLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not_like":
			var err error
			it.TypeNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_ilike":
			var err error
			it.TypeIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not_ilike":
			var err error
			it.TypeNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_suffix":
			var err error
			it.TypeSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_prefix":
			var err error
			it.TypePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_exists":
			var err error
			it.DistributionExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_not":
			var err error
			it.DistributionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_eq":
			var err error
			it.DistributionEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_neq":
			var err error
			it.DistributionNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_in":
			var err error
			it.DistributionIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_not_in":
			var err error
			it.DistributionNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_like":
			var err error
			it.DistributionLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_not_like":
			var err error
			it.DistributionNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_ilike":
			var err error
			it.DistributionIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_not_ilike":
			var err error
			it.DistributionNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_suffix":
			var err error
			it.DistributionSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_prefix":
			var err error
			it.DistributionPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_exists":
			var err error
			it.ArchitectureExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_eq":
			var err error
			it.ArchitectureEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_neq":
			var err error
			it.ArchitectureNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_in":
			var err error
			it.ArchitectureIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_not_in":
			var err error
			it.ArchitectureNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_gt":
			var err error
			it.ArchitectureGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_gte":
			var err error
			it.ArchitectureGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_lt":
			var err error
			it.ArchitectureLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_lte":
			var err error
			it.ArchitectureLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_exists":
			var err error
			it.ServicePackExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_not":
			var err error
			it.ServicePackNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_eq":
			var err error
			it.ServicePackEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_neq":
			var err error
			it.ServicePackNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_in":
			var err error
			it.ServicePackIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_not_in":
			var err error
			it.ServicePackNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_like":
			var err error
			it.ServicePackLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_not_like":
			var err error
			it.ServicePackNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_ilike":
			var err error
			it.ServicePackIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_not_ilike":
			var err error
			it.ServicePackNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_suffix":
			var err error
			it.ServicePackSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_prefix":
			var err error
			it.ServicePackPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_exists":
			var err error
			it.InstallDateExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_eq":
			var err error
			it.InstallDateEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_neq":
			var err error
			it.InstallDateNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_in":
			var err error
			it.InstallDateIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_not_in":
			var err error
			it.InstallDateNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_gt":
			var err error
			it.InstallDateGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_gte":
			var err error
			it.InstallDateGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_lt":
			var err error
			it.InstallDateLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_lte":
			var err error
			it.InstallDateLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_days":
			var err error
			it.InstallDateDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_exists":
			var err error
			it.KernelVersionExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_not":
			var err error
			it.KernelVersionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_eq":
			var err error
			it.KernelVersionEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_neq":
			var err error
			it.KernelVersionNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_in":
			var err error
			it.KernelVersionIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_not_in":
			var err error
			it.KernelVersionNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_like":
			var err error
			it.KernelVersionLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_not_like":
			var err error
			it.KernelVersionNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_ilike":
			var err error
			it.KernelVersionIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_not_ilike":
			var err error
			it.KernelVersionNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_suffix":
			var err error
			it.KernelVersionSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_prefix":
			var err error
			it.KernelVersionPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_exists":
			var err error
			it.CodeNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_not":
			var err error
			it.CodeNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_eq":
			var err error
			it.CodeNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_neq":
			var err error
			it.CodeNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_in":
			var err error
			it.CodeNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_not_in":
			var err error
			it.CodeNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_like":
			var err error
			it.CodeNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_not_like":
			var err error
			it.CodeNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_ilike":
			var err error
			it.CodeNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_not_ilike":
			var err error
			it.CodeNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_suffix":
			var err error
			it.CodeNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_prefix":
			var err error
			it.CodeNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_exists":
			var err error
			it.MajorExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_eq":
			var err error
			it.MajorEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_neq":
			var err error
			it.MajorNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_in":
			var err error
			it.MajorIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_not_in":
			var err error
			it.MajorNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_gt":
			var err error
			it.MajorGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_gte":
			var err error
			it.MajorGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_lt":
			var err error
			it.MajorLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_lte":
			var err error
			it.MajorLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_exists":
			var err error
			it.MinorExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_eq":
			var err error
			it.MinorEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_neq":
			var err error
			it.MinorNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_in":
			var err error
			it.MinorIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_not_in":
			var err error
			it.MinorNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_gt":
			var err error
			it.MinorGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_gte":
			var err error
			it.MinorGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_lt":
			var err error
			it.MinorLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_lte":
			var err error
			it.MinorLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_exists":
			var err error
			it.BuildExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not":
			var err error
			it.BuildNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_eq":
			var err error
			it.BuildEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_neq":
			var err error
			it.BuildNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_in":
			var err error
			it.BuildIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_in":
			var err error
			it.BuildNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_like":
			var err error
			it.BuildLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_like":
			var err error
			it.BuildNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_ilike":
			var err error
			it.BuildIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_ilike":
			var err error
			it.BuildNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_suffix":
			var err error
			it.BuildSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_prefix":
			var err error
			it.BuildPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_exists":
			var err error
			it.RawNameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_not":
			var err error
			it.RawNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_eq":
			var err error
			it.RawNameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_neq":
			var err error
			it.RawNameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_in":
			var err error
			it.RawNameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_not_in":
			var err error
			it.RawNameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_like":
			var err error
			it.RawNameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_not_like":
			var err error
			it.RawNameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_ilike":
			var err error
			it.RawNameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_not_ilike":
			var err error
			it.RawNameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_suffix":
			var err error
			it.RawNameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_prefix":
			var err error
			it.RawNamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOoperating_system_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐOperatingSystemBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOoperating_system_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐOperatingSystemBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOoperating_system_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐOperatingSystemBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputtag_bool_exp(ctx context.Context, obj interface{}) (TagBoolExp, error) {
	var it TagBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_exists":
			var err error
			it.CreatorExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_not":
			var err error
			it.CreatorNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_eq":
			var err error
			it.CreatorEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_neq":
			var err error
			it.CreatorNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_in":
			var err error
			it.CreatorIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_not_in":
			var err error
			it.CreatorNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_like":
			var err error
			it.CreatorLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_not_like":
			var err error
			it.CreatorNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_ilike":
			var err error
			it.CreatorIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_not_ilike":
			var err error
			it.CreatorNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_suffix":
			var err error
			it.CreatorSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_prefix":
			var err error
			it.CreatorPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_exists":
			var err error
			it.LevelExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_not":
			var err error
			it.LevelNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_eq":
			var err error
			it.LevelEq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_neq":
			var err error
			it.LevelNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_in":
			var err error
			it.LevelIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_not_in":
			var err error
			it.LevelNotIn, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_like":
			var err error
			it.LevelLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_not_like":
			var err error
			it.LevelNotLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_ilike":
			var err error
			it.LevelIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_not_ilike":
			var err error
			it.LevelNotIlike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_suffix":
			var err error
			it.LevelSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_prefix":
			var err error
			it.LevelPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOtag_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐTagBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOtag_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐTagBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOtag_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐTagBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputuser_bool_exp(ctx context.Context, obj interface{}) (UserBoolExp, error) {
	var it UserBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_exists":
			var err error
			it.FetchCycleExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_eq":
			var err error
			it.FetchCycleEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_neq":
			var err error
			it.FetchCycleNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_in":
			var err error
			it.FetchCycleIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_not_in":
			var err error
			it.FetchCycleNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gt":
			var err error
			it.FetchCycleGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gte":
			var err error
			it.FetchCycleGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lt":
			var err error
			it.FetchCycleLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lte":
			var err error
			it.FetchCycleLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_exists":
			var err error
			it.AdapterCountExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_eq":
			var err error
			it.AdapterCountEq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_neq":
			var err error
			it.AdapterCountNeq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_in":
			var err error
			it.AdapterCountIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_not_in":
			var err error
			it.AdapterCountNotIn, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_gt":
			var err error
			it.AdapterCountGt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_gte":
			var err error
			it.AdapterCountGte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_lt":
			var err error
			it.AdapterCountLt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_lte":
			var err error
			it.AdapterCountLte, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contains":
			var err error
			it.AdapterNamesContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contained_by":
			var err error
			it.AdapterNamesContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_overlap":
			var err error
			it.AdapterNamesOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_size":
			var err error
			it.AdapterNamesSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contains_regex":
			var err error
			it.AdapterNamesContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernames_contains":
			var err error
			it.UsernamesContains, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernames_contained_by":
			var err error
			it.UsernamesContainedBy, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernames_overlap":
			var err error
			it.UsernamesOverlap, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernames_size":
			var err error
			it.UsernamesSize, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernames_contains_regex":
			var err error
			it.UsernamesContainsRegex, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_exists":
			var err error
			it.LastSeenExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_eq":
			var err error
			it.LastSeenEq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_neq":
			var err error
			it.LastSeenNeq, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_in":
			var err error
			it.LastSeenIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_not_in":
			var err error
			it.LastSeenNotIn, err = ec.unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gt":
			var err error
			it.LastSeenGt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gte":
			var err error
			it.LastSeenGte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lt":
			var err error
			it.LastSeenLt, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lte":
			var err error
			it.LastSeenLte, err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_days":
			var err error
			it.LastSeenDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterUsers":
			var err error
			it.AdapterUsers, err = ec.unmarshalOadapter_user_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOuser_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐUserBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOuser_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐUserBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOuser_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐUserBoolExpᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _AdapterData(ctx context.Context, sel ast.SelectionSet, obj AdapterData) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case ActiveDirectoryData:
		return ec._ActiveDirectoryData(ctx, sel, &obj)
	case *ActiveDirectoryData:
		if obj == nil {
			return graphql.Null
		}
		return ec._ActiveDirectoryData(ctx, sel, obj)
	case CylanceData:
		return ec._CylanceData(ctx, sel, &obj)
	case *CylanceData:
		if obj == nil {
			return graphql.Null
		}
		return ec._CylanceData(ctx, sel, obj)
	case CrowdStrikeData:
		return ec._CrowdStrikeData(ctx, sel, &obj)
	case *CrowdStrikeData:
		if obj == nil {
			return graphql.Null
		}
		return ec._CrowdStrikeData(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Aggregate(ctx context.Context, sel ast.SelectionSet, obj Aggregate) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var activeDirectoryDataImplementors = []string{"ActiveDirectoryData", "AdapterData"}

func (ec *executionContext) _ActiveDirectoryData(ctx context.Context, sel ast.SelectionSet, obj *ActiveDirectoryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, activeDirectoryDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActiveDirectoryData")
		case "adCn":
			out.Values[i] = ec._ActiveDirectoryData_adCn(ctx, field, obj)
		case "adSid":
			out.Values[i] = ec._ActiveDirectoryData_adSid(ctx, field, obj)
		case "adGuid":
			out.Values[i] = ec._ActiveDirectoryData_adGuid(ctx, field, obj)
		case "adName":
			out.Values[i] = ec._ActiveDirectoryData_adName(ctx, field, obj)
		case "adSAMAccountName":
			out.Values[i] = ec._ActiveDirectoryData_adSAMAccountName(ctx, field, obj)
		case "adUserPrincipalName":
			out.Values[i] = ec._ActiveDirectoryData_adUserPrincipalName(ctx, field, obj)
		case "adDisplayName":
			out.Values[i] = ec._ActiveDirectoryData_adDisplayName(ctx, field, obj)
		case "adDistinguishedName":
			out.Values[i] = ec._ActiveDirectoryData_adDistinguishedName(ctx, field, obj)
		case "adCanonicalName":
			out.Values[i] = ec._ActiveDirectoryData_adCanonicalName(ctx, field, obj)
		case "adAccountExpires":
			out.Values[i] = ec._ActiveDirectoryData_adAccountExpires(ctx, field, obj)
		case "adObjectClass":
			out.Values[i] = ec._ActiveDirectoryData_adObjectClass(ctx, field, obj)
		case "adObjectCategory":
			out.Values[i] = ec._ActiveDirectoryData_adObjectCategory(ctx, field, obj)
		case "adOrganizationalUnit":
			out.Values[i] = ec._ActiveDirectoryData_adOrganizationalUnit(ctx, field, obj)
		case "adLastLogoff":
			out.Values[i] = ec._ActiveDirectoryData_adLastLogoff(ctx, field, obj)
		case "adLastLogon":
			out.Values[i] = ec._ActiveDirectoryData_adLastLogon(ctx, field, obj)
		case "adLastLogonTimestamp":
			out.Values[i] = ec._ActiveDirectoryData_adLastLogonTimestamp(ctx, field, obj)
		case "adBadPasswordTime":
			out.Values[i] = ec._ActiveDirectoryData_adBadPasswordTime(ctx, field, obj)
		case "ad_bad_pwd_count":
			out.Values[i] = ec._ActiveDirectoryData_ad_bad_pwd_count(ctx, field, obj)
		case "adManagedBy":
			out.Values[i] = ec._ActiveDirectoryData_adManagedBy(ctx, field, obj)
		case "adPasswordLastSet":
			out.Values[i] = ec._ActiveDirectoryData_adPasswordLastSet(ctx, field, obj)
		case "adPrimaryGroupId":
			out.Values[i] = ec._ActiveDirectoryData_adPrimaryGroupId(ctx, field, obj)
		case "adPrimaryGroupDn":
			out.Values[i] = ec._ActiveDirectoryData_adPrimaryGroupDn(ctx, field, obj)
		case "adMemberOf":
			out.Values[i] = ec._ActiveDirectoryData_adMemberOf(ctx, field, obj)
		case "adMemberOfFull":
			out.Values[i] = ec._ActiveDirectoryData_adMemberOfFull(ctx, field, obj)
		case "adUsnChanged":
			out.Values[i] = ec._ActiveDirectoryData_adUsnChanged(ctx, field, obj)
		case "adUsnCreated":
			out.Values[i] = ec._ActiveDirectoryData_adUsnCreated(ctx, field, obj)
		case "adWhenChanged":
			out.Values[i] = ec._ActiveDirectoryData_adWhenChanged(ctx, field, obj)
		case "adWhenCreated":
			out.Values[i] = ec._ActiveDirectoryData_adWhenCreated(ctx, field, obj)
		case "adIsCriticalSystemObject":
			out.Values[i] = ec._ActiveDirectoryData_adIsCriticalSystemObject(ctx, field, obj)
		case "adMsdsAllowedToDelegateTo":
			out.Values[i] = ec._ActiveDirectoryData_adMsdsAllowedToDelegateTo(ctx, field, obj)
		case "adPwdMustChange":
			out.Values[i] = ec._ActiveDirectoryData_adPwdMustChange(ctx, field, obj)
		case "adMsdsResultantPso":
			out.Values[i] = ec._ActiveDirectoryData_adMsdsResultantPso(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterImplementors = []string{"Adapter"}

func (ec *executionContext) _Adapter(ctx context.Context, sel ast.SelectionSet, obj *Adapter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Adapter")
		case "id":
			out.Values[i] = ec._Adapter_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Adapter_name(ctx, field, obj)
		case "properties":
			out.Values[i] = ec._Adapter_properties(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDeviceImplementors = []string{"AdapterDevice"}

func (ec *executionContext) _AdapterDevice(ctx context.Context, sel ast.SelectionSet, obj *AdapterDevice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDeviceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterDevice")
		case "id":
			out.Values[i] = ec._AdapterDevice_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._AdapterDevice_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterId":
			out.Values[i] = ec._AdapterDevice_adapterId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapter":
			out.Values[i] = ec._AdapterDevice_adapter(ctx, field, obj)
		case "adapterName":
			out.Values[i] = ec._AdapterDevice_adapterName(ctx, field, obj)
		case "deviceId":
			out.Values[i] = ec._AdapterDevice_deviceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdapterDevice_adapterData(ctx, field, obj)
				return res
			})
		case "data":
			out.Values[i] = ec._AdapterDevice_data(ctx, field, obj)
		case "fetchTime":
			out.Values[i] = ec._AdapterDevice_fetchTime(ctx, field, obj)
		case "hostname":
			out.Values[i] = ec._AdapterDevice_hostname(ctx, field, obj)
		case "name":
			out.Values[i] = ec._AdapterDevice_name(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._AdapterDevice_lastSeen(ctx, field, obj)
		case "osId":
			out.Values[i] = ec._AdapterDevice_osId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "os":
			out.Values[i] = ec._AdapterDevice_os(ctx, field, obj)
		case "prettyId":
			out.Values[i] = ec._AdapterDevice_prettyId(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._AdapterDevice_tags(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec._AdapterDevice_interfaces(ctx, field, obj)
		case "lastUsedUsers":
			out.Values[i] = ec._AdapterDevice_lastUsedUsers(ctx, field, obj)
		case "domain":
			out.Values[i] = ec._AdapterDevice_domain(ctx, field, obj)
		case "partOfDomain":
			out.Values[i] = ec._AdapterDevice_partOfDomain(ctx, field, obj)
		case "deviceUsers":
			out.Values[i] = ec._AdapterDevice_deviceUsers(ctx, field, obj)
		case "localAdmins":
			out.Values[i] = ec._AdapterDevice_localAdmins(ctx, field, obj)
		case "firewallRules":
			out.Values[i] = ec._AdapterDevice_firewallRules(ctx, field, obj)
		case "installedSoftware":
			out.Values[i] = ec._AdapterDevice_installedSoftware(ctx, field, obj)
		case "agentVersion":
			out.Values[i] = ec._AdapterDevice_agentVersion(ctx, field, obj)
		case "agentStatus":
			out.Values[i] = ec._AdapterDevice_agentStatus(ctx, field, obj)
		case "agentName":
			out.Values[i] = ec._AdapterDevice_agentName(ctx, field, obj)
		case "model":
			out.Values[i] = ec._AdapterDevice_model(ctx, field, obj)
		case "manufacturer":
			out.Values[i] = ec._AdapterDevice_manufacturer(ctx, field, obj)
		case "serial":
			out.Values[i] = ec._AdapterDevice_serial(ctx, field, obj)
		case "family":
			out.Values[i] = ec._AdapterDevice_family(ctx, field, obj)
		case "biosVersion":
			out.Values[i] = ec._AdapterDevice_biosVersion(ctx, field, obj)
		case "biosSerial":
			out.Values[i] = ec._AdapterDevice_biosSerial(ctx, field, obj)
		case "tags_aggregate":
			out.Values[i] = ec._AdapterDevice_tags_aggregate(ctx, field, obj)
		case "interfaces_aggregate":
			out.Values[i] = ec._AdapterDevice_interfaces_aggregate(ctx, field, obj)
		case "firewallRules_aggregate":
			out.Values[i] = ec._AdapterDevice_firewallRules_aggregate(ctx, field, obj)
		case "installedSoftware_aggregate":
			out.Values[i] = ec._AdapterDevice_installedSoftware_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDeviceAdminImplementors = []string{"AdapterDeviceAdmin"}

func (ec *executionContext) _AdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, obj *AdapterDeviceAdmin) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDeviceAdminImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterDeviceAdmin")
		case "name":
			out.Values[i] = ec._AdapterDeviceAdmin_name(ctx, field, obj)
		case "type":
			out.Values[i] = ec._AdapterDeviceAdmin_type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDeviceUserImplementors = []string{"AdapterDeviceUser"}

func (ec *executionContext) _AdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, obj *AdapterDeviceUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDeviceUserImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterDeviceUser")
		case "deviceId":
			out.Values[i] = ec._AdapterDeviceUser_deviceId(ctx, field, obj)
		case "sid":
			out.Values[i] = ec._AdapterDeviceUser_sid(ctx, field, obj)
		case "username":
			out.Values[i] = ec._AdapterDeviceUser_username(ctx, field, obj)
		case "lastUseDate":
			out.Values[i] = ec._AdapterDeviceUser_lastUseDate(ctx, field, obj)
		case "isLocal":
			out.Values[i] = ec._AdapterDeviceUser_isLocal(ctx, field, obj)
		case "isDisabled":
			out.Values[i] = ec._AdapterDeviceUser_isDisabled(ctx, field, obj)
		case "isAdmin":
			out.Values[i] = ec._AdapterDeviceUser_isAdmin(ctx, field, obj)
		case "userDepartment":
			out.Values[i] = ec._AdapterDeviceUser_userDepartment(ctx, field, obj)
		case "passwordMaxAge":
			out.Values[i] = ec._AdapterDeviceUser_passwordMaxAge(ctx, field, obj)
		case "interpreter":
			out.Values[i] = ec._AdapterDeviceUser_interpreter(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterUserImplementors = []string{"AdapterUser"}

func (ec *executionContext) _AdapterUser(ctx context.Context, sel ast.SelectionSet, obj *AdapterUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterUserImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterUser")
		case "id":
			out.Values[i] = ec._AdapterUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._AdapterUser_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterId":
			out.Values[i] = ec._AdapterUser_adapterId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapter":
			out.Values[i] = ec._AdapterUser_adapter(ctx, field, obj)
		case "adapterName":
			out.Values[i] = ec._AdapterUser_adapterName(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._AdapterUser_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdapterUser_adapterData(ctx, field, obj)
				return res
			})
		case "data":
			out.Values[i] = ec._AdapterUser_data(ctx, field, obj)
		case "fetchTime":
			out.Values[i] = ec._AdapterUser_fetchTime(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._AdapterUser_lastSeen(ctx, field, obj)
		case "username":
			out.Values[i] = ec._AdapterUser_username(ctx, field, obj)
		case "firstName":
			out.Values[i] = ec._AdapterUser_firstName(ctx, field, obj)
		case "lastName":
			out.Values[i] = ec._AdapterUser_lastName(ctx, field, obj)
		case "mail":
			out.Values[i] = ec._AdapterUser_mail(ctx, field, obj)
		case "admin":
			out.Values[i] = ec._AdapterUser_admin(ctx, field, obj)
		case "local":
			out.Values[i] = ec._AdapterUser_local(ctx, field, obj)
		case "delegated_admin":
			out.Values[i] = ec._AdapterUser_delegated_admin(ctx, field, obj)
		case "mfa_enforced":
			out.Values[i] = ec._AdapterUser_mfa_enforced(ctx, field, obj)
		case "mfa_enrolled":
			out.Values[i] = ec._AdapterUser_mfa_enrolled(ctx, field, obj)
		case "suspended":
			out.Values[i] = ec._AdapterUser_suspended(ctx, field, obj)
		case "locked":
			out.Values[i] = ec._AdapterUser_locked(ctx, field, obj)
		case "disabled":
			out.Values[i] = ec._AdapterUser_disabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cPUImplementors = []string{"CPU"}

func (ec *executionContext) _CPU(ctx context.Context, sel ast.SelectionSet, obj *CPU) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cPUImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CPU")
		case "id":
			out.Values[i] = ec._CPU_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._CPU_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manfacturer":
			out.Values[i] = ec._CPU_manfacturer(ctx, field, obj)
		case "bitness":
			out.Values[i] = ec._CPU_bitness(ctx, field, obj)
		case "family":
			out.Values[i] = ec._CPU_family(ctx, field, obj)
		case "cores":
			out.Values[i] = ec._CPU_cores(ctx, field, obj)
		case "coresThreads":
			out.Values[i] = ec._CPU_coresThreads(ctx, field, obj)
		case "ghz":
			out.Values[i] = ec._CPU_ghz(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var crowdStrikeDataImplementors = []string{"CrowdStrikeData", "AdapterData"}

func (ec *executionContext) _CrowdStrikeData(ctx context.Context, sel ast.SelectionSet, obj *CrowdStrikeData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, crowdStrikeDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CrowdStrikeData")
		case "externalIp":
			out.Values[i] = ec._CrowdStrikeData_externalIp(ctx, field, obj)
		case "groups":
			out.Values[i] = ec._CrowdStrikeData_groups(ctx, field, obj)
		case "preventionPolicy":
			out.Values[i] = ec._CrowdStrikeData_preventionPolicy(ctx, field, obj)
		case "sensorUpdatePolicy":
			out.Values[i] = ec._CrowdStrikeData_sensorUpdatePolicy(ctx, field, obj)
		case "csAgentVersion":
			out.Values[i] = ec._CrowdStrikeData_csAgentVersion(ctx, field, obj)
		case "groups_aggregate":
			out.Values[i] = ec._CrowdStrikeData_groups_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cylanceDataImplementors = []string{"CylanceData", "AdapterData"}

func (ec *executionContext) _CylanceData(ctx context.Context, sel ast.SelectionSet, obj *CylanceData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cylanceDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CylanceData")
		case "isSafe":
			out.Values[i] = ec._CylanceData_isSafe(ctx, field, obj)
		case "deviceState":
			out.Values[i] = ec._CylanceData_deviceState(ctx, field, obj)
		case "policyId":
			out.Values[i] = ec._CylanceData_policyId(ctx, field, obj)
		case "policyName":
			out.Values[i] = ec._CylanceData_policyName(ctx, field, obj)
		case "policiesDetails":
			out.Values[i] = ec._CylanceData_policiesDetails(ctx, field, obj)
		case "tenantTag":
			out.Values[i] = ec._CylanceData_tenantTag(ctx, field, obj)
		case "zoneNames":
			out.Values[i] = ec._CylanceData_zoneNames(ctx, field, obj)
		case "agentVersion":
			out.Values[i] = ec._CylanceData_agentVersion(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deviceImplementors = []string{"Device"}

func (ec *executionContext) _Device(ctx context.Context, sel ast.SelectionSet, obj *Device) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deviceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Device")
		case "id":
			out.Values[i] = ec._Device_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._Device_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterCount":
			out.Values[i] = ec._Device_adapterCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterNames":
			out.Values[i] = ec._Device_adapterNames(ctx, field, obj)
		case "hostnames":
			out.Values[i] = ec._Device_hostnames(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._Device_lastSeen(ctx, field, obj)
		case "adapterDevices":
			out.Values[i] = ec._Device_adapterDevices(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec._Device_interfaces(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._Device_tags(ctx, field, obj)
		case "_compatibilityAPI":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Device__compatibilityAPI(ctx, field, obj)
				return res
			})
		case "adapterDevices_aggregate":
			out.Values[i] = ec._Device_adapterDevices_aggregate(ctx, field, obj)
		case "interfaces_aggregate":
			out.Values[i] = ec._Device_interfaces_aggregate(ctx, field, obj)
		case "tags_aggregate":
			out.Values[i] = ec._Device_tags_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var firewallRuleImplementors = []string{"FirewallRule"}

func (ec *executionContext) _FirewallRule(ctx context.Context, sel ast.SelectionSet, obj *FirewallRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, firewallRuleImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FirewallRule")
		case "name":
			out.Values[i] = ec._FirewallRule_name(ctx, field, obj)
		case "source":
			out.Values[i] = ec._FirewallRule_source(ctx, field, obj)
		case "type":
			out.Values[i] = ec._FirewallRule_type(ctx, field, obj)
		case "direction":
			out.Values[i] = ec._FirewallRule_direction(ctx, field, obj)
		case "target":
			out.Values[i] = ec._FirewallRule_target(ctx, field, obj)
		case "protocol":
			out.Values[i] = ec._FirewallRule_protocol(ctx, field, obj)
		case "srcPort":
			out.Values[i] = ec._FirewallRule_srcPort(ctx, field, obj)
		case "dstPort":
			out.Values[i] = ec._FirewallRule_dstPort(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gCETagsAggregateImplementors = []string{"GCETagsAggregate"}

func (ec *executionContext) _GCETagsAggregate(ctx context.Context, sel ast.SelectionSet, obj *GCETagsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gCETagsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GCETagsAggregate")
		case "group":
			out.Values[i] = ec._GCETagsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._GCETagsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._GCETagsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._GCETagsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._GCETagsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._GCETagsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._GCETagsAggregate_max(ctx, field, obj)
		case "GCETags":
			out.Values[i] = ec._GCETagsAggregate_GCETags(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gceTagsImplementors = []string{"GceTags"}

func (ec *executionContext) _GceTags(ctx context.Context, sel ast.SelectionSet, obj *GceTags) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gceTagsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GceTags")
		case "gceKey":
			out.Values[i] = ec._GceTags_gceKey(ctx, field, obj)
		case "gceValue":
			out.Values[i] = ec._GceTags_gceValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var googleCloudDataImplementors = []string{"GoogleCloudData"}

func (ec *executionContext) _GoogleCloudData(ctx context.Context, sel ast.SelectionSet, obj *GoogleCloudData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, googleCloudDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GoogleCloudData")
		case "Id":
			out.Values[i] = ec._GoogleCloudData_Id(ctx, field, obj)
		case "Size":
			out.Values[i] = ec._GoogleCloudData_Size(ctx, field, obj)
		case "Image":
			out.Values[i] = ec._GoogleCloudData_Image(ctx, field, obj)
		case "GCETags":
			out.Values[i] = ec._GoogleCloudData_GCETags(ctx, field, obj)
		case "GCETags_aggregate":
			out.Values[i] = ec._GoogleCloudData_GCETags_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var installedSoftwareImplementors = []string{"InstalledSoftware"}

func (ec *executionContext) _InstalledSoftware(ctx context.Context, sel ast.SelectionSet, obj *InstalledSoftware) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, installedSoftwareImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InstalledSoftware")
		case "name":
			out.Values[i] = ec._InstalledSoftware_name(ctx, field, obj)
		case "version":
			out.Values[i] = ec._InstalledSoftware_version(ctx, field, obj)
		case "architecture":
			out.Values[i] = ec._InstalledSoftware_architecture(ctx, field, obj)
		case "description":
			out.Values[i] = ec._InstalledSoftware_description(ctx, field, obj)
		case "vendor":
			out.Values[i] = ec._InstalledSoftware_vendor(ctx, field, obj)
		case "publisher":
			out.Values[i] = ec._InstalledSoftware_publisher(ctx, field, obj)
		case "cveCount":
			out.Values[i] = ec._InstalledSoftware_cveCount(ctx, field, obj)
		case "swLicense":
			out.Values[i] = ec._InstalledSoftware_swLicense(ctx, field, obj)
		case "path":
			out.Values[i] = ec._InstalledSoftware_path(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var networkInterfaceImplementors = []string{"NetworkInterface"}

func (ec *executionContext) _NetworkInterface(ctx context.Context, sel ast.SelectionSet, obj *NetworkInterface) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkInterfaceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkInterface")
		case "deviceId":
			out.Values[i] = ec._NetworkInterface_deviceId(ctx, field, obj)
		case "macAddr":
			out.Values[i] = ec._NetworkInterface_macAddr(ctx, field, obj)
		case "ipAddrs":
			out.Values[i] = ec._NetworkInterface_ipAddrs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var operatingSystemImplementors = []string{"OperatingSystem"}

func (ec *executionContext) _OperatingSystem(ctx context.Context, sel ast.SelectionSet, obj *OperatingSystem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, operatingSystemImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperatingSystem")
		case "id":
			out.Values[i] = ec._OperatingSystem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec._OperatingSystem_type(ctx, field, obj)
		case "distribution":
			out.Values[i] = ec._OperatingSystem_distribution(ctx, field, obj)
		case "architecture":
			out.Values[i] = ec._OperatingSystem_architecture(ctx, field, obj)
		case "servicePack":
			out.Values[i] = ec._OperatingSystem_servicePack(ctx, field, obj)
		case "installDate":
			out.Values[i] = ec._OperatingSystem_installDate(ctx, field, obj)
		case "kernelVersion":
			out.Values[i] = ec._OperatingSystem_kernelVersion(ctx, field, obj)
		case "codeName":
			out.Values[i] = ec._OperatingSystem_codeName(ctx, field, obj)
		case "major":
			out.Values[i] = ec._OperatingSystem_major(ctx, field, obj)
		case "minor":
			out.Values[i] = ec._OperatingSystem_minor(ctx, field, obj)
		case "build":
			out.Values[i] = ec._OperatingSystem_build(ctx, field, obj)
		case "RawName":
			out.Values[i] = ec._OperatingSystem_RawName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "adapterDevices":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterDevices(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "devices":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_devices(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "adapterUsers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "users":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "adapterDevices_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterDevices_aggregate(ctx, field)
				return res
			})
		case "devices_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_devices_aggregate(ctx, field)
				return res
			})
		case "adapterUsers_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterUsers_aggregate(ctx, field)
				return res
			})
		case "users_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users_aggregate(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var storageImplementors = []string{"Storage"}

func (ec *executionContext) _Storage(ctx context.Context, sel ast.SelectionSet, obj *Storage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Storage")
		case "deviceId":
			out.Values[i] = ec._Storage_deviceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "path":
			out.Values[i] = ec._Storage_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Storage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalSize":
			out.Values[i] = ec._Storage_totalSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "freeSize":
			out.Values[i] = ec._Storage_freeSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isEncrypted":
			out.Values[i] = ec._Storage_isEncrypted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Storage_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagImplementors = []string{"Tag"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "name":
			out.Values[i] = ec._Tag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "creator":
			out.Values[i] = ec._Tag_creator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "level":
			out.Values[i] = ec._Tag_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._User_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterCount":
			out.Values[i] = ec._User_adapterCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterNames":
			out.Values[i] = ec._User_adapterNames(ctx, field, obj)
		case "usernames":
			out.Values[i] = ec._User_usernames(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._User_lastSeen(ctx, field, obj)
		case "adapterUsers":
			out.Values[i] = ec._User_adapterUsers(ctx, field, obj)
		case "_compatibilityAPI":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User__compatibilityAPI(ctx, field, obj)
				return res
			})
		case "adapterUsers_aggregate":
			out.Values[i] = ec._User_adapterUsers_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDevicesAggregateImplementors = []string{"adapterDevicesAggregate"}

func (ec *executionContext) _adapterDevicesAggregate(ctx context.Context, sel ast.SelectionSet, obj *AdapterDevicesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDevicesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("adapterDevicesAggregate")
		case "group":
			out.Values[i] = ec._adapterDevicesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._adapterDevicesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._adapterDevicesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._adapterDevicesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._adapterDevicesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._adapterDevicesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._adapterDevicesAggregate_max(ctx, field, obj)
		case "adapterDevices":
			out.Values[i] = ec._adapterDevicesAggregate_adapterDevices(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterUsersAggregateImplementors = []string{"adapterUsersAggregate"}

func (ec *executionContext) _adapterUsersAggregate(ctx context.Context, sel ast.SelectionSet, obj *AdapterUsersAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterUsersAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("adapterUsersAggregate")
		case "group":
			out.Values[i] = ec._adapterUsersAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._adapterUsersAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._adapterUsersAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._adapterUsersAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._adapterUsersAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._adapterUsersAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._adapterUsersAggregate_max(ctx, field, obj)
		case "adapterUsers":
			out.Values[i] = ec._adapterUsersAggregate_adapterUsers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csGroupImplementors = []string{"csGroup"}

func (ec *executionContext) _csGroup(ctx context.Context, sel ast.SelectionSet, obj *CsGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csGroupImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csGroup")
		case "id":
			out.Values[i] = ec._csGroup_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._csGroup_name(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._csGroup_createdBy(ctx, field, obj)
		case "createdTimestamp":
			out.Values[i] = ec._csGroup_createdTimestamp(ctx, field, obj)
		case "description":
			out.Values[i] = ec._csGroup_description(ctx, field, obj)
		case "groupType":
			out.Values[i] = ec._csGroup_groupType(ctx, field, obj)
		case "modifiedBy":
			out.Values[i] = ec._csGroup_modifiedBy(ctx, field, obj)
		case "modifiedTime":
			out.Values[i] = ec._csGroup_modifiedTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csPolicyImplementors = []string{"csPolicy"}

func (ec *executionContext) _csPolicy(ctx context.Context, sel ast.SelectionSet, obj *CsPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csPolicy")
		case "name":
			out.Values[i] = ec._csPolicy_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._csPolicy_description(ctx, field, obj)
		case "platformName":
			out.Values[i] = ec._csPolicy_platformName(ctx, field, obj)
		case "groups":
			out.Values[i] = ec._csPolicy_groups(ctx, field, obj)
		case "enabled":
			out.Values[i] = ec._csPolicy_enabled(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._csPolicy_createdBy(ctx, field, obj)
		case "createdTime":
			out.Values[i] = ec._csPolicy_createdTime(ctx, field, obj)
		case "preventionSettings":
			out.Values[i] = ec._csPolicy_preventionSettings(ctx, field, obj)
		case "sensorUpdateSettings":
			out.Values[i] = ec._csPolicy_sensorUpdateSettings(ctx, field, obj)
		case "groups_aggregate":
			out.Values[i] = ec._csPolicy_groups_aggregate(ctx, field, obj)
		case "preventionSettings_aggregate":
			out.Values[i] = ec._csPolicy_preventionSettings_aggregate(ctx, field, obj)
		case "sensorUpdateSettings_aggregate":
			out.Values[i] = ec._csPolicy_sensorUpdateSettings_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csPolicySettingsImplementors = []string{"csPolicySettings"}

func (ec *executionContext) _csPolicySettings(ctx context.Context, sel ast.SelectionSet, obj *CsPolicySettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csPolicySettingsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csPolicySettings")
		case "enabled":
			out.Values[i] = ec._csPolicySettings_enabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csPreventionSettingsImplementors = []string{"csPreventionSettings"}

func (ec *executionContext) _csPreventionSettings(ctx context.Context, sel ast.SelectionSet, obj *CsPreventionSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csPreventionSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csPreventionSettings")
		case "name":
			out.Values[i] = ec._csPreventionSettings_name(ctx, field, obj)
		case "settings":
			out.Values[i] = ec._csPreventionSettings_settings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csSensorUpdateSettingsImplementors = []string{"csSensorUpdateSettings"}

func (ec *executionContext) _csSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, obj *CsSensorUpdateSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csSensorUpdateSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csSensorUpdateSettings")
		case "build":
			out.Values[i] = ec._csSensorUpdateSettings_build(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var devicesAggregateImplementors = []string{"devicesAggregate"}

func (ec *executionContext) _devicesAggregate(ctx context.Context, sel ast.SelectionSet, obj *DevicesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, devicesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("devicesAggregate")
		case "group":
			out.Values[i] = ec._devicesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._devicesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._devicesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._devicesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._devicesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._devicesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._devicesAggregate_max(ctx, field, obj)
		case "devices":
			out.Values[i] = ec._devicesAggregate_devices(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var firewallRulesAggregateImplementors = []string{"firewallRulesAggregate"}

func (ec *executionContext) _firewallRulesAggregate(ctx context.Context, sel ast.SelectionSet, obj *FirewallRulesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, firewallRulesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("firewallRulesAggregate")
		case "group":
			out.Values[i] = ec._firewallRulesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._firewallRulesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._firewallRulesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._firewallRulesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._firewallRulesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._firewallRulesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._firewallRulesAggregate_max(ctx, field, obj)
		case "firewallRules":
			out.Values[i] = ec._firewallRulesAggregate_firewallRules(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var groupsAggregateImplementors = []string{"groupsAggregate"}

func (ec *executionContext) _groupsAggregate(ctx context.Context, sel ast.SelectionSet, obj *GroupsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("groupsAggregate")
		case "group":
			out.Values[i] = ec._groupsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._groupsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._groupsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._groupsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._groupsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._groupsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._groupsAggregate_max(ctx, field, obj)
		case "groups":
			out.Values[i] = ec._groupsAggregate_groups(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var installedSoftwareAggregateImplementors = []string{"installedSoftwareAggregate"}

func (ec *executionContext) _installedSoftwareAggregate(ctx context.Context, sel ast.SelectionSet, obj *InstalledSoftwareAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, installedSoftwareAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("installedSoftwareAggregate")
		case "group":
			out.Values[i] = ec._installedSoftwareAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._installedSoftwareAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._installedSoftwareAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._installedSoftwareAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._installedSoftwareAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._installedSoftwareAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._installedSoftwareAggregate_max(ctx, field, obj)
		case "installedSoftware":
			out.Values[i] = ec._installedSoftwareAggregate_installedSoftware(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfacesAggregateImplementors = []string{"interfacesAggregate"}

func (ec *executionContext) _interfacesAggregate(ctx context.Context, sel ast.SelectionSet, obj *InterfacesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfacesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("interfacesAggregate")
		case "group":
			out.Values[i] = ec._interfacesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._interfacesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._interfacesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._interfacesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._interfacesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._interfacesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._interfacesAggregate_max(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec._interfacesAggregate_interfaces(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var preventionSettingsAggregateImplementors = []string{"preventionSettingsAggregate"}

func (ec *executionContext) _preventionSettingsAggregate(ctx context.Context, sel ast.SelectionSet, obj *PreventionSettingsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preventionSettingsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("preventionSettingsAggregate")
		case "group":
			out.Values[i] = ec._preventionSettingsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._preventionSettingsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._preventionSettingsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._preventionSettingsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._preventionSettingsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._preventionSettingsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._preventionSettingsAggregate_max(ctx, field, obj)
		case "preventionSettings":
			out.Values[i] = ec._preventionSettingsAggregate_preventionSettings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sensorUpdateSettingsAggregateImplementors = []string{"sensorUpdateSettingsAggregate"}

func (ec *executionContext) _sensorUpdateSettingsAggregate(ctx context.Context, sel ast.SelectionSet, obj *SensorUpdateSettingsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sensorUpdateSettingsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("sensorUpdateSettingsAggregate")
		case "group":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_max(ctx, field, obj)
		case "sensorUpdateSettings":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_sensorUpdateSettings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagsAggregateImplementors = []string{"tagsAggregate"}

func (ec *executionContext) _tagsAggregate(ctx context.Context, sel ast.SelectionSet, obj *TagsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("tagsAggregate")
		case "group":
			out.Values[i] = ec._tagsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._tagsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._tagsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._tagsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._tagsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._tagsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._tagsAggregate_max(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._tagsAggregate_tags(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var usersAggregateImplementors = []string{"usersAggregate"}

func (ec *executionContext) _usersAggregate(ctx context.Context, sel ast.SelectionSet, obj *UsersAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, usersAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("usersAggregate")
		case "group":
			out.Values[i] = ec._usersAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._usersAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._usersAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._usersAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._usersAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._usersAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._usersAggregate_max(ctx, field, obj)
		case "users":
			out.Values[i] = ec._usersAggregate_users(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAdapterDevice2bandicootᚋpkgᚋgqlᚐAdapterDevice(ctx context.Context, sel ast.SelectionSet, v AdapterDevice) graphql.Marshaler {
	return ec._AdapterDevice(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdapterDevice2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterDevice) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterDevice2bandicootᚋpkgᚋgqlᚐAdapterDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNAdapterType2bandicootᚋpkgᚋdomainᚐAdapterType(ctx context.Context, v interface{}) (domain.AdapterType, error) {
	tmp, err := graphql.UnmarshalString(v)
	return domain.AdapterType(tmp), err
}

func (ec *executionContext) marshalNAdapterType2bandicootᚋpkgᚋdomainᚐAdapterType(ctx context.Context, sel ast.SelectionSet, v domain.AdapterType) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNAdapterUser2bandicootᚋpkgᚋgqlᚐAdapterUser(ctx context.Context, sel ast.SelectionSet, v AdapterUser) graphql.Marshaler {
	return ec._AdapterUser(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdapterUser2ᚕbandicootᚋpkgᚋgqlᚐAdapterUserᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterUser2bandicootᚋpkgᚋgqlᚐAdapterUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNAggregateOrdering2bandicootᚋpkgᚋgqlᚐAggregateOrdering(ctx context.Context, v interface{}) (AggregateOrdering, error) {
	var res AggregateOrdering
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNAggregateOrdering2bandicootᚋpkgᚋgqlᚐAggregateOrdering(ctx context.Context, sel ast.SelectionSet, v AggregateOrdering) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNDevice2bandicootᚋpkgᚋgqlᚐDevice(ctx context.Context, sel ast.SelectionSet, v Device) graphql.Marshaler {
	return ec._Device(ctx, sel, &v)
}

func (ec *executionContext) marshalNDevice2ᚕbandicootᚋpkgᚋgqlᚐDeviceᚄ(ctx context.Context, sel ast.SelectionSet, v []Device) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDevice2bandicootᚋpkgᚋgqlᚐDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNGCETagsAggregate2bandicootᚋpkgᚋgqlᚐGCETagsAggregate(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregate) graphql.Marshaler {
	return ec._GCETagsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNGCETags_aggregate_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateColumns(ctx context.Context, v interface{}) (GCETagsAggregateColumns, error) {
	var res GCETagsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNGCETags_aggregate_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGCETags_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateMaxColumns(ctx context.Context, v interface{}) (GCETagsAggregateMaxColumns, error) {
	var res GCETagsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNGCETags_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGCETags_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]GCETagsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GCETagsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNGCETags_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNGCETags_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETags_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNGCETags_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateMinColumns(ctx context.Context, v interface{}) (GCETagsAggregateMinColumns, error) {
	var res GCETagsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNGCETags_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGCETags_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]GCETagsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GCETagsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNGCETags_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNGCETags_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETags_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNIP2netᚐIP(ctx context.Context, v interface{}) (net.IP, error) {
	return UnmarshalIPScalar(v)
}

func (ec *executionContext) marshalNIP2netᚐIP(ctx context.Context, sel ast.SelectionSet, v net.IP) graphql.Marshaler {
	res := MarshalIPScalar(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNNetworkInterface2bandicootᚋpkgᚋgqlᚐNetworkInterface(ctx context.Context, sel ast.SelectionSet, v NetworkInterface) graphql.Marshaler {
	return ec._NetworkInterface(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNRelationType2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNRelationType2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalNTag2bandicootᚋpkgᚋgqlᚐTag(ctx context.Context, sel ast.SelectionSet, v Tag) graphql.Marshaler {
	return ec._Tag(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx context.Context, v interface{}) (uuid.UUID, error) {
	return UnmarshalUUIDScalar(v)
}

func (ec *executionContext) marshalNUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	res := MarshalUUIDScalar(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2bandicootᚋpkgᚋgqlᚐUser(ctx context.Context, sel ast.SelectionSet, v User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕbandicootᚋpkgᚋgqlᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2bandicootᚋpkgᚋgqlᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNadapterDevicesAggregate2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregate(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregate) graphql.Marshaler {
	return ec._adapterDevicesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateAvgColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateAvgColumns, error) {
	var res AdapterDevicesAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateAvgColumnsᚄ(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateAvgColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateColumns, error) {
	var res AdapterDevicesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMaxColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateMaxColumns, error) {
	var res AdapterDevicesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMinColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateMinColumns, error) {
	var res AdapterDevicesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateSumColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateSumColumns, error) {
	var res AdapterDevicesAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateSumColumnsᚄ(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateSumColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNadapterUsersAggregate2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregate(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregate) graphql.Marshaler {
	return ec._adapterUsersAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateAvgColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateAvgColumns, error) {
	var res AdapterUsersAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateAvgColumnsᚄ(ctx context.Context, v interface{}) ([]AdapterUsersAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateAvgColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateColumns, error) {
	var res AdapterUsersAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMaxColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateMaxColumns, error) {
	var res AdapterUsersAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]AdapterUsersAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMinColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateMinColumns, error) {
	var res AdapterUsersAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]AdapterUsersAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateSumColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateSumColumns, error) {
	var res AdapterUsersAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateSumColumnsᚄ(ctx context.Context, v interface{}) ([]AdapterUsersAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateSumColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapter_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterBoolExp(ctx context.Context, v interface{}) (AdapterBoolExp, error) {
	return ec.unmarshalInputadapter_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_data_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDataBoolExp(ctx context.Context, v interface{}) (AdapterDataBoolExp, error) {
	return ec.unmarshalInputadapter_data_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_device_admin_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceAdminBoolExp(ctx context.Context, v interface{}) (AdapterDeviceAdminBoolExp, error) {
	return ec.unmarshalInputadapter_device_admin_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_device_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExp(ctx context.Context, v interface{}) (AdapterDeviceBoolExp, error) {
	return ec.unmarshalInputadapter_device_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_device_order_by2bandicootᚋpkgᚋgqlᚐAdapterDeviceOrderBy(ctx context.Context, v interface{}) (AdapterDeviceOrderBy, error) {
	var res AdapterDeviceOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapter_device_order_by2bandicootᚋpkgᚋgqlᚐAdapterDeviceOrderBy(ctx context.Context, sel ast.SelectionSet, v AdapterDeviceOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapter_device_user_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceUserBoolExp(ctx context.Context, v interface{}) (AdapterDeviceUserBoolExp, error) {
	return ec.unmarshalInputadapter_device_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_user_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterUserBoolExp(ctx context.Context, v interface{}) (AdapterUserBoolExp, error) {
	return ec.unmarshalInputadapter_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_user_order_by2bandicootᚋpkgᚋgqlᚐAdapterUserOrderBy(ctx context.Context, v interface{}) (AdapterUserOrderBy, error) {
	var res AdapterUserOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapter_user_order_by2bandicootᚋpkgᚋgqlᚐAdapterUserOrderBy(ctx context.Context, sel ast.SelectionSet, v AdapterUserOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNcs_group_bool_exp2bandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx context.Context, v interface{}) (CsGroupBoolExp, error) {
	return ec.unmarshalInputcs_group_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_policy_bool_exp2bandicootᚋpkgᚋgqlᚐCsPolicyBoolExp(ctx context.Context, v interface{}) (CsPolicyBoolExp, error) {
	return ec.unmarshalInputcs_policy_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_policy_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsPolicySettingsBoolExp(ctx context.Context, v interface{}) (CsPolicySettingsBoolExp, error) {
	return ec.unmarshalInputcs_policy_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_prevention_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExp(ctx context.Context, v interface{}) (CsPreventionSettingsBoolExp, error) {
	return ec.unmarshalInputcs_prevention_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_sensor_update_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExp(ctx context.Context, v interface{}) (CsSensorUpdateSettingsBoolExp, error) {
	return ec.unmarshalInputcs_sensor_update_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNdevice_bool_exp2bandicootᚋpkgᚋgqlᚐDeviceBoolExp(ctx context.Context, v interface{}) (DeviceBoolExp, error) {
	return ec.unmarshalInputdevice_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNdevice_order_by2bandicootᚋpkgᚋgqlᚐDeviceOrderBy(ctx context.Context, v interface{}) (DeviceOrderBy, error) {
	var res DeviceOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevice_order_by2bandicootᚋpkgᚋgqlᚐDeviceOrderBy(ctx context.Context, sel ast.SelectionSet, v DeviceOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNdevicesAggregate2bandicootᚋpkgᚋgqlᚐDevicesAggregate(ctx context.Context, sel ast.SelectionSet, v DevicesAggregate) graphql.Marshaler {
	return ec._devicesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNdevices_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateAvgColumns(ctx context.Context, v interface{}) (DevicesAggregateAvgColumns, error) {
	var res DevicesAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateAvgColumnsᚄ(ctx context.Context, v interface{}) ([]DevicesAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateAvgColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNdevices_aggregate_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateColumns(ctx context.Context, v interface{}) (DevicesAggregateColumns, error) {
	var res DevicesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateMaxColumns(ctx context.Context, v interface{}) (DevicesAggregateMaxColumns, error) {
	var res DevicesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]DevicesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNdevices_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateMinColumns(ctx context.Context, v interface{}) (DevicesAggregateMinColumns, error) {
	var res DevicesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]DevicesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNdevices_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateSumColumns(ctx context.Context, v interface{}) (DevicesAggregateSumColumns, error) {
	var res DevicesAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateSumColumnsᚄ(ctx context.Context, v interface{}) ([]DevicesAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateSumColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNfirewallRulesAggregate2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregate(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregate) graphql.Marshaler {
	return ec._firewallRulesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateAvgColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateAvgColumns, error) {
	var res FirewallRulesAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateAvgColumnsᚄ(ctx context.Context, v interface{}) ([]FirewallRulesAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateAvgColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateColumns, error) {
	var res FirewallRulesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMaxColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateMaxColumns, error) {
	var res FirewallRulesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]FirewallRulesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMinColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateMinColumns, error) {
	var res FirewallRulesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]FirewallRulesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateSumColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateSumColumns, error) {
	var res FirewallRulesAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateSumColumnsᚄ(ctx context.Context, v interface{}) ([]FirewallRulesAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateSumColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewall_rule_bool_exp2bandicootᚋpkgᚋgqlᚐFirewallRuleBoolExp(ctx context.Context, v interface{}) (FirewallRuleBoolExp, error) {
	return ec.unmarshalInputfirewall_rule_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNgce_tags_bool_exp2bandicootᚋpkgᚋgqlᚐGceTagsBoolExp(ctx context.Context, v interface{}) (GceTagsBoolExp, error) {
	return ec.unmarshalInputgce_tags_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNgroupsAggregate2bandicootᚋpkgᚋgqlᚐGroupsAggregate(ctx context.Context, sel ast.SelectionSet, v GroupsAggregate) graphql.Marshaler {
	return ec._groupsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNgroups_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateAvgColumns(ctx context.Context, v interface{}) (GroupsAggregateAvgColumns, error) {
	var res GroupsAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateAvgColumnsᚄ(ctx context.Context, v interface{}) ([]GroupsAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateAvgColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNgroups_aggregate_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateColumns(ctx context.Context, v interface{}) (GroupsAggregateColumns, error) {
	var res GroupsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateMaxColumns(ctx context.Context, v interface{}) (GroupsAggregateMaxColumns, error) {
	var res GroupsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]GroupsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNgroups_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateMinColumns(ctx context.Context, v interface{}) (GroupsAggregateMinColumns, error) {
	var res GroupsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]GroupsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNgroups_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateSumColumns(ctx context.Context, v interface{}) (GroupsAggregateSumColumns, error) {
	var res GroupsAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateSumColumnsᚄ(ctx context.Context, v interface{}) ([]GroupsAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateSumColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNinstalledSoftwareAggregate2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregate(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregate) graphql.Marshaler {
	return ec._installedSoftwareAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateAvgColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateAvgColumns, error) {
	var res InstalledSoftwareAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateAvgColumnsᚄ(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateAvgColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateColumns, error) {
	var res InstalledSoftwareAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMaxColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateMaxColumns, error) {
	var res InstalledSoftwareAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMinColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateMinColumns, error) {
	var res InstalledSoftwareAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateSumColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateSumColumns, error) {
	var res InstalledSoftwareAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateSumColumnsᚄ(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateSumColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalled_software_bool_exp2bandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExp(ctx context.Context, v interface{}) (InstalledSoftwareBoolExp, error) {
	return ec.unmarshalInputinstalled_software_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNinterfacesAggregate2bandicootᚋpkgᚋgqlᚐInterfacesAggregate(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregate) graphql.Marshaler {
	return ec._interfacesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateColumns(ctx context.Context, v interface{}) (InterfacesAggregateColumns, error) {
	var res InterfacesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinterfaces_aggregate_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateMaxColumns(ctx context.Context, v interface{}) (InterfacesAggregateMaxColumns, error) {
	var res InterfacesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinterfaces_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]InterfacesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InterfacesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinterfaces_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinterfaces_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfaces_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateMinColumns(ctx context.Context, v interface{}) (InterfacesAggregateMinColumns, error) {
	var res InterfacesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinterfaces_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]InterfacesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InterfacesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinterfaces_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinterfaces_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfaces_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNnetwork_interface_bool_exp2bandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx context.Context, v interface{}) (NetworkInterfaceBoolExp, error) {
	return ec.unmarshalInputnetwork_interface_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNoperating_system_bool_exp2bandicootᚋpkgᚋgqlᚐOperatingSystemBoolExp(ctx context.Context, v interface{}) (OperatingSystemBoolExp, error) {
	return ec.unmarshalInputoperating_system_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNpreventionSettingsAggregate2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregate(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregate) graphql.Marshaler {
	return ec._preventionSettingsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateColumns(ctx context.Context, v interface{}) (PreventionSettingsAggregateColumns, error) {
	var res PreventionSettingsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMaxColumns(ctx context.Context, v interface{}) (PreventionSettingsAggregateMaxColumns, error) {
	var res PreventionSettingsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]PreventionSettingsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]PreventionSettingsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNpreventionSettings_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettings_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMinColumns(ctx context.Context, v interface{}) (PreventionSettingsAggregateMinColumns, error) {
	var res PreventionSettingsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]PreventionSettingsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]PreventionSettingsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNpreventionSettings_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettings_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNsensorUpdateSettingsAggregate2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregate(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregate) graphql.Marshaler {
	return ec._sensorUpdateSettingsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateColumns(ctx context.Context, v interface{}) (SensorUpdateSettingsAggregateColumns, error) {
	var res SensorUpdateSettingsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMaxColumns(ctx context.Context, v interface{}) (SensorUpdateSettingsAggregateMaxColumns, error) {
	var res SensorUpdateSettingsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]SensorUpdateSettingsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]SensorUpdateSettingsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNsensorUpdateSettings_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettings_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMinColumns(ctx context.Context, v interface{}) (SensorUpdateSettingsAggregateMinColumns, error) {
	var res SensorUpdateSettingsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]SensorUpdateSettingsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]SensorUpdateSettingsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNsensorUpdateSettings_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettings_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNtag_bool_exp2bandicootᚋpkgᚋgqlᚐTagBoolExp(ctx context.Context, v interface{}) (TagBoolExp, error) {
	return ec.unmarshalInputtag_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNtagsAggregate2bandicootᚋpkgᚋgqlᚐTagsAggregate(ctx context.Context, sel ast.SelectionSet, v TagsAggregate) graphql.Marshaler {
	return ec._tagsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNtags_aggregate_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateColumns(ctx context.Context, v interface{}) (TagsAggregateColumns, error) {
	var res TagsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNtags_aggregate_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v TagsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNtags_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateMaxColumns(ctx context.Context, v interface{}) (TagsAggregateMaxColumns, error) {
	var res TagsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNtags_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v TagsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNtags_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]TagsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtags_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNtags_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []TagsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtags_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNtags_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateMinColumns(ctx context.Context, v interface{}) (TagsAggregateMinColumns, error) {
	var res TagsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNtags_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v TagsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNtags_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]TagsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtags_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNtags_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []TagsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtags_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNuser_bool_exp2bandicootᚋpkgᚋgqlᚐUserBoolExp(ctx context.Context, v interface{}) (UserBoolExp, error) {
	return ec.unmarshalInputuser_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNuser_order_by2bandicootᚋpkgᚋgqlᚐUserOrderBy(ctx context.Context, v interface{}) (UserOrderBy, error) {
	var res UserOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNuser_order_by2bandicootᚋpkgᚋgqlᚐUserOrderBy(ctx context.Context, sel ast.SelectionSet, v UserOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNusersAggregate2bandicootᚋpkgᚋgqlᚐUsersAggregate(ctx context.Context, sel ast.SelectionSet, v UsersAggregate) graphql.Marshaler {
	return ec._usersAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNusers_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateAvgColumns(ctx context.Context, v interface{}) (UsersAggregateAvgColumns, error) {
	var res UsersAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateAvgColumnsᚄ(ctx context.Context, v interface{}) ([]UsersAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_avg_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateAvgColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_avg_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNusers_aggregate_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateColumns(ctx context.Context, v interface{}) (UsersAggregateColumns, error) {
	var res UsersAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateMaxColumns(ctx context.Context, v interface{}) (UsersAggregateMaxColumns, error) {
	var res UsersAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateMaxColumnsᚄ(ctx context.Context, v interface{}) ([]UsersAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_max_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateMaxColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_max_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNusers_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateMinColumns(ctx context.Context, v interface{}) (UsersAggregateMinColumns, error) {
	var res UsersAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateMinColumnsᚄ(ctx context.Context, v interface{}) ([]UsersAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_min_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateMinColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_min_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNusers_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateSumColumns(ctx context.Context, v interface{}) (UsersAggregateSumColumns, error) {
	var res UsersAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateSumColumnsᚄ(ctx context.Context, v interface{}) ([]UsersAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_sum_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateSumColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_sum_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAccessType2bandicootᚋpkgᚋgqlᚐAccessType(ctx context.Context, v interface{}) (AccessType, error) {
	var res AccessType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAccessType2bandicootᚋpkgᚋgqlᚐAccessType(ctx context.Context, sel ast.SelectionSet, v AccessType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAccessType2ᚕᚖbandicootᚋpkgᚋgqlᚐAccessType(ctx context.Context, v interface{}) ([]*AccessType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*AccessType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOAccessType2ᚖbandicootᚋpkgᚋgqlᚐAccessType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAccessType2ᚕᚖbandicootᚋpkgᚋgqlᚐAccessType(ctx context.Context, sel ast.SelectionSet, v []*AccessType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAccessType2ᚖbandicootᚋpkgᚋgqlᚐAccessType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAccessType2ᚖbandicootᚋpkgᚋgqlᚐAccessType(ctx context.Context, v interface{}) (*AccessType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAccessType2bandicootᚋpkgᚋgqlᚐAccessType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAccessType2ᚖbandicootᚋpkgᚋgqlᚐAccessType(ctx context.Context, sel ast.SelectionSet, v *AccessType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOAdapter2bandicootᚋpkgᚋgqlᚐAdapter(ctx context.Context, sel ast.SelectionSet, v Adapter) graphql.Marshaler {
	return ec._Adapter(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapter2ᚖbandicootᚋpkgᚋgqlᚐAdapter(ctx context.Context, sel ast.SelectionSet, v *Adapter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Adapter(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterData2bandicootᚋpkgᚋgqlᚐAdapterData(ctx context.Context, sel ast.SelectionSet, v AdapterData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterData(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterDevice2bandicootᚋpkgᚋgqlᚐAdapterDevice(ctx context.Context, sel ast.SelectionSet, v AdapterDevice) graphql.Marshaler {
	return ec._AdapterDevice(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterDevice2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterDevice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterDevice2bandicootᚋpkgᚋgqlᚐAdapterDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDevice2ᚕᚖbandicootᚋpkgᚋgqlᚐAdapterDevice(ctx context.Context, sel ast.SelectionSet, v []*AdapterDevice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterDevice2ᚖbandicootᚋpkgᚋgqlᚐAdapterDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDevice2ᚖbandicootᚋpkgᚋgqlᚐAdapterDevice(ctx context.Context, sel ast.SelectionSet, v *AdapterDevice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterDevice(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterDeviceAdmin2bandicootᚋpkgᚋgqlᚐAdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, v AdapterDeviceAdmin) graphql.Marshaler {
	return ec._AdapterDeviceAdmin(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterDeviceAdmin2ᚕᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, v []*AdapterDeviceAdmin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterDeviceAdmin2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceAdmin(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDeviceAdmin2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, v *AdapterDeviceAdmin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterDeviceAdmin(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterDeviceUser2bandicootᚋpkgᚋgqlᚐAdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, v AdapterDeviceUser) graphql.Marshaler {
	return ec._AdapterDeviceUser(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterDeviceUser2ᚕᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, v []*AdapterDeviceUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterDeviceUser2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDeviceUser2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, v *AdapterDeviceUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterDeviceUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAdapterType2bandicootᚋpkgᚋdomainᚐAdapterType(ctx context.Context, v interface{}) (domain.AdapterType, error) {
	tmp, err := graphql.UnmarshalString(v)
	return domain.AdapterType(tmp), err
}

func (ec *executionContext) marshalOAdapterType2bandicootᚋpkgᚋdomainᚐAdapterType(ctx context.Context, sel ast.SelectionSet, v domain.AdapterType) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOAdapterType2ᚕᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx context.Context, v interface{}) ([]*domain.AdapterType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*domain.AdapterType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOAdapterType2ᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAdapterType2ᚕᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx context.Context, sel ast.SelectionSet, v []*domain.AdapterType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterType2ᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAdapterType2ᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx context.Context, v interface{}) (*domain.AdapterType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAdapterType2bandicootᚋpkgᚋdomainᚐAdapterType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAdapterType2ᚖbandicootᚋpkgᚋdomainᚐAdapterType(ctx context.Context, sel ast.SelectionSet, v *domain.AdapterType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOAdapterType2bandicootᚋpkgᚋdomainᚐAdapterType(ctx, sel, *v)
}

func (ec *executionContext) marshalOAdapterUser2bandicootᚋpkgᚋgqlᚐAdapterUser(ctx context.Context, sel ast.SelectionSet, v AdapterUser) graphql.Marshaler {
	return ec._AdapterUser(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterUser2ᚕbandicootᚋpkgᚋgqlᚐAdapterUserᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterUser2bandicootᚋpkgᚋgqlᚐAdapterUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterUser2ᚕᚖbandicootᚋpkgᚋgqlᚐAdapterUser(ctx context.Context, sel ast.SelectionSet, v []*AdapterUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterUser2ᚖbandicootᚋpkgᚋgqlᚐAdapterUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterUser2ᚖbandicootᚋpkgᚋgqlᚐAdapterUser(ctx context.Context, sel ast.SelectionSet, v *AdapterUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAdminType2bandicootᚋpkgᚋgqlᚐAdminType(ctx context.Context, v interface{}) (AdminType, error) {
	var res AdminType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAdminType2bandicootᚋpkgᚋgqlᚐAdminType(ctx context.Context, sel ast.SelectionSet, v AdminType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAdminType2ᚕᚖbandicootᚋpkgᚋgqlᚐAdminType(ctx context.Context, v interface{}) ([]*AdminType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*AdminType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOAdminType2ᚖbandicootᚋpkgᚋgqlᚐAdminType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAdminType2ᚕᚖbandicootᚋpkgᚋgqlᚐAdminType(ctx context.Context, sel ast.SelectionSet, v []*AdminType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdminType2ᚖbandicootᚋpkgᚋgqlᚐAdminType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAdminType2ᚖbandicootᚋpkgᚋgqlᚐAdminType(ctx context.Context, v interface{}) (*AdminType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAdminType2bandicootᚋpkgᚋgqlᚐAdminType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAdminType2ᚖbandicootᚋpkgᚋgqlᚐAdminType(ctx context.Context, sel ast.SelectionSet, v *AdminType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx context.Context, v interface{}) ([]AggregateOrdering, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AggregateOrdering, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNAggregateOrdering2bandicootᚋpkgᚋgqlᚐAggregateOrdering(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAggregateOrdering2ᚕbandicootᚋpkgᚋgqlᚐAggregateOrderingᚄ(ctx context.Context, sel ast.SelectionSet, v []AggregateOrdering) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAggregateOrdering2bandicootᚋpkgᚋgqlᚐAggregateOrdering(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOArchitecture2bandicootᚋpkgᚋgqlᚐArchitecture(ctx context.Context, v interface{}) (Architecture, error) {
	var res Architecture
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOArchitecture2bandicootᚋpkgᚋgqlᚐArchitecture(ctx context.Context, sel ast.SelectionSet, v Architecture) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOArchitecture2ᚕᚖbandicootᚋpkgᚋgqlᚐArchitecture(ctx context.Context, v interface{}) ([]*Architecture, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*Architecture, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOArchitecture2ᚖbandicootᚋpkgᚋgqlᚐArchitecture(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOArchitecture2ᚕᚖbandicootᚋpkgᚋgqlᚐArchitecture(ctx context.Context, sel ast.SelectionSet, v []*Architecture) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOArchitecture2ᚖbandicootᚋpkgᚋgqlᚐArchitecture(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOArchitecture2ᚖbandicootᚋpkgᚋgqlᚐArchitecture(ctx context.Context, v interface{}) (*Architecture, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOArchitecture2bandicootᚋpkgᚋgqlᚐArchitecture(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOArchitecture2ᚖbandicootᚋpkgᚋgqlᚐArchitecture(ctx context.Context, sel ast.SelectionSet, v *Architecture) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOCIDR2netᚐIPNet(ctx context.Context, v interface{}) (net.IPNet, error) {
	return UnmarshalCIDRScalar(v)
}

func (ec *executionContext) marshalOCIDR2netᚐIPNet(ctx context.Context, sel ast.SelectionSet, v net.IPNet) graphql.Marshaler {
	return MarshalCIDRScalar(v)
}

func (ec *executionContext) unmarshalOCIDR2ᚖnetᚐIPNet(ctx context.Context, v interface{}) (*net.IPNet, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCIDR2netᚐIPNet(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOCIDR2ᚖnetᚐIPNet(ctx context.Context, sel ast.SelectionSet, v *net.IPNet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOCIDR2netᚐIPNet(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOCylanceDeviceState2bandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx context.Context, v interface{}) (CylanceDeviceState, error) {
	var res CylanceDeviceState
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOCylanceDeviceState2bandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx context.Context, sel ast.SelectionSet, v CylanceDeviceState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOCylanceDeviceState2ᚕᚖbandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx context.Context, v interface{}) ([]*CylanceDeviceState, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*CylanceDeviceState, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOCylanceDeviceState2ᚖbandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOCylanceDeviceState2ᚕᚖbandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx context.Context, sel ast.SelectionSet, v []*CylanceDeviceState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCylanceDeviceState2ᚖbandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOCylanceDeviceState2ᚖbandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx context.Context, v interface{}) (*CylanceDeviceState, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCylanceDeviceState2bandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOCylanceDeviceState2ᚖbandicootᚋpkgᚋgqlᚐCylanceDeviceState(ctx context.Context, sel ast.SelectionSet, v *CylanceDeviceState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODevice2bandicootᚋpkgᚋgqlᚐDevice(ctx context.Context, sel ast.SelectionSet, v Device) graphql.Marshaler {
	return ec._Device(ctx, sel, &v)
}

func (ec *executionContext) marshalODevice2ᚕᚖbandicootᚋpkgᚋgqlᚐDevice(ctx context.Context, sel ast.SelectionSet, v []*Device) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODevice2ᚖbandicootᚋpkgᚋgqlᚐDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalODevice2ᚖbandicootᚋpkgᚋgqlᚐDevice(ctx context.Context, sel ast.SelectionSet, v *Device) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Device(ctx, sel, v)
}

func (ec *executionContext) unmarshalODirection2bandicootᚋpkgᚋgqlᚐDirection(ctx context.Context, v interface{}) (Direction, error) {
	var res Direction
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalODirection2bandicootᚋpkgᚋgqlᚐDirection(ctx context.Context, sel ast.SelectionSet, v Direction) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalODirection2ᚕᚖbandicootᚋpkgᚋgqlᚐDirection(ctx context.Context, v interface{}) ([]*Direction, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*Direction, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalODirection2ᚖbandicootᚋpkgᚋgqlᚐDirection(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODirection2ᚕᚖbandicootᚋpkgᚋgqlᚐDirection(ctx context.Context, sel ast.SelectionSet, v []*Direction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODirection2ᚖbandicootᚋpkgᚋgqlᚐDirection(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalODirection2ᚖbandicootᚋpkgᚋgqlᚐDirection(ctx context.Context, v interface{}) (*Direction, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODirection2bandicootᚋpkgᚋgqlᚐDirection(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODirection2ᚖbandicootᚋpkgᚋgqlᚐDirection(ctx context.Context, sel ast.SelectionSet, v *Direction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEpoch2bandicootᚋinternalᚐEpoch(ctx context.Context, v interface{}) (internal.Epoch, error) {
	return UnmarshalEpochScalar(v)
}

func (ec *executionContext) marshalOEpoch2bandicootᚋinternalᚐEpoch(ctx context.Context, sel ast.SelectionSet, v internal.Epoch) graphql.Marshaler {
	return MarshalEpochScalar(v)
}

func (ec *executionContext) unmarshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx context.Context, v interface{}) ([]*internal.Epoch, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*internal.Epoch, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEpoch2ᚕᚖbandicootᚋinternalᚐEpoch(ctx context.Context, sel ast.SelectionSet, v []*internal.Epoch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx context.Context, v interface{}) (*internal.Epoch, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEpoch2bandicootᚋinternalᚐEpoch(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOEpoch2ᚖbandicootᚋinternalᚐEpoch(ctx context.Context, sel ast.SelectionSet, v *internal.Epoch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOEpoch2bandicootᚋinternalᚐEpoch(ctx, sel, *v)
}

func (ec *executionContext) marshalOFirewallRule2bandicootᚋpkgᚋgqlᚐFirewallRule(ctx context.Context, sel ast.SelectionSet, v FirewallRule) graphql.Marshaler {
	return ec._FirewallRule(ctx, sel, &v)
}

func (ec *executionContext) marshalOFirewallRule2ᚕᚖbandicootᚋpkgᚋgqlᚐFirewallRule(ctx context.Context, sel ast.SelectionSet, v []*FirewallRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFirewallRule2ᚖbandicootᚋpkgᚋgqlᚐFirewallRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOFirewallRule2ᚖbandicootᚋpkgᚋgqlᚐFirewallRule(ctx context.Context, sel ast.SelectionSet, v *FirewallRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FirewallRule(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFloat2float64(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOFloat2float64(ctx, sel, *v)
}

func (ec *executionContext) marshalOGCETagsAggregate2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETagsAggregate2bandicootᚋpkgᚋgqlᚐGCETagsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOGCETags_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]GCETagsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GCETagsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNGCETags_aggregate_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOGCETags_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐGCETagsAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETags_aggregate_columns2bandicootᚋpkgᚋgqlᚐGCETagsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOGceTags2bandicootᚋpkgᚋgqlᚐGceTags(ctx context.Context, sel ast.SelectionSet, v GceTags) graphql.Marshaler {
	return ec._GceTags(ctx, sel, &v)
}

func (ec *executionContext) marshalOGceTags2ᚕᚖbandicootᚋpkgᚋgqlᚐGceTags(ctx context.Context, sel ast.SelectionSet, v []*GceTags) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGceTags2ᚖbandicootᚋpkgᚋgqlᚐGceTags(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOGceTags2ᚖbandicootᚋpkgᚋgqlᚐGceTags(ctx context.Context, sel ast.SelectionSet, v *GceTags) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GceTags(ctx, sel, v)
}

func (ec *executionContext) unmarshalOIP2netᚐIP(ctx context.Context, v interface{}) (net.IP, error) {
	return UnmarshalIPScalar(v)
}

func (ec *executionContext) marshalOIP2netᚐIP(ctx context.Context, sel ast.SelectionSet, v net.IP) graphql.Marshaler {
	return MarshalIPScalar(v)
}

func (ec *executionContext) unmarshalOIP2ᚕnetᚐIPᚄ(ctx context.Context, v interface{}) ([]net.IP, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]net.IP, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNIP2netᚐIP(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOIP2ᚕnetᚐIPᚄ(ctx context.Context, sel ast.SelectionSet, v []net.IP) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNIP2netᚐIP(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOIP2ᚕᚖnetᚐIP(ctx context.Context, v interface{}) ([]*net.IP, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*net.IP, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOIP2ᚖnetᚐIP(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOIP2ᚕᚖnetᚐIP(ctx context.Context, sel ast.SelectionSet, v []*net.IP) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOIP2ᚖnetᚐIP(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOIP2ᚖnetᚐIP(ctx context.Context, v interface{}) (*net.IP, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOIP2netᚐIP(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOIP2ᚖnetᚐIP(ctx context.Context, sel ast.SelectionSet, v *net.IP) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOIP2netᚐIP(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOIPFamily2bandicootᚋpkgᚋgqlᚐIPFamily(ctx context.Context, v interface{}) (IPFamily, error) {
	var res IPFamily
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOIPFamily2bandicootᚋpkgᚋgqlᚐIPFamily(ctx context.Context, sel ast.SelectionSet, v IPFamily) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOIPFamily2ᚖbandicootᚋpkgᚋgqlᚐIPFamily(ctx context.Context, v interface{}) (*IPFamily, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOIPFamily2bandicootᚋpkgᚋgqlᚐIPFamily(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOIPFamily2ᚖbandicootᚋpkgᚋgqlᚐIPFamily(ctx context.Context, sel ast.SelectionSet, v *IPFamily) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOInstalledSoftware2bandicootᚋpkgᚋgqlᚐInstalledSoftware(ctx context.Context, sel ast.SelectionSet, v InstalledSoftware) graphql.Marshaler {
	return ec._InstalledSoftware(ctx, sel, &v)
}

func (ec *executionContext) marshalOInstalledSoftware2ᚕᚖbandicootᚋpkgᚋgqlᚐInstalledSoftware(ctx context.Context, sel ast.SelectionSet, v []*InstalledSoftware) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInstalledSoftware2ᚖbandicootᚋpkgᚋgqlᚐInstalledSoftware(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOInstalledSoftware2ᚖbandicootᚋpkgᚋgqlᚐInstalledSoftware(ctx context.Context, sel ast.SelectionSet, v *InstalledSoftware) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InstalledSoftware(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2ᚕᚖint(ctx context.Context, v interface{}) ([]*int, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*int, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOInt2ᚖint(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2ᚕᚖint(ctx context.Context, sel ast.SelectionSet, v []*int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOInt2ᚖint(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOMac2string(ctx context.Context, v interface{}) (string, error) {
	return UnmarshalMacScalar(v)
}

func (ec *executionContext) marshalOMac2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return MarshalMacScalar(v)
}

func (ec *executionContext) unmarshalOMac2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOMac2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMac2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOMac2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOMac2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMac2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOMac2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOMac2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return graphql.UnmarshalMap(v)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalMap(v)
}

func (ec *executionContext) marshalONetworkInterface2bandicootᚋpkgᚋgqlᚐNetworkInterface(ctx context.Context, sel ast.SelectionSet, v NetworkInterface) graphql.Marshaler {
	return ec._NetworkInterface(ctx, sel, &v)
}

func (ec *executionContext) marshalONetworkInterface2ᚕbandicootᚋpkgᚋgqlᚐNetworkInterfaceᚄ(ctx context.Context, sel ast.SelectionSet, v []NetworkInterface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNetworkInterface2bandicootᚋpkgᚋgqlᚐNetworkInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalONetworkInterface2ᚕᚖbandicootᚋpkgᚋgqlᚐNetworkInterface(ctx context.Context, sel ast.SelectionSet, v []*NetworkInterface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONetworkInterface2ᚖbandicootᚋpkgᚋgqlᚐNetworkInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalONetworkInterface2ᚖbandicootᚋpkgᚋgqlᚐNetworkInterface(ctx context.Context, sel ast.SelectionSet, v *NetworkInterface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NetworkInterface(ctx, sel, v)
}

func (ec *executionContext) marshalOOperatingSystem2bandicootᚋpkgᚋgqlᚐOperatingSystem(ctx context.Context, sel ast.SelectionSet, v OperatingSystem) graphql.Marshaler {
	return ec._OperatingSystem(ctx, sel, &v)
}

func (ec *executionContext) marshalOOperatingSystem2ᚖbandicootᚋpkgᚋgqlᚐOperatingSystem(ctx context.Context, sel ast.SelectionSet, v *OperatingSystem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OperatingSystem(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOTag2bandicootᚋpkgᚋgqlᚐTag(ctx context.Context, sel ast.SelectionSet, v Tag) graphql.Marshaler {
	return ec._Tag(ctx, sel, &v)
}

func (ec *executionContext) marshalOTag2ᚕbandicootᚋpkgᚋgqlᚐTagᚄ(ctx context.Context, sel ast.SelectionSet, v []Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2bandicootᚋpkgᚋgqlᚐTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTag2ᚕᚖbandicootᚋpkgᚋgqlᚐTag(ctx context.Context, sel ast.SelectionSet, v []*Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTag2ᚖbandicootᚋpkgᚋgqlᚐTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTag2ᚖbandicootᚋpkgᚋgqlᚐTag(ctx context.Context, sel ast.SelectionSet, v *Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return graphql.MarshalTime(v)
}

func (ec *executionContext) unmarshalOTime2ᚕᚖtimeᚐTime(ctx context.Context, v interface{}) ([]*time.Time, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*time.Time, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2ᚕᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v []*time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOTime2ᚖtimeᚐTime(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTime2timeᚐTime(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTime2timeᚐTime(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx context.Context, v interface{}) (uuid.UUID, error) {
	return UnmarshalUUIDScalar(v)
}

func (ec *executionContext) marshalOUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	return MarshalUUIDScalar(v)
}

func (ec *executionContext) unmarshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx context.Context, v interface{}) ([]*uuid.UUID, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*uuid.UUID, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUUID2ᚕᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v []*uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx context.Context, v interface{}) (*uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUUID2ᚖgithubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v *uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOUUID2githubᚗcomᚋsatoriᚋgoᚗuuidᚐUUID(ctx, sel, *v)
}

func (ec *executionContext) marshalOUser2bandicootᚋpkgᚋgqlᚐUser(ctx context.Context, sel ast.SelectionSet, v User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2ᚕᚖbandicootᚋpkgᚋgqlᚐUser(ctx context.Context, sel ast.SelectionSet, v []*User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2ᚖbandicootᚋpkgᚋgqlᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOUser2ᚖbandicootᚋpkgᚋgqlᚐUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) marshalOadapterDevicesAggregate2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevicesAggregate2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapterDevices_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapterDevices_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_columns2bandicootᚋpkgᚋgqlᚐAdapterDevicesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOadapterUsersAggregate2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsersAggregate2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapterUsers_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]AdapterUsersAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapterUsers_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐAdapterUsersAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_columns2bandicootᚋpkgᚋgqlᚐAdapterUsersAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapter_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterBoolExp(ctx context.Context, v interface{}) (AdapterBoolExp, error) {
	return ec.unmarshalInputadapter_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterBoolExpᚄ(ctx context.Context, v interface{}) ([]AdapterBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterBoolExp(ctx context.Context, v interface{}) (*AdapterBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_data_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDataBoolExp(ctx context.Context, v interface{}) (AdapterDataBoolExp, error) {
	return ec.unmarshalInputadapter_data_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_data_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDataBoolExpᚄ(ctx context.Context, v interface{}) ([]AdapterDataBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDataBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_data_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDataBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_data_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDataBoolExp(ctx context.Context, v interface{}) (*AdapterDataBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_data_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDataBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_device_admin_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceAdminBoolExp(ctx context.Context, v interface{}) (AdapterDeviceAdminBoolExp, error) {
	return ec.unmarshalInputadapter_device_admin_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_device_admin_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceAdminBoolExpᚄ(ctx context.Context, v interface{}) ([]AdapterDeviceAdminBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceAdminBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_admin_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceAdminBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_device_admin_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceAdminBoolExp(ctx context.Context, v interface{}) (*AdapterDeviceAdminBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_device_admin_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceAdminBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_device_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExp(ctx context.Context, v interface{}) (AdapterDeviceBoolExp, error) {
	return ec.unmarshalInputadapter_device_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_device_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExpᚄ(ctx context.Context, v interface{}) ([]AdapterDeviceBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_device_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExp(ctx context.Context, v interface{}) (*AdapterDeviceBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_device_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_device_order_by2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceOrderByᚄ(ctx context.Context, v interface{}) ([]AdapterDeviceOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_order_by2bandicootᚋpkgᚋgqlᚐAdapterDeviceOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapter_device_order_by2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceOrderByᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterDeviceOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapter_device_order_by2bandicootᚋpkgᚋgqlᚐAdapterDeviceOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapter_device_user_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceUserBoolExp(ctx context.Context, v interface{}) (AdapterDeviceUserBoolExp, error) {
	return ec.unmarshalInputadapter_device_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_device_user_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterDeviceUserBoolExpᚄ(ctx context.Context, v interface{}) ([]AdapterDeviceUserBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceUserBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_user_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceUserBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_device_user_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterDeviceUserBoolExp(ctx context.Context, v interface{}) (*AdapterDeviceUserBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_device_user_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterDeviceUserBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_user_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterUserBoolExp(ctx context.Context, v interface{}) (AdapterUserBoolExp, error) {
	return ec.unmarshalInputadapter_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_user_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐAdapterUserBoolExpᚄ(ctx context.Context, v interface{}) ([]AdapterUserBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUserBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_user_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterUserBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_user_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐAdapterUserBoolExp(ctx context.Context, v interface{}) (*AdapterUserBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_user_bool_exp2bandicootᚋpkgᚋgqlᚐAdapterUserBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_user_order_by2ᚕbandicootᚋpkgᚋgqlᚐAdapterUserOrderByᚄ(ctx context.Context, v interface{}) ([]AdapterUserOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUserOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_user_order_by2bandicootᚋpkgᚋgqlᚐAdapterUserOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapter_user_order_by2ᚕbandicootᚋpkgᚋgqlᚐAdapterUserOrderByᚄ(ctx context.Context, sel ast.SelectionSet, v []AdapterUserOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapter_user_order_by2bandicootᚋpkgᚋgqlᚐAdapterUserOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsGroup2bandicootᚋpkgᚋgqlᚐCsGroup(ctx context.Context, sel ast.SelectionSet, v CsGroup) graphql.Marshaler {
	return ec._csGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsGroup2ᚕᚖbandicootᚋpkgᚋgqlᚐCsGroup(ctx context.Context, sel ast.SelectionSet, v []*CsGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsGroup2ᚖbandicootᚋpkgᚋgqlᚐCsGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsGroup2ᚖbandicootᚋpkgᚋgqlᚐCsGroup(ctx context.Context, sel ast.SelectionSet, v *CsGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csGroup(ctx, sel, v)
}

func (ec *executionContext) marshalOcsPolicy2bandicootᚋpkgᚋgqlᚐCsPolicy(ctx context.Context, sel ast.SelectionSet, v CsPolicy) graphql.Marshaler {
	return ec._csPolicy(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsPolicy2ᚖbandicootᚋpkgᚋgqlᚐCsPolicy(ctx context.Context, sel ast.SelectionSet, v *CsPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csPolicy(ctx, sel, v)
}

func (ec *executionContext) marshalOcsPolicySettings2bandicootᚋpkgᚋgqlᚐCsPolicySettings(ctx context.Context, sel ast.SelectionSet, v CsPolicySettings) graphql.Marshaler {
	return ec._csPolicySettings(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsPolicySettings2ᚕᚖbandicootᚋpkgᚋgqlᚐCsPolicySettings(ctx context.Context, sel ast.SelectionSet, v []*CsPolicySettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsPolicySettings2ᚖbandicootᚋpkgᚋgqlᚐCsPolicySettings(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsPolicySettings2ᚖbandicootᚋpkgᚋgqlᚐCsPolicySettings(ctx context.Context, sel ast.SelectionSet, v *CsPolicySettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csPolicySettings(ctx, sel, v)
}

func (ec *executionContext) marshalOcsPreventionSettings2bandicootᚋpkgᚋgqlᚐCsPreventionSettings(ctx context.Context, sel ast.SelectionSet, v CsPreventionSettings) graphql.Marshaler {
	return ec._csPreventionSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsPreventionSettings2ᚕᚖbandicootᚋpkgᚋgqlᚐCsPreventionSettings(ctx context.Context, sel ast.SelectionSet, v []*CsPreventionSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsPreventionSettings2ᚖbandicootᚋpkgᚋgqlᚐCsPreventionSettings(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsPreventionSettings2ᚖbandicootᚋpkgᚋgqlᚐCsPreventionSettings(ctx context.Context, sel ast.SelectionSet, v *CsPreventionSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csPreventionSettings(ctx, sel, v)
}

func (ec *executionContext) marshalOcsSensorUpdateSettings2bandicootᚋpkgᚋgqlᚐCsSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, v CsSensorUpdateSettings) graphql.Marshaler {
	return ec._csSensorUpdateSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsSensorUpdateSettings2ᚕᚖbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, v []*CsSensorUpdateSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsSensorUpdateSettings2ᚖbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettings(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsSensorUpdateSettings2ᚖbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, v *CsSensorUpdateSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csSensorUpdateSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOcs_group_bool_exp2bandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx context.Context, v interface{}) (CsGroupBoolExp, error) {
	return ec.unmarshalInputcs_group_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_group_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsGroupBoolExpᚄ(ctx context.Context, v interface{}) ([]CsGroupBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsGroupBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_group_bool_exp2bandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_group_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx context.Context, v interface{}) (*CsGroupBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_group_bool_exp2bandicootᚋpkgᚋgqlᚐCsGroupBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_policy_bool_exp2bandicootᚋpkgᚋgqlᚐCsPolicyBoolExp(ctx context.Context, v interface{}) (CsPolicyBoolExp, error) {
	return ec.unmarshalInputcs_policy_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_policy_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPolicyBoolExpᚄ(ctx context.Context, v interface{}) ([]CsPolicyBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsPolicyBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_policy_bool_exp2bandicootᚋpkgᚋgqlᚐCsPolicyBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_policy_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsPolicyBoolExp(ctx context.Context, v interface{}) (*CsPolicyBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_policy_bool_exp2bandicootᚋpkgᚋgqlᚐCsPolicyBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_policy_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsPolicySettingsBoolExp(ctx context.Context, v interface{}) (CsPolicySettingsBoolExp, error) {
	return ec.unmarshalInputcs_policy_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_policy_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPolicySettingsBoolExpᚄ(ctx context.Context, v interface{}) ([]CsPolicySettingsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsPolicySettingsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_policy_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsPolicySettingsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_policy_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsPolicySettingsBoolExp(ctx context.Context, v interface{}) (*CsPolicySettingsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_policy_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsPolicySettingsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_prevention_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExp(ctx context.Context, v interface{}) (CsPreventionSettingsBoolExp, error) {
	return ec.unmarshalInputcs_prevention_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_prevention_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExpᚄ(ctx context.Context, v interface{}) ([]CsPreventionSettingsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsPreventionSettingsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_prevention_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_prevention_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExp(ctx context.Context, v interface{}) (*CsPreventionSettingsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_prevention_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsPreventionSettingsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_sensor_update_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExp(ctx context.Context, v interface{}) (CsSensorUpdateSettingsBoolExp, error) {
	return ec.unmarshalInputcs_sensor_update_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_sensor_update_settings_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExpᚄ(ctx context.Context, v interface{}) ([]CsSensorUpdateSettingsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsSensorUpdateSettingsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_sensor_update_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_sensor_update_settings_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExp(ctx context.Context, v interface{}) (*CsSensorUpdateSettingsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootᚋpkgᚋgqlᚐCsSensorUpdateSettingsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOdevice_bool_exp2bandicootᚋpkgᚋgqlᚐDeviceBoolExp(ctx context.Context, v interface{}) (DeviceBoolExp, error) {
	return ec.unmarshalInputdevice_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOdevice_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐDeviceBoolExpᚄ(ctx context.Context, v interface{}) ([]DeviceBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DeviceBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevice_bool_exp2bandicootᚋpkgᚋgqlᚐDeviceBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOdevice_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐDeviceBoolExp(ctx context.Context, v interface{}) (*DeviceBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOdevice_bool_exp2bandicootᚋpkgᚋgqlᚐDeviceBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOdevice_order_by2ᚕbandicootᚋpkgᚋgqlᚐDeviceOrderByᚄ(ctx context.Context, v interface{}) ([]DeviceOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DeviceOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevice_order_by2bandicootᚋpkgᚋgqlᚐDeviceOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOdevice_order_by2ᚕbandicootᚋpkgᚋgqlᚐDeviceOrderByᚄ(ctx context.Context, sel ast.SelectionSet, v []DeviceOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevice_order_by2bandicootᚋpkgᚋgqlᚐDeviceOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOdevicesAggregate2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevicesAggregate2bandicootᚋpkgᚋgqlᚐDevicesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOdevices_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]DevicesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOdevices_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐDevicesAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_columns2bandicootᚋpkgᚋgqlᚐDevicesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOfirewallRulesAggregate2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRulesAggregate2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOfirewallRules_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]FirewallRulesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOfirewallRules_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐFirewallRulesAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_columns2bandicootᚋpkgᚋgqlᚐFirewallRulesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOfirewall_rule_bool_exp2bandicootᚋpkgᚋgqlᚐFirewallRuleBoolExp(ctx context.Context, v interface{}) (FirewallRuleBoolExp, error) {
	return ec.unmarshalInputfirewall_rule_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOfirewall_rule_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐFirewallRuleBoolExpᚄ(ctx context.Context, v interface{}) ([]FirewallRuleBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRuleBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewall_rule_bool_exp2bandicootᚋpkgᚋgqlᚐFirewallRuleBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOfirewall_rule_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐFirewallRuleBoolExp(ctx context.Context, v interface{}) (*FirewallRuleBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOfirewall_rule_bool_exp2bandicootᚋpkgᚋgqlᚐFirewallRuleBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOgce_tags_bool_exp2bandicootᚋpkgᚋgqlᚐGceTagsBoolExp(ctx context.Context, v interface{}) (GceTagsBoolExp, error) {
	return ec.unmarshalInputgce_tags_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOgce_tags_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐGceTagsBoolExpᚄ(ctx context.Context, v interface{}) ([]GceTagsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GceTagsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgce_tags_bool_exp2bandicootᚋpkgᚋgqlᚐGceTagsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOgce_tags_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐGceTagsBoolExp(ctx context.Context, v interface{}) (*GceTagsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOgce_tags_bool_exp2bandicootᚋpkgᚋgqlᚐGceTagsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOgroupsAggregate2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroupsAggregate2bandicootᚋpkgᚋgqlᚐGroupsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOgroups_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]GroupsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOgroups_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐGroupsAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_columns2bandicootᚋpkgᚋgqlᚐGroupsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOinstalledSoftwareAggregate2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftwareAggregate2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOinstalledSoftware_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOinstalledSoftware_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_columns2bandicootᚋpkgᚋgqlᚐInstalledSoftwareAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOinstalled_software_bool_exp2bandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExp(ctx context.Context, v interface{}) (InstalledSoftwareBoolExp, error) {
	return ec.unmarshalInputinstalled_software_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOinstalled_software_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExpᚄ(ctx context.Context, v interface{}) ([]InstalledSoftwareBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalled_software_bool_exp2bandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOinstalled_software_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExp(ctx context.Context, v interface{}) (*InstalledSoftwareBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOinstalled_software_bool_exp2bandicootᚋpkgᚋgqlᚐInstalledSoftwareBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOinterfacesAggregate2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfacesAggregate2bandicootᚋpkgᚋgqlᚐInterfacesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOinterfaces_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]InterfacesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InterfacesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinterfaces_aggregate_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOinterfaces_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐInterfacesAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfaces_aggregate_columns2bandicootᚋpkgᚋgqlᚐInterfacesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOnetwork_interface_bool_exp2bandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx context.Context, v interface{}) (NetworkInterfaceBoolExp, error) {
	return ec.unmarshalInputnetwork_interface_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOnetwork_interface_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExpᚄ(ctx context.Context, v interface{}) ([]NetworkInterfaceBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]NetworkInterfaceBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNnetwork_interface_bool_exp2bandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOnetwork_interface_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx context.Context, v interface{}) (*NetworkInterfaceBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOnetwork_interface_bool_exp2bandicootᚋpkgᚋgqlᚐNetworkInterfaceBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOoperating_system_bool_exp2bandicootᚋpkgᚋgqlᚐOperatingSystemBoolExp(ctx context.Context, v interface{}) (OperatingSystemBoolExp, error) {
	return ec.unmarshalInputoperating_system_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOoperating_system_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐOperatingSystemBoolExpᚄ(ctx context.Context, v interface{}) ([]OperatingSystemBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]OperatingSystemBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNoperating_system_bool_exp2bandicootᚋpkgᚋgqlᚐOperatingSystemBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOoperating_system_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐOperatingSystemBoolExp(ctx context.Context, v interface{}) (*OperatingSystemBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOoperating_system_bool_exp2bandicootᚋpkgᚋgqlᚐOperatingSystemBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOpreventionSettingsAggregate2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettingsAggregate2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOpreventionSettings_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]PreventionSettingsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]PreventionSettingsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNpreventionSettings_aggregate_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOpreventionSettings_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettings_aggregate_columns2bandicootᚋpkgᚋgqlᚐPreventionSettingsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOsensorUpdateSettingsAggregate2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettingsAggregate2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOsensorUpdateSettings_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]SensorUpdateSettingsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]SensorUpdateSettingsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNsensorUpdateSettings_aggregate_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOsensorUpdateSettings_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettings_aggregate_columns2bandicootᚋpkgᚋgqlᚐSensorUpdateSettingsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOtag_bool_exp2bandicootᚋpkgᚋgqlᚐTagBoolExp(ctx context.Context, v interface{}) (TagBoolExp, error) {
	return ec.unmarshalInputtag_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOtag_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐTagBoolExpᚄ(ctx context.Context, v interface{}) ([]TagBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtag_bool_exp2bandicootᚋpkgᚋgqlᚐTagBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOtag_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐTagBoolExp(ctx context.Context, v interface{}) (*TagBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOtag_bool_exp2bandicootᚋpkgᚋgqlᚐTagBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOtagsAggregate2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []TagsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtagsAggregate2bandicootᚋpkgᚋgqlᚐTagsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOtags_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]TagsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtags_aggregate_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOtags_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐTagsAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []TagsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtags_aggregate_columns2bandicootᚋpkgᚋgqlᚐTagsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOuser_bool_exp2bandicootᚋpkgᚋgqlᚐUserBoolExp(ctx context.Context, v interface{}) (UserBoolExp, error) {
	return ec.unmarshalInputuser_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOuser_bool_exp2ᚕbandicootᚋpkgᚋgqlᚐUserBoolExpᚄ(ctx context.Context, v interface{}) ([]UserBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UserBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNuser_bool_exp2bandicootᚋpkgᚋgqlᚐUserBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOuser_bool_exp2ᚖbandicootᚋpkgᚋgqlᚐUserBoolExp(ctx context.Context, v interface{}) (*UserBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOuser_bool_exp2bandicootᚋpkgᚋgqlᚐUserBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOuser_order_by2ᚕbandicootᚋpkgᚋgqlᚐUserOrderByᚄ(ctx context.Context, v interface{}) ([]UserOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UserOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNuser_order_by2bandicootᚋpkgᚋgqlᚐUserOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOuser_order_by2ᚕbandicootᚋpkgᚋgqlᚐUserOrderByᚄ(ctx context.Context, sel ast.SelectionSet, v []UserOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNuser_order_by2bandicootᚋpkgᚋgqlᚐUserOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOusersAggregate2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []UsersAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusersAggregate2bandicootᚋpkgᚋgqlᚐUsersAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOusers_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateColumnsᚄ(ctx context.Context, v interface{}) ([]UsersAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOusers_aggregate_columns2ᚕbandicootᚋpkgᚋgqlᚐUsersAggregateColumnsᚄ(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_columns2bandicootᚋpkgᚋgqlᚐUsersAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

// endregion ***************************** type.gotpl *****************************
