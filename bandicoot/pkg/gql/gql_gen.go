// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bandicoot/internal"
	"bandicoot/pkg/domain"
	"bytes"
	"context"
	"errors"
	"fmt"
	"net"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/satori/go.uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AdapterDevice() AdapterDeviceResolver
	AdapterUser() AdapterUserResolver
	Device() DeviceResolver
	Query() QueryResolver
	User() UserResolver
}

type DirectiveRoot struct {
	GenerateInputs func(ctx context.Context, obj interface{}, next graphql.Resolver, where *string, orderBy *string) (res interface{}, err error)
	Jsonpath       func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string, depends []*string) (res interface{}, err error)
	Relation       func(ctx context.Context, obj interface{}, next graphql.Resolver, name string, fkName []string, relationFkName []string, relType string, manyToManyTableName *string, joinOn []string) (res interface{}, err error)
	ViewFunction   func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string, arguments []*string) (res interface{}, err error)
}

type ComplexityRoot struct {
	ActiveDirectoryData struct {
		AdAccountExpires          func(childComplexity int) int
		AdBadPasswordTime         func(childComplexity int) int
		AdBadPwdCount             func(childComplexity int) int
		AdCanonicalName           func(childComplexity int) int
		AdCn                      func(childComplexity int) int
		AdDisplayName             func(childComplexity int) int
		AdDistinguishedName       func(childComplexity int) int
		AdGUID                    func(childComplexity int) int
		AdIsCriticalSystemObject  func(childComplexity int) int
		AdLastLogoff              func(childComplexity int) int
		AdLastLogon               func(childComplexity int) int
		AdLastLogonTimestamp      func(childComplexity int) int
		AdManagedBy               func(childComplexity int) int
		AdMemberOf                func(childComplexity int) int
		AdMemberOfFull            func(childComplexity int) int
		AdMsdsAllowedToDelegateTo func(childComplexity int) int
		AdMsdsResultantPso        func(childComplexity int) int
		AdName                    func(childComplexity int) int
		AdObjectCategory          func(childComplexity int) int
		AdObjectClass             func(childComplexity int) int
		AdOrganizationalUnit      func(childComplexity int) int
		AdPasswordLastSet         func(childComplexity int) int
		AdPrimaryGroupDn          func(childComplexity int) int
		AdPrimaryGroupID          func(childComplexity int) int
		AdPwdMustChange           func(childComplexity int) int
		AdSAMAccountName          func(childComplexity int) int
		AdSid                     func(childComplexity int) int
		AdUserPrincipalName       func(childComplexity int) int
		AdUsnChanged              func(childComplexity int) int
		AdUsnCreated              func(childComplexity int) int
		AdWhenChanged             func(childComplexity int) int
		AdWhenCreated             func(childComplexity int) int
	}

	Adapter struct {
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		Properties func(childComplexity int) int
	}

	AdapterDevice struct {
		Adapter                    func(childComplexity int, where *AdapterBoolExp) int
		AdapterData                func(childComplexity int, where *AdapterDataBoolExp) int
		AdapterID                  func(childComplexity int) int
		AdapterName                func(childComplexity int) int
		AgentName                  func(childComplexity int) int
		AgentStatus                func(childComplexity int) int
		AgentVersion               func(childComplexity int) int
		BiosSerial                 func(childComplexity int) int
		BiosVersion                func(childComplexity int) int
		Data                       func(childComplexity int) int
		DeviceID                   func(childComplexity int) int
		DeviceUsers                func(childComplexity int, limit *int, offset *int, where *AdapterDeviceUserBoolExp) int
		Domain                     func(childComplexity int) int
		Family                     func(childComplexity int) int
		FetchCycle                 func(childComplexity int) int
		FetchTime                  func(childComplexity int) int
		FirewallRules              func(childComplexity int, limit *int, offset *int, where *FirewallRuleBoolExp) int
		FirewallRulesAggregate     func(childComplexity int, groupBy []FirewallRulesAggregateColumns, distinctOn []FirewallRulesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *FirewallRuleBoolExp) int
		Hostname                   func(childComplexity int) int
		ID                         func(childComplexity int) int
		InstalledSoftware          func(childComplexity int, limit *int, offset *int, where *InstalledSoftwareBoolExp) int
		InstalledSoftwareAggregate func(childComplexity int, groupBy []InstalledSoftwareAggregateColumns, distinctOn []InstalledSoftwareAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *InstalledSoftwareBoolExp) int
		Interfaces                 func(childComplexity int, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		InterfacesAggregate        func(childComplexity int, groupBy []InterfacesAggregateColumns, distinctOn []InterfacesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		LastSeen                   func(childComplexity int) int
		LastUsedUsers              func(childComplexity int) int
		LocalAdmins                func(childComplexity int, limit *int, offset *int, where *AdapterDeviceAdminBoolExp) int
		Manufacturer               func(childComplexity int) int
		Model                      func(childComplexity int) int
		Name                       func(childComplexity int) int
		Os                         func(childComplexity int, where *OperatingSystemBoolExp) int
		OsID                       func(childComplexity int) int
		PartOfDomain               func(childComplexity int) int
		PrettyID                   func(childComplexity int) int
		Serial                     func(childComplexity int) int
		Tags                       func(childComplexity int, limit *int, offset *int, where *TagBoolExp) int
		TagsAggregate              func(childComplexity int, groupBy []TagsAggregateColumns, distinctOn []TagsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *TagBoolExp) int
	}

	AdapterDeviceAdmin struct {
		Name func(childComplexity int) int
		Type func(childComplexity int) int
	}

	AdapterDeviceUser struct {
		DeviceID       func(childComplexity int) int
		Interpreter    func(childComplexity int) int
		IsAdmin        func(childComplexity int) int
		IsDisabled     func(childComplexity int) int
		IsLocal        func(childComplexity int) int
		LastUseDate    func(childComplexity int) int
		PasswordMaxAge func(childComplexity int) int
		Sid            func(childComplexity int) int
		UserDepartment func(childComplexity int) int
		Username       func(childComplexity int) int
	}

	AdapterUser struct {
		Adapter        func(childComplexity int, where *AdapterBoolExp) int
		AdapterData    func(childComplexity int, where *AdapterDataBoolExp) int
		AdapterID      func(childComplexity int) int
		AdapterName    func(childComplexity int) int
		Admin          func(childComplexity int) int
		Data           func(childComplexity int) int
		DelegatedAdmin func(childComplexity int) int
		Disabled       func(childComplexity int) int
		FetchCycle     func(childComplexity int) int
		FetchTime      func(childComplexity int) int
		FirstName      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastName       func(childComplexity int) int
		LastSeen       func(childComplexity int) int
		Local          func(childComplexity int) int
		Locked         func(childComplexity int) int
		Mail           func(childComplexity int) int
		MfaEnforced    func(childComplexity int) int
		MfaEnrolled    func(childComplexity int) int
		Suspended      func(childComplexity int) int
		UserID         func(childComplexity int) int
		Username       func(childComplexity int) int
	}

	CPU struct {
		Bitness      func(childComplexity int) int
		Cores        func(childComplexity int) int
		CoresThreads func(childComplexity int) int
		Family       func(childComplexity int) int
		Ghz          func(childComplexity int) int
		ID           func(childComplexity int) int
		Manfacturer  func(childComplexity int) int
		Name         func(childComplexity int) int
	}

	CrowdStrikeData struct {
		CsAgentVersion     func(childComplexity int) int
		ExternalIP         func(childComplexity int) int
		Groups             func(childComplexity int, limit *int, offset *int, where *CsGroupBoolExp) int
		GroupsAggregate    func(childComplexity int, groupBy []GroupsAggregateColumns, distinctOn []GroupsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsGroupBoolExp) int
		PreventionPolicy   func(childComplexity int, where *CsPolicyBoolExp) int
		SensorUpdatePolicy func(childComplexity int, where *CsGroupBoolExp) int
	}

	CylanceData struct {
		AgentVersion    func(childComplexity int) int
		DeviceState     func(childComplexity int) int
		IsSafe          func(childComplexity int) int
		PoliciesDetails func(childComplexity int) int
		PolicyID        func(childComplexity int) int
		PolicyName      func(childComplexity int) int
		TenantTag       func(childComplexity int) int
		ZoneNames       func(childComplexity int) int
	}

	Device struct {
		AdapterCount            func(childComplexity int) int
		AdapterDevices          func(childComplexity int, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		AdapterDevicesAggregate func(childComplexity int, groupBy []AdapterDevicesAggregateColumns, distinctOn []AdapterDevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		AdapterNames            func(childComplexity int) int
		CompatibilityAPI        func(childComplexity int) int
		FetchCycle              func(childComplexity int) int
		Hostnames               func(childComplexity int) int
		ID                      func(childComplexity int) int
		Interfaces              func(childComplexity int, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		InterfacesAggregate     func(childComplexity int, groupBy []InterfacesAggregateColumns, distinctOn []InterfacesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		LastSeen                func(childComplexity int) int
		Tags                    func(childComplexity int, limit *int, offset *int, where *TagBoolExp) int
		TagsAggregate           func(childComplexity int, groupBy []TagsAggregateColumns, distinctOn []TagsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *TagBoolExp) int
	}

	FirewallRule struct {
		Direction func(childComplexity int) int
		DstPort   func(childComplexity int) int
		Name      func(childComplexity int) int
		Protocol  func(childComplexity int) int
		Source    func(childComplexity int) int
		SrcPort   func(childComplexity int) int
		Target    func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	GCETagsAggregate struct {
		Avg      func(childComplexity int) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		GCETags  func(childComplexity int, limit *int, offset *int, where *GceTagsBoolExp) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []GCETagsAggregateMaxColumns) int
		Min      func(childComplexity int, column []GCETagsAggregateMinColumns) int
		Sum      func(childComplexity int) int
	}

	GceTags struct {
		GceKey   func(childComplexity int) int
		GceValue func(childComplexity int) int
	}

	GoogleCloudData struct {
		GCETags          func(childComplexity int, limit *int, offset *int, where *GceTagsBoolExp) int
		GCETagsAggregate func(childComplexity int, groupBy []GCETagsAggregateColumns, distinctOn []GCETagsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *GceTagsBoolExp) int
		ID               func(childComplexity int) int
		Image            func(childComplexity int) int
		Size             func(childComplexity int) int
	}

	InstalledSoftware struct {
		Architecture func(childComplexity int) int
		CveCount     func(childComplexity int) int
		Description  func(childComplexity int) int
		Name         func(childComplexity int) int
		Path         func(childComplexity int) int
		Publisher    func(childComplexity int) int
		SwLicense    func(childComplexity int) int
		Vendor       func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	NetworkInterface struct {
		DeviceID func(childComplexity int) int
		IPAddrs  func(childComplexity int) int
		MacAddr  func(childComplexity int) int
	}

	OperatingSystem struct {
		Architecture  func(childComplexity int) int
		Build         func(childComplexity int) int
		CodeName      func(childComplexity int) int
		Distribution  func(childComplexity int) int
		ID            func(childComplexity int) int
		InstallDate   func(childComplexity int) int
		KernelVersion func(childComplexity int) int
		Major         func(childComplexity int) int
		Minor         func(childComplexity int) int
		RawName       func(childComplexity int) int
		ServicePack   func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	Query struct {
		AdapterDevices          func(childComplexity int, limit *int, offset *int, where *AdapterDeviceBoolExp, orderBy []AdapterDeviceOrderBy) int
		AdapterDevicesAggregate func(childComplexity int, groupBy []AdapterDevicesAggregateColumns, distinctOn []AdapterDevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		AdapterUsers            func(childComplexity int, limit *int, offset *int, where *AdapterUserBoolExp, orderBy []AdapterUserOrderBy) int
		AdapterUsersAggregate   func(childComplexity int, groupBy []AdapterUsersAggregateColumns, distinctOn []AdapterUsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterUserBoolExp) int
		Devices                 func(childComplexity int, limit *int, offset *int, where *DeviceBoolExp, orderBy []DeviceOrderBy) int
		DevicesAggregate        func(childComplexity int, groupBy []DevicesAggregateColumns, distinctOn []DevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *DeviceBoolExp) int
		Users                   func(childComplexity int, limit *int, offset *int, where *UserBoolExp, orderBy []UserOrderBy) int
		UsersAggregate          func(childComplexity int, groupBy []UsersAggregateColumns, distinctOn []UsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *UserBoolExp) int
	}

	Storage struct {
		Description func(childComplexity int) int
		DeviceID    func(childComplexity int) int
		FreeSize    func(childComplexity int) int
		IsEncrypted func(childComplexity int) int
		Name        func(childComplexity int) int
		Path        func(childComplexity int) int
		TotalSize   func(childComplexity int) int
	}

	Tag struct {
		Creator func(childComplexity int) int
		Level   func(childComplexity int) int
		Name    func(childComplexity int) int
	}

	User struct {
		AdapterCount          func(childComplexity int) int
		AdapterNames          func(childComplexity int) int
		AdapterUsers          func(childComplexity int, limit *int, offset *int, where *AdapterUserBoolExp) int
		AdapterUsersAggregate func(childComplexity int, groupBy []AdapterUsersAggregateColumns, distinctOn []AdapterUsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterUserBoolExp) int
		CompatibilityAPI      func(childComplexity int) int
		FetchCycle            func(childComplexity int) int
		ID                    func(childComplexity int) int
		LastSeen              func(childComplexity int) int
		Usernames             func(childComplexity int) int
	}

	AdapterDevicesAggregate struct {
		AdapterDevices func(childComplexity int, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		Avg            func(childComplexity int, column []AdapterDevicesAggregateAvgColumns) int
		Count          func(childComplexity int) int
		Distinct       func(childComplexity int) int
		Group          func(childComplexity int) int
		Max            func(childComplexity int, column []AdapterDevicesAggregateMaxColumns) int
		Min            func(childComplexity int, column []AdapterDevicesAggregateMinColumns) int
		Sum            func(childComplexity int, column []AdapterDevicesAggregateSumColumns) int
	}

	AdapterUsersAggregate struct {
		AdapterUsers func(childComplexity int, limit *int, offset *int, where *AdapterUserBoolExp) int
		Avg          func(childComplexity int, column []AdapterUsersAggregateAvgColumns) int
		Count        func(childComplexity int) int
		Distinct     func(childComplexity int) int
		Group        func(childComplexity int) int
		Max          func(childComplexity int, column []AdapterUsersAggregateMaxColumns) int
		Min          func(childComplexity int, column []AdapterUsersAggregateMinColumns) int
		Sum          func(childComplexity int, column []AdapterUsersAggregateSumColumns) int
	}

	CsGroup struct {
		CreatedBy        func(childComplexity int) int
		CreatedTimestamp func(childComplexity int) int
		Description      func(childComplexity int) int
		GroupType        func(childComplexity int) int
		ID               func(childComplexity int) int
		ModifiedBy       func(childComplexity int) int
		ModifiedTime     func(childComplexity int) int
		Name             func(childComplexity int) int
	}

	CsPolicy struct {
		CreatedBy                     func(childComplexity int) int
		CreatedTime                   func(childComplexity int) int
		Description                   func(childComplexity int) int
		Enabled                       func(childComplexity int) int
		Groups                        func(childComplexity int, limit *int, offset *int, where *CsGroupBoolExp) int
		GroupsAggregate               func(childComplexity int, groupBy []GroupsAggregateColumns, distinctOn []GroupsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsGroupBoolExp) int
		Name                          func(childComplexity int) int
		PlatformName                  func(childComplexity int) int
		PreventionSettings            func(childComplexity int, limit *int, offset *int, where *CsPreventionSettingsBoolExp) int
		PreventionSettingsAggregate   func(childComplexity int, groupBy []PreventionSettingsAggregateColumns, distinctOn []PreventionSettingsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsPreventionSettingsBoolExp) int
		SensorUpdateSettings          func(childComplexity int, limit *int, offset *int, where *CsSensorUpdateSettingsBoolExp) int
		SensorUpdateSettingsAggregate func(childComplexity int, groupBy []SensorUpdateSettingsAggregateColumns, distinctOn []SensorUpdateSettingsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsSensorUpdateSettingsBoolExp) int
	}

	CsPolicySettings struct {
		Enabled func(childComplexity int) int
	}

	CsPreventionSettings struct {
		Name     func(childComplexity int) int
		Settings func(childComplexity int, limit *int, offset *int, where *CsPolicySettingsBoolExp) int
	}

	CsSensorUpdateSettings struct {
		Build func(childComplexity int) int
	}

	DevicesAggregate struct {
		Avg      func(childComplexity int, column []DevicesAggregateAvgColumns) int
		Count    func(childComplexity int) int
		Devices  func(childComplexity int, limit *int, offset *int, where *DeviceBoolExp) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []DevicesAggregateMaxColumns) int
		Min      func(childComplexity int, column []DevicesAggregateMinColumns) int
		Sum      func(childComplexity int, column []DevicesAggregateSumColumns) int
	}

	FirewallRulesAggregate struct {
		Avg           func(childComplexity int, column []FirewallRulesAggregateAvgColumns) int
		Count         func(childComplexity int) int
		Distinct      func(childComplexity int) int
		FirewallRules func(childComplexity int, limit *int, offset *int, where *FirewallRuleBoolExp) int
		Group         func(childComplexity int) int
		Max           func(childComplexity int, column []FirewallRulesAggregateMaxColumns) int
		Min           func(childComplexity int, column []FirewallRulesAggregateMinColumns) int
		Sum           func(childComplexity int, column []FirewallRulesAggregateSumColumns) int
	}

	GroupsAggregate struct {
		Avg      func(childComplexity int, column []GroupsAggregateAvgColumns) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Groups   func(childComplexity int, limit *int, offset *int, where *CsGroupBoolExp) int
		Max      func(childComplexity int, column []GroupsAggregateMaxColumns) int
		Min      func(childComplexity int, column []GroupsAggregateMinColumns) int
		Sum      func(childComplexity int, column []GroupsAggregateSumColumns) int
	}

	InstalledSoftwareAggregate struct {
		Avg               func(childComplexity int, column []InstalledSoftwareAggregateAvgColumns) int
		Count             func(childComplexity int) int
		Distinct          func(childComplexity int) int
		Group             func(childComplexity int) int
		InstalledSoftware func(childComplexity int, limit *int, offset *int, where *InstalledSoftwareBoolExp) int
		Max               func(childComplexity int, column []InstalledSoftwareAggregateMaxColumns) int
		Min               func(childComplexity int, column []InstalledSoftwareAggregateMinColumns) int
		Sum               func(childComplexity int, column []InstalledSoftwareAggregateSumColumns) int
	}

	InterfacesAggregate struct {
		Avg        func(childComplexity int) int
		Count      func(childComplexity int) int
		Distinct   func(childComplexity int) int
		Group      func(childComplexity int) int
		Interfaces func(childComplexity int, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		Max        func(childComplexity int, column []InterfacesAggregateMaxColumns) int
		Min        func(childComplexity int, column []InterfacesAggregateMinColumns) int
		Sum        func(childComplexity int) int
	}

	PreventionSettingsAggregate struct {
		Avg                func(childComplexity int) int
		Count              func(childComplexity int) int
		Distinct           func(childComplexity int) int
		Group              func(childComplexity int) int
		Max                func(childComplexity int, column []PreventionSettingsAggregateMaxColumns) int
		Min                func(childComplexity int, column []PreventionSettingsAggregateMinColumns) int
		PreventionSettings func(childComplexity int, limit *int, offset *int, where *CsPreventionSettingsBoolExp) int
		Sum                func(childComplexity int) int
	}

	SensorUpdateSettingsAggregate struct {
		Avg                  func(childComplexity int) int
		Count                func(childComplexity int) int
		Distinct             func(childComplexity int) int
		Group                func(childComplexity int) int
		Max                  func(childComplexity int, column []SensorUpdateSettingsAggregateMaxColumns) int
		Min                  func(childComplexity int, column []SensorUpdateSettingsAggregateMinColumns) int
		SensorUpdateSettings func(childComplexity int, limit *int, offset *int, where *CsSensorUpdateSettingsBoolExp) int
		Sum                  func(childComplexity int) int
	}

	TagsAggregate struct {
		Avg      func(childComplexity int) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []TagsAggregateMaxColumns) int
		Min      func(childComplexity int, column []TagsAggregateMinColumns) int
		Sum      func(childComplexity int) int
		Tags     func(childComplexity int, limit *int, offset *int, where *TagBoolExp) int
	}

	UsersAggregate struct {
		Avg      func(childComplexity int, column []UsersAggregateAvgColumns) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []UsersAggregateMaxColumns) int
		Min      func(childComplexity int, column []UsersAggregateMinColumns) int
		Sum      func(childComplexity int, column []UsersAggregateSumColumns) int
		Users    func(childComplexity int, limit *int, offset *int, where *UserBoolExp) int
	}
}

type AdapterDeviceResolver interface {
	AdapterData(ctx context.Context, obj *AdapterDevice, where *AdapterDataBoolExp) (AdapterData, error)
}
type AdapterUserResolver interface {
	AdapterData(ctx context.Context, obj *AdapterUser, where *AdapterDataBoolExp) (AdapterData, error)
}
type DeviceResolver interface {
	CompatibilityAPI(ctx context.Context, obj *Device) (map[string]interface{}, error)
}
type QueryResolver interface {
	AdapterDevices(ctx context.Context, limit *int, offset *int, where *AdapterDeviceBoolExp, orderBy []AdapterDeviceOrderBy) ([]AdapterDevice, error)
	Devices(ctx context.Context, limit *int, offset *int, where *DeviceBoolExp, orderBy []DeviceOrderBy) ([]Device, error)
	AdapterUsers(ctx context.Context, limit *int, offset *int, where *AdapterUserBoolExp, orderBy []AdapterUserOrderBy) ([]AdapterUser, error)
	Users(ctx context.Context, limit *int, offset *int, where *UserBoolExp, orderBy []UserOrderBy) ([]User, error)
	AdapterDevicesAggregate(ctx context.Context, groupBy []AdapterDevicesAggregateColumns, distinctOn []AdapterDevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterDeviceBoolExp) ([]AdapterDevicesAggregate, error)
	DevicesAggregate(ctx context.Context, groupBy []DevicesAggregateColumns, distinctOn []DevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *DeviceBoolExp) ([]DevicesAggregate, error)
	AdapterUsersAggregate(ctx context.Context, groupBy []AdapterUsersAggregateColumns, distinctOn []AdapterUsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterUserBoolExp) ([]AdapterUsersAggregate, error)
	UsersAggregate(ctx context.Context, groupBy []UsersAggregateColumns, distinctOn []UsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *UserBoolExp) ([]UsersAggregate, error)
}
type UserResolver interface {
	CompatibilityAPI(ctx context.Context, obj *User) (map[string]interface{}, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "ActiveDirectoryData.adAccountExpires":
		if e.complexity.ActiveDirectoryData.AdAccountExpires == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdAccountExpires(childComplexity), true

	case "ActiveDirectoryData.adBadPasswordTime":
		if e.complexity.ActiveDirectoryData.AdBadPasswordTime == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdBadPasswordTime(childComplexity), true

	case "ActiveDirectoryData.ad_bad_pwd_count":
		if e.complexity.ActiveDirectoryData.AdBadPwdCount == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdBadPwdCount(childComplexity), true

	case "ActiveDirectoryData.adCanonicalName":
		if e.complexity.ActiveDirectoryData.AdCanonicalName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdCanonicalName(childComplexity), true

	case "ActiveDirectoryData.adCn":
		if e.complexity.ActiveDirectoryData.AdCn == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdCn(childComplexity), true

	case "ActiveDirectoryData.adDisplayName":
		if e.complexity.ActiveDirectoryData.AdDisplayName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdDisplayName(childComplexity), true

	case "ActiveDirectoryData.adDistinguishedName":
		if e.complexity.ActiveDirectoryData.AdDistinguishedName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdDistinguishedName(childComplexity), true

	case "ActiveDirectoryData.adGuid":
		if e.complexity.ActiveDirectoryData.AdGUID == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdGUID(childComplexity), true

	case "ActiveDirectoryData.adIsCriticalSystemObject":
		if e.complexity.ActiveDirectoryData.AdIsCriticalSystemObject == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdIsCriticalSystemObject(childComplexity), true

	case "ActiveDirectoryData.adLastLogoff":
		if e.complexity.ActiveDirectoryData.AdLastLogoff == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdLastLogoff(childComplexity), true

	case "ActiveDirectoryData.adLastLogon":
		if e.complexity.ActiveDirectoryData.AdLastLogon == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdLastLogon(childComplexity), true

	case "ActiveDirectoryData.adLastLogonTimestamp":
		if e.complexity.ActiveDirectoryData.AdLastLogonTimestamp == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdLastLogonTimestamp(childComplexity), true

	case "ActiveDirectoryData.adManagedBy":
		if e.complexity.ActiveDirectoryData.AdManagedBy == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdManagedBy(childComplexity), true

	case "ActiveDirectoryData.adMemberOf":
		if e.complexity.ActiveDirectoryData.AdMemberOf == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMemberOf(childComplexity), true

	case "ActiveDirectoryData.adMemberOfFull":
		if e.complexity.ActiveDirectoryData.AdMemberOfFull == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMemberOfFull(childComplexity), true

	case "ActiveDirectoryData.adMsdsAllowedToDelegateTo":
		if e.complexity.ActiveDirectoryData.AdMsdsAllowedToDelegateTo == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMsdsAllowedToDelegateTo(childComplexity), true

	case "ActiveDirectoryData.adMsdsResultantPso":
		if e.complexity.ActiveDirectoryData.AdMsdsResultantPso == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMsdsResultantPso(childComplexity), true

	case "ActiveDirectoryData.adName":
		if e.complexity.ActiveDirectoryData.AdName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdName(childComplexity), true

	case "ActiveDirectoryData.adObjectCategory":
		if e.complexity.ActiveDirectoryData.AdObjectCategory == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdObjectCategory(childComplexity), true

	case "ActiveDirectoryData.adObjectClass":
		if e.complexity.ActiveDirectoryData.AdObjectClass == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdObjectClass(childComplexity), true

	case "ActiveDirectoryData.adOrganizationalUnit":
		if e.complexity.ActiveDirectoryData.AdOrganizationalUnit == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdOrganizationalUnit(childComplexity), true

	case "ActiveDirectoryData.adPasswordLastSet":
		if e.complexity.ActiveDirectoryData.AdPasswordLastSet == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPasswordLastSet(childComplexity), true

	case "ActiveDirectoryData.adPrimaryGroupDn":
		if e.complexity.ActiveDirectoryData.AdPrimaryGroupDn == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPrimaryGroupDn(childComplexity), true

	case "ActiveDirectoryData.adPrimaryGroupId":
		if e.complexity.ActiveDirectoryData.AdPrimaryGroupID == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPrimaryGroupID(childComplexity), true

	case "ActiveDirectoryData.adPwdMustChange":
		if e.complexity.ActiveDirectoryData.AdPwdMustChange == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPwdMustChange(childComplexity), true

	case "ActiveDirectoryData.adSAMAccountName":
		if e.complexity.ActiveDirectoryData.AdSAMAccountName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdSAMAccountName(childComplexity), true

	case "ActiveDirectoryData.adSid":
		if e.complexity.ActiveDirectoryData.AdSid == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdSid(childComplexity), true

	case "ActiveDirectoryData.adUserPrincipalName":
		if e.complexity.ActiveDirectoryData.AdUserPrincipalName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdUserPrincipalName(childComplexity), true

	case "ActiveDirectoryData.adUsnChanged":
		if e.complexity.ActiveDirectoryData.AdUsnChanged == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdUsnChanged(childComplexity), true

	case "ActiveDirectoryData.adUsnCreated":
		if e.complexity.ActiveDirectoryData.AdUsnCreated == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdUsnCreated(childComplexity), true

	case "ActiveDirectoryData.adWhenChanged":
		if e.complexity.ActiveDirectoryData.AdWhenChanged == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdWhenChanged(childComplexity), true

	case "ActiveDirectoryData.adWhenCreated":
		if e.complexity.ActiveDirectoryData.AdWhenCreated == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdWhenCreated(childComplexity), true

	case "Adapter.id":
		if e.complexity.Adapter.ID == nil {
			break
		}

		return e.complexity.Adapter.ID(childComplexity), true

	case "Adapter.name":
		if e.complexity.Adapter.Name == nil {
			break
		}

		return e.complexity.Adapter.Name(childComplexity), true

	case "Adapter.properties":
		if e.complexity.Adapter.Properties == nil {
			break
		}

		return e.complexity.Adapter.Properties(childComplexity), true

	case "AdapterDevice.adapter":
		if e.complexity.AdapterDevice.Adapter == nil {
			break
		}

		args, err := ec.field_AdapterDevice_adapter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Adapter(childComplexity, args["where"].(*AdapterBoolExp)), true

	case "AdapterDevice.adapterData":
		if e.complexity.AdapterDevice.AdapterData == nil {
			break
		}

		args, err := ec.field_AdapterDevice_adapterData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.AdapterData(childComplexity, args["where"].(*AdapterDataBoolExp)), true

	case "AdapterDevice.adapterId":
		if e.complexity.AdapterDevice.AdapterID == nil {
			break
		}

		return e.complexity.AdapterDevice.AdapterID(childComplexity), true

	case "AdapterDevice.adapterName":
		if e.complexity.AdapterDevice.AdapterName == nil {
			break
		}

		return e.complexity.AdapterDevice.AdapterName(childComplexity), true

	case "AdapterDevice.agentName":
		if e.complexity.AdapterDevice.AgentName == nil {
			break
		}

		return e.complexity.AdapterDevice.AgentName(childComplexity), true

	case "AdapterDevice.agentStatus":
		if e.complexity.AdapterDevice.AgentStatus == nil {
			break
		}

		return e.complexity.AdapterDevice.AgentStatus(childComplexity), true

	case "AdapterDevice.agentVersion":
		if e.complexity.AdapterDevice.AgentVersion == nil {
			break
		}

		return e.complexity.AdapterDevice.AgentVersion(childComplexity), true

	case "AdapterDevice.biosSerial":
		if e.complexity.AdapterDevice.BiosSerial == nil {
			break
		}

		return e.complexity.AdapterDevice.BiosSerial(childComplexity), true

	case "AdapterDevice.biosVersion":
		if e.complexity.AdapterDevice.BiosVersion == nil {
			break
		}

		return e.complexity.AdapterDevice.BiosVersion(childComplexity), true

	case "AdapterDevice.data":
		if e.complexity.AdapterDevice.Data == nil {
			break
		}

		return e.complexity.AdapterDevice.Data(childComplexity), true

	case "AdapterDevice.deviceId":
		if e.complexity.AdapterDevice.DeviceID == nil {
			break
		}

		return e.complexity.AdapterDevice.DeviceID(childComplexity), true

	case "AdapterDevice.deviceUsers":
		if e.complexity.AdapterDevice.DeviceUsers == nil {
			break
		}

		args, err := ec.field_AdapterDevice_deviceUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.DeviceUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceUserBoolExp)), true

	case "AdapterDevice.domain":
		if e.complexity.AdapterDevice.Domain == nil {
			break
		}

		return e.complexity.AdapterDevice.Domain(childComplexity), true

	case "AdapterDevice.family":
		if e.complexity.AdapterDevice.Family == nil {
			break
		}

		return e.complexity.AdapterDevice.Family(childComplexity), true

	case "AdapterDevice.fetchCycle":
		if e.complexity.AdapterDevice.FetchCycle == nil {
			break
		}

		return e.complexity.AdapterDevice.FetchCycle(childComplexity), true

	case "AdapterDevice.fetchTime":
		if e.complexity.AdapterDevice.FetchTime == nil {
			break
		}

		return e.complexity.AdapterDevice.FetchTime(childComplexity), true

	case "AdapterDevice.firewallRules":
		if e.complexity.AdapterDevice.FirewallRules == nil {
			break
		}

		args, err := ec.field_AdapterDevice_firewallRules_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.FirewallRules(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*FirewallRuleBoolExp)), true

	case "AdapterDevice.firewallRules_aggregate":
		if e.complexity.AdapterDevice.FirewallRulesAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_firewallRules_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.FirewallRulesAggregate(childComplexity, args["groupBy"].([]FirewallRulesAggregateColumns), args["distinctOn"].([]FirewallRulesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*FirewallRuleBoolExp)), true

	case "AdapterDevice.hostname":
		if e.complexity.AdapterDevice.Hostname == nil {
			break
		}

		return e.complexity.AdapterDevice.Hostname(childComplexity), true

	case "AdapterDevice.id":
		if e.complexity.AdapterDevice.ID == nil {
			break
		}

		return e.complexity.AdapterDevice.ID(childComplexity), true

	case "AdapterDevice.installedSoftware":
		if e.complexity.AdapterDevice.InstalledSoftware == nil {
			break
		}

		args, err := ec.field_AdapterDevice_installedSoftware_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.InstalledSoftware(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*InstalledSoftwareBoolExp)), true

	case "AdapterDevice.installedSoftware_aggregate":
		if e.complexity.AdapterDevice.InstalledSoftwareAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_installedSoftware_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.InstalledSoftwareAggregate(childComplexity, args["groupBy"].([]InstalledSoftwareAggregateColumns), args["distinctOn"].([]InstalledSoftwareAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*InstalledSoftwareBoolExp)), true

	case "AdapterDevice.interfaces":
		if e.complexity.AdapterDevice.Interfaces == nil {
			break
		}

		args, err := ec.field_AdapterDevice_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Interfaces(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "AdapterDevice.interfaces_aggregate":
		if e.complexity.AdapterDevice.InterfacesAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_interfaces_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.InterfacesAggregate(childComplexity, args["groupBy"].([]InterfacesAggregateColumns), args["distinctOn"].([]InterfacesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "AdapterDevice.lastSeen":
		if e.complexity.AdapterDevice.LastSeen == nil {
			break
		}

		return e.complexity.AdapterDevice.LastSeen(childComplexity), true

	case "AdapterDevice.lastUsedUsers":
		if e.complexity.AdapterDevice.LastUsedUsers == nil {
			break
		}

		return e.complexity.AdapterDevice.LastUsedUsers(childComplexity), true

	case "AdapterDevice.localAdmins":
		if e.complexity.AdapterDevice.LocalAdmins == nil {
			break
		}

		args, err := ec.field_AdapterDevice_localAdmins_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.LocalAdmins(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceAdminBoolExp)), true

	case "AdapterDevice.manufacturer":
		if e.complexity.AdapterDevice.Manufacturer == nil {
			break
		}

		return e.complexity.AdapterDevice.Manufacturer(childComplexity), true

	case "AdapterDevice.model":
		if e.complexity.AdapterDevice.Model == nil {
			break
		}

		return e.complexity.AdapterDevice.Model(childComplexity), true

	case "AdapterDevice.name":
		if e.complexity.AdapterDevice.Name == nil {
			break
		}

		return e.complexity.AdapterDevice.Name(childComplexity), true

	case "AdapterDevice.os":
		if e.complexity.AdapterDevice.Os == nil {
			break
		}

		args, err := ec.field_AdapterDevice_os_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Os(childComplexity, args["where"].(*OperatingSystemBoolExp)), true

	case "AdapterDevice.osId":
		if e.complexity.AdapterDevice.OsID == nil {
			break
		}

		return e.complexity.AdapterDevice.OsID(childComplexity), true

	case "AdapterDevice.partOfDomain":
		if e.complexity.AdapterDevice.PartOfDomain == nil {
			break
		}

		return e.complexity.AdapterDevice.PartOfDomain(childComplexity), true

	case "AdapterDevice.prettyId":
		if e.complexity.AdapterDevice.PrettyID == nil {
			break
		}

		return e.complexity.AdapterDevice.PrettyID(childComplexity), true

	case "AdapterDevice.serial":
		if e.complexity.AdapterDevice.Serial == nil {
			break
		}

		return e.complexity.AdapterDevice.Serial(childComplexity), true

	case "AdapterDevice.tags":
		if e.complexity.AdapterDevice.Tags == nil {
			break
		}

		args, err := ec.field_AdapterDevice_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Tags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "AdapterDevice.tags_aggregate":
		if e.complexity.AdapterDevice.TagsAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_tags_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.TagsAggregate(childComplexity, args["groupBy"].([]TagsAggregateColumns), args["distinctOn"].([]TagsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "AdapterDeviceAdmin.name":
		if e.complexity.AdapterDeviceAdmin.Name == nil {
			break
		}

		return e.complexity.AdapterDeviceAdmin.Name(childComplexity), true

	case "AdapterDeviceAdmin.type":
		if e.complexity.AdapterDeviceAdmin.Type == nil {
			break
		}

		return e.complexity.AdapterDeviceAdmin.Type(childComplexity), true

	case "AdapterDeviceUser.deviceId":
		if e.complexity.AdapterDeviceUser.DeviceID == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.DeviceID(childComplexity), true

	case "AdapterDeviceUser.interpreter":
		if e.complexity.AdapterDeviceUser.Interpreter == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.Interpreter(childComplexity), true

	case "AdapterDeviceUser.isAdmin":
		if e.complexity.AdapterDeviceUser.IsAdmin == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.IsAdmin(childComplexity), true

	case "AdapterDeviceUser.isDisabled":
		if e.complexity.AdapterDeviceUser.IsDisabled == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.IsDisabled(childComplexity), true

	case "AdapterDeviceUser.isLocal":
		if e.complexity.AdapterDeviceUser.IsLocal == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.IsLocal(childComplexity), true

	case "AdapterDeviceUser.lastUseDate":
		if e.complexity.AdapterDeviceUser.LastUseDate == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.LastUseDate(childComplexity), true

	case "AdapterDeviceUser.passwordMaxAge":
		if e.complexity.AdapterDeviceUser.PasswordMaxAge == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.PasswordMaxAge(childComplexity), true

	case "AdapterDeviceUser.sid":
		if e.complexity.AdapterDeviceUser.Sid == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.Sid(childComplexity), true

	case "AdapterDeviceUser.userDepartment":
		if e.complexity.AdapterDeviceUser.UserDepartment == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.UserDepartment(childComplexity), true

	case "AdapterDeviceUser.username":
		if e.complexity.AdapterDeviceUser.Username == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.Username(childComplexity), true

	case "AdapterUser.adapter":
		if e.complexity.AdapterUser.Adapter == nil {
			break
		}

		args, err := ec.field_AdapterUser_adapter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUser.Adapter(childComplexity, args["where"].(*AdapterBoolExp)), true

	case "AdapterUser.adapterData":
		if e.complexity.AdapterUser.AdapterData == nil {
			break
		}

		args, err := ec.field_AdapterUser_adapterData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUser.AdapterData(childComplexity, args["where"].(*AdapterDataBoolExp)), true

	case "AdapterUser.adapterId":
		if e.complexity.AdapterUser.AdapterID == nil {
			break
		}

		return e.complexity.AdapterUser.AdapterID(childComplexity), true

	case "AdapterUser.adapterName":
		if e.complexity.AdapterUser.AdapterName == nil {
			break
		}

		return e.complexity.AdapterUser.AdapterName(childComplexity), true

	case "AdapterUser.admin":
		if e.complexity.AdapterUser.Admin == nil {
			break
		}

		return e.complexity.AdapterUser.Admin(childComplexity), true

	case "AdapterUser.data":
		if e.complexity.AdapterUser.Data == nil {
			break
		}

		return e.complexity.AdapterUser.Data(childComplexity), true

	case "AdapterUser.delegated_admin":
		if e.complexity.AdapterUser.DelegatedAdmin == nil {
			break
		}

		return e.complexity.AdapterUser.DelegatedAdmin(childComplexity), true

	case "AdapterUser.disabled":
		if e.complexity.AdapterUser.Disabled == nil {
			break
		}

		return e.complexity.AdapterUser.Disabled(childComplexity), true

	case "AdapterUser.fetchCycle":
		if e.complexity.AdapterUser.FetchCycle == nil {
			break
		}

		return e.complexity.AdapterUser.FetchCycle(childComplexity), true

	case "AdapterUser.fetchTime":
		if e.complexity.AdapterUser.FetchTime == nil {
			break
		}

		return e.complexity.AdapterUser.FetchTime(childComplexity), true

	case "AdapterUser.firstName":
		if e.complexity.AdapterUser.FirstName == nil {
			break
		}

		return e.complexity.AdapterUser.FirstName(childComplexity), true

	case "AdapterUser.id":
		if e.complexity.AdapterUser.ID == nil {
			break
		}

		return e.complexity.AdapterUser.ID(childComplexity), true

	case "AdapterUser.lastName":
		if e.complexity.AdapterUser.LastName == nil {
			break
		}

		return e.complexity.AdapterUser.LastName(childComplexity), true

	case "AdapterUser.lastSeen":
		if e.complexity.AdapterUser.LastSeen == nil {
			break
		}

		return e.complexity.AdapterUser.LastSeen(childComplexity), true

	case "AdapterUser.local":
		if e.complexity.AdapterUser.Local == nil {
			break
		}

		return e.complexity.AdapterUser.Local(childComplexity), true

	case "AdapterUser.locked":
		if e.complexity.AdapterUser.Locked == nil {
			break
		}

		return e.complexity.AdapterUser.Locked(childComplexity), true

	case "AdapterUser.mail":
		if e.complexity.AdapterUser.Mail == nil {
			break
		}

		return e.complexity.AdapterUser.Mail(childComplexity), true

	case "AdapterUser.mfa_enforced":
		if e.complexity.AdapterUser.MfaEnforced == nil {
			break
		}

		return e.complexity.AdapterUser.MfaEnforced(childComplexity), true

	case "AdapterUser.mfa_enrolled":
		if e.complexity.AdapterUser.MfaEnrolled == nil {
			break
		}

		return e.complexity.AdapterUser.MfaEnrolled(childComplexity), true

	case "AdapterUser.suspended":
		if e.complexity.AdapterUser.Suspended == nil {
			break
		}

		return e.complexity.AdapterUser.Suspended(childComplexity), true

	case "AdapterUser.userId":
		if e.complexity.AdapterUser.UserID == nil {
			break
		}

		return e.complexity.AdapterUser.UserID(childComplexity), true

	case "AdapterUser.username":
		if e.complexity.AdapterUser.Username == nil {
			break
		}

		return e.complexity.AdapterUser.Username(childComplexity), true

	case "CPU.bitness":
		if e.complexity.CPU.Bitness == nil {
			break
		}

		return e.complexity.CPU.Bitness(childComplexity), true

	case "CPU.cores":
		if e.complexity.CPU.Cores == nil {
			break
		}

		return e.complexity.CPU.Cores(childComplexity), true

	case "CPU.coresThreads":
		if e.complexity.CPU.CoresThreads == nil {
			break
		}

		return e.complexity.CPU.CoresThreads(childComplexity), true

	case "CPU.family":
		if e.complexity.CPU.Family == nil {
			break
		}

		return e.complexity.CPU.Family(childComplexity), true

	case "CPU.ghz":
		if e.complexity.CPU.Ghz == nil {
			break
		}

		return e.complexity.CPU.Ghz(childComplexity), true

	case "CPU.id":
		if e.complexity.CPU.ID == nil {
			break
		}

		return e.complexity.CPU.ID(childComplexity), true

	case "CPU.manfacturer":
		if e.complexity.CPU.Manfacturer == nil {
			break
		}

		return e.complexity.CPU.Manfacturer(childComplexity), true

	case "CPU.name":
		if e.complexity.CPU.Name == nil {
			break
		}

		return e.complexity.CPU.Name(childComplexity), true

	case "CrowdStrikeData.csAgentVersion":
		if e.complexity.CrowdStrikeData.CsAgentVersion == nil {
			break
		}

		return e.complexity.CrowdStrikeData.CsAgentVersion(childComplexity), true

	case "CrowdStrikeData.externalIp":
		if e.complexity.CrowdStrikeData.ExternalIP == nil {
			break
		}

		return e.complexity.CrowdStrikeData.ExternalIP(childComplexity), true

	case "CrowdStrikeData.groups":
		if e.complexity.CrowdStrikeData.Groups == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_groups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.Groups(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "CrowdStrikeData.groups_aggregate":
		if e.complexity.CrowdStrikeData.GroupsAggregate == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_groups_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.GroupsAggregate(childComplexity, args["groupBy"].([]GroupsAggregateColumns), args["distinctOn"].([]GroupsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "CrowdStrikeData.preventionPolicy":
		if e.complexity.CrowdStrikeData.PreventionPolicy == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_preventionPolicy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.PreventionPolicy(childComplexity, args["where"].(*CsPolicyBoolExp)), true

	case "CrowdStrikeData.sensorUpdatePolicy":
		if e.complexity.CrowdStrikeData.SensorUpdatePolicy == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_sensorUpdatePolicy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.SensorUpdatePolicy(childComplexity, args["where"].(*CsGroupBoolExp)), true

	case "CylanceData.agentVersion":
		if e.complexity.CylanceData.AgentVersion == nil {
			break
		}

		return e.complexity.CylanceData.AgentVersion(childComplexity), true

	case "CylanceData.deviceState":
		if e.complexity.CylanceData.DeviceState == nil {
			break
		}

		return e.complexity.CylanceData.DeviceState(childComplexity), true

	case "CylanceData.isSafe":
		if e.complexity.CylanceData.IsSafe == nil {
			break
		}

		return e.complexity.CylanceData.IsSafe(childComplexity), true

	case "CylanceData.policiesDetails":
		if e.complexity.CylanceData.PoliciesDetails == nil {
			break
		}

		return e.complexity.CylanceData.PoliciesDetails(childComplexity), true

	case "CylanceData.policyId":
		if e.complexity.CylanceData.PolicyID == nil {
			break
		}

		return e.complexity.CylanceData.PolicyID(childComplexity), true

	case "CylanceData.policyName":
		if e.complexity.CylanceData.PolicyName == nil {
			break
		}

		return e.complexity.CylanceData.PolicyName(childComplexity), true

	case "CylanceData.tenantTag":
		if e.complexity.CylanceData.TenantTag == nil {
			break
		}

		return e.complexity.CylanceData.TenantTag(childComplexity), true

	case "CylanceData.zoneNames":
		if e.complexity.CylanceData.ZoneNames == nil {
			break
		}

		return e.complexity.CylanceData.ZoneNames(childComplexity), true

	case "Device.adapterCount":
		if e.complexity.Device.AdapterCount == nil {
			break
		}

		return e.complexity.Device.AdapterCount(childComplexity), true

	case "Device.adapterDevices":
		if e.complexity.Device.AdapterDevices == nil {
			break
		}

		args, err := ec.field_Device_adapterDevices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.AdapterDevices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "Device.adapterDevices_aggregate":
		if e.complexity.Device.AdapterDevicesAggregate == nil {
			break
		}

		args, err := ec.field_Device_adapterDevices_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.AdapterDevicesAggregate(childComplexity, args["groupBy"].([]AdapterDevicesAggregateColumns), args["distinctOn"].([]AdapterDevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "Device.adapterNames":
		if e.complexity.Device.AdapterNames == nil {
			break
		}

		return e.complexity.Device.AdapterNames(childComplexity), true

	case "Device._compatibilityAPI":
		if e.complexity.Device.CompatibilityAPI == nil {
			break
		}

		return e.complexity.Device.CompatibilityAPI(childComplexity), true

	case "Device.fetchCycle":
		if e.complexity.Device.FetchCycle == nil {
			break
		}

		return e.complexity.Device.FetchCycle(childComplexity), true

	case "Device.hostnames":
		if e.complexity.Device.Hostnames == nil {
			break
		}

		return e.complexity.Device.Hostnames(childComplexity), true

	case "Device.id":
		if e.complexity.Device.ID == nil {
			break
		}

		return e.complexity.Device.ID(childComplexity), true

	case "Device.interfaces":
		if e.complexity.Device.Interfaces == nil {
			break
		}

		args, err := ec.field_Device_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.Interfaces(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "Device.interfaces_aggregate":
		if e.complexity.Device.InterfacesAggregate == nil {
			break
		}

		args, err := ec.field_Device_interfaces_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.InterfacesAggregate(childComplexity, args["groupBy"].([]InterfacesAggregateColumns), args["distinctOn"].([]InterfacesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "Device.lastSeen":
		if e.complexity.Device.LastSeen == nil {
			break
		}

		return e.complexity.Device.LastSeen(childComplexity), true

	case "Device.tags":
		if e.complexity.Device.Tags == nil {
			break
		}

		args, err := ec.field_Device_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.Tags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "Device.tags_aggregate":
		if e.complexity.Device.TagsAggregate == nil {
			break
		}

		args, err := ec.field_Device_tags_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.TagsAggregate(childComplexity, args["groupBy"].([]TagsAggregateColumns), args["distinctOn"].([]TagsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "FirewallRule.direction":
		if e.complexity.FirewallRule.Direction == nil {
			break
		}

		return e.complexity.FirewallRule.Direction(childComplexity), true

	case "FirewallRule.dstPort":
		if e.complexity.FirewallRule.DstPort == nil {
			break
		}

		return e.complexity.FirewallRule.DstPort(childComplexity), true

	case "FirewallRule.name":
		if e.complexity.FirewallRule.Name == nil {
			break
		}

		return e.complexity.FirewallRule.Name(childComplexity), true

	case "FirewallRule.protocol":
		if e.complexity.FirewallRule.Protocol == nil {
			break
		}

		return e.complexity.FirewallRule.Protocol(childComplexity), true

	case "FirewallRule.source":
		if e.complexity.FirewallRule.Source == nil {
			break
		}

		return e.complexity.FirewallRule.Source(childComplexity), true

	case "FirewallRule.srcPort":
		if e.complexity.FirewallRule.SrcPort == nil {
			break
		}

		return e.complexity.FirewallRule.SrcPort(childComplexity), true

	case "FirewallRule.target":
		if e.complexity.FirewallRule.Target == nil {
			break
		}

		return e.complexity.FirewallRule.Target(childComplexity), true

	case "FirewallRule.type":
		if e.complexity.FirewallRule.Type == nil {
			break
		}

		return e.complexity.FirewallRule.Type(childComplexity), true

	case "GCETagsAggregate.avg":
		if e.complexity.GCETagsAggregate.Avg == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Avg(childComplexity), true

	case "GCETagsAggregate.count":
		if e.complexity.GCETagsAggregate.Count == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Count(childComplexity), true

	case "GCETagsAggregate.distinct":
		if e.complexity.GCETagsAggregate.Distinct == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Distinct(childComplexity), true

	case "GCETagsAggregate.GCETags":
		if e.complexity.GCETagsAggregate.GCETags == nil {
			break
		}

		args, err := ec.field_GCETagsAggregate_GCETags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GCETagsAggregate.GCETags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*GceTagsBoolExp)), true

	case "GCETagsAggregate.group":
		if e.complexity.GCETagsAggregate.Group == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Group(childComplexity), true

	case "GCETagsAggregate.max":
		if e.complexity.GCETagsAggregate.Max == nil {
			break
		}

		args, err := ec.field_GCETagsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GCETagsAggregate.Max(childComplexity, args["column"].([]GCETagsAggregateMaxColumns)), true

	case "GCETagsAggregate.min":
		if e.complexity.GCETagsAggregate.Min == nil {
			break
		}

		args, err := ec.field_GCETagsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GCETagsAggregate.Min(childComplexity, args["column"].([]GCETagsAggregateMinColumns)), true

	case "GCETagsAggregate.sum":
		if e.complexity.GCETagsAggregate.Sum == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Sum(childComplexity), true

	case "GceTags.gceKey":
		if e.complexity.GceTags.GceKey == nil {
			break
		}

		return e.complexity.GceTags.GceKey(childComplexity), true

	case "GceTags.gceValue":
		if e.complexity.GceTags.GceValue == nil {
			break
		}

		return e.complexity.GceTags.GceValue(childComplexity), true

	case "GoogleCloudData.GCETags":
		if e.complexity.GoogleCloudData.GCETags == nil {
			break
		}

		args, err := ec.field_GoogleCloudData_GCETags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GoogleCloudData.GCETags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*GceTagsBoolExp)), true

	case "GoogleCloudData.GCETags_aggregate":
		if e.complexity.GoogleCloudData.GCETagsAggregate == nil {
			break
		}

		args, err := ec.field_GoogleCloudData_GCETags_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GoogleCloudData.GCETagsAggregate(childComplexity, args["groupBy"].([]GCETagsAggregateColumns), args["distinctOn"].([]GCETagsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*GceTagsBoolExp)), true

	case "GoogleCloudData.Id":
		if e.complexity.GoogleCloudData.ID == nil {
			break
		}

		return e.complexity.GoogleCloudData.ID(childComplexity), true

	case "GoogleCloudData.Image":
		if e.complexity.GoogleCloudData.Image == nil {
			break
		}

		return e.complexity.GoogleCloudData.Image(childComplexity), true

	case "GoogleCloudData.Size":
		if e.complexity.GoogleCloudData.Size == nil {
			break
		}

		return e.complexity.GoogleCloudData.Size(childComplexity), true

	case "InstalledSoftware.architecture":
		if e.complexity.InstalledSoftware.Architecture == nil {
			break
		}

		return e.complexity.InstalledSoftware.Architecture(childComplexity), true

	case "InstalledSoftware.cveCount":
		if e.complexity.InstalledSoftware.CveCount == nil {
			break
		}

		return e.complexity.InstalledSoftware.CveCount(childComplexity), true

	case "InstalledSoftware.description":
		if e.complexity.InstalledSoftware.Description == nil {
			break
		}

		return e.complexity.InstalledSoftware.Description(childComplexity), true

	case "InstalledSoftware.name":
		if e.complexity.InstalledSoftware.Name == nil {
			break
		}

		return e.complexity.InstalledSoftware.Name(childComplexity), true

	case "InstalledSoftware.path":
		if e.complexity.InstalledSoftware.Path == nil {
			break
		}

		return e.complexity.InstalledSoftware.Path(childComplexity), true

	case "InstalledSoftware.publisher":
		if e.complexity.InstalledSoftware.Publisher == nil {
			break
		}

		return e.complexity.InstalledSoftware.Publisher(childComplexity), true

	case "InstalledSoftware.swLicense":
		if e.complexity.InstalledSoftware.SwLicense == nil {
			break
		}

		return e.complexity.InstalledSoftware.SwLicense(childComplexity), true

	case "InstalledSoftware.vendor":
		if e.complexity.InstalledSoftware.Vendor == nil {
			break
		}

		return e.complexity.InstalledSoftware.Vendor(childComplexity), true

	case "InstalledSoftware.version":
		if e.complexity.InstalledSoftware.Version == nil {
			break
		}

		return e.complexity.InstalledSoftware.Version(childComplexity), true

	case "NetworkInterface.deviceId":
		if e.complexity.NetworkInterface.DeviceID == nil {
			break
		}

		return e.complexity.NetworkInterface.DeviceID(childComplexity), true

	case "NetworkInterface.ipAddrs":
		if e.complexity.NetworkInterface.IPAddrs == nil {
			break
		}

		return e.complexity.NetworkInterface.IPAddrs(childComplexity), true

	case "NetworkInterface.macAddr":
		if e.complexity.NetworkInterface.MacAddr == nil {
			break
		}

		return e.complexity.NetworkInterface.MacAddr(childComplexity), true

	case "OperatingSystem.architecture":
		if e.complexity.OperatingSystem.Architecture == nil {
			break
		}

		return e.complexity.OperatingSystem.Architecture(childComplexity), true

	case "OperatingSystem.build":
		if e.complexity.OperatingSystem.Build == nil {
			break
		}

		return e.complexity.OperatingSystem.Build(childComplexity), true

	case "OperatingSystem.codeName":
		if e.complexity.OperatingSystem.CodeName == nil {
			break
		}

		return e.complexity.OperatingSystem.CodeName(childComplexity), true

	case "OperatingSystem.distribution":
		if e.complexity.OperatingSystem.Distribution == nil {
			break
		}

		return e.complexity.OperatingSystem.Distribution(childComplexity), true

	case "OperatingSystem.id":
		if e.complexity.OperatingSystem.ID == nil {
			break
		}

		return e.complexity.OperatingSystem.ID(childComplexity), true

	case "OperatingSystem.installDate":
		if e.complexity.OperatingSystem.InstallDate == nil {
			break
		}

		return e.complexity.OperatingSystem.InstallDate(childComplexity), true

	case "OperatingSystem.kernelVersion":
		if e.complexity.OperatingSystem.KernelVersion == nil {
			break
		}

		return e.complexity.OperatingSystem.KernelVersion(childComplexity), true

	case "OperatingSystem.major":
		if e.complexity.OperatingSystem.Major == nil {
			break
		}

		return e.complexity.OperatingSystem.Major(childComplexity), true

	case "OperatingSystem.minor":
		if e.complexity.OperatingSystem.Minor == nil {
			break
		}

		return e.complexity.OperatingSystem.Minor(childComplexity), true

	case "OperatingSystem.RawName":
		if e.complexity.OperatingSystem.RawName == nil {
			break
		}

		return e.complexity.OperatingSystem.RawName(childComplexity), true

	case "OperatingSystem.servicePack":
		if e.complexity.OperatingSystem.ServicePack == nil {
			break
		}

		return e.complexity.OperatingSystem.ServicePack(childComplexity), true

	case "OperatingSystem.type":
		if e.complexity.OperatingSystem.Type == nil {
			break
		}

		return e.complexity.OperatingSystem.Type(childComplexity), true

	case "Query.adapterDevices":
		if e.complexity.Query.AdapterDevices == nil {
			break
		}

		args, err := ec.field_Query_adapterDevices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterDevices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp), args["orderBy"].([]AdapterDeviceOrderBy)), true

	case "Query.adapterDevices_aggregate":
		if e.complexity.Query.AdapterDevicesAggregate == nil {
			break
		}

		args, err := ec.field_Query_adapterDevices_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterDevicesAggregate(childComplexity, args["groupBy"].([]AdapterDevicesAggregateColumns), args["distinctOn"].([]AdapterDevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "Query.adapterUsers":
		if e.complexity.Query.AdapterUsers == nil {
			break
		}

		args, err := ec.field_Query_adapterUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp), args["orderBy"].([]AdapterUserOrderBy)), true

	case "Query.adapterUsers_aggregate":
		if e.complexity.Query.AdapterUsersAggregate == nil {
			break
		}

		args, err := ec.field_Query_adapterUsers_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterUsersAggregate(childComplexity, args["groupBy"].([]AdapterUsersAggregateColumns), args["distinctOn"].([]AdapterUsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "Query.devices":
		if e.complexity.Query.Devices == nil {
			break
		}

		args, err := ec.field_Query_devices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Devices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp), args["orderBy"].([]DeviceOrderBy)), true

	case "Query.devices_aggregate":
		if e.complexity.Query.DevicesAggregate == nil {
			break
		}

		args, err := ec.field_Query_devices_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DevicesAggregate(childComplexity, args["groupBy"].([]DevicesAggregateColumns), args["distinctOn"].([]DevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp), args["orderBy"].([]UserOrderBy)), true

	case "Query.users_aggregate":
		if e.complexity.Query.UsersAggregate == nil {
			break
		}

		args, err := ec.field_Query_users_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UsersAggregate(childComplexity, args["groupBy"].([]UsersAggregateColumns), args["distinctOn"].([]UsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp)), true

	case "Storage.description":
		if e.complexity.Storage.Description == nil {
			break
		}

		return e.complexity.Storage.Description(childComplexity), true

	case "Storage.deviceId":
		if e.complexity.Storage.DeviceID == nil {
			break
		}

		return e.complexity.Storage.DeviceID(childComplexity), true

	case "Storage.freeSize":
		if e.complexity.Storage.FreeSize == nil {
			break
		}

		return e.complexity.Storage.FreeSize(childComplexity), true

	case "Storage.isEncrypted":
		if e.complexity.Storage.IsEncrypted == nil {
			break
		}

		return e.complexity.Storage.IsEncrypted(childComplexity), true

	case "Storage.name":
		if e.complexity.Storage.Name == nil {
			break
		}

		return e.complexity.Storage.Name(childComplexity), true

	case "Storage.path":
		if e.complexity.Storage.Path == nil {
			break
		}

		return e.complexity.Storage.Path(childComplexity), true

	case "Storage.totalSize":
		if e.complexity.Storage.TotalSize == nil {
			break
		}

		return e.complexity.Storage.TotalSize(childComplexity), true

	case "Tag.creator":
		if e.complexity.Tag.Creator == nil {
			break
		}

		return e.complexity.Tag.Creator(childComplexity), true

	case "Tag.level":
		if e.complexity.Tag.Level == nil {
			break
		}

		return e.complexity.Tag.Level(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "User.adapterCount":
		if e.complexity.User.AdapterCount == nil {
			break
		}

		return e.complexity.User.AdapterCount(childComplexity), true

	case "User.adapterNames":
		if e.complexity.User.AdapterNames == nil {
			break
		}

		return e.complexity.User.AdapterNames(childComplexity), true

	case "User.adapterUsers":
		if e.complexity.User.AdapterUsers == nil {
			break
		}

		args, err := ec.field_User_adapterUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.AdapterUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "User.adapterUsers_aggregate":
		if e.complexity.User.AdapterUsersAggregate == nil {
			break
		}

		args, err := ec.field_User_adapterUsers_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.AdapterUsersAggregate(childComplexity, args["groupBy"].([]AdapterUsersAggregateColumns), args["distinctOn"].([]AdapterUsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "User._compatibilityAPI":
		if e.complexity.User.CompatibilityAPI == nil {
			break
		}

		return e.complexity.User.CompatibilityAPI(childComplexity), true

	case "User.fetchCycle":
		if e.complexity.User.FetchCycle == nil {
			break
		}

		return e.complexity.User.FetchCycle(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lastSeen":
		if e.complexity.User.LastSeen == nil {
			break
		}

		return e.complexity.User.LastSeen(childComplexity), true

	case "User.usernames":
		if e.complexity.User.Usernames == nil {
			break
		}

		return e.complexity.User.Usernames(childComplexity), true

	case "adapterDevicesAggregate.adapterDevices":
		if e.complexity.AdapterDevicesAggregate.AdapterDevices == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_adapterDevices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.AdapterDevices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "adapterDevicesAggregate.avg":
		if e.complexity.AdapterDevicesAggregate.Avg == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Avg(childComplexity, args["column"].([]AdapterDevicesAggregateAvgColumns)), true

	case "adapterDevicesAggregate.count":
		if e.complexity.AdapterDevicesAggregate.Count == nil {
			break
		}

		return e.complexity.AdapterDevicesAggregate.Count(childComplexity), true

	case "adapterDevicesAggregate.distinct":
		if e.complexity.AdapterDevicesAggregate.Distinct == nil {
			break
		}

		return e.complexity.AdapterDevicesAggregate.Distinct(childComplexity), true

	case "adapterDevicesAggregate.group":
		if e.complexity.AdapterDevicesAggregate.Group == nil {
			break
		}

		return e.complexity.AdapterDevicesAggregate.Group(childComplexity), true

	case "adapterDevicesAggregate.max":
		if e.complexity.AdapterDevicesAggregate.Max == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Max(childComplexity, args["column"].([]AdapterDevicesAggregateMaxColumns)), true

	case "adapterDevicesAggregate.min":
		if e.complexity.AdapterDevicesAggregate.Min == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Min(childComplexity, args["column"].([]AdapterDevicesAggregateMinColumns)), true

	case "adapterDevicesAggregate.sum":
		if e.complexity.AdapterDevicesAggregate.Sum == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Sum(childComplexity, args["column"].([]AdapterDevicesAggregateSumColumns)), true

	case "adapterUsersAggregate.adapterUsers":
		if e.complexity.AdapterUsersAggregate.AdapterUsers == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_adapterUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.AdapterUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "adapterUsersAggregate.avg":
		if e.complexity.AdapterUsersAggregate.Avg == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Avg(childComplexity, args["column"].([]AdapterUsersAggregateAvgColumns)), true

	case "adapterUsersAggregate.count":
		if e.complexity.AdapterUsersAggregate.Count == nil {
			break
		}

		return e.complexity.AdapterUsersAggregate.Count(childComplexity), true

	case "adapterUsersAggregate.distinct":
		if e.complexity.AdapterUsersAggregate.Distinct == nil {
			break
		}

		return e.complexity.AdapterUsersAggregate.Distinct(childComplexity), true

	case "adapterUsersAggregate.group":
		if e.complexity.AdapterUsersAggregate.Group == nil {
			break
		}

		return e.complexity.AdapterUsersAggregate.Group(childComplexity), true

	case "adapterUsersAggregate.max":
		if e.complexity.AdapterUsersAggregate.Max == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Max(childComplexity, args["column"].([]AdapterUsersAggregateMaxColumns)), true

	case "adapterUsersAggregate.min":
		if e.complexity.AdapterUsersAggregate.Min == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Min(childComplexity, args["column"].([]AdapterUsersAggregateMinColumns)), true

	case "adapterUsersAggregate.sum":
		if e.complexity.AdapterUsersAggregate.Sum == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Sum(childComplexity, args["column"].([]AdapterUsersAggregateSumColumns)), true

	case "csGroup.createdBy":
		if e.complexity.CsGroup.CreatedBy == nil {
			break
		}

		return e.complexity.CsGroup.CreatedBy(childComplexity), true

	case "csGroup.createdTimestamp":
		if e.complexity.CsGroup.CreatedTimestamp == nil {
			break
		}

		return e.complexity.CsGroup.CreatedTimestamp(childComplexity), true

	case "csGroup.description":
		if e.complexity.CsGroup.Description == nil {
			break
		}

		return e.complexity.CsGroup.Description(childComplexity), true

	case "csGroup.groupType":
		if e.complexity.CsGroup.GroupType == nil {
			break
		}

		return e.complexity.CsGroup.GroupType(childComplexity), true

	case "csGroup.id":
		if e.complexity.CsGroup.ID == nil {
			break
		}

		return e.complexity.CsGroup.ID(childComplexity), true

	case "csGroup.modifiedBy":
		if e.complexity.CsGroup.ModifiedBy == nil {
			break
		}

		return e.complexity.CsGroup.ModifiedBy(childComplexity), true

	case "csGroup.modifiedTime":
		if e.complexity.CsGroup.ModifiedTime == nil {
			break
		}

		return e.complexity.CsGroup.ModifiedTime(childComplexity), true

	case "csGroup.name":
		if e.complexity.CsGroup.Name == nil {
			break
		}

		return e.complexity.CsGroup.Name(childComplexity), true

	case "csPolicy.createdBy":
		if e.complexity.CsPolicy.CreatedBy == nil {
			break
		}

		return e.complexity.CsPolicy.CreatedBy(childComplexity), true

	case "csPolicy.createdTime":
		if e.complexity.CsPolicy.CreatedTime == nil {
			break
		}

		return e.complexity.CsPolicy.CreatedTime(childComplexity), true

	case "csPolicy.description":
		if e.complexity.CsPolicy.Description == nil {
			break
		}

		return e.complexity.CsPolicy.Description(childComplexity), true

	case "csPolicy.enabled":
		if e.complexity.CsPolicy.Enabled == nil {
			break
		}

		return e.complexity.CsPolicy.Enabled(childComplexity), true

	case "csPolicy.groups":
		if e.complexity.CsPolicy.Groups == nil {
			break
		}

		args, err := ec.field_csPolicy_groups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.Groups(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "csPolicy.groups_aggregate":
		if e.complexity.CsPolicy.GroupsAggregate == nil {
			break
		}

		args, err := ec.field_csPolicy_groups_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.GroupsAggregate(childComplexity, args["groupBy"].([]GroupsAggregateColumns), args["distinctOn"].([]GroupsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "csPolicy.name":
		if e.complexity.CsPolicy.Name == nil {
			break
		}

		return e.complexity.CsPolicy.Name(childComplexity), true

	case "csPolicy.platformName":
		if e.complexity.CsPolicy.PlatformName == nil {
			break
		}

		return e.complexity.CsPolicy.PlatformName(childComplexity), true

	case "csPolicy.preventionSettings":
		if e.complexity.CsPolicy.PreventionSettings == nil {
			break
		}

		args, err := ec.field_csPolicy_preventionSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.PreventionSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPreventionSettingsBoolExp)), true

	case "csPolicy.preventionSettings_aggregate":
		if e.complexity.CsPolicy.PreventionSettingsAggregate == nil {
			break
		}

		args, err := ec.field_csPolicy_preventionSettings_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.PreventionSettingsAggregate(childComplexity, args["groupBy"].([]PreventionSettingsAggregateColumns), args["distinctOn"].([]PreventionSettingsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPreventionSettingsBoolExp)), true

	case "csPolicy.sensorUpdateSettings":
		if e.complexity.CsPolicy.SensorUpdateSettings == nil {
			break
		}

		args, err := ec.field_csPolicy_sensorUpdateSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.SensorUpdateSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsSensorUpdateSettingsBoolExp)), true

	case "csPolicy.sensorUpdateSettings_aggregate":
		if e.complexity.CsPolicy.SensorUpdateSettingsAggregate == nil {
			break
		}

		args, err := ec.field_csPolicy_sensorUpdateSettings_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.SensorUpdateSettingsAggregate(childComplexity, args["groupBy"].([]SensorUpdateSettingsAggregateColumns), args["distinctOn"].([]SensorUpdateSettingsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsSensorUpdateSettingsBoolExp)), true

	case "csPolicySettings.enabled":
		if e.complexity.CsPolicySettings.Enabled == nil {
			break
		}

		return e.complexity.CsPolicySettings.Enabled(childComplexity), true

	case "csPreventionSettings.name":
		if e.complexity.CsPreventionSettings.Name == nil {
			break
		}

		return e.complexity.CsPreventionSettings.Name(childComplexity), true

	case "csPreventionSettings.settings":
		if e.complexity.CsPreventionSettings.Settings == nil {
			break
		}

		args, err := ec.field_csPreventionSettings_settings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPreventionSettings.Settings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPolicySettingsBoolExp)), true

	case "csSensorUpdateSettings.build":
		if e.complexity.CsSensorUpdateSettings.Build == nil {
			break
		}

		return e.complexity.CsSensorUpdateSettings.Build(childComplexity), true

	case "devicesAggregate.avg":
		if e.complexity.DevicesAggregate.Avg == nil {
			break
		}

		args, err := ec.field_devicesAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Avg(childComplexity, args["column"].([]DevicesAggregateAvgColumns)), true

	case "devicesAggregate.count":
		if e.complexity.DevicesAggregate.Count == nil {
			break
		}

		return e.complexity.DevicesAggregate.Count(childComplexity), true

	case "devicesAggregate.devices":
		if e.complexity.DevicesAggregate.Devices == nil {
			break
		}

		args, err := ec.field_devicesAggregate_devices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Devices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp)), true

	case "devicesAggregate.distinct":
		if e.complexity.DevicesAggregate.Distinct == nil {
			break
		}

		return e.complexity.DevicesAggregate.Distinct(childComplexity), true

	case "devicesAggregate.group":
		if e.complexity.DevicesAggregate.Group == nil {
			break
		}

		return e.complexity.DevicesAggregate.Group(childComplexity), true

	case "devicesAggregate.max":
		if e.complexity.DevicesAggregate.Max == nil {
			break
		}

		args, err := ec.field_devicesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Max(childComplexity, args["column"].([]DevicesAggregateMaxColumns)), true

	case "devicesAggregate.min":
		if e.complexity.DevicesAggregate.Min == nil {
			break
		}

		args, err := ec.field_devicesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Min(childComplexity, args["column"].([]DevicesAggregateMinColumns)), true

	case "devicesAggregate.sum":
		if e.complexity.DevicesAggregate.Sum == nil {
			break
		}

		args, err := ec.field_devicesAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Sum(childComplexity, args["column"].([]DevicesAggregateSumColumns)), true

	case "firewallRulesAggregate.avg":
		if e.complexity.FirewallRulesAggregate.Avg == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Avg(childComplexity, args["column"].([]FirewallRulesAggregateAvgColumns)), true

	case "firewallRulesAggregate.count":
		if e.complexity.FirewallRulesAggregate.Count == nil {
			break
		}

		return e.complexity.FirewallRulesAggregate.Count(childComplexity), true

	case "firewallRulesAggregate.distinct":
		if e.complexity.FirewallRulesAggregate.Distinct == nil {
			break
		}

		return e.complexity.FirewallRulesAggregate.Distinct(childComplexity), true

	case "firewallRulesAggregate.firewallRules":
		if e.complexity.FirewallRulesAggregate.FirewallRules == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_firewallRules_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.FirewallRules(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*FirewallRuleBoolExp)), true

	case "firewallRulesAggregate.group":
		if e.complexity.FirewallRulesAggregate.Group == nil {
			break
		}

		return e.complexity.FirewallRulesAggregate.Group(childComplexity), true

	case "firewallRulesAggregate.max":
		if e.complexity.FirewallRulesAggregate.Max == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Max(childComplexity, args["column"].([]FirewallRulesAggregateMaxColumns)), true

	case "firewallRulesAggregate.min":
		if e.complexity.FirewallRulesAggregate.Min == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Min(childComplexity, args["column"].([]FirewallRulesAggregateMinColumns)), true

	case "firewallRulesAggregate.sum":
		if e.complexity.FirewallRulesAggregate.Sum == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Sum(childComplexity, args["column"].([]FirewallRulesAggregateSumColumns)), true

	case "groupsAggregate.avg":
		if e.complexity.GroupsAggregate.Avg == nil {
			break
		}

		args, err := ec.field_groupsAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Avg(childComplexity, args["column"].([]GroupsAggregateAvgColumns)), true

	case "groupsAggregate.count":
		if e.complexity.GroupsAggregate.Count == nil {
			break
		}

		return e.complexity.GroupsAggregate.Count(childComplexity), true

	case "groupsAggregate.distinct":
		if e.complexity.GroupsAggregate.Distinct == nil {
			break
		}

		return e.complexity.GroupsAggregate.Distinct(childComplexity), true

	case "groupsAggregate.group":
		if e.complexity.GroupsAggregate.Group == nil {
			break
		}

		return e.complexity.GroupsAggregate.Group(childComplexity), true

	case "groupsAggregate.groups":
		if e.complexity.GroupsAggregate.Groups == nil {
			break
		}

		args, err := ec.field_groupsAggregate_groups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Groups(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "groupsAggregate.max":
		if e.complexity.GroupsAggregate.Max == nil {
			break
		}

		args, err := ec.field_groupsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Max(childComplexity, args["column"].([]GroupsAggregateMaxColumns)), true

	case "groupsAggregate.min":
		if e.complexity.GroupsAggregate.Min == nil {
			break
		}

		args, err := ec.field_groupsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Min(childComplexity, args["column"].([]GroupsAggregateMinColumns)), true

	case "groupsAggregate.sum":
		if e.complexity.GroupsAggregate.Sum == nil {
			break
		}

		args, err := ec.field_groupsAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Sum(childComplexity, args["column"].([]GroupsAggregateSumColumns)), true

	case "installedSoftwareAggregate.avg":
		if e.complexity.InstalledSoftwareAggregate.Avg == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Avg(childComplexity, args["column"].([]InstalledSoftwareAggregateAvgColumns)), true

	case "installedSoftwareAggregate.count":
		if e.complexity.InstalledSoftwareAggregate.Count == nil {
			break
		}

		return e.complexity.InstalledSoftwareAggregate.Count(childComplexity), true

	case "installedSoftwareAggregate.distinct":
		if e.complexity.InstalledSoftwareAggregate.Distinct == nil {
			break
		}

		return e.complexity.InstalledSoftwareAggregate.Distinct(childComplexity), true

	case "installedSoftwareAggregate.group":
		if e.complexity.InstalledSoftwareAggregate.Group == nil {
			break
		}

		return e.complexity.InstalledSoftwareAggregate.Group(childComplexity), true

	case "installedSoftwareAggregate.installedSoftware":
		if e.complexity.InstalledSoftwareAggregate.InstalledSoftware == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_installedSoftware_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.InstalledSoftware(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*InstalledSoftwareBoolExp)), true

	case "installedSoftwareAggregate.max":
		if e.complexity.InstalledSoftwareAggregate.Max == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Max(childComplexity, args["column"].([]InstalledSoftwareAggregateMaxColumns)), true

	case "installedSoftwareAggregate.min":
		if e.complexity.InstalledSoftwareAggregate.Min == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Min(childComplexity, args["column"].([]InstalledSoftwareAggregateMinColumns)), true

	case "installedSoftwareAggregate.sum":
		if e.complexity.InstalledSoftwareAggregate.Sum == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Sum(childComplexity, args["column"].([]InstalledSoftwareAggregateSumColumns)), true

	case "interfacesAggregate.avg":
		if e.complexity.InterfacesAggregate.Avg == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Avg(childComplexity), true

	case "interfacesAggregate.count":
		if e.complexity.InterfacesAggregate.Count == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Count(childComplexity), true

	case "interfacesAggregate.distinct":
		if e.complexity.InterfacesAggregate.Distinct == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Distinct(childComplexity), true

	case "interfacesAggregate.group":
		if e.complexity.InterfacesAggregate.Group == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Group(childComplexity), true

	case "interfacesAggregate.interfaces":
		if e.complexity.InterfacesAggregate.Interfaces == nil {
			break
		}

		args, err := ec.field_interfacesAggregate_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfacesAggregate.Interfaces(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "interfacesAggregate.max":
		if e.complexity.InterfacesAggregate.Max == nil {
			break
		}

		args, err := ec.field_interfacesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfacesAggregate.Max(childComplexity, args["column"].([]InterfacesAggregateMaxColumns)), true

	case "interfacesAggregate.min":
		if e.complexity.InterfacesAggregate.Min == nil {
			break
		}

		args, err := ec.field_interfacesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfacesAggregate.Min(childComplexity, args["column"].([]InterfacesAggregateMinColumns)), true

	case "interfacesAggregate.sum":
		if e.complexity.InterfacesAggregate.Sum == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Sum(childComplexity), true

	case "preventionSettingsAggregate.avg":
		if e.complexity.PreventionSettingsAggregate.Avg == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Avg(childComplexity), true

	case "preventionSettingsAggregate.count":
		if e.complexity.PreventionSettingsAggregate.Count == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Count(childComplexity), true

	case "preventionSettingsAggregate.distinct":
		if e.complexity.PreventionSettingsAggregate.Distinct == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Distinct(childComplexity), true

	case "preventionSettingsAggregate.group":
		if e.complexity.PreventionSettingsAggregate.Group == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Group(childComplexity), true

	case "preventionSettingsAggregate.max":
		if e.complexity.PreventionSettingsAggregate.Max == nil {
			break
		}

		args, err := ec.field_preventionSettingsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PreventionSettingsAggregate.Max(childComplexity, args["column"].([]PreventionSettingsAggregateMaxColumns)), true

	case "preventionSettingsAggregate.min":
		if e.complexity.PreventionSettingsAggregate.Min == nil {
			break
		}

		args, err := ec.field_preventionSettingsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PreventionSettingsAggregate.Min(childComplexity, args["column"].([]PreventionSettingsAggregateMinColumns)), true

	case "preventionSettingsAggregate.preventionSettings":
		if e.complexity.PreventionSettingsAggregate.PreventionSettings == nil {
			break
		}

		args, err := ec.field_preventionSettingsAggregate_preventionSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PreventionSettingsAggregate.PreventionSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPreventionSettingsBoolExp)), true

	case "preventionSettingsAggregate.sum":
		if e.complexity.PreventionSettingsAggregate.Sum == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Sum(childComplexity), true

	case "sensorUpdateSettingsAggregate.avg":
		if e.complexity.SensorUpdateSettingsAggregate.Avg == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Avg(childComplexity), true

	case "sensorUpdateSettingsAggregate.count":
		if e.complexity.SensorUpdateSettingsAggregate.Count == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Count(childComplexity), true

	case "sensorUpdateSettingsAggregate.distinct":
		if e.complexity.SensorUpdateSettingsAggregate.Distinct == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Distinct(childComplexity), true

	case "sensorUpdateSettingsAggregate.group":
		if e.complexity.SensorUpdateSettingsAggregate.Group == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Group(childComplexity), true

	case "sensorUpdateSettingsAggregate.max":
		if e.complexity.SensorUpdateSettingsAggregate.Max == nil {
			break
		}

		args, err := ec.field_sensorUpdateSettingsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SensorUpdateSettingsAggregate.Max(childComplexity, args["column"].([]SensorUpdateSettingsAggregateMaxColumns)), true

	case "sensorUpdateSettingsAggregate.min":
		if e.complexity.SensorUpdateSettingsAggregate.Min == nil {
			break
		}

		args, err := ec.field_sensorUpdateSettingsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SensorUpdateSettingsAggregate.Min(childComplexity, args["column"].([]SensorUpdateSettingsAggregateMinColumns)), true

	case "sensorUpdateSettingsAggregate.sensorUpdateSettings":
		if e.complexity.SensorUpdateSettingsAggregate.SensorUpdateSettings == nil {
			break
		}

		args, err := ec.field_sensorUpdateSettingsAggregate_sensorUpdateSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SensorUpdateSettingsAggregate.SensorUpdateSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsSensorUpdateSettingsBoolExp)), true

	case "sensorUpdateSettingsAggregate.sum":
		if e.complexity.SensorUpdateSettingsAggregate.Sum == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Sum(childComplexity), true

	case "tagsAggregate.avg":
		if e.complexity.TagsAggregate.Avg == nil {
			break
		}

		return e.complexity.TagsAggregate.Avg(childComplexity), true

	case "tagsAggregate.count":
		if e.complexity.TagsAggregate.Count == nil {
			break
		}

		return e.complexity.TagsAggregate.Count(childComplexity), true

	case "tagsAggregate.distinct":
		if e.complexity.TagsAggregate.Distinct == nil {
			break
		}

		return e.complexity.TagsAggregate.Distinct(childComplexity), true

	case "tagsAggregate.group":
		if e.complexity.TagsAggregate.Group == nil {
			break
		}

		return e.complexity.TagsAggregate.Group(childComplexity), true

	case "tagsAggregate.max":
		if e.complexity.TagsAggregate.Max == nil {
			break
		}

		args, err := ec.field_tagsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagsAggregate.Max(childComplexity, args["column"].([]TagsAggregateMaxColumns)), true

	case "tagsAggregate.min":
		if e.complexity.TagsAggregate.Min == nil {
			break
		}

		args, err := ec.field_tagsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagsAggregate.Min(childComplexity, args["column"].([]TagsAggregateMinColumns)), true

	case "tagsAggregate.sum":
		if e.complexity.TagsAggregate.Sum == nil {
			break
		}

		return e.complexity.TagsAggregate.Sum(childComplexity), true

	case "tagsAggregate.tags":
		if e.complexity.TagsAggregate.Tags == nil {
			break
		}

		args, err := ec.field_tagsAggregate_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagsAggregate.Tags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "usersAggregate.avg":
		if e.complexity.UsersAggregate.Avg == nil {
			break
		}

		args, err := ec.field_usersAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Avg(childComplexity, args["column"].([]UsersAggregateAvgColumns)), true

	case "usersAggregate.count":
		if e.complexity.UsersAggregate.Count == nil {
			break
		}

		return e.complexity.UsersAggregate.Count(childComplexity), true

	case "usersAggregate.distinct":
		if e.complexity.UsersAggregate.Distinct == nil {
			break
		}

		return e.complexity.UsersAggregate.Distinct(childComplexity), true

	case "usersAggregate.group":
		if e.complexity.UsersAggregate.Group == nil {
			break
		}

		return e.complexity.UsersAggregate.Group(childComplexity), true

	case "usersAggregate.max":
		if e.complexity.UsersAggregate.Max == nil {
			break
		}

		args, err := ec.field_usersAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Max(childComplexity, args["column"].([]UsersAggregateMaxColumns)), true

	case "usersAggregate.min":
		if e.complexity.UsersAggregate.Min == nil {
			break
		}

		args, err := ec.field_usersAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Min(childComplexity, args["column"].([]UsersAggregateMinColumns)), true

	case "usersAggregate.sum":
		if e.complexity.UsersAggregate.Sum == nil {
			break
		}

		args, err := ec.field_usersAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Sum(childComplexity, args["column"].([]UsersAggregateSumColumns)), true

	case "usersAggregate.users":
		if e.complexity.UsersAggregate.Users == nil {
			break
		}

		args, err := ec.field_usersAggregate_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Users(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	&ast.Source{Name: "../../api/generated/augmented_schema.graphql", Input: `# Code generated by go generate; DO NOT EDIT THIS FILE. 
# This file was generated at 2020-03-11T10:47:43+02:00
directive @generateInputs(where: String, orderBy: String) on OBJECT | UNION
directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
directive @jsonpath(name: String, depends: [String]) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
directive @relation(name: String!, fkName: [String!]!, relationFkName: [String!]!, relType: RelationType!, manyToManyTableName: String, joinOn: [String!]) on FIELD_DEFINITION
directive @viewFunction(name: String, arguments: [String]) on FIELD_DEFINITION
enum AccessType {
	ALLOW
	DENY
}
type ActiveDirectoryData {
	"""
	AD Common Name (CN)
	"""
	adCn: String
	"""
	AD objectSid
	"""
	adSid: String
	"""
	AD objectGUID
	"""
	adGuid: String
	"""
	AD name
	"""
	adName: String
	"""
	AD SAMAccountName
	"""
	adSAMAccountName: String
	"""
	AD User Principal Name
	"""
	adUserPrincipalName: String
	"""
	AD displayName
	"""
	adDisplayName: String
	"""
	AD distinguishedName
	"""
	adDistinguishedName: String
	"""
	AD canonicalName
	"""
	adCanonicalName: String
	"""
	AD accountExpires
	"""
	adAccountExpires: Epoch
	"""
	AD objectClass
	"""
	adObjectClass: [String]
	"""
	AD objectCategory
	"""
	adObjectCategory: String
	"""
	AD Organizational Unit
	"""
	adOrganizationalUnit: [String]
	"""
	AD lastLogoff
	"""
	adLastLogoff: Time
	"""
	AD lastLogon
	"""
	adLastLogon: Time
	"""
	AD lastLogonTimestamp
	"""
	adLastLogonTimestamp: Time
	"""
	AD badPasswordTime
	"""
	adBadPasswordTime: Time
	"""
	AD badPwdCount
	"""
	ad_bad_pwd_count: Int
	"""
	AD managedBy
	"""
	adManagedBy: String
	"""
	AD pwdLastSet
	"""
	adPasswordLastSet: Time
	"""
	AD Primary group ID
	"""
	adPrimaryGroupId: Int
	"""
	AD Primary group ID
	"""
	adPrimaryGroupDn: String
	"""
	AD memberOf
	"""
	adMemberOf: [String]
	"""
	AD memberOf (nested full list)
	"""
	adMemberOfFull: [String]
	"""
	AD uSNChanged
	"""
	adUsnChanged: Int
	"""
	AD uSNCreated
	"""
	adUsnCreated: Int
	"""
	AD whenChanged
	"""
	adWhenChanged: Time
	"""
	AD whenCreated
	"""
	adWhenCreated: Time
	"""
	AD isCriticalSystemObject
	"""
	adIsCriticalSystemObject: Boolean
	"""
	AD msDS-AllowedToDelegateTo
	"""
	adMsdsAllowedToDelegateTo: [String]
	"""
	AD Password Must Change
	"""
	adPwdMustChange: Boolean
	"""
	AD Resultant Password Settings Object
	"""
	adMsdsResultantPso: String
}
type Adapter @generateInputs(where: "adapter_bool_exp", orderBy: "adapter_order_by") {
	id: AdapterType!
	name: String
	properties: [String]
}
union AdapterData @generateInputs(where: "adapter_data_bool_exp", orderBy: "adapter_data_order_by") = ActiveDirectoryData | CylanceData | CrowdStrikeData
type AdapterDevice @generateInputs(where: "adapter_device_bool_exp", orderBy: "adapter_device_order_by") {
	"""
	Unique id of adapter device
	"""
	id: UUID!
	"""
	Cycle adapter device was fetched
	"""
	fetchCycle: Int!
	"""
	Idadas of adapter that fetched this device
	"""
	adapterId: AdapterType!
	adapter("""
	filter the rows returned
	"""
	where: adapter_bool_exp): Adapter @relation(name: "adapters", fkName: ["adapterId"], relationFkName: ["id"], relType: ONE_TO_ONE)
	"""
	Name of adapter that fetched this advice
	"""
	adapterName: String
	"""
	Correlated device id
	"""
	deviceId: UUID!
	"""
	Unique data returned by adapter on this device
	"""
	adapterData("""
	filter the rows returned
	"""
	where: adapter_data_bool_exp): AdapterData @jsonpath(name: "data", depends: ["adapterId"]) @goField(forceResolver: true, name: "adapterData")
	"""
	Data returned by this adapter as a json mappping
	"""
	data: Map
	"""
	Time adapter was requested to fetch device by axonius
	"""
	fetchTime: Epoch
	"""
	hostname of device
	"""
	hostname: String
	"""
	name given to device by the adapter
	"""
	name: String
	"""
	Last time device was seen by adapter in Unix time
	"""
	lastSeen: Epoch
	osId: UUID!
	"""
	Operating system adapter device is running on
	"""
	os("""
	filter the rows returned
	"""
	where: operating_system_bool_exp): OperatingSystem @relation(name: "operating_systems", fkName: ["osId"], relationFkName: ["id"], relType: ONE_TO_ONE)
	"""
	Pertty id given to adapter device when axonius created it
	"""
	prettyId: String
	tags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [Tag] @relation(name: "adapter_device_tags", fkName: ["id"], relationFkName: ["adapter_device_id"], relType: MANY_TO_MANY, manyToManyTableName: "tags", joinOn: ["name"])
	interfaces("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [NetworkInterface!] @relation(name: "network_interfaces", fkName: ["id","fetch_cycle"], relationFkName: ["deviceId","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	List of uses who last used the device
	"""
	lastUsedUsers: [String]
	"""
	Name of domain this adapter device belongs too
	"""
	domain: String
	"""
	Whether this adapter device is part of the domain
	"""
	partOfDomain: Boolean
	"""
	Users known by this device
	"""
	deviceUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_user_bool_exp): [AdapterDeviceUser] @jsonpath(name: "deviceUsers")
	"""
	local admins known by this device
	"""
	localAdmins("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_admin_bool_exp): [AdapterDeviceAdmin] @jsonpath(name: "localAdmins")
	"""
	Firewall rules defined on this adapter device
	"""
	firewallRules("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: firewall_rule_bool_exp): [FirewallRule] @relation(name: "adapter_device_firewall_rules", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "firewall_rules", joinOn: ["name"])
	"""
	Software installed on this device
	"""
	installedSoftware("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: installed_software_bool_exp): [InstalledSoftware] @relation(name: "adapter_device_installed_software", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "installed_software", joinOn: ["name","version"])
	agentVersion: String
	agentStatus: String
	agentName: String
	model: String
	manufacturer: String
	serial: String
	family: String
	biosVersion: String
	biosSerial: String
	"""
	Returns aggregate of tags
	"""
	tags_aggregate("""
	group by columns
	"""
	groupBy: [tags_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [tags_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [tagsAggregate!] @relation(name: "adapter_device_tags", fkName: ["id"], relationFkName: ["adapter_device_id"], relType: MANY_TO_MANY, manyToManyTableName: "tags", joinOn: ["name"])
	"""
	Returns aggregate of interfaces
	"""
	interfaces_aggregate("""
	group by columns
	"""
	groupBy: [interfaces_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [interfaces_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [interfacesAggregate!] @relation(name: "network_interfaces", fkName: ["id","fetch_cycle"], relationFkName: ["deviceId","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	Returns aggregate of firewallRules
	"""
	firewallRules_aggregate("""
	group by columns
	"""
	groupBy: [firewallRules_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [firewallRules_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: firewall_rule_bool_exp): [firewallRulesAggregate!] @relation(name: "adapter_device_firewall_rules", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "firewall_rules", joinOn: ["name"])
	"""
	Returns aggregate of installedSoftware
	"""
	installedSoftware_aggregate("""
	group by columns
	"""
	groupBy: [installedSoftware_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [installedSoftware_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: installed_software_bool_exp): [installedSoftwareAggregate!] @relation(name: "adapter_device_installed_software", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "installed_software", joinOn: ["name","version"])
}
type AdapterDeviceAdmin @generateInputs(where: "adapter_device_admin_bool_exp", orderBy: "adapter_device_admin_order_by") {
	name: String
	type: AdminType
}
"""
User known by an adapter device
"""
type AdapterDeviceUser @generateInputs(where: "adapter_device_user_bool_exp", orderBy: "adapter_device_user_order_by") {
	deviceId: UUID
	sid: String
	username: String
	lastUseDate: Epoch
	isLocal: Boolean
	isDisabled: Boolean
	isAdmin: Boolean
	userDepartment: Boolean
	passwordMaxAge: Int
	interpreter: String
}
enum AdapterType @goModel(model: "bandicoot/pkg/domain.AdapterType") {
	UNKNOWN
	CUSTOM
	ABSOLUTE
	ACTIVE_DIRECTORY
	AIRWATCH
	AIRWAVE
	ALERTLOGIC
	ALIBABA
	ANSIBLE_TOWER
	AQUA
	ARISTA_EOS
	ARMIS
	ARSENAL
	ARUBA
	AUTOMOX
	AWS
	AZURE_AD
	AZURE
	BAMBOOHR
	BIGFIX
	BIGFIX_INVENTORY
	BITDEFENDER
	BITLOCKER
	BITSIGHT
	BLACKBERRY_UEM
	BLUECAT
	BOMGAR
	CA_CMDB
	CA_SPECTRUM
	CARBONBLACK_DEFENSE
	CARBONBLACK_RESPONSE
	CENSYS
	CHECKPOINTR90
	CHEF
	CHERWELL
	CISCO
	CISCO_AMP
	CISCO_FIREPOWER_MANAGEMENT_CENTER
	CISCO_ISE
	CISCO_MERAKI
	CISCO_PRIME
	CISCO_STEALTHWATCH
	CISCO_UCM
	CISCO_UCSM
	CISCO_UMBERELLA
	CLAROTY
	CLEARPASS
	CLOUDFLARE
	CLOUD_PASSAGE
	CODE42
	COUNTER_ACT
	CROWD_STRIKE
	CSC_GLOBAL
	CSV
	CYBEREASON
	CYCOGNITO
	CYLANCE
	CYNET
	DATADOG
	DATTO
	DEEP_SECURITY
	DEFENDER_ATP
	DESKTOP_CENTRAL
	DEVICE42
	DIGICERT_CERTCENTRAL
	DIVVY_CLOUD
	DROPBOX
	DRUVA
	DUO
	DYNATRACE
	ECLYPSIUM
	EDGESSCAN
	ENDGAME
	ENSILO
	EPO
	ESET
	ESX
	F5_ICONTROL
	FIRE_EYE_HX
	FORCEPOINT
	FOREMAN
	FORTIGATE
	FRESH_SERVICE
	GCE
	GITHUB
	GOOGLE_BIG_QUERY
	GOOGLE_MDM
	GOTOASSIST
	GURDICORE
	GUARDIUM
	HASHICORP
	HAVEIBEENPWNED
	HP_NNMI
	HYPER_V
	IBM_TIVOLI_TADDM
	ICINGA
	IGAR
	ILLUSIVE
	IMPERVA
	INDEGY
	INFINITE_SLEEP
	INFOBLOX
	IVANTI_SM
	JAMF
	JSON
	JSON_FILE
	JUMPCLOUD
	JUNIPER
	JUNOS
	KASEYA
	KASPERSKY_SC
	LANDESK
	LANSWEEPER
	LIBERNMS
	LINUX_SSH
	LOGRYTHM
	MAAS360
	MALWAREBYTES
	MASSCAN
	MEDIGATE
	MEN_AND_MICE
	MINERVA
	MOBI_CONTROL
	MOBILE_IRON
	MSSQL
	NESSUS
	NESSUS_CSV
	NETBOX
	NETBRAIN
	NETSKOPE
	NEXPOSE
	NIMBUL
	NMAP
	NUTANIX
	OBSERVEIT
	OBSERVIUM
	OFFICE_SCAN
	OKTA
	OMNIVISTA
	OPENSTACK
	OPSWAT
	ORACLE_CLOUD
	ORACLE_VM
	ORCA
	PACKETFENCE
	PALOALTO_CORTEX
	PALOALTO_PANORAMA
	PALOALTO_XDR
	PKWARE
	PREEMPT
	PROMISEC
	PROXMOX
	PUPPET
	QCORE
	QUALYS
	QUEST_KACE
	RANDORI
	REDCANARY
	REDCLOAK
	REDSEAL
	RISK_IQ
	RIVERBED
	RUMBLE
	SALTSTACK
	SALTSTACK_ENTERPRISE
	SAMANGE
	SCCM
	SCEP
	SECDO
	SENTINELONE
	SERVICENOW
	SHOADAN
	SIGNALSCIENCES
	SKYBOX
	SNIPEIT
	SNOW
	SOFTLAYER
	SOLARWINDS_ORION
	SOPHOS
	SPACEWALK
	SPECOPS
	SPLUNK
	STRESSTEST
	SYMANTEC
	SYMANTEC_ALTIRIS
	SYMANTEC_CCS
	SYMANTEC_CLOUD_WORKLOAD
	SYMANTEC_DLP
	SYMANTEC_SEP_CLOUD
	SYSAID
	TANIUM
	TENABLE_IO
	TENABLE_SECURITY_CENTER
	TORIIHQ
	TRAIANA_LAB_MACHINES
	TRIPWIRE_ENTERPRISE
	TRUEFORT
	TWISTLOCK
	UNIFI
	VCLOUD_DIRECTOR
	WAZUH
	WEBROOT
	WEBSCAN
	WSUS
	ZABBIX
	ZSCALER
}
type AdapterUser @generateInputs(where: "adapter_user_bool_exp", orderBy: "adapter_user_order_by") {
	"""
	Unique id of adapter device
	"""
	id: UUID!
	"""
	Cycle adapter device was fetched
	"""
	fetchCycle: Int!
	"""
	Id of adapter that fetched this device
	"""
	adapterId: AdapterType!
	adapter("""
	filter the rows returned
	"""
	where: adapter_bool_exp): Adapter @relation(name: "adapters", fkName: ["adapterId"], relationFkName: ["id"], relType: ONE_TO_ONE)
	"""
	Name of adapter that fetched this advice
	"""
	adapterName: String
	"""
	Correlated device id
	"""
	userId: UUID!
	"""
	Unique data returned by adapter on this device
	"""
	adapterData("""
	filter the rows returned
	"""
	where: adapter_data_bool_exp): AdapterData @jsonpath(name: "data", depends: ["adapterId"]) @goField(forceResolver: true, name: "adapterData")
	"""
	Data returned by this adapter as a json mappping
	"""
	data: Map
	"""
	Time adapter was requested to fetch device by axonius
	"""
	fetchTime: Epoch
	"""
	Last time device was seen by adapter in Unix time
	"""
	lastSeen: Epoch
	"""
	Username
	"""
	username: String
	"""
	User first name
	"""
	firstName: String
	"""
	User last name
	"""
	lastName: String
	"""
	User email account
	"""
	mail: String
	"""
	User account has admin privileges
	"""
	admin: Boolean
	"""
	User entity is local 
	"""
	local: Boolean
	"""
	User account is a delegated admin
	"""
	delegated_admin: Boolean
	"""
	User account has multi-factor authentication enforced
	"""
	mfa_enforced: Boolean
	"""
	User account is enrollled in multi-factor authenticaton
	"""
	mfa_enrolled: Boolean
	"""
	User account is suspended
	"""
	suspended: Boolean
	"""
	User account has been locked
	"""
	locked: Boolean
	"""
	User account has been disabled
	"""
	disabled: Boolean
}
enum AdminType {
	ADMIN_USER
	GROUP_MEMBERSHIP
}
interface Aggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min: Map
	max: Map
}
enum AggregateOrdering {
	count_ASC
	count_DESC
	sum_ASC
	sum_DESC
	avg_ASC
	avg_DESC
	min_ASC
	min_DESC
	max_ASC
	max_DESC
}
enum Architecture {
	X86
	X64
	MIPS
	ALPHA
	ARM
	POWER_PC
	IA64
}
"""
IPv4 and IPv6 networks
"""
scalar CIDR
type CPU {
	id: Int!
	name: String!
	manfacturer: String
	bitness: Int
	family: String
	"""
	Core count of CPU
	"""
	cores: Int
	coresThreads: Int
	ghz: Float
}
type CrowdStrikeData {
	externalIp: String
	groups("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [csGroup]
	preventionPolicy("""
	filter the rows returned
	"""
	where: cs_policy_bool_exp): csPolicy
	sensorUpdatePolicy("""
	filter the rows returned
	"""
	where: cs_group_bool_exp): csGroup
	csAgentVersion: String
	"""
	Returns aggregate of groups
	"""
	groups_aggregate("""
	group by columns
	"""
	groupBy: [groups_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [groups_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [groupsAggregate!]
}
type CylanceData {
	isSafe: String
	deviceState: CylanceDeviceState
	policyId: String
	policyName: String
	policiesDetails: [String]
	tenantTag: String
	zoneNames: [String]
	agentVersion: String
}
enum CylanceDeviceState {
	ONLINE
	OFFLINE
}
"""
Device aggregates one or more adapter device that were correlated
"""
type Device @generateInputs(where: "device_bool_exp", orderBy: "device_order_by") {
	"""
	Unique ID of correlated device
	"""
	id: UUID!
	"""
	Fetch cycle this device was collected
	"""
	fetchCycle: Int!
	"""
	Count of adapters that are correlated to this device
	"""
	adapterCount: Int!
	"""
	Names of adapters that are correlated to this device
	"""
	adapterNames: [String!]
	"""
	Unique hostnames given to device by all adapters
	"""
	hostnames: [String!]
	"""
	Last time device was seen by one of the adapters
	"""
	lastSeen: Epoch
	"""
	Adapter devices that are correlated to this device
	"""
	adapterDevices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [AdapterDevice!] @relation(name: "adapter_devices", fkName: ["id","fetch_cycle"], relationFkName: ["device_id","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	Unique set of network interfaces collected by all adapter devices
	"""
	interfaces("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [NetworkInterface!] @viewFunction(name: "device_network_interfaces", arguments: ["id","fetch_cycle"])
	"""
	Unique set tags given to all adapter devices
	"""
	tags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [Tag!] @viewFunction(name: "device_tags", arguments: ["id","fetch_cycle"])
	"""
	Allows transformation of queried data to API v1
	"""
	_compatibilityAPI: Map @goField(forceResolver: true, name: "compatabilityAPI") @deprecated
	"""
	Returns aggregate of adapterDevices
	"""
	adapterDevices_aggregate("""
	group by columns
	"""
	groupBy: [adapterDevices_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterDevices_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [adapterDevicesAggregate!] @relation(name: "adapter_devices", fkName: ["id","fetch_cycle"], relationFkName: ["device_id","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	Returns aggregate of interfaces
	"""
	interfaces_aggregate("""
	group by columns
	"""
	groupBy: [interfaces_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [interfaces_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [interfacesAggregate!] @viewFunction(name: "device_network_interfaces", arguments: ["id","fetch_cycle"])
	"""
	Returns aggregate of tags
	"""
	tags_aggregate("""
	group by columns
	"""
	groupBy: [tags_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [tags_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [tagsAggregate!] @viewFunction(name: "device_tags", arguments: ["id","fetch_cycle"])
}
enum Direction {
	INGRESS
	EGRESS
}
"""
Unix Time (also known as Epoch time) is a system for describing a point in time.
It is the number of seconds that have elapsed since the Unix epoch, that is the time 00:00:00 UTC on 1 January 1970,
minus leap seconds.
"""
scalar Epoch
type FirewallRule @generateInputs(where: "firewall_rule_bool_exp", orderBy: "firewall_rule_order_by") {
	name: String
	source: String
	type: AccessType
	direction: Direction
	target: String
	protocol: String
	srcPort: Int
	dstPort: Int
}
type GCETagsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [GCETags_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [GCETags_aggregate_max_columns!]!): Map
	GCETags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: gce_tags_bool_exp): [GceTags]
}
enum GCETags_aggregate_columns {
	"""
	groupBy by gceKey
	"""
	gceKey
	"""
	groupBy by gceValue
	"""
	gceValue
}
enum GCETags_aggregate_max_columns {
	"""
	max by gceKey
	"""
	gceKey
	"""
	max by gceValue
	"""
	gceValue
}
enum GCETags_aggregate_min_columns {
	"""
	min by gceKey
	"""
	gceKey
	"""
	min by gceValue
	"""
	gceValue
}
type GceTags @generateInputs(where: "gce_tags_bool_exp", orderBy: "gce_tags_order_by") {
	gceKey: String
	gceValue: String
}
type GoogleCloudData {
	Id: String
	Size: String
	Image: String
	GCETags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: gce_tags_bool_exp): [GceTags]
	"""
	Returns aggregate of GCETags
	"""
	GCETags_aggregate("""
	group by columns
	"""
	groupBy: [GCETags_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [GCETags_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: gce_tags_bool_exp): [GCETagsAggregate!]
}
scalar IP
enum IPFamily {
	V4
	V6
}
type InstalledSoftware @generateInputs(where: "installed_software_bool_exp", orderBy: "installed_software_order_by") {
	"""
	Software Name
	"""
	name: String
	"""
	Software Version
	"""
	version: String
	architecture: Architecture
	description: String
	"""
	Software Vendor
	"""
	vendor: String
	publisher: String
	cveCount: Int
	swLicense: String
	path: String
}
"""
A media access control address (MAC address) is a unique identifier assigned to a network interface controller (NIC)
for use as a network address in communications within a network segment.
"""
scalar Mac
"""
JavaScript Object Notation (JSON) is an open-standard file format or data interchange format
that uses human-readable text to transmit data objects consisting of attributevalue pairs and array data types
(or any other serializable value)
"""
scalar Map
type NetworkInterface @generateInputs(where: "network_interface_bool_exp", orderBy: "networkInterface_order_by") {
	deviceId: UUID
	macAddr: Mac
	ipAddrs: [IP!]
}
"""
Operating System is the system installed on an adapter device
"""
type OperatingSystem @generateInputs(where: "operating_system_bool_exp", orderBy: "operating_system_order_by") {
	id: UUID!
	type: String
	distribution: String
	architecture: Int
	servicePack: String
	installDate: Epoch
	kernelVersion: String
	codeName: String
	major: Int
	minor: Int
	build: String
	RawName: String
}
enum OsTypes {
	WINDOWS
	LINUX
	OS_X
	IOS
	AIR_OS
	ANDROID
	FREE_BSD
	VMWARE
	CISCO
	MIKROTIK
	VXWORKS
	F5_NETWORKS_BIG_IP
	SOLARIS
	AIX
	PRINTER
	PLAYSTATION
	CHECKPOINT
	ARISTA
}
type Query {
	adapterDevices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [adapter_device_order_by!]): [AdapterDevice!]!
	devices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: device_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [device_order_by!]): [Device!]!
	adapterUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [adapter_user_order_by!]): [AdapterUser!]!
	users("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: user_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [user_order_by!]): [User!]!
	"""
	Returns aggregate of adapterDevices
	"""
	adapterDevices_aggregate("""
	group by columns
	"""
	groupBy: [adapterDevices_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterDevices_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [adapterDevicesAggregate!]
	"""
	Returns aggregate of devices
	"""
	devices_aggregate("""
	group by columns
	"""
	groupBy: [devices_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [devices_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: device_bool_exp): [devicesAggregate!]
	"""
	Returns aggregate of adapterUsers
	"""
	adapterUsers_aggregate("""
	group by columns
	"""
	groupBy: [adapterUsers_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterUsers_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [adapterUsersAggregate!]
	"""
	Returns aggregate of users
	"""
	users_aggregate("""
	group by columns
	"""
	groupBy: [users_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [users_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: user_bool_exp): [usersAggregate!]
}
enum RelationType {
	ONE_TO_ONE
	ONE_TO_MANY
	MANY_TO_MANY
}
type Storage {
	deviceId: UUID!
	"""
	Path
	"""
	path: String!
	"""
	Device Name
	"""
	name: String!
	"""
	Size (GB)
	"""
	totalSize: Float!
	"""
	Size (GB)
	"""
	freeSize: Float!
	"""
	Whether drive is encrypted or not
	"""
	isEncrypted: Boolean!
	"""
	Descirption of device
	"""
	description: String
}
type Tag @generateInputs(where: "tag_bool_exp", orderBy: "tag_order_by") {
	name: String!
	creator: String!
	level: String!
}
scalar Time
scalar UUID
type User @generateInputs(where: "user_bool_exp", orderBy: "user_order_by") {
	id: UUID!
	fetchCycle: Int!
	adapterCount: Int!
	adapterNames: [String!]
	usernames: [String!]
	lastSeen: Epoch
	adapterUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [AdapterUser!] @relation(name: "adapter_users", fkName: ["id","fetch_cycle"], relationFkName: ["user_id","fetch_cycle"], relType: ONE_TO_MANY)
	_compatibilityAPI: Map @goField(forceResolver: true, name: "compatabilityAPI")
	"""
	Returns aggregate of adapterUsers
	"""
	adapterUsers_aggregate("""
	group by columns
	"""
	groupBy: [adapterUsers_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterUsers_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [adapterUsersAggregate!] @relation(name: "adapter_users", fkName: ["id","fetch_cycle"], relationFkName: ["user_id","fetch_cycle"], relType: ONE_TO_MANY)
}
type adapterDevicesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_max_columns!]!): Map
	"""
	Adapter devices that are correlated to this device
	"""
	adapterDevices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [AdapterDevice] @relation(name: "adapter_devices", fkName: ["id","fetch_cycle"], relationFkName: ["device_id","fetch_cycle"], relType: ONE_TO_MANY)
}
enum adapterDevices_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by fetchTime
	"""
	fetchTime
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum adapterDevices_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterName
	"""
	adapterName
	"""
	groupBy by deviceId
	"""
	deviceId
	"""
	groupBy by fetchTime
	"""
	fetchTime
	"""
	groupBy by hostname
	"""
	hostname
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by lastSeen
	"""
	lastSeen
	"""
	groupBy by osId
	"""
	osId
	"""
	groupBy by prettyId
	"""
	prettyId
	"""
	groupBy by domain
	"""
	domain
	"""
	groupBy by agentVersion
	"""
	agentVersion
	"""
	groupBy by agentStatus
	"""
	agentStatus
	"""
	groupBy by agentName
	"""
	agentName
	"""
	groupBy by model
	"""
	model
	"""
	groupBy by manufacturer
	"""
	manufacturer
	"""
	groupBy by serial
	"""
	serial
	"""
	groupBy by family
	"""
	family
	"""
	groupBy by biosVersion
	"""
	biosVersion
	"""
	groupBy by biosSerial
	"""
	biosSerial
}
enum adapterDevices_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterName
	"""
	adapterName
	"""
	max by deviceId
	"""
	deviceId
	"""
	max by fetchTime
	"""
	fetchTime
	"""
	max by hostname
	"""
	hostname
	"""
	max by name
	"""
	name
	"""
	max by lastSeen
	"""
	lastSeen
	"""
	max by osId
	"""
	osId
	"""
	max by prettyId
	"""
	prettyId
	"""
	max by domain
	"""
	domain
	"""
	max by agentVersion
	"""
	agentVersion
	"""
	max by agentStatus
	"""
	agentStatus
	"""
	max by agentName
	"""
	agentName
	"""
	max by model
	"""
	model
	"""
	max by manufacturer
	"""
	manufacturer
	"""
	max by serial
	"""
	serial
	"""
	max by family
	"""
	family
	"""
	max by biosVersion
	"""
	biosVersion
	"""
	max by biosSerial
	"""
	biosSerial
}
enum adapterDevices_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterName
	"""
	adapterName
	"""
	min by deviceId
	"""
	deviceId
	"""
	min by fetchTime
	"""
	fetchTime
	"""
	min by hostname
	"""
	hostname
	"""
	min by name
	"""
	name
	"""
	min by lastSeen
	"""
	lastSeen
	"""
	min by osId
	"""
	osId
	"""
	min by prettyId
	"""
	prettyId
	"""
	min by domain
	"""
	domain
	"""
	min by agentVersion
	"""
	agentVersion
	"""
	min by agentStatus
	"""
	agentStatus
	"""
	min by agentName
	"""
	agentName
	"""
	min by model
	"""
	model
	"""
	min by manufacturer
	"""
	manufacturer
	"""
	min by serial
	"""
	serial
	"""
	min by family
	"""
	family
	"""
	min by biosVersion
	"""
	biosVersion
	"""
	min by biosSerial
	"""
	biosSerial
}
enum adapterDevices_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by fetchTime
	"""
	fetchTime
	"""
	sum by lastSeen
	"""
	lastSeen
}
type adapterUsersAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_max_columns!]!): Map
	adapterUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [AdapterUser] @relation(name: "adapter_users", fkName: ["id","fetch_cycle"], relationFkName: ["user_id","fetch_cycle"], relType: ONE_TO_MANY)
}
enum adapterUsers_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by fetchTime
	"""
	fetchTime
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum adapterUsers_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterName
	"""
	adapterName
	"""
	groupBy by userId
	"""
	userId
	"""
	groupBy by fetchTime
	"""
	fetchTime
	"""
	groupBy by lastSeen
	"""
	lastSeen
	"""
	groupBy by username
	"""
	username
	"""
	groupBy by firstName
	"""
	firstName
	"""
	groupBy by lastName
	"""
	lastName
	"""
	groupBy by mail
	"""
	mail
}
enum adapterUsers_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterName
	"""
	adapterName
	"""
	max by userId
	"""
	userId
	"""
	max by fetchTime
	"""
	fetchTime
	"""
	max by lastSeen
	"""
	lastSeen
	"""
	max by username
	"""
	username
	"""
	max by firstName
	"""
	firstName
	"""
	max by lastName
	"""
	lastName
	"""
	max by mail
	"""
	mail
}
enum adapterUsers_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterName
	"""
	adapterName
	"""
	min by userId
	"""
	userId
	"""
	min by fetchTime
	"""
	fetchTime
	"""
	min by lastSeen
	"""
	lastSeen
	"""
	min by username
	"""
	username
	"""
	min by firstName
	"""
	firstName
	"""
	min by lastName
	"""
	lastName
	"""
	min by mail
	"""
	mail
}
enum adapterUsers_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by fetchTime
	"""
	fetchTime
	"""
	sum by lastSeen
	"""
	lastSeen
}
"""
Boolean filter expression for Adapter
"""
input adapter_bool_exp {
	"""
	eq comparison operator
	"""
	id_eq: AdapterType
	"""
	neq comparison operator
	"""
	id_neq: AdapterType
	"""
	in comparison operator
	"""
	id_in: [AdapterType]
	"""
	not_in comparison operator
	"""
	id_not_in: [AdapterType]
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	contains comparison operator
	"""
	properties_contains: [String]
	"""
	contained_by comparison operator
	"""
	properties_contained_by: [String]
	"""
	overlap comparison operator
	"""
	properties_overlap: [String]
	"""
	size comparison operator
	"""
	properties_size: Int
	"""
	contains_regex comparison operator
	"""
	properties_contains_regex: String
	AND: [adapter_bool_exp!]
	OR: [adapter_bool_exp!]
	NOT: [adapter_bool_exp!]
}
"""
Boolean filter expression for AdapterData
"""
input adapter_data_bool_exp {
	"""
	exists comparison operator
	"""
	adCn_exists: Boolean
	"""
	not comparison operator
	"""
	adCn_not: String
	"""
	eq comparison operator
	"""
	adCn_eq: String
	"""
	neq comparison operator
	"""
	adCn_neq: String
	"""
	in comparison operator
	"""
	adCn_in: [String]
	"""
	not_in comparison operator
	"""
	adCn_not_in: [String]
	"""
	like comparison operator
	"""
	adCn_like: String
	"""
	not_like comparison operator
	"""
	adCn_not_like: String
	"""
	ilike comparison operator
	"""
	adCn_ilike: String
	"""
	not_ilike comparison operator
	"""
	adCn_not_ilike: String
	"""
	suffix comparison operator
	"""
	adCn_suffix: String
	"""
	prefix comparison operator
	"""
	adCn_prefix: String
	"""
	exists comparison operator
	"""
	adSid_exists: Boolean
	"""
	not comparison operator
	"""
	adSid_not: String
	"""
	eq comparison operator
	"""
	adSid_eq: String
	"""
	neq comparison operator
	"""
	adSid_neq: String
	"""
	in comparison operator
	"""
	adSid_in: [String]
	"""
	not_in comparison operator
	"""
	adSid_not_in: [String]
	"""
	like comparison operator
	"""
	adSid_like: String
	"""
	not_like comparison operator
	"""
	adSid_not_like: String
	"""
	ilike comparison operator
	"""
	adSid_ilike: String
	"""
	not_ilike comparison operator
	"""
	adSid_not_ilike: String
	"""
	suffix comparison operator
	"""
	adSid_suffix: String
	"""
	prefix comparison operator
	"""
	adSid_prefix: String
	"""
	exists comparison operator
	"""
	adGuid_exists: Boolean
	"""
	not comparison operator
	"""
	adGuid_not: String
	"""
	eq comparison operator
	"""
	adGuid_eq: String
	"""
	neq comparison operator
	"""
	adGuid_neq: String
	"""
	in comparison operator
	"""
	adGuid_in: [String]
	"""
	not_in comparison operator
	"""
	adGuid_not_in: [String]
	"""
	like comparison operator
	"""
	adGuid_like: String
	"""
	not_like comparison operator
	"""
	adGuid_not_like: String
	"""
	ilike comparison operator
	"""
	adGuid_ilike: String
	"""
	not_ilike comparison operator
	"""
	adGuid_not_ilike: String
	"""
	suffix comparison operator
	"""
	adGuid_suffix: String
	"""
	prefix comparison operator
	"""
	adGuid_prefix: String
	"""
	exists comparison operator
	"""
	adName_exists: Boolean
	"""
	not comparison operator
	"""
	adName_not: String
	"""
	eq comparison operator
	"""
	adName_eq: String
	"""
	neq comparison operator
	"""
	adName_neq: String
	"""
	in comparison operator
	"""
	adName_in: [String]
	"""
	not_in comparison operator
	"""
	adName_not_in: [String]
	"""
	like comparison operator
	"""
	adName_like: String
	"""
	not_like comparison operator
	"""
	adName_not_like: String
	"""
	ilike comparison operator
	"""
	adName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adName_suffix: String
	"""
	prefix comparison operator
	"""
	adName_prefix: String
	"""
	exists comparison operator
	"""
	adSAMAccountName_exists: Boolean
	"""
	not comparison operator
	"""
	adSAMAccountName_not: String
	"""
	eq comparison operator
	"""
	adSAMAccountName_eq: String
	"""
	neq comparison operator
	"""
	adSAMAccountName_neq: String
	"""
	in comparison operator
	"""
	adSAMAccountName_in: [String]
	"""
	not_in comparison operator
	"""
	adSAMAccountName_not_in: [String]
	"""
	like comparison operator
	"""
	adSAMAccountName_like: String
	"""
	not_like comparison operator
	"""
	adSAMAccountName_not_like: String
	"""
	ilike comparison operator
	"""
	adSAMAccountName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adSAMAccountName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adSAMAccountName_suffix: String
	"""
	prefix comparison operator
	"""
	adSAMAccountName_prefix: String
	"""
	exists comparison operator
	"""
	adUserPrincipalName_exists: Boolean
	"""
	not comparison operator
	"""
	adUserPrincipalName_not: String
	"""
	eq comparison operator
	"""
	adUserPrincipalName_eq: String
	"""
	neq comparison operator
	"""
	adUserPrincipalName_neq: String
	"""
	in comparison operator
	"""
	adUserPrincipalName_in: [String]
	"""
	not_in comparison operator
	"""
	adUserPrincipalName_not_in: [String]
	"""
	like comparison operator
	"""
	adUserPrincipalName_like: String
	"""
	not_like comparison operator
	"""
	adUserPrincipalName_not_like: String
	"""
	ilike comparison operator
	"""
	adUserPrincipalName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adUserPrincipalName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adUserPrincipalName_suffix: String
	"""
	prefix comparison operator
	"""
	adUserPrincipalName_prefix: String
	"""
	exists comparison operator
	"""
	adDisplayName_exists: Boolean
	"""
	not comparison operator
	"""
	adDisplayName_not: String
	"""
	eq comparison operator
	"""
	adDisplayName_eq: String
	"""
	neq comparison operator
	"""
	adDisplayName_neq: String
	"""
	in comparison operator
	"""
	adDisplayName_in: [String]
	"""
	not_in comparison operator
	"""
	adDisplayName_not_in: [String]
	"""
	like comparison operator
	"""
	adDisplayName_like: String
	"""
	not_like comparison operator
	"""
	adDisplayName_not_like: String
	"""
	ilike comparison operator
	"""
	adDisplayName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adDisplayName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adDisplayName_suffix: String
	"""
	prefix comparison operator
	"""
	adDisplayName_prefix: String
	"""
	exists comparison operator
	"""
	adDistinguishedName_exists: Boolean
	"""
	not comparison operator
	"""
	adDistinguishedName_not: String
	"""
	eq comparison operator
	"""
	adDistinguishedName_eq: String
	"""
	neq comparison operator
	"""
	adDistinguishedName_neq: String
	"""
	in comparison operator
	"""
	adDistinguishedName_in: [String]
	"""
	not_in comparison operator
	"""
	adDistinguishedName_not_in: [String]
	"""
	like comparison operator
	"""
	adDistinguishedName_like: String
	"""
	not_like comparison operator
	"""
	adDistinguishedName_not_like: String
	"""
	ilike comparison operator
	"""
	adDistinguishedName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adDistinguishedName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adDistinguishedName_suffix: String
	"""
	prefix comparison operator
	"""
	adDistinguishedName_prefix: String
	"""
	exists comparison operator
	"""
	adCanonicalName_exists: Boolean
	"""
	not comparison operator
	"""
	adCanonicalName_not: String
	"""
	eq comparison operator
	"""
	adCanonicalName_eq: String
	"""
	neq comparison operator
	"""
	adCanonicalName_neq: String
	"""
	in comparison operator
	"""
	adCanonicalName_in: [String]
	"""
	not_in comparison operator
	"""
	adCanonicalName_not_in: [String]
	"""
	like comparison operator
	"""
	adCanonicalName_like: String
	"""
	not_like comparison operator
	"""
	adCanonicalName_not_like: String
	"""
	ilike comparison operator
	"""
	adCanonicalName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adCanonicalName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adCanonicalName_suffix: String
	"""
	prefix comparison operator
	"""
	adCanonicalName_prefix: String
	"""
	exists comparison operator
	"""
	adAccountExpires_exists: Boolean
	"""
	eq comparison operator
	"""
	adAccountExpires_eq: Epoch
	"""
	neq comparison operator
	"""
	adAccountExpires_neq: Epoch
	"""
	in comparison operator
	"""
	adAccountExpires_in: [Epoch]
	"""
	not_in comparison operator
	"""
	adAccountExpires_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	adAccountExpires_gt: Epoch
	"""
	gte comparison operator
	"""
	adAccountExpires_gte: Epoch
	"""
	lt comparison operator
	"""
	adAccountExpires_lt: Epoch
	"""
	lte comparison operator
	"""
	adAccountExpires_lte: Epoch
	"""
	days comparison operator
	"""
	adAccountExpires_days: Int
	"""
	contains comparison operator
	"""
	adObjectClass_contains: [String]
	"""
	contained_by comparison operator
	"""
	adObjectClass_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adObjectClass_overlap: [String]
	"""
	size comparison operator
	"""
	adObjectClass_size: Int
	"""
	contains_regex comparison operator
	"""
	adObjectClass_contains_regex: String
	"""
	exists comparison operator
	"""
	adObjectCategory_exists: Boolean
	"""
	not comparison operator
	"""
	adObjectCategory_not: String
	"""
	eq comparison operator
	"""
	adObjectCategory_eq: String
	"""
	neq comparison operator
	"""
	adObjectCategory_neq: String
	"""
	in comparison operator
	"""
	adObjectCategory_in: [String]
	"""
	not_in comparison operator
	"""
	adObjectCategory_not_in: [String]
	"""
	like comparison operator
	"""
	adObjectCategory_like: String
	"""
	not_like comparison operator
	"""
	adObjectCategory_not_like: String
	"""
	ilike comparison operator
	"""
	adObjectCategory_ilike: String
	"""
	not_ilike comparison operator
	"""
	adObjectCategory_not_ilike: String
	"""
	suffix comparison operator
	"""
	adObjectCategory_suffix: String
	"""
	prefix comparison operator
	"""
	adObjectCategory_prefix: String
	"""
	contains comparison operator
	"""
	adOrganizationalUnit_contains: [String]
	"""
	contained_by comparison operator
	"""
	adOrganizationalUnit_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adOrganizationalUnit_overlap: [String]
	"""
	size comparison operator
	"""
	adOrganizationalUnit_size: Int
	"""
	contains_regex comparison operator
	"""
	adOrganizationalUnit_contains_regex: String
	"""
	exists comparison operator
	"""
	adLastLogoff_exists: Boolean
	"""
	eq comparison operator
	"""
	adLastLogoff_eq: Time
	"""
	neq comparison operator
	"""
	adLastLogoff_neq: Time
	"""
	in comparison operator
	"""
	adLastLogoff_in: [Time]
	"""
	not_in comparison operator
	"""
	adLastLogoff_not_in: [Time]
	"""
	gt comparison operator
	"""
	adLastLogoff_gt: Time
	"""
	gte comparison operator
	"""
	adLastLogoff_gte: Time
	"""
	lt comparison operator
	"""
	adLastLogoff_lt: Time
	"""
	lte comparison operator
	"""
	adLastLogoff_lte: Time
	"""
	days comparison operator
	"""
	adLastLogoff_days: Int
	"""
	exists comparison operator
	"""
	adLastLogon_exists: Boolean
	"""
	eq comparison operator
	"""
	adLastLogon_eq: Time
	"""
	neq comparison operator
	"""
	adLastLogon_neq: Time
	"""
	in comparison operator
	"""
	adLastLogon_in: [Time]
	"""
	not_in comparison operator
	"""
	adLastLogon_not_in: [Time]
	"""
	gt comparison operator
	"""
	adLastLogon_gt: Time
	"""
	gte comparison operator
	"""
	adLastLogon_gte: Time
	"""
	lt comparison operator
	"""
	adLastLogon_lt: Time
	"""
	lte comparison operator
	"""
	adLastLogon_lte: Time
	"""
	days comparison operator
	"""
	adLastLogon_days: Int
	"""
	exists comparison operator
	"""
	adLastLogonTimestamp_exists: Boolean
	"""
	eq comparison operator
	"""
	adLastLogonTimestamp_eq: Time
	"""
	neq comparison operator
	"""
	adLastLogonTimestamp_neq: Time
	"""
	in comparison operator
	"""
	adLastLogonTimestamp_in: [Time]
	"""
	not_in comparison operator
	"""
	adLastLogonTimestamp_not_in: [Time]
	"""
	gt comparison operator
	"""
	adLastLogonTimestamp_gt: Time
	"""
	gte comparison operator
	"""
	adLastLogonTimestamp_gte: Time
	"""
	lt comparison operator
	"""
	adLastLogonTimestamp_lt: Time
	"""
	lte comparison operator
	"""
	adLastLogonTimestamp_lte: Time
	"""
	days comparison operator
	"""
	adLastLogonTimestamp_days: Int
	"""
	exists comparison operator
	"""
	adBadPasswordTime_exists: Boolean
	"""
	eq comparison operator
	"""
	adBadPasswordTime_eq: Time
	"""
	neq comparison operator
	"""
	adBadPasswordTime_neq: Time
	"""
	in comparison operator
	"""
	adBadPasswordTime_in: [Time]
	"""
	not_in comparison operator
	"""
	adBadPasswordTime_not_in: [Time]
	"""
	gt comparison operator
	"""
	adBadPasswordTime_gt: Time
	"""
	gte comparison operator
	"""
	adBadPasswordTime_gte: Time
	"""
	lt comparison operator
	"""
	adBadPasswordTime_lt: Time
	"""
	lte comparison operator
	"""
	adBadPasswordTime_lte: Time
	"""
	days comparison operator
	"""
	adBadPasswordTime_days: Int
	"""
	exists comparison operator
	"""
	ad_bad_pwd_count_exists: Boolean
	"""
	eq comparison operator
	"""
	ad_bad_pwd_count_eq: Int
	"""
	neq comparison operator
	"""
	ad_bad_pwd_count_neq: Int
	"""
	in comparison operator
	"""
	ad_bad_pwd_count_in: [Int]
	"""
	not_in comparison operator
	"""
	ad_bad_pwd_count_not_in: [Int]
	"""
	gt comparison operator
	"""
	ad_bad_pwd_count_gt: Int
	"""
	gte comparison operator
	"""
	ad_bad_pwd_count_gte: Int
	"""
	lt comparison operator
	"""
	ad_bad_pwd_count_lt: Int
	"""
	lte comparison operator
	"""
	ad_bad_pwd_count_lte: Int
	"""
	exists comparison operator
	"""
	adManagedBy_exists: Boolean
	"""
	not comparison operator
	"""
	adManagedBy_not: String
	"""
	eq comparison operator
	"""
	adManagedBy_eq: String
	"""
	neq comparison operator
	"""
	adManagedBy_neq: String
	"""
	in comparison operator
	"""
	adManagedBy_in: [String]
	"""
	not_in comparison operator
	"""
	adManagedBy_not_in: [String]
	"""
	like comparison operator
	"""
	adManagedBy_like: String
	"""
	not_like comparison operator
	"""
	adManagedBy_not_like: String
	"""
	ilike comparison operator
	"""
	adManagedBy_ilike: String
	"""
	not_ilike comparison operator
	"""
	adManagedBy_not_ilike: String
	"""
	suffix comparison operator
	"""
	adManagedBy_suffix: String
	"""
	prefix comparison operator
	"""
	adManagedBy_prefix: String
	"""
	exists comparison operator
	"""
	adPasswordLastSet_exists: Boolean
	"""
	eq comparison operator
	"""
	adPasswordLastSet_eq: Time
	"""
	neq comparison operator
	"""
	adPasswordLastSet_neq: Time
	"""
	in comparison operator
	"""
	adPasswordLastSet_in: [Time]
	"""
	not_in comparison operator
	"""
	adPasswordLastSet_not_in: [Time]
	"""
	gt comparison operator
	"""
	adPasswordLastSet_gt: Time
	"""
	gte comparison operator
	"""
	adPasswordLastSet_gte: Time
	"""
	lt comparison operator
	"""
	adPasswordLastSet_lt: Time
	"""
	lte comparison operator
	"""
	adPasswordLastSet_lte: Time
	"""
	days comparison operator
	"""
	adPasswordLastSet_days: Int
	"""
	exists comparison operator
	"""
	adPrimaryGroupId_exists: Boolean
	"""
	eq comparison operator
	"""
	adPrimaryGroupId_eq: Int
	"""
	neq comparison operator
	"""
	adPrimaryGroupId_neq: Int
	"""
	in comparison operator
	"""
	adPrimaryGroupId_in: [Int]
	"""
	not_in comparison operator
	"""
	adPrimaryGroupId_not_in: [Int]
	"""
	gt comparison operator
	"""
	adPrimaryGroupId_gt: Int
	"""
	gte comparison operator
	"""
	adPrimaryGroupId_gte: Int
	"""
	lt comparison operator
	"""
	adPrimaryGroupId_lt: Int
	"""
	lte comparison operator
	"""
	adPrimaryGroupId_lte: Int
	"""
	exists comparison operator
	"""
	adPrimaryGroupDn_exists: Boolean
	"""
	not comparison operator
	"""
	adPrimaryGroupDn_not: String
	"""
	eq comparison operator
	"""
	adPrimaryGroupDn_eq: String
	"""
	neq comparison operator
	"""
	adPrimaryGroupDn_neq: String
	"""
	in comparison operator
	"""
	adPrimaryGroupDn_in: [String]
	"""
	not_in comparison operator
	"""
	adPrimaryGroupDn_not_in: [String]
	"""
	like comparison operator
	"""
	adPrimaryGroupDn_like: String
	"""
	not_like comparison operator
	"""
	adPrimaryGroupDn_not_like: String
	"""
	ilike comparison operator
	"""
	adPrimaryGroupDn_ilike: String
	"""
	not_ilike comparison operator
	"""
	adPrimaryGroupDn_not_ilike: String
	"""
	suffix comparison operator
	"""
	adPrimaryGroupDn_suffix: String
	"""
	prefix comparison operator
	"""
	adPrimaryGroupDn_prefix: String
	"""
	contains comparison operator
	"""
	adMemberOf_contains: [String]
	"""
	contained_by comparison operator
	"""
	adMemberOf_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adMemberOf_overlap: [String]
	"""
	size comparison operator
	"""
	adMemberOf_size: Int
	"""
	contains_regex comparison operator
	"""
	adMemberOf_contains_regex: String
	"""
	contains comparison operator
	"""
	adMemberOfFull_contains: [String]
	"""
	contained_by comparison operator
	"""
	adMemberOfFull_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adMemberOfFull_overlap: [String]
	"""
	size comparison operator
	"""
	adMemberOfFull_size: Int
	"""
	contains_regex comparison operator
	"""
	adMemberOfFull_contains_regex: String
	"""
	exists comparison operator
	"""
	adUsnChanged_exists: Boolean
	"""
	eq comparison operator
	"""
	adUsnChanged_eq: Int
	"""
	neq comparison operator
	"""
	adUsnChanged_neq: Int
	"""
	in comparison operator
	"""
	adUsnChanged_in: [Int]
	"""
	not_in comparison operator
	"""
	adUsnChanged_not_in: [Int]
	"""
	gt comparison operator
	"""
	adUsnChanged_gt: Int
	"""
	gte comparison operator
	"""
	adUsnChanged_gte: Int
	"""
	lt comparison operator
	"""
	adUsnChanged_lt: Int
	"""
	lte comparison operator
	"""
	adUsnChanged_lte: Int
	"""
	exists comparison operator
	"""
	adUsnCreated_exists: Boolean
	"""
	eq comparison operator
	"""
	adUsnCreated_eq: Int
	"""
	neq comparison operator
	"""
	adUsnCreated_neq: Int
	"""
	in comparison operator
	"""
	adUsnCreated_in: [Int]
	"""
	not_in comparison operator
	"""
	adUsnCreated_not_in: [Int]
	"""
	gt comparison operator
	"""
	adUsnCreated_gt: Int
	"""
	gte comparison operator
	"""
	adUsnCreated_gte: Int
	"""
	lt comparison operator
	"""
	adUsnCreated_lt: Int
	"""
	lte comparison operator
	"""
	adUsnCreated_lte: Int
	"""
	exists comparison operator
	"""
	adWhenChanged_exists: Boolean
	"""
	eq comparison operator
	"""
	adWhenChanged_eq: Time
	"""
	neq comparison operator
	"""
	adWhenChanged_neq: Time
	"""
	in comparison operator
	"""
	adWhenChanged_in: [Time]
	"""
	not_in comparison operator
	"""
	adWhenChanged_not_in: [Time]
	"""
	gt comparison operator
	"""
	adWhenChanged_gt: Time
	"""
	gte comparison operator
	"""
	adWhenChanged_gte: Time
	"""
	lt comparison operator
	"""
	adWhenChanged_lt: Time
	"""
	lte comparison operator
	"""
	adWhenChanged_lte: Time
	"""
	days comparison operator
	"""
	adWhenChanged_days: Int
	"""
	exists comparison operator
	"""
	adWhenCreated_exists: Boolean
	"""
	eq comparison operator
	"""
	adWhenCreated_eq: Time
	"""
	neq comparison operator
	"""
	adWhenCreated_neq: Time
	"""
	in comparison operator
	"""
	adWhenCreated_in: [Time]
	"""
	not_in comparison operator
	"""
	adWhenCreated_not_in: [Time]
	"""
	gt comparison operator
	"""
	adWhenCreated_gt: Time
	"""
	gte comparison operator
	"""
	adWhenCreated_gte: Time
	"""
	lt comparison operator
	"""
	adWhenCreated_lt: Time
	"""
	lte comparison operator
	"""
	adWhenCreated_lte: Time
	"""
	days comparison operator
	"""
	adWhenCreated_days: Int
	"""
	exists comparison operator
	"""
	adIsCriticalSystemObject_exists: Boolean
	"""
	eq comparison operator
	"""
	adIsCriticalSystemObject_eq: Boolean
	"""
	neq comparison operator
	"""
	adIsCriticalSystemObject_neq: Boolean
	"""
	contains comparison operator
	"""
	adMsdsAllowedToDelegateTo_contains: [String]
	"""
	contained_by comparison operator
	"""
	adMsdsAllowedToDelegateTo_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adMsdsAllowedToDelegateTo_overlap: [String]
	"""
	size comparison operator
	"""
	adMsdsAllowedToDelegateTo_size: Int
	"""
	contains_regex comparison operator
	"""
	adMsdsAllowedToDelegateTo_contains_regex: String
	"""
	exists comparison operator
	"""
	adPwdMustChange_exists: Boolean
	"""
	eq comparison operator
	"""
	adPwdMustChange_eq: Boolean
	"""
	neq comparison operator
	"""
	adPwdMustChange_neq: Boolean
	"""
	exists comparison operator
	"""
	adMsdsResultantPso_exists: Boolean
	"""
	not comparison operator
	"""
	adMsdsResultantPso_not: String
	"""
	eq comparison operator
	"""
	adMsdsResultantPso_eq: String
	"""
	neq comparison operator
	"""
	adMsdsResultantPso_neq: String
	"""
	in comparison operator
	"""
	adMsdsResultantPso_in: [String]
	"""
	not_in comparison operator
	"""
	adMsdsResultantPso_not_in: [String]
	"""
	like comparison operator
	"""
	adMsdsResultantPso_like: String
	"""
	not_like comparison operator
	"""
	adMsdsResultantPso_not_like: String
	"""
	ilike comparison operator
	"""
	adMsdsResultantPso_ilike: String
	"""
	not_ilike comparison operator
	"""
	adMsdsResultantPso_not_ilike: String
	"""
	suffix comparison operator
	"""
	adMsdsResultantPso_suffix: String
	"""
	prefix comparison operator
	"""
	adMsdsResultantPso_prefix: String
	"""
	exists comparison operator
	"""
	isSafe_exists: Boolean
	"""
	not comparison operator
	"""
	isSafe_not: String
	"""
	eq comparison operator
	"""
	isSafe_eq: String
	"""
	neq comparison operator
	"""
	isSafe_neq: String
	"""
	in comparison operator
	"""
	isSafe_in: [String]
	"""
	not_in comparison operator
	"""
	isSafe_not_in: [String]
	"""
	like comparison operator
	"""
	isSafe_like: String
	"""
	not_like comparison operator
	"""
	isSafe_not_like: String
	"""
	ilike comparison operator
	"""
	isSafe_ilike: String
	"""
	not_ilike comparison operator
	"""
	isSafe_not_ilike: String
	"""
	suffix comparison operator
	"""
	isSafe_suffix: String
	"""
	prefix comparison operator
	"""
	isSafe_prefix: String
	"""
	eq comparison operator
	"""
	deviceState_eq: CylanceDeviceState
	"""
	neq comparison operator
	"""
	deviceState_neq: CylanceDeviceState
	"""
	in comparison operator
	"""
	deviceState_in: [CylanceDeviceState]
	"""
	not_in comparison operator
	"""
	deviceState_not_in: [CylanceDeviceState]
	"""
	exists comparison operator
	"""
	policyId_exists: Boolean
	"""
	not comparison operator
	"""
	policyId_not: String
	"""
	eq comparison operator
	"""
	policyId_eq: String
	"""
	neq comparison operator
	"""
	policyId_neq: String
	"""
	in comparison operator
	"""
	policyId_in: [String]
	"""
	not_in comparison operator
	"""
	policyId_not_in: [String]
	"""
	like comparison operator
	"""
	policyId_like: String
	"""
	not_like comparison operator
	"""
	policyId_not_like: String
	"""
	ilike comparison operator
	"""
	policyId_ilike: String
	"""
	not_ilike comparison operator
	"""
	policyId_not_ilike: String
	"""
	suffix comparison operator
	"""
	policyId_suffix: String
	"""
	prefix comparison operator
	"""
	policyId_prefix: String
	"""
	exists comparison operator
	"""
	policyName_exists: Boolean
	"""
	not comparison operator
	"""
	policyName_not: String
	"""
	eq comparison operator
	"""
	policyName_eq: String
	"""
	neq comparison operator
	"""
	policyName_neq: String
	"""
	in comparison operator
	"""
	policyName_in: [String]
	"""
	not_in comparison operator
	"""
	policyName_not_in: [String]
	"""
	like comparison operator
	"""
	policyName_like: String
	"""
	not_like comparison operator
	"""
	policyName_not_like: String
	"""
	ilike comparison operator
	"""
	policyName_ilike: String
	"""
	not_ilike comparison operator
	"""
	policyName_not_ilike: String
	"""
	suffix comparison operator
	"""
	policyName_suffix: String
	"""
	prefix comparison operator
	"""
	policyName_prefix: String
	"""
	contains comparison operator
	"""
	policiesDetails_contains: [String]
	"""
	contained_by comparison operator
	"""
	policiesDetails_contained_by: [String]
	"""
	overlap comparison operator
	"""
	policiesDetails_overlap: [String]
	"""
	size comparison operator
	"""
	policiesDetails_size: Int
	"""
	contains_regex comparison operator
	"""
	policiesDetails_contains_regex: String
	"""
	exists comparison operator
	"""
	tenantTag_exists: Boolean
	"""
	not comparison operator
	"""
	tenantTag_not: String
	"""
	eq comparison operator
	"""
	tenantTag_eq: String
	"""
	neq comparison operator
	"""
	tenantTag_neq: String
	"""
	in comparison operator
	"""
	tenantTag_in: [String]
	"""
	not_in comparison operator
	"""
	tenantTag_not_in: [String]
	"""
	like comparison operator
	"""
	tenantTag_like: String
	"""
	not_like comparison operator
	"""
	tenantTag_not_like: String
	"""
	ilike comparison operator
	"""
	tenantTag_ilike: String
	"""
	not_ilike comparison operator
	"""
	tenantTag_not_ilike: String
	"""
	suffix comparison operator
	"""
	tenantTag_suffix: String
	"""
	prefix comparison operator
	"""
	tenantTag_prefix: String
	"""
	contains comparison operator
	"""
	zoneNames_contains: [String]
	"""
	contained_by comparison operator
	"""
	zoneNames_contained_by: [String]
	"""
	overlap comparison operator
	"""
	zoneNames_overlap: [String]
	"""
	size comparison operator
	"""
	zoneNames_size: Int
	"""
	contains_regex comparison operator
	"""
	zoneNames_contains_regex: String
	"""
	exists comparison operator
	"""
	agentVersion_exists: Boolean
	"""
	not comparison operator
	"""
	agentVersion_not: String
	"""
	eq comparison operator
	"""
	agentVersion_eq: String
	"""
	neq comparison operator
	"""
	agentVersion_neq: String
	"""
	in comparison operator
	"""
	agentVersion_in: [String]
	"""
	not_in comparison operator
	"""
	agentVersion_not_in: [String]
	"""
	like comparison operator
	"""
	agentVersion_like: String
	"""
	not_like comparison operator
	"""
	agentVersion_not_like: String
	"""
	ilike comparison operator
	"""
	agentVersion_ilike: String
	"""
	not_ilike comparison operator
	"""
	agentVersion_not_ilike: String
	"""
	suffix comparison operator
	"""
	agentVersion_suffix: String
	"""
	prefix comparison operator
	"""
	agentVersion_prefix: String
	"""
	exists comparison operator
	"""
	externalIp_exists: Boolean
	"""
	not comparison operator
	"""
	externalIp_not: String
	"""
	eq comparison operator
	"""
	externalIp_eq: String
	"""
	neq comparison operator
	"""
	externalIp_neq: String
	"""
	in comparison operator
	"""
	externalIp_in: [String]
	"""
	not_in comparison operator
	"""
	externalIp_not_in: [String]
	"""
	like comparison operator
	"""
	externalIp_like: String
	"""
	not_like comparison operator
	"""
	externalIp_not_like: String
	"""
	ilike comparison operator
	"""
	externalIp_ilike: String
	"""
	not_ilike comparison operator
	"""
	externalIp_not_ilike: String
	"""
	suffix comparison operator
	"""
	externalIp_suffix: String
	"""
	prefix comparison operator
	"""
	externalIp_prefix: String
	"""
	filter by groups
	"""
	groups: cs_group_bool_exp
	"""
	filter by preventionPolicy
	"""
	preventionPolicy: cs_policy_bool_exp
	"""
	filter by sensorUpdatePolicy
	"""
	sensorUpdatePolicy: cs_group_bool_exp
	"""
	exists comparison operator
	"""
	csAgentVersion_exists: Boolean
	"""
	not comparison operator
	"""
	csAgentVersion_not: String
	"""
	eq comparison operator
	"""
	csAgentVersion_eq: String
	"""
	neq comparison operator
	"""
	csAgentVersion_neq: String
	"""
	in comparison operator
	"""
	csAgentVersion_in: [String]
	"""
	not_in comparison operator
	"""
	csAgentVersion_not_in: [String]
	"""
	like comparison operator
	"""
	csAgentVersion_like: String
	"""
	not_like comparison operator
	"""
	csAgentVersion_not_like: String
	"""
	ilike comparison operator
	"""
	csAgentVersion_ilike: String
	"""
	not_ilike comparison operator
	"""
	csAgentVersion_not_ilike: String
	"""
	suffix comparison operator
	"""
	csAgentVersion_suffix: String
	"""
	prefix comparison operator
	"""
	csAgentVersion_prefix: String
	AND: [adapter_data_bool_exp!]
	OR: [adapter_data_bool_exp!]
	NOT: [adapter_data_bool_exp!]
}
"""
Boolean filter expression for AdapterDeviceAdmin
"""
input adapter_device_admin_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	eq comparison operator
	"""
	type_eq: AdminType
	"""
	neq comparison operator
	"""
	type_neq: AdminType
	"""
	in comparison operator
	"""
	type_in: [AdminType]
	"""
	not_in comparison operator
	"""
	type_not_in: [AdminType]
	AND: [adapter_device_admin_bool_exp!]
	OR: [adapter_device_admin_bool_exp!]
	NOT: [adapter_device_admin_bool_exp!]
}
"""
Order for AdapterDeviceAdmin
"""
enum adapter_device_admin_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
}
"""
Boolean filter expression for AdapterDevice
"""
input adapter_device_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	eq comparison operator
	"""
	id_eq: UUID
	"""
	neq comparison operator
	"""
	id_neq: UUID
	"""
	in comparison operator
	"""
	id_in: [UUID]
	"""
	not_in comparison operator
	"""
	id_not_in: [UUID]
	"""
	gt comparison operator
	"""
	id_gt: UUID
	"""
	gte comparison operator
	"""
	id_gte: UUID
	"""
	lt comparison operator
	"""
	id_lt: UUID
	"""
	lte comparison operator
	"""
	id_lte: UUID
	"""
	exists comparison operator
	"""
	fetchCycle_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchCycle_eq: Int
	"""
	neq comparison operator
	"""
	fetchCycle_neq: Int
	"""
	in comparison operator
	"""
	fetchCycle_in: [Int]
	"""
	not_in comparison operator
	"""
	fetchCycle_not_in: [Int]
	"""
	gt comparison operator
	"""
	fetchCycle_gt: Int
	"""
	gte comparison operator
	"""
	fetchCycle_gte: Int
	"""
	lt comparison operator
	"""
	fetchCycle_lt: Int
	"""
	lte comparison operator
	"""
	fetchCycle_lte: Int
	"""
	eq comparison operator
	"""
	adapterId_eq: AdapterType
	"""
	neq comparison operator
	"""
	adapterId_neq: AdapterType
	"""
	in comparison operator
	"""
	adapterId_in: [AdapterType]
	"""
	not_in comparison operator
	"""
	adapterId_not_in: [AdapterType]
	"""
	filter by adapter
	"""
	adapter: adapter_bool_exp
	"""
	exists comparison operator
	"""
	adapterName_exists: Boolean
	"""
	not comparison operator
	"""
	adapterName_not: String
	"""
	eq comparison operator
	"""
	adapterName_eq: String
	"""
	neq comparison operator
	"""
	adapterName_neq: String
	"""
	in comparison operator
	"""
	adapterName_in: [String]
	"""
	not_in comparison operator
	"""
	adapterName_not_in: [String]
	"""
	like comparison operator
	"""
	adapterName_like: String
	"""
	not_like comparison operator
	"""
	adapterName_not_like: String
	"""
	ilike comparison operator
	"""
	adapterName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adapterName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adapterName_suffix: String
	"""
	prefix comparison operator
	"""
	adapterName_prefix: String
	"""
	exists comparison operator
	"""
	deviceId_exists: Boolean
	"""
	eq comparison operator
	"""
	deviceId_eq: UUID
	"""
	neq comparison operator
	"""
	deviceId_neq: UUID
	"""
	in comparison operator
	"""
	deviceId_in: [UUID]
	"""
	not_in comparison operator
	"""
	deviceId_not_in: [UUID]
	"""
	gt comparison operator
	"""
	deviceId_gt: UUID
	"""
	gte comparison operator
	"""
	deviceId_gte: UUID
	"""
	lt comparison operator
	"""
	deviceId_lt: UUID
	"""
	lte comparison operator
	"""
	deviceId_lte: UUID
	"""
	filter by adapterData
	"""
	adapterData: adapter_data_bool_exp
	"""
	exists comparison operator
	"""
	fetchTime_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchTime_eq: Epoch
	"""
	neq comparison operator
	"""
	fetchTime_neq: Epoch
	"""
	in comparison operator
	"""
	fetchTime_in: [Epoch]
	"""
	not_in comparison operator
	"""
	fetchTime_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	fetchTime_gt: Epoch
	"""
	gte comparison operator
	"""
	fetchTime_gte: Epoch
	"""
	lt comparison operator
	"""
	fetchTime_lt: Epoch
	"""
	lte comparison operator
	"""
	fetchTime_lte: Epoch
	"""
	days comparison operator
	"""
	fetchTime_days: Int
	"""
	exists comparison operator
	"""
	hostname_exists: Boolean
	"""
	not comparison operator
	"""
	hostname_not: String
	"""
	eq comparison operator
	"""
	hostname_eq: String
	"""
	neq comparison operator
	"""
	hostname_neq: String
	"""
	in comparison operator
	"""
	hostname_in: [String]
	"""
	not_in comparison operator
	"""
	hostname_not_in: [String]
	"""
	like comparison operator
	"""
	hostname_like: String
	"""
	not_like comparison operator
	"""
	hostname_not_like: String
	"""
	ilike comparison operator
	"""
	hostname_ilike: String
	"""
	not_ilike comparison operator
	"""
	hostname_not_ilike: String
	"""
	suffix comparison operator
	"""
	hostname_suffix: String
	"""
	prefix comparison operator
	"""
	hostname_prefix: String
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	lastSeen_exists: Boolean
	"""
	eq comparison operator
	"""
	lastSeen_eq: Epoch
	"""
	neq comparison operator
	"""
	lastSeen_neq: Epoch
	"""
	in comparison operator
	"""
	lastSeen_in: [Epoch]
	"""
	not_in comparison operator
	"""
	lastSeen_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	lastSeen_gt: Epoch
	"""
	gte comparison operator
	"""
	lastSeen_gte: Epoch
	"""
	lt comparison operator
	"""
	lastSeen_lt: Epoch
	"""
	lte comparison operator
	"""
	lastSeen_lte: Epoch
	"""
	days comparison operator
	"""
	lastSeen_days: Int
	"""
	exists comparison operator
	"""
	osId_exists: Boolean
	"""
	eq comparison operator
	"""
	osId_eq: UUID
	"""
	neq comparison operator
	"""
	osId_neq: UUID
	"""
	in comparison operator
	"""
	osId_in: [UUID]
	"""
	not_in comparison operator
	"""
	osId_not_in: [UUID]
	"""
	gt comparison operator
	"""
	osId_gt: UUID
	"""
	gte comparison operator
	"""
	osId_gte: UUID
	"""
	lt comparison operator
	"""
	osId_lt: UUID
	"""
	lte comparison operator
	"""
	osId_lte: UUID
	"""
	filter by os
	"""
	os: operating_system_bool_exp
	"""
	exists comparison operator
	"""
	prettyId_exists: Boolean
	"""
	not comparison operator
	"""
	prettyId_not: String
	"""
	eq comparison operator
	"""
	prettyId_eq: String
	"""
	neq comparison operator
	"""
	prettyId_neq: String
	"""
	in comparison operator
	"""
	prettyId_in: [String]
	"""
	not_in comparison operator
	"""
	prettyId_not_in: [String]
	"""
	like comparison operator
	"""
	prettyId_like: String
	"""
	not_like comparison operator
	"""
	prettyId_not_like: String
	"""
	ilike comparison operator
	"""
	prettyId_ilike: String
	"""
	not_ilike comparison operator
	"""
	prettyId_not_ilike: String
	"""
	suffix comparison operator
	"""
	prettyId_suffix: String
	"""
	prefix comparison operator
	"""
	prettyId_prefix: String
	"""
	filter by tags
	"""
	tags: tag_bool_exp
	"""
	filter by interfaces
	"""
	interfaces: network_interface_bool_exp
	"""
	contains comparison operator
	"""
	lastUsedUsers_contains: [String]
	"""
	contained_by comparison operator
	"""
	lastUsedUsers_contained_by: [String]
	"""
	overlap comparison operator
	"""
	lastUsedUsers_overlap: [String]
	"""
	size comparison operator
	"""
	lastUsedUsers_size: Int
	"""
	contains_regex comparison operator
	"""
	lastUsedUsers_contains_regex: String
	"""
	exists comparison operator
	"""
	domain_exists: Boolean
	"""
	not comparison operator
	"""
	domain_not: String
	"""
	eq comparison operator
	"""
	domain_eq: String
	"""
	neq comparison operator
	"""
	domain_neq: String
	"""
	in comparison operator
	"""
	domain_in: [String]
	"""
	not_in comparison operator
	"""
	domain_not_in: [String]
	"""
	like comparison operator
	"""
	domain_like: String
	"""
	not_like comparison operator
	"""
	domain_not_like: String
	"""
	ilike comparison operator
	"""
	domain_ilike: String
	"""
	not_ilike comparison operator
	"""
	domain_not_ilike: String
	"""
	suffix comparison operator
	"""
	domain_suffix: String
	"""
	prefix comparison operator
	"""
	domain_prefix: String
	"""
	exists comparison operator
	"""
	partOfDomain_exists: Boolean
	"""
	eq comparison operator
	"""
	partOfDomain_eq: Boolean
	"""
	neq comparison operator
	"""
	partOfDomain_neq: Boolean
	"""
	filter by deviceUsers
	"""
	deviceUsers: adapter_device_user_bool_exp
	"""
	filter by localAdmins
	"""
	localAdmins: adapter_device_admin_bool_exp
	"""
	filter by firewallRules
	"""
	firewallRules: firewall_rule_bool_exp
	"""
	filter by installedSoftware
	"""
	installedSoftware: installed_software_bool_exp
	"""
	exists comparison operator
	"""
	agentVersion_exists: Boolean
	"""
	not comparison operator
	"""
	agentVersion_not: String
	"""
	eq comparison operator
	"""
	agentVersion_eq: String
	"""
	neq comparison operator
	"""
	agentVersion_neq: String
	"""
	in comparison operator
	"""
	agentVersion_in: [String]
	"""
	not_in comparison operator
	"""
	agentVersion_not_in: [String]
	"""
	like comparison operator
	"""
	agentVersion_like: String
	"""
	not_like comparison operator
	"""
	agentVersion_not_like: String
	"""
	ilike comparison operator
	"""
	agentVersion_ilike: String
	"""
	not_ilike comparison operator
	"""
	agentVersion_not_ilike: String
	"""
	suffix comparison operator
	"""
	agentVersion_suffix: String
	"""
	prefix comparison operator
	"""
	agentVersion_prefix: String
	"""
	exists comparison operator
	"""
	agentStatus_exists: Boolean
	"""
	not comparison operator
	"""
	agentStatus_not: String
	"""
	eq comparison operator
	"""
	agentStatus_eq: String
	"""
	neq comparison operator
	"""
	agentStatus_neq: String
	"""
	in comparison operator
	"""
	agentStatus_in: [String]
	"""
	not_in comparison operator
	"""
	agentStatus_not_in: [String]
	"""
	like comparison operator
	"""
	agentStatus_like: String
	"""
	not_like comparison operator
	"""
	agentStatus_not_like: String
	"""
	ilike comparison operator
	"""
	agentStatus_ilike: String
	"""
	not_ilike comparison operator
	"""
	agentStatus_not_ilike: String
	"""
	suffix comparison operator
	"""
	agentStatus_suffix: String
	"""
	prefix comparison operator
	"""
	agentStatus_prefix: String
	"""
	exists comparison operator
	"""
	agentName_exists: Boolean
	"""
	not comparison operator
	"""
	agentName_not: String
	"""
	eq comparison operator
	"""
	agentName_eq: String
	"""
	neq comparison operator
	"""
	agentName_neq: String
	"""
	in comparison operator
	"""
	agentName_in: [String]
	"""
	not_in comparison operator
	"""
	agentName_not_in: [String]
	"""
	like comparison operator
	"""
	agentName_like: String
	"""
	not_like comparison operator
	"""
	agentName_not_like: String
	"""
	ilike comparison operator
	"""
	agentName_ilike: String
	"""
	not_ilike comparison operator
	"""
	agentName_not_ilike: String
	"""
	suffix comparison operator
	"""
	agentName_suffix: String
	"""
	prefix comparison operator
	"""
	agentName_prefix: String
	"""
	exists comparison operator
	"""
	model_exists: Boolean
	"""
	not comparison operator
	"""
	model_not: String
	"""
	eq comparison operator
	"""
	model_eq: String
	"""
	neq comparison operator
	"""
	model_neq: String
	"""
	in comparison operator
	"""
	model_in: [String]
	"""
	not_in comparison operator
	"""
	model_not_in: [String]
	"""
	like comparison operator
	"""
	model_like: String
	"""
	not_like comparison operator
	"""
	model_not_like: String
	"""
	ilike comparison operator
	"""
	model_ilike: String
	"""
	not_ilike comparison operator
	"""
	model_not_ilike: String
	"""
	suffix comparison operator
	"""
	model_suffix: String
	"""
	prefix comparison operator
	"""
	model_prefix: String
	"""
	exists comparison operator
	"""
	manufacturer_exists: Boolean
	"""
	not comparison operator
	"""
	manufacturer_not: String
	"""
	eq comparison operator
	"""
	manufacturer_eq: String
	"""
	neq comparison operator
	"""
	manufacturer_neq: String
	"""
	in comparison operator
	"""
	manufacturer_in: [String]
	"""
	not_in comparison operator
	"""
	manufacturer_not_in: [String]
	"""
	like comparison operator
	"""
	manufacturer_like: String
	"""
	not_like comparison operator
	"""
	manufacturer_not_like: String
	"""
	ilike comparison operator
	"""
	manufacturer_ilike: String
	"""
	not_ilike comparison operator
	"""
	manufacturer_not_ilike: String
	"""
	suffix comparison operator
	"""
	manufacturer_suffix: String
	"""
	prefix comparison operator
	"""
	manufacturer_prefix: String
	"""
	exists comparison operator
	"""
	serial_exists: Boolean
	"""
	not comparison operator
	"""
	serial_not: String
	"""
	eq comparison operator
	"""
	serial_eq: String
	"""
	neq comparison operator
	"""
	serial_neq: String
	"""
	in comparison operator
	"""
	serial_in: [String]
	"""
	not_in comparison operator
	"""
	serial_not_in: [String]
	"""
	like comparison operator
	"""
	serial_like: String
	"""
	not_like comparison operator
	"""
	serial_not_like: String
	"""
	ilike comparison operator
	"""
	serial_ilike: String
	"""
	not_ilike comparison operator
	"""
	serial_not_ilike: String
	"""
	suffix comparison operator
	"""
	serial_suffix: String
	"""
	prefix comparison operator
	"""
	serial_prefix: String
	"""
	exists comparison operator
	"""
	family_exists: Boolean
	"""
	not comparison operator
	"""
	family_not: String
	"""
	eq comparison operator
	"""
	family_eq: String
	"""
	neq comparison operator
	"""
	family_neq: String
	"""
	in comparison operator
	"""
	family_in: [String]
	"""
	not_in comparison operator
	"""
	family_not_in: [String]
	"""
	like comparison operator
	"""
	family_like: String
	"""
	not_like comparison operator
	"""
	family_not_like: String
	"""
	ilike comparison operator
	"""
	family_ilike: String
	"""
	not_ilike comparison operator
	"""
	family_not_ilike: String
	"""
	suffix comparison operator
	"""
	family_suffix: String
	"""
	prefix comparison operator
	"""
	family_prefix: String
	"""
	exists comparison operator
	"""
	biosVersion_exists: Boolean
	"""
	not comparison operator
	"""
	biosVersion_not: String
	"""
	eq comparison operator
	"""
	biosVersion_eq: String
	"""
	neq comparison operator
	"""
	biosVersion_neq: String
	"""
	in comparison operator
	"""
	biosVersion_in: [String]
	"""
	not_in comparison operator
	"""
	biosVersion_not_in: [String]
	"""
	like comparison operator
	"""
	biosVersion_like: String
	"""
	not_like comparison operator
	"""
	biosVersion_not_like: String
	"""
	ilike comparison operator
	"""
	biosVersion_ilike: String
	"""
	not_ilike comparison operator
	"""
	biosVersion_not_ilike: String
	"""
	suffix comparison operator
	"""
	biosVersion_suffix: String
	"""
	prefix comparison operator
	"""
	biosVersion_prefix: String
	"""
	exists comparison operator
	"""
	biosSerial_exists: Boolean
	"""
	not comparison operator
	"""
	biosSerial_not: String
	"""
	eq comparison operator
	"""
	biosSerial_eq: String
	"""
	neq comparison operator
	"""
	biosSerial_neq: String
	"""
	in comparison operator
	"""
	biosSerial_in: [String]
	"""
	not_in comparison operator
	"""
	biosSerial_not_in: [String]
	"""
	like comparison operator
	"""
	biosSerial_like: String
	"""
	not_like comparison operator
	"""
	biosSerial_not_like: String
	"""
	ilike comparison operator
	"""
	biosSerial_ilike: String
	"""
	not_ilike comparison operator
	"""
	biosSerial_not_ilike: String
	"""
	suffix comparison operator
	"""
	biosSerial_suffix: String
	"""
	prefix comparison operator
	"""
	biosSerial_prefix: String
	AND: [adapter_device_bool_exp!]
	OR: [adapter_device_bool_exp!]
	NOT: [adapter_device_bool_exp!]
}
"""
Order for AdapterDevice
"""
enum adapter_device_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterName in an ascending order
	"""
	adapterName_ASC
	"""
	Order by adapterName in a descending order
	"""
	adapterName_DESC
	"""
	Order by fetchTime in an ascending order
	"""
	fetchTime_ASC
	"""
	Order by fetchTime in a descending order
	"""
	fetchTime_DESC
	"""
	Order by hostname in an ascending order
	"""
	hostname_ASC
	"""
	Order by hostname in a descending order
	"""
	hostname_DESC
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
	"""
	Order by prettyId in an ascending order
	"""
	prettyId_ASC
	"""
	Order by prettyId in a descending order
	"""
	prettyId_DESC
	"""
	Order by domain in an ascending order
	"""
	domain_ASC
	"""
	Order by domain in a descending order
	"""
	domain_DESC
	"""
	Order by agentVersion in an ascending order
	"""
	agentVersion_ASC
	"""
	Order by agentVersion in a descending order
	"""
	agentVersion_DESC
	"""
	Order by agentStatus in an ascending order
	"""
	agentStatus_ASC
	"""
	Order by agentStatus in a descending order
	"""
	agentStatus_DESC
	"""
	Order by agentName in an ascending order
	"""
	agentName_ASC
	"""
	Order by agentName in a descending order
	"""
	agentName_DESC
	"""
	Order by model in an ascending order
	"""
	model_ASC
	"""
	Order by model in a descending order
	"""
	model_DESC
	"""
	Order by manufacturer in an ascending order
	"""
	manufacturer_ASC
	"""
	Order by manufacturer in a descending order
	"""
	manufacturer_DESC
	"""
	Order by serial in an ascending order
	"""
	serial_ASC
	"""
	Order by serial in a descending order
	"""
	serial_DESC
	"""
	Order by family in an ascending order
	"""
	family_ASC
	"""
	Order by family in a descending order
	"""
	family_DESC
	"""
	Order by biosVersion in an ascending order
	"""
	biosVersion_ASC
	"""
	Order by biosVersion in a descending order
	"""
	biosVersion_DESC
	"""
	Order by biosSerial in an ascending order
	"""
	biosSerial_ASC
	"""
	Order by biosSerial in a descending order
	"""
	biosSerial_DESC
}
"""
Boolean filter expression for AdapterDeviceUser
"""
input adapter_device_user_bool_exp {
	"""
	exists comparison operator
	"""
	deviceId_exists: Boolean
	"""
	eq comparison operator
	"""
	deviceId_eq: UUID
	"""
	neq comparison operator
	"""
	deviceId_neq: UUID
	"""
	in comparison operator
	"""
	deviceId_in: [UUID]
	"""
	not_in comparison operator
	"""
	deviceId_not_in: [UUID]
	"""
	gt comparison operator
	"""
	deviceId_gt: UUID
	"""
	gte comparison operator
	"""
	deviceId_gte: UUID
	"""
	lt comparison operator
	"""
	deviceId_lt: UUID
	"""
	lte comparison operator
	"""
	deviceId_lte: UUID
	"""
	exists comparison operator
	"""
	sid_exists: Boolean
	"""
	not comparison operator
	"""
	sid_not: String
	"""
	eq comparison operator
	"""
	sid_eq: String
	"""
	neq comparison operator
	"""
	sid_neq: String
	"""
	in comparison operator
	"""
	sid_in: [String]
	"""
	not_in comparison operator
	"""
	sid_not_in: [String]
	"""
	like comparison operator
	"""
	sid_like: String
	"""
	not_like comparison operator
	"""
	sid_not_like: String
	"""
	ilike comparison operator
	"""
	sid_ilike: String
	"""
	not_ilike comparison operator
	"""
	sid_not_ilike: String
	"""
	suffix comparison operator
	"""
	sid_suffix: String
	"""
	prefix comparison operator
	"""
	sid_prefix: String
	"""
	exists comparison operator
	"""
	username_exists: Boolean
	"""
	not comparison operator
	"""
	username_not: String
	"""
	eq comparison operator
	"""
	username_eq: String
	"""
	neq comparison operator
	"""
	username_neq: String
	"""
	in comparison operator
	"""
	username_in: [String]
	"""
	not_in comparison operator
	"""
	username_not_in: [String]
	"""
	like comparison operator
	"""
	username_like: String
	"""
	not_like comparison operator
	"""
	username_not_like: String
	"""
	ilike comparison operator
	"""
	username_ilike: String
	"""
	not_ilike comparison operator
	"""
	username_not_ilike: String
	"""
	suffix comparison operator
	"""
	username_suffix: String
	"""
	prefix comparison operator
	"""
	username_prefix: String
	"""
	exists comparison operator
	"""
	lastUseDate_exists: Boolean
	"""
	eq comparison operator
	"""
	lastUseDate_eq: Epoch
	"""
	neq comparison operator
	"""
	lastUseDate_neq: Epoch
	"""
	in comparison operator
	"""
	lastUseDate_in: [Epoch]
	"""
	not_in comparison operator
	"""
	lastUseDate_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	lastUseDate_gt: Epoch
	"""
	gte comparison operator
	"""
	lastUseDate_gte: Epoch
	"""
	lt comparison operator
	"""
	lastUseDate_lt: Epoch
	"""
	lte comparison operator
	"""
	lastUseDate_lte: Epoch
	"""
	days comparison operator
	"""
	lastUseDate_days: Int
	"""
	exists comparison operator
	"""
	isLocal_exists: Boolean
	"""
	eq comparison operator
	"""
	isLocal_eq: Boolean
	"""
	neq comparison operator
	"""
	isLocal_neq: Boolean
	"""
	exists comparison operator
	"""
	isDisabled_exists: Boolean
	"""
	eq comparison operator
	"""
	isDisabled_eq: Boolean
	"""
	neq comparison operator
	"""
	isDisabled_neq: Boolean
	"""
	exists comparison operator
	"""
	isAdmin_exists: Boolean
	"""
	eq comparison operator
	"""
	isAdmin_eq: Boolean
	"""
	neq comparison operator
	"""
	isAdmin_neq: Boolean
	"""
	exists comparison operator
	"""
	userDepartment_exists: Boolean
	"""
	eq comparison operator
	"""
	userDepartment_eq: Boolean
	"""
	neq comparison operator
	"""
	userDepartment_neq: Boolean
	"""
	exists comparison operator
	"""
	passwordMaxAge_exists: Boolean
	"""
	eq comparison operator
	"""
	passwordMaxAge_eq: Int
	"""
	neq comparison operator
	"""
	passwordMaxAge_neq: Int
	"""
	in comparison operator
	"""
	passwordMaxAge_in: [Int]
	"""
	not_in comparison operator
	"""
	passwordMaxAge_not_in: [Int]
	"""
	gt comparison operator
	"""
	passwordMaxAge_gt: Int
	"""
	gte comparison operator
	"""
	passwordMaxAge_gte: Int
	"""
	lt comparison operator
	"""
	passwordMaxAge_lt: Int
	"""
	lte comparison operator
	"""
	passwordMaxAge_lte: Int
	"""
	exists comparison operator
	"""
	interpreter_exists: Boolean
	"""
	not comparison operator
	"""
	interpreter_not: String
	"""
	eq comparison operator
	"""
	interpreter_eq: String
	"""
	neq comparison operator
	"""
	interpreter_neq: String
	"""
	in comparison operator
	"""
	interpreter_in: [String]
	"""
	not_in comparison operator
	"""
	interpreter_not_in: [String]
	"""
	like comparison operator
	"""
	interpreter_like: String
	"""
	not_like comparison operator
	"""
	interpreter_not_like: String
	"""
	ilike comparison operator
	"""
	interpreter_ilike: String
	"""
	not_ilike comparison operator
	"""
	interpreter_not_ilike: String
	"""
	suffix comparison operator
	"""
	interpreter_suffix: String
	"""
	prefix comparison operator
	"""
	interpreter_prefix: String
	AND: [adapter_device_user_bool_exp!]
	OR: [adapter_device_user_bool_exp!]
	NOT: [adapter_device_user_bool_exp!]
}
"""
Order for AdapterDeviceUser
"""
enum adapter_device_user_order_by {
	"""
	Order by sid in an ascending order
	"""
	sid_ASC
	"""
	Order by sid in a descending order
	"""
	sid_DESC
	"""
	Order by username in an ascending order
	"""
	username_ASC
	"""
	Order by username in a descending order
	"""
	username_DESC
	"""
	Order by lastUseDate in an ascending order
	"""
	lastUseDate_ASC
	"""
	Order by lastUseDate in a descending order
	"""
	lastUseDate_DESC
	"""
	Order by passwordMaxAge in an ascending order
	"""
	passwordMaxAge_ASC
	"""
	Order by passwordMaxAge in a descending order
	"""
	passwordMaxAge_DESC
	"""
	Order by interpreter in an ascending order
	"""
	interpreter_ASC
	"""
	Order by interpreter in a descending order
	"""
	interpreter_DESC
}
"""
Order for Adapter
"""
enum adapter_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
}
"""
Boolean filter expression for AdapterUser
"""
input adapter_user_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	eq comparison operator
	"""
	id_eq: UUID
	"""
	neq comparison operator
	"""
	id_neq: UUID
	"""
	in comparison operator
	"""
	id_in: [UUID]
	"""
	not_in comparison operator
	"""
	id_not_in: [UUID]
	"""
	gt comparison operator
	"""
	id_gt: UUID
	"""
	gte comparison operator
	"""
	id_gte: UUID
	"""
	lt comparison operator
	"""
	id_lt: UUID
	"""
	lte comparison operator
	"""
	id_lte: UUID
	"""
	exists comparison operator
	"""
	fetchCycle_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchCycle_eq: Int
	"""
	neq comparison operator
	"""
	fetchCycle_neq: Int
	"""
	in comparison operator
	"""
	fetchCycle_in: [Int]
	"""
	not_in comparison operator
	"""
	fetchCycle_not_in: [Int]
	"""
	gt comparison operator
	"""
	fetchCycle_gt: Int
	"""
	gte comparison operator
	"""
	fetchCycle_gte: Int
	"""
	lt comparison operator
	"""
	fetchCycle_lt: Int
	"""
	lte comparison operator
	"""
	fetchCycle_lte: Int
	"""
	eq comparison operator
	"""
	adapterId_eq: AdapterType
	"""
	neq comparison operator
	"""
	adapterId_neq: AdapterType
	"""
	in comparison operator
	"""
	adapterId_in: [AdapterType]
	"""
	not_in comparison operator
	"""
	adapterId_not_in: [AdapterType]
	"""
	filter by adapter
	"""
	adapter: adapter_bool_exp
	"""
	exists comparison operator
	"""
	adapterName_exists: Boolean
	"""
	not comparison operator
	"""
	adapterName_not: String
	"""
	eq comparison operator
	"""
	adapterName_eq: String
	"""
	neq comparison operator
	"""
	adapterName_neq: String
	"""
	in comparison operator
	"""
	adapterName_in: [String]
	"""
	not_in comparison operator
	"""
	adapterName_not_in: [String]
	"""
	like comparison operator
	"""
	adapterName_like: String
	"""
	not_like comparison operator
	"""
	adapterName_not_like: String
	"""
	ilike comparison operator
	"""
	adapterName_ilike: String
	"""
	not_ilike comparison operator
	"""
	adapterName_not_ilike: String
	"""
	suffix comparison operator
	"""
	adapterName_suffix: String
	"""
	prefix comparison operator
	"""
	adapterName_prefix: String
	"""
	exists comparison operator
	"""
	userId_exists: Boolean
	"""
	eq comparison operator
	"""
	userId_eq: UUID
	"""
	neq comparison operator
	"""
	userId_neq: UUID
	"""
	in comparison operator
	"""
	userId_in: [UUID]
	"""
	not_in comparison operator
	"""
	userId_not_in: [UUID]
	"""
	gt comparison operator
	"""
	userId_gt: UUID
	"""
	gte comparison operator
	"""
	userId_gte: UUID
	"""
	lt comparison operator
	"""
	userId_lt: UUID
	"""
	lte comparison operator
	"""
	userId_lte: UUID
	"""
	filter by adapterData
	"""
	adapterData: adapter_data_bool_exp
	"""
	exists comparison operator
	"""
	fetchTime_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchTime_eq: Epoch
	"""
	neq comparison operator
	"""
	fetchTime_neq: Epoch
	"""
	in comparison operator
	"""
	fetchTime_in: [Epoch]
	"""
	not_in comparison operator
	"""
	fetchTime_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	fetchTime_gt: Epoch
	"""
	gte comparison operator
	"""
	fetchTime_gte: Epoch
	"""
	lt comparison operator
	"""
	fetchTime_lt: Epoch
	"""
	lte comparison operator
	"""
	fetchTime_lte: Epoch
	"""
	days comparison operator
	"""
	fetchTime_days: Int
	"""
	exists comparison operator
	"""
	lastSeen_exists: Boolean
	"""
	eq comparison operator
	"""
	lastSeen_eq: Epoch
	"""
	neq comparison operator
	"""
	lastSeen_neq: Epoch
	"""
	in comparison operator
	"""
	lastSeen_in: [Epoch]
	"""
	not_in comparison operator
	"""
	lastSeen_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	lastSeen_gt: Epoch
	"""
	gte comparison operator
	"""
	lastSeen_gte: Epoch
	"""
	lt comparison operator
	"""
	lastSeen_lt: Epoch
	"""
	lte comparison operator
	"""
	lastSeen_lte: Epoch
	"""
	days comparison operator
	"""
	lastSeen_days: Int
	"""
	exists comparison operator
	"""
	username_exists: Boolean
	"""
	not comparison operator
	"""
	username_not: String
	"""
	eq comparison operator
	"""
	username_eq: String
	"""
	neq comparison operator
	"""
	username_neq: String
	"""
	in comparison operator
	"""
	username_in: [String]
	"""
	not_in comparison operator
	"""
	username_not_in: [String]
	"""
	like comparison operator
	"""
	username_like: String
	"""
	not_like comparison operator
	"""
	username_not_like: String
	"""
	ilike comparison operator
	"""
	username_ilike: String
	"""
	not_ilike comparison operator
	"""
	username_not_ilike: String
	"""
	suffix comparison operator
	"""
	username_suffix: String
	"""
	prefix comparison operator
	"""
	username_prefix: String
	"""
	exists comparison operator
	"""
	firstName_exists: Boolean
	"""
	not comparison operator
	"""
	firstName_not: String
	"""
	eq comparison operator
	"""
	firstName_eq: String
	"""
	neq comparison operator
	"""
	firstName_neq: String
	"""
	in comparison operator
	"""
	firstName_in: [String]
	"""
	not_in comparison operator
	"""
	firstName_not_in: [String]
	"""
	like comparison operator
	"""
	firstName_like: String
	"""
	not_like comparison operator
	"""
	firstName_not_like: String
	"""
	ilike comparison operator
	"""
	firstName_ilike: String
	"""
	not_ilike comparison operator
	"""
	firstName_not_ilike: String
	"""
	suffix comparison operator
	"""
	firstName_suffix: String
	"""
	prefix comparison operator
	"""
	firstName_prefix: String
	"""
	exists comparison operator
	"""
	lastName_exists: Boolean
	"""
	not comparison operator
	"""
	lastName_not: String
	"""
	eq comparison operator
	"""
	lastName_eq: String
	"""
	neq comparison operator
	"""
	lastName_neq: String
	"""
	in comparison operator
	"""
	lastName_in: [String]
	"""
	not_in comparison operator
	"""
	lastName_not_in: [String]
	"""
	like comparison operator
	"""
	lastName_like: String
	"""
	not_like comparison operator
	"""
	lastName_not_like: String
	"""
	ilike comparison operator
	"""
	lastName_ilike: String
	"""
	not_ilike comparison operator
	"""
	lastName_not_ilike: String
	"""
	suffix comparison operator
	"""
	lastName_suffix: String
	"""
	prefix comparison operator
	"""
	lastName_prefix: String
	"""
	exists comparison operator
	"""
	mail_exists: Boolean
	"""
	not comparison operator
	"""
	mail_not: String
	"""
	eq comparison operator
	"""
	mail_eq: String
	"""
	neq comparison operator
	"""
	mail_neq: String
	"""
	in comparison operator
	"""
	mail_in: [String]
	"""
	not_in comparison operator
	"""
	mail_not_in: [String]
	"""
	like comparison operator
	"""
	mail_like: String
	"""
	not_like comparison operator
	"""
	mail_not_like: String
	"""
	ilike comparison operator
	"""
	mail_ilike: String
	"""
	not_ilike comparison operator
	"""
	mail_not_ilike: String
	"""
	suffix comparison operator
	"""
	mail_suffix: String
	"""
	prefix comparison operator
	"""
	mail_prefix: String
	"""
	exists comparison operator
	"""
	admin_exists: Boolean
	"""
	eq comparison operator
	"""
	admin_eq: Boolean
	"""
	neq comparison operator
	"""
	admin_neq: Boolean
	"""
	exists comparison operator
	"""
	local_exists: Boolean
	"""
	eq comparison operator
	"""
	local_eq: Boolean
	"""
	neq comparison operator
	"""
	local_neq: Boolean
	"""
	exists comparison operator
	"""
	delegated_admin_exists: Boolean
	"""
	eq comparison operator
	"""
	delegated_admin_eq: Boolean
	"""
	neq comparison operator
	"""
	delegated_admin_neq: Boolean
	"""
	exists comparison operator
	"""
	mfa_enforced_exists: Boolean
	"""
	eq comparison operator
	"""
	mfa_enforced_eq: Boolean
	"""
	neq comparison operator
	"""
	mfa_enforced_neq: Boolean
	"""
	exists comparison operator
	"""
	mfa_enrolled_exists: Boolean
	"""
	eq comparison operator
	"""
	mfa_enrolled_eq: Boolean
	"""
	neq comparison operator
	"""
	mfa_enrolled_neq: Boolean
	"""
	exists comparison operator
	"""
	suspended_exists: Boolean
	"""
	eq comparison operator
	"""
	suspended_eq: Boolean
	"""
	neq comparison operator
	"""
	suspended_neq: Boolean
	"""
	exists comparison operator
	"""
	locked_exists: Boolean
	"""
	eq comparison operator
	"""
	locked_eq: Boolean
	"""
	neq comparison operator
	"""
	locked_neq: Boolean
	"""
	exists comparison operator
	"""
	disabled_exists: Boolean
	"""
	eq comparison operator
	"""
	disabled_eq: Boolean
	"""
	neq comparison operator
	"""
	disabled_neq: Boolean
	AND: [adapter_user_bool_exp!]
	OR: [adapter_user_bool_exp!]
	NOT: [adapter_user_bool_exp!]
}
"""
Order for AdapterUser
"""
enum adapter_user_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterName in an ascending order
	"""
	adapterName_ASC
	"""
	Order by adapterName in a descending order
	"""
	adapterName_DESC
	"""
	Order by fetchTime in an ascending order
	"""
	fetchTime_ASC
	"""
	Order by fetchTime in a descending order
	"""
	fetchTime_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
	"""
	Order by username in an ascending order
	"""
	username_ASC
	"""
	Order by username in a descending order
	"""
	username_DESC
	"""
	Order by firstName in an ascending order
	"""
	firstName_ASC
	"""
	Order by firstName in a descending order
	"""
	firstName_DESC
	"""
	Order by lastName in an ascending order
	"""
	lastName_ASC
	"""
	Order by lastName in a descending order
	"""
	lastName_DESC
	"""
	Order by mail in an ascending order
	"""
	mail_ASC
	"""
	Order by mail in a descending order
	"""
	mail_DESC
}
type csGroup @generateInputs(where: "cs_group_bool_exp", orderBy: "cs_group_order_by") {
	id: String
	name: String
	createdBy: String
	createdTimestamp: Epoch
	description: String
	groupType: String
	modifiedBy: String
	modifiedTime: Epoch
}
type csPolicy @generateInputs(where: "cs_policy_bool_exp", orderBy: "cs_policy_order_by") {
	name: String
	description: String
	platformName: String
	groups("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [csGroup]
	enabled: Boolean
	createdBy: String
	createdTime: Epoch
	preventionSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_prevention_settings_bool_exp): [csPreventionSettings]
	sensorUpdateSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_sensor_update_settings_bool_exp): [csSensorUpdateSettings]
	"""
	Returns aggregate of groups
	"""
	groups_aggregate("""
	group by columns
	"""
	groupBy: [groups_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [groups_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [groupsAggregate!]
	"""
	Returns aggregate of preventionSettings
	"""
	preventionSettings_aggregate("""
	group by columns
	"""
	groupBy: [preventionSettings_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [preventionSettings_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_prevention_settings_bool_exp): [preventionSettingsAggregate!]
	"""
	Returns aggregate of sensorUpdateSettings
	"""
	sensorUpdateSettings_aggregate("""
	group by columns
	"""
	groupBy: [sensorUpdateSettings_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [sensorUpdateSettings_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_sensor_update_settings_bool_exp): [sensorUpdateSettingsAggregate!]
}
type csPolicySettings @generateInputs(where: "cs_policy_settings_bool_exp", orderBy: "cs_policy_settings_order_by") {
	enabled: Boolean
}
type csPreventionSettings @generateInputs(where: "cs_prevention_settings_bool_exp", orderBy: "cs_prevention_settings_order_by") {
	name: String
	settings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_policy_settings_bool_exp): [csPolicySettings]
}
type csSensorUpdateSettings @generateInputs(where: "cs_sensor_update_settings_bool_exp", orderBy: "cs_sensor_update_settings_order_by") {
	build: String
}
"""
Boolean filter expression for csGroup
"""
input cs_group_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	not comparison operator
	"""
	id_not: String
	"""
	eq comparison operator
	"""
	id_eq: String
	"""
	neq comparison operator
	"""
	id_neq: String
	"""
	in comparison operator
	"""
	id_in: [String]
	"""
	not_in comparison operator
	"""
	id_not_in: [String]
	"""
	like comparison operator
	"""
	id_like: String
	"""
	not_like comparison operator
	"""
	id_not_like: String
	"""
	ilike comparison operator
	"""
	id_ilike: String
	"""
	not_ilike comparison operator
	"""
	id_not_ilike: String
	"""
	suffix comparison operator
	"""
	id_suffix: String
	"""
	prefix comparison operator
	"""
	id_prefix: String
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	createdBy_exists: Boolean
	"""
	not comparison operator
	"""
	createdBy_not: String
	"""
	eq comparison operator
	"""
	createdBy_eq: String
	"""
	neq comparison operator
	"""
	createdBy_neq: String
	"""
	in comparison operator
	"""
	createdBy_in: [String]
	"""
	not_in comparison operator
	"""
	createdBy_not_in: [String]
	"""
	like comparison operator
	"""
	createdBy_like: String
	"""
	not_like comparison operator
	"""
	createdBy_not_like: String
	"""
	ilike comparison operator
	"""
	createdBy_ilike: String
	"""
	not_ilike comparison operator
	"""
	createdBy_not_ilike: String
	"""
	suffix comparison operator
	"""
	createdBy_suffix: String
	"""
	prefix comparison operator
	"""
	createdBy_prefix: String
	"""
	exists comparison operator
	"""
	createdTimestamp_exists: Boolean
	"""
	eq comparison operator
	"""
	createdTimestamp_eq: Epoch
	"""
	neq comparison operator
	"""
	createdTimestamp_neq: Epoch
	"""
	in comparison operator
	"""
	createdTimestamp_in: [Epoch]
	"""
	not_in comparison operator
	"""
	createdTimestamp_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	createdTimestamp_gt: Epoch
	"""
	gte comparison operator
	"""
	createdTimestamp_gte: Epoch
	"""
	lt comparison operator
	"""
	createdTimestamp_lt: Epoch
	"""
	lte comparison operator
	"""
	createdTimestamp_lte: Epoch
	"""
	days comparison operator
	"""
	createdTimestamp_days: Int
	"""
	exists comparison operator
	"""
	description_exists: Boolean
	"""
	not comparison operator
	"""
	description_not: String
	"""
	eq comparison operator
	"""
	description_eq: String
	"""
	neq comparison operator
	"""
	description_neq: String
	"""
	in comparison operator
	"""
	description_in: [String]
	"""
	not_in comparison operator
	"""
	description_not_in: [String]
	"""
	like comparison operator
	"""
	description_like: String
	"""
	not_like comparison operator
	"""
	description_not_like: String
	"""
	ilike comparison operator
	"""
	description_ilike: String
	"""
	not_ilike comparison operator
	"""
	description_not_ilike: String
	"""
	suffix comparison operator
	"""
	description_suffix: String
	"""
	prefix comparison operator
	"""
	description_prefix: String
	"""
	exists comparison operator
	"""
	groupType_exists: Boolean
	"""
	not comparison operator
	"""
	groupType_not: String
	"""
	eq comparison operator
	"""
	groupType_eq: String
	"""
	neq comparison operator
	"""
	groupType_neq: String
	"""
	in comparison operator
	"""
	groupType_in: [String]
	"""
	not_in comparison operator
	"""
	groupType_not_in: [String]
	"""
	like comparison operator
	"""
	groupType_like: String
	"""
	not_like comparison operator
	"""
	groupType_not_like: String
	"""
	ilike comparison operator
	"""
	groupType_ilike: String
	"""
	not_ilike comparison operator
	"""
	groupType_not_ilike: String
	"""
	suffix comparison operator
	"""
	groupType_suffix: String
	"""
	prefix comparison operator
	"""
	groupType_prefix: String
	"""
	exists comparison operator
	"""
	modifiedBy_exists: Boolean
	"""
	not comparison operator
	"""
	modifiedBy_not: String
	"""
	eq comparison operator
	"""
	modifiedBy_eq: String
	"""
	neq comparison operator
	"""
	modifiedBy_neq: String
	"""
	in comparison operator
	"""
	modifiedBy_in: [String]
	"""
	not_in comparison operator
	"""
	modifiedBy_not_in: [String]
	"""
	like comparison operator
	"""
	modifiedBy_like: String
	"""
	not_like comparison operator
	"""
	modifiedBy_not_like: String
	"""
	ilike comparison operator
	"""
	modifiedBy_ilike: String
	"""
	not_ilike comparison operator
	"""
	modifiedBy_not_ilike: String
	"""
	suffix comparison operator
	"""
	modifiedBy_suffix: String
	"""
	prefix comparison operator
	"""
	modifiedBy_prefix: String
	"""
	exists comparison operator
	"""
	modifiedTime_exists: Boolean
	"""
	eq comparison operator
	"""
	modifiedTime_eq: Epoch
	"""
	neq comparison operator
	"""
	modifiedTime_neq: Epoch
	"""
	in comparison operator
	"""
	modifiedTime_in: [Epoch]
	"""
	not_in comparison operator
	"""
	modifiedTime_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	modifiedTime_gt: Epoch
	"""
	gte comparison operator
	"""
	modifiedTime_gte: Epoch
	"""
	lt comparison operator
	"""
	modifiedTime_lt: Epoch
	"""
	lte comparison operator
	"""
	modifiedTime_lte: Epoch
	"""
	days comparison operator
	"""
	modifiedTime_days: Int
	AND: [cs_group_bool_exp!]
	OR: [cs_group_bool_exp!]
	NOT: [cs_group_bool_exp!]
}
"""
Order for csGroup
"""
enum cs_group_order_by {
	"""
	Order by id in an ascending order
	"""
	id_ASC
	"""
	Order by id in a descending order
	"""
	id_DESC
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by createdBy in an ascending order
	"""
	createdBy_ASC
	"""
	Order by createdBy in a descending order
	"""
	createdBy_DESC
	"""
	Order by createdTimestamp in an ascending order
	"""
	createdTimestamp_ASC
	"""
	Order by createdTimestamp in a descending order
	"""
	createdTimestamp_DESC
	"""
	Order by description in an ascending order
	"""
	description_ASC
	"""
	Order by description in a descending order
	"""
	description_DESC
	"""
	Order by groupType in an ascending order
	"""
	groupType_ASC
	"""
	Order by groupType in a descending order
	"""
	groupType_DESC
	"""
	Order by modifiedBy in an ascending order
	"""
	modifiedBy_ASC
	"""
	Order by modifiedBy in a descending order
	"""
	modifiedBy_DESC
	"""
	Order by modifiedTime in an ascending order
	"""
	modifiedTime_ASC
	"""
	Order by modifiedTime in a descending order
	"""
	modifiedTime_DESC
}
"""
Boolean filter expression for csPolicy
"""
input cs_policy_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	description_exists: Boolean
	"""
	not comparison operator
	"""
	description_not: String
	"""
	eq comparison operator
	"""
	description_eq: String
	"""
	neq comparison operator
	"""
	description_neq: String
	"""
	in comparison operator
	"""
	description_in: [String]
	"""
	not_in comparison operator
	"""
	description_not_in: [String]
	"""
	like comparison operator
	"""
	description_like: String
	"""
	not_like comparison operator
	"""
	description_not_like: String
	"""
	ilike comparison operator
	"""
	description_ilike: String
	"""
	not_ilike comparison operator
	"""
	description_not_ilike: String
	"""
	suffix comparison operator
	"""
	description_suffix: String
	"""
	prefix comparison operator
	"""
	description_prefix: String
	"""
	exists comparison operator
	"""
	platformName_exists: Boolean
	"""
	not comparison operator
	"""
	platformName_not: String
	"""
	eq comparison operator
	"""
	platformName_eq: String
	"""
	neq comparison operator
	"""
	platformName_neq: String
	"""
	in comparison operator
	"""
	platformName_in: [String]
	"""
	not_in comparison operator
	"""
	platformName_not_in: [String]
	"""
	like comparison operator
	"""
	platformName_like: String
	"""
	not_like comparison operator
	"""
	platformName_not_like: String
	"""
	ilike comparison operator
	"""
	platformName_ilike: String
	"""
	not_ilike comparison operator
	"""
	platformName_not_ilike: String
	"""
	suffix comparison operator
	"""
	platformName_suffix: String
	"""
	prefix comparison operator
	"""
	platformName_prefix: String
	"""
	filter by groups
	"""
	groups: cs_group_bool_exp
	"""
	exists comparison operator
	"""
	enabled_exists: Boolean
	"""
	eq comparison operator
	"""
	enabled_eq: Boolean
	"""
	neq comparison operator
	"""
	enabled_neq: Boolean
	"""
	exists comparison operator
	"""
	createdBy_exists: Boolean
	"""
	not comparison operator
	"""
	createdBy_not: String
	"""
	eq comparison operator
	"""
	createdBy_eq: String
	"""
	neq comparison operator
	"""
	createdBy_neq: String
	"""
	in comparison operator
	"""
	createdBy_in: [String]
	"""
	not_in comparison operator
	"""
	createdBy_not_in: [String]
	"""
	like comparison operator
	"""
	createdBy_like: String
	"""
	not_like comparison operator
	"""
	createdBy_not_like: String
	"""
	ilike comparison operator
	"""
	createdBy_ilike: String
	"""
	not_ilike comparison operator
	"""
	createdBy_not_ilike: String
	"""
	suffix comparison operator
	"""
	createdBy_suffix: String
	"""
	prefix comparison operator
	"""
	createdBy_prefix: String
	"""
	exists comparison operator
	"""
	createdTime_exists: Boolean
	"""
	eq comparison operator
	"""
	createdTime_eq: Epoch
	"""
	neq comparison operator
	"""
	createdTime_neq: Epoch
	"""
	in comparison operator
	"""
	createdTime_in: [Epoch]
	"""
	not_in comparison operator
	"""
	createdTime_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	createdTime_gt: Epoch
	"""
	gte comparison operator
	"""
	createdTime_gte: Epoch
	"""
	lt comparison operator
	"""
	createdTime_lt: Epoch
	"""
	lte comparison operator
	"""
	createdTime_lte: Epoch
	"""
	days comparison operator
	"""
	createdTime_days: Int
	"""
	filter by preventionSettings
	"""
	preventionSettings: cs_prevention_settings_bool_exp
	"""
	filter by sensorUpdateSettings
	"""
	sensorUpdateSettings: cs_sensor_update_settings_bool_exp
	AND: [cs_policy_bool_exp!]
	OR: [cs_policy_bool_exp!]
	NOT: [cs_policy_bool_exp!]
}
"""
Order for csPolicy
"""
enum cs_policy_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by description in an ascending order
	"""
	description_ASC
	"""
	Order by description in a descending order
	"""
	description_DESC
	"""
	Order by platformName in an ascending order
	"""
	platformName_ASC
	"""
	Order by platformName in a descending order
	"""
	platformName_DESC
	"""
	Order by createdBy in an ascending order
	"""
	createdBy_ASC
	"""
	Order by createdBy in a descending order
	"""
	createdBy_DESC
	"""
	Order by createdTime in an ascending order
	"""
	createdTime_ASC
	"""
	Order by createdTime in a descending order
	"""
	createdTime_DESC
}
"""
Boolean filter expression for csPolicySettings
"""
input cs_policy_settings_bool_exp {
	"""
	exists comparison operator
	"""
	enabled_exists: Boolean
	"""
	eq comparison operator
	"""
	enabled_eq: Boolean
	"""
	neq comparison operator
	"""
	enabled_neq: Boolean
	AND: [cs_policy_settings_bool_exp!]
	OR: [cs_policy_settings_bool_exp!]
	NOT: [cs_policy_settings_bool_exp!]
}
"""
Boolean filter expression for csPreventionSettings
"""
input cs_prevention_settings_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	filter by settings
	"""
	settings: cs_policy_settings_bool_exp
	AND: [cs_prevention_settings_bool_exp!]
	OR: [cs_prevention_settings_bool_exp!]
	NOT: [cs_prevention_settings_bool_exp!]
}
"""
Order for csPreventionSettings
"""
enum cs_prevention_settings_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
}
"""
Boolean filter expression for csSensorUpdateSettings
"""
input cs_sensor_update_settings_bool_exp {
	"""
	exists comparison operator
	"""
	build_exists: Boolean
	"""
	not comparison operator
	"""
	build_not: String
	"""
	eq comparison operator
	"""
	build_eq: String
	"""
	neq comparison operator
	"""
	build_neq: String
	"""
	in comparison operator
	"""
	build_in: [String]
	"""
	not_in comparison operator
	"""
	build_not_in: [String]
	"""
	like comparison operator
	"""
	build_like: String
	"""
	not_like comparison operator
	"""
	build_not_like: String
	"""
	ilike comparison operator
	"""
	build_ilike: String
	"""
	not_ilike comparison operator
	"""
	build_not_ilike: String
	"""
	suffix comparison operator
	"""
	build_suffix: String
	"""
	prefix comparison operator
	"""
	build_prefix: String
	AND: [cs_sensor_update_settings_bool_exp!]
	OR: [cs_sensor_update_settings_bool_exp!]
	NOT: [cs_sensor_update_settings_bool_exp!]
}
"""
Order for csSensorUpdateSettings
"""
enum cs_sensor_update_settings_order_by {
	"""
	Order by build in an ascending order
	"""
	build_ASC
	"""
	Order by build in a descending order
	"""
	build_DESC
}
"""
Boolean filter expression for Device
"""
input device_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	eq comparison operator
	"""
	id_eq: UUID
	"""
	neq comparison operator
	"""
	id_neq: UUID
	"""
	in comparison operator
	"""
	id_in: [UUID]
	"""
	not_in comparison operator
	"""
	id_not_in: [UUID]
	"""
	gt comparison operator
	"""
	id_gt: UUID
	"""
	gte comparison operator
	"""
	id_gte: UUID
	"""
	lt comparison operator
	"""
	id_lt: UUID
	"""
	lte comparison operator
	"""
	id_lte: UUID
	"""
	exists comparison operator
	"""
	fetchCycle_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchCycle_eq: Int
	"""
	neq comparison operator
	"""
	fetchCycle_neq: Int
	"""
	in comparison operator
	"""
	fetchCycle_in: [Int]
	"""
	not_in comparison operator
	"""
	fetchCycle_not_in: [Int]
	"""
	gt comparison operator
	"""
	fetchCycle_gt: Int
	"""
	gte comparison operator
	"""
	fetchCycle_gte: Int
	"""
	lt comparison operator
	"""
	fetchCycle_lt: Int
	"""
	lte comparison operator
	"""
	fetchCycle_lte: Int
	"""
	exists comparison operator
	"""
	adapterCount_exists: Boolean
	"""
	eq comparison operator
	"""
	adapterCount_eq: Int
	"""
	neq comparison operator
	"""
	adapterCount_neq: Int
	"""
	in comparison operator
	"""
	adapterCount_in: [Int]
	"""
	not_in comparison operator
	"""
	adapterCount_not_in: [Int]
	"""
	gt comparison operator
	"""
	adapterCount_gt: Int
	"""
	gte comparison operator
	"""
	adapterCount_gte: Int
	"""
	lt comparison operator
	"""
	adapterCount_lt: Int
	"""
	lte comparison operator
	"""
	adapterCount_lte: Int
	"""
	contains comparison operator
	"""
	adapterNames_contains: [String]
	"""
	contained_by comparison operator
	"""
	adapterNames_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adapterNames_overlap: [String]
	"""
	size comparison operator
	"""
	adapterNames_size: Int
	"""
	contains_regex comparison operator
	"""
	adapterNames_contains_regex: String
	"""
	contains comparison operator
	"""
	hostnames_contains: [String]
	"""
	contained_by comparison operator
	"""
	hostnames_contained_by: [String]
	"""
	overlap comparison operator
	"""
	hostnames_overlap: [String]
	"""
	size comparison operator
	"""
	hostnames_size: Int
	"""
	contains_regex comparison operator
	"""
	hostnames_contains_regex: String
	"""
	exists comparison operator
	"""
	lastSeen_exists: Boolean
	"""
	eq comparison operator
	"""
	lastSeen_eq: Epoch
	"""
	neq comparison operator
	"""
	lastSeen_neq: Epoch
	"""
	in comparison operator
	"""
	lastSeen_in: [Epoch]
	"""
	not_in comparison operator
	"""
	lastSeen_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	lastSeen_gt: Epoch
	"""
	gte comparison operator
	"""
	lastSeen_gte: Epoch
	"""
	lt comparison operator
	"""
	lastSeen_lt: Epoch
	"""
	lte comparison operator
	"""
	lastSeen_lte: Epoch
	"""
	days comparison operator
	"""
	lastSeen_days: Int
	"""
	filter by adapterDevices
	"""
	adapterDevices: adapter_device_bool_exp
	"""
	filter by interfaces
	"""
	interfaces: network_interface_bool_exp
	"""
	filter by tags
	"""
	tags: tag_bool_exp
	AND: [device_bool_exp!]
	OR: [device_bool_exp!]
	NOT: [device_bool_exp!]
}
"""
Order for Device
"""
enum device_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterCount in an ascending order
	"""
	adapterCount_ASC
	"""
	Order by adapterCount in a descending order
	"""
	adapterCount_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
}
type devicesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_max_columns!]!): Map
	devices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: device_bool_exp): [Device]
}
enum devices_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by adapterCount
	"""
	adapterCount
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterCount
	"""
	adapterCount
	"""
	groupBy by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterCount
	"""
	adapterCount
	"""
	max by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterCount
	"""
	adapterCount
	"""
	min by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by adapterCount
	"""
	adapterCount
	"""
	sum by lastSeen
	"""
	lastSeen
}
type firewallRulesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_max_columns!]!): Map
	"""
	Firewall rules defined on this adapter device
	"""
	firewallRules("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: firewall_rule_bool_exp): [FirewallRule] @relation(name: "adapter_device_firewall_rules", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "firewall_rules", joinOn: ["name"])
}
enum firewallRules_aggregate_avg_columns {
	"""
	avg by srcPort
	"""
	srcPort
	"""
	avg by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_columns {
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by source
	"""
	source
	"""
	groupBy by target
	"""
	target
	"""
	groupBy by protocol
	"""
	protocol
	"""
	groupBy by srcPort
	"""
	srcPort
	"""
	groupBy by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_max_columns {
	"""
	max by name
	"""
	name
	"""
	max by source
	"""
	source
	"""
	max by target
	"""
	target
	"""
	max by protocol
	"""
	protocol
	"""
	max by srcPort
	"""
	srcPort
	"""
	max by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_min_columns {
	"""
	min by name
	"""
	name
	"""
	min by source
	"""
	source
	"""
	min by target
	"""
	target
	"""
	min by protocol
	"""
	protocol
	"""
	min by srcPort
	"""
	srcPort
	"""
	min by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_sum_columns {
	"""
	sum by srcPort
	"""
	srcPort
	"""
	sum by dstPort
	"""
	dstPort
}
"""
Boolean filter expression for FirewallRule
"""
input firewall_rule_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	source_exists: Boolean
	"""
	not comparison operator
	"""
	source_not: String
	"""
	eq comparison operator
	"""
	source_eq: String
	"""
	neq comparison operator
	"""
	source_neq: String
	"""
	in comparison operator
	"""
	source_in: [String]
	"""
	not_in comparison operator
	"""
	source_not_in: [String]
	"""
	like comparison operator
	"""
	source_like: String
	"""
	not_like comparison operator
	"""
	source_not_like: String
	"""
	ilike comparison operator
	"""
	source_ilike: String
	"""
	not_ilike comparison operator
	"""
	source_not_ilike: String
	"""
	suffix comparison operator
	"""
	source_suffix: String
	"""
	prefix comparison operator
	"""
	source_prefix: String
	"""
	eq comparison operator
	"""
	type_eq: AccessType
	"""
	neq comparison operator
	"""
	type_neq: AccessType
	"""
	in comparison operator
	"""
	type_in: [AccessType]
	"""
	not_in comparison operator
	"""
	type_not_in: [AccessType]
	"""
	eq comparison operator
	"""
	direction_eq: Direction
	"""
	neq comparison operator
	"""
	direction_neq: Direction
	"""
	in comparison operator
	"""
	direction_in: [Direction]
	"""
	not_in comparison operator
	"""
	direction_not_in: [Direction]
	"""
	exists comparison operator
	"""
	target_exists: Boolean
	"""
	not comparison operator
	"""
	target_not: String
	"""
	eq comparison operator
	"""
	target_eq: String
	"""
	neq comparison operator
	"""
	target_neq: String
	"""
	in comparison operator
	"""
	target_in: [String]
	"""
	not_in comparison operator
	"""
	target_not_in: [String]
	"""
	like comparison operator
	"""
	target_like: String
	"""
	not_like comparison operator
	"""
	target_not_like: String
	"""
	ilike comparison operator
	"""
	target_ilike: String
	"""
	not_ilike comparison operator
	"""
	target_not_ilike: String
	"""
	suffix comparison operator
	"""
	target_suffix: String
	"""
	prefix comparison operator
	"""
	target_prefix: String
	"""
	exists comparison operator
	"""
	protocol_exists: Boolean
	"""
	not comparison operator
	"""
	protocol_not: String
	"""
	eq comparison operator
	"""
	protocol_eq: String
	"""
	neq comparison operator
	"""
	protocol_neq: String
	"""
	in comparison operator
	"""
	protocol_in: [String]
	"""
	not_in comparison operator
	"""
	protocol_not_in: [String]
	"""
	like comparison operator
	"""
	protocol_like: String
	"""
	not_like comparison operator
	"""
	protocol_not_like: String
	"""
	ilike comparison operator
	"""
	protocol_ilike: String
	"""
	not_ilike comparison operator
	"""
	protocol_not_ilike: String
	"""
	suffix comparison operator
	"""
	protocol_suffix: String
	"""
	prefix comparison operator
	"""
	protocol_prefix: String
	"""
	exists comparison operator
	"""
	srcPort_exists: Boolean
	"""
	eq comparison operator
	"""
	srcPort_eq: Int
	"""
	neq comparison operator
	"""
	srcPort_neq: Int
	"""
	in comparison operator
	"""
	srcPort_in: [Int]
	"""
	not_in comparison operator
	"""
	srcPort_not_in: [Int]
	"""
	gt comparison operator
	"""
	srcPort_gt: Int
	"""
	gte comparison operator
	"""
	srcPort_gte: Int
	"""
	lt comparison operator
	"""
	srcPort_lt: Int
	"""
	lte comparison operator
	"""
	srcPort_lte: Int
	"""
	exists comparison operator
	"""
	dstPort_exists: Boolean
	"""
	eq comparison operator
	"""
	dstPort_eq: Int
	"""
	neq comparison operator
	"""
	dstPort_neq: Int
	"""
	in comparison operator
	"""
	dstPort_in: [Int]
	"""
	not_in comparison operator
	"""
	dstPort_not_in: [Int]
	"""
	gt comparison operator
	"""
	dstPort_gt: Int
	"""
	gte comparison operator
	"""
	dstPort_gte: Int
	"""
	lt comparison operator
	"""
	dstPort_lt: Int
	"""
	lte comparison operator
	"""
	dstPort_lte: Int
	AND: [firewall_rule_bool_exp!]
	OR: [firewall_rule_bool_exp!]
	NOT: [firewall_rule_bool_exp!]
}
"""
Order for FirewallRule
"""
enum firewall_rule_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by source in an ascending order
	"""
	source_ASC
	"""
	Order by source in a descending order
	"""
	source_DESC
	"""
	Order by target in an ascending order
	"""
	target_ASC
	"""
	Order by target in a descending order
	"""
	target_DESC
	"""
	Order by protocol in an ascending order
	"""
	protocol_ASC
	"""
	Order by protocol in a descending order
	"""
	protocol_DESC
	"""
	Order by srcPort in an ascending order
	"""
	srcPort_ASC
	"""
	Order by srcPort in a descending order
	"""
	srcPort_DESC
	"""
	Order by dstPort in an ascending order
	"""
	dstPort_ASC
	"""
	Order by dstPort in a descending order
	"""
	dstPort_DESC
}
"""
Boolean filter expression for GceTags
"""
input gce_tags_bool_exp {
	"""
	exists comparison operator
	"""
	gceKey_exists: Boolean
	"""
	not comparison operator
	"""
	gceKey_not: String
	"""
	eq comparison operator
	"""
	gceKey_eq: String
	"""
	neq comparison operator
	"""
	gceKey_neq: String
	"""
	in comparison operator
	"""
	gceKey_in: [String]
	"""
	not_in comparison operator
	"""
	gceKey_not_in: [String]
	"""
	like comparison operator
	"""
	gceKey_like: String
	"""
	not_like comparison operator
	"""
	gceKey_not_like: String
	"""
	ilike comparison operator
	"""
	gceKey_ilike: String
	"""
	not_ilike comparison operator
	"""
	gceKey_not_ilike: String
	"""
	suffix comparison operator
	"""
	gceKey_suffix: String
	"""
	prefix comparison operator
	"""
	gceKey_prefix: String
	"""
	exists comparison operator
	"""
	gceValue_exists: Boolean
	"""
	not comparison operator
	"""
	gceValue_not: String
	"""
	eq comparison operator
	"""
	gceValue_eq: String
	"""
	neq comparison operator
	"""
	gceValue_neq: String
	"""
	in comparison operator
	"""
	gceValue_in: [String]
	"""
	not_in comparison operator
	"""
	gceValue_not_in: [String]
	"""
	like comparison operator
	"""
	gceValue_like: String
	"""
	not_like comparison operator
	"""
	gceValue_not_like: String
	"""
	ilike comparison operator
	"""
	gceValue_ilike: String
	"""
	not_ilike comparison operator
	"""
	gceValue_not_ilike: String
	"""
	suffix comparison operator
	"""
	gceValue_suffix: String
	"""
	prefix comparison operator
	"""
	gceValue_prefix: String
	AND: [gce_tags_bool_exp!]
	OR: [gce_tags_bool_exp!]
	NOT: [gce_tags_bool_exp!]
}
"""
Order for GceTags
"""
enum gce_tags_order_by {
	"""
	Order by gceKey in an ascending order
	"""
	gceKey_ASC
	"""
	Order by gceKey in a descending order
	"""
	gceKey_DESC
	"""
	Order by gceValue in an ascending order
	"""
	gceValue_ASC
	"""
	Order by gceValue in a descending order
	"""
	gceValue_DESC
}
type groupsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_max_columns!]!): Map
	groups("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [csGroup]
}
enum groups_aggregate_avg_columns {
	"""
	avg by createdTimestamp
	"""
	createdTimestamp
	"""
	avg by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by createdBy
	"""
	createdBy
	"""
	groupBy by createdTimestamp
	"""
	createdTimestamp
	"""
	groupBy by description
	"""
	description
	"""
	groupBy by groupType
	"""
	groupType
	"""
	groupBy by modifiedBy
	"""
	modifiedBy
	"""
	groupBy by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by name
	"""
	name
	"""
	max by createdBy
	"""
	createdBy
	"""
	max by createdTimestamp
	"""
	createdTimestamp
	"""
	max by description
	"""
	description
	"""
	max by groupType
	"""
	groupType
	"""
	max by modifiedBy
	"""
	modifiedBy
	"""
	max by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by name
	"""
	name
	"""
	min by createdBy
	"""
	createdBy
	"""
	min by createdTimestamp
	"""
	createdTimestamp
	"""
	min by description
	"""
	description
	"""
	min by groupType
	"""
	groupType
	"""
	min by modifiedBy
	"""
	modifiedBy
	"""
	min by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_sum_columns {
	"""
	sum by createdTimestamp
	"""
	createdTimestamp
	"""
	sum by modifiedTime
	"""
	modifiedTime
}
type installedSoftwareAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_max_columns!]!): Map
	"""
	Software installed on this device
	"""
	installedSoftware("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: installed_software_bool_exp): [InstalledSoftware] @relation(name: "adapter_device_installed_software", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "installed_software", joinOn: ["name","version"])
}
enum installedSoftware_aggregate_avg_columns {
	"""
	avg by cveCount
	"""
	cveCount
}
enum installedSoftware_aggregate_columns {
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by version
	"""
	version
	"""
	groupBy by description
	"""
	description
	"""
	groupBy by vendor
	"""
	vendor
	"""
	groupBy by publisher
	"""
	publisher
	"""
	groupBy by cveCount
	"""
	cveCount
	"""
	groupBy by swLicense
	"""
	swLicense
	"""
	groupBy by path
	"""
	path
}
enum installedSoftware_aggregate_max_columns {
	"""
	max by name
	"""
	name
	"""
	max by version
	"""
	version
	"""
	max by description
	"""
	description
	"""
	max by vendor
	"""
	vendor
	"""
	max by publisher
	"""
	publisher
	"""
	max by cveCount
	"""
	cveCount
	"""
	max by swLicense
	"""
	swLicense
	"""
	max by path
	"""
	path
}
enum installedSoftware_aggregate_min_columns {
	"""
	min by name
	"""
	name
	"""
	min by version
	"""
	version
	"""
	min by description
	"""
	description
	"""
	min by vendor
	"""
	vendor
	"""
	min by publisher
	"""
	publisher
	"""
	min by cveCount
	"""
	cveCount
	"""
	min by swLicense
	"""
	swLicense
	"""
	min by path
	"""
	path
}
enum installedSoftware_aggregate_sum_columns {
	"""
	sum by cveCount
	"""
	cveCount
}
"""
Boolean filter expression for InstalledSoftware
"""
input installed_software_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	version_exists: Boolean
	"""
	not comparison operator
	"""
	version_not: String
	"""
	eq comparison operator
	"""
	version_eq: String
	"""
	neq comparison operator
	"""
	version_neq: String
	"""
	in comparison operator
	"""
	version_in: [String]
	"""
	not_in comparison operator
	"""
	version_not_in: [String]
	"""
	like comparison operator
	"""
	version_like: String
	"""
	not_like comparison operator
	"""
	version_not_like: String
	"""
	ilike comparison operator
	"""
	version_ilike: String
	"""
	not_ilike comparison operator
	"""
	version_not_ilike: String
	"""
	suffix comparison operator
	"""
	version_suffix: String
	"""
	prefix comparison operator
	"""
	version_prefix: String
	"""
	eq comparison operator
	"""
	architecture_eq: Architecture
	"""
	neq comparison operator
	"""
	architecture_neq: Architecture
	"""
	in comparison operator
	"""
	architecture_in: [Architecture]
	"""
	not_in comparison operator
	"""
	architecture_not_in: [Architecture]
	"""
	exists comparison operator
	"""
	description_exists: Boolean
	"""
	not comparison operator
	"""
	description_not: String
	"""
	eq comparison operator
	"""
	description_eq: String
	"""
	neq comparison operator
	"""
	description_neq: String
	"""
	in comparison operator
	"""
	description_in: [String]
	"""
	not_in comparison operator
	"""
	description_not_in: [String]
	"""
	like comparison operator
	"""
	description_like: String
	"""
	not_like comparison operator
	"""
	description_not_like: String
	"""
	ilike comparison operator
	"""
	description_ilike: String
	"""
	not_ilike comparison operator
	"""
	description_not_ilike: String
	"""
	suffix comparison operator
	"""
	description_suffix: String
	"""
	prefix comparison operator
	"""
	description_prefix: String
	"""
	exists comparison operator
	"""
	vendor_exists: Boolean
	"""
	not comparison operator
	"""
	vendor_not: String
	"""
	eq comparison operator
	"""
	vendor_eq: String
	"""
	neq comparison operator
	"""
	vendor_neq: String
	"""
	in comparison operator
	"""
	vendor_in: [String]
	"""
	not_in comparison operator
	"""
	vendor_not_in: [String]
	"""
	like comparison operator
	"""
	vendor_like: String
	"""
	not_like comparison operator
	"""
	vendor_not_like: String
	"""
	ilike comparison operator
	"""
	vendor_ilike: String
	"""
	not_ilike comparison operator
	"""
	vendor_not_ilike: String
	"""
	suffix comparison operator
	"""
	vendor_suffix: String
	"""
	prefix comparison operator
	"""
	vendor_prefix: String
	"""
	exists comparison operator
	"""
	publisher_exists: Boolean
	"""
	not comparison operator
	"""
	publisher_not: String
	"""
	eq comparison operator
	"""
	publisher_eq: String
	"""
	neq comparison operator
	"""
	publisher_neq: String
	"""
	in comparison operator
	"""
	publisher_in: [String]
	"""
	not_in comparison operator
	"""
	publisher_not_in: [String]
	"""
	like comparison operator
	"""
	publisher_like: String
	"""
	not_like comparison operator
	"""
	publisher_not_like: String
	"""
	ilike comparison operator
	"""
	publisher_ilike: String
	"""
	not_ilike comparison operator
	"""
	publisher_not_ilike: String
	"""
	suffix comparison operator
	"""
	publisher_suffix: String
	"""
	prefix comparison operator
	"""
	publisher_prefix: String
	"""
	exists comparison operator
	"""
	cveCount_exists: Boolean
	"""
	eq comparison operator
	"""
	cveCount_eq: Int
	"""
	neq comparison operator
	"""
	cveCount_neq: Int
	"""
	in comparison operator
	"""
	cveCount_in: [Int]
	"""
	not_in comparison operator
	"""
	cveCount_not_in: [Int]
	"""
	gt comparison operator
	"""
	cveCount_gt: Int
	"""
	gte comparison operator
	"""
	cveCount_gte: Int
	"""
	lt comparison operator
	"""
	cveCount_lt: Int
	"""
	lte comparison operator
	"""
	cveCount_lte: Int
	"""
	exists comparison operator
	"""
	swLicense_exists: Boolean
	"""
	not comparison operator
	"""
	swLicense_not: String
	"""
	eq comparison operator
	"""
	swLicense_eq: String
	"""
	neq comparison operator
	"""
	swLicense_neq: String
	"""
	in comparison operator
	"""
	swLicense_in: [String]
	"""
	not_in comparison operator
	"""
	swLicense_not_in: [String]
	"""
	like comparison operator
	"""
	swLicense_like: String
	"""
	not_like comparison operator
	"""
	swLicense_not_like: String
	"""
	ilike comparison operator
	"""
	swLicense_ilike: String
	"""
	not_ilike comparison operator
	"""
	swLicense_not_ilike: String
	"""
	suffix comparison operator
	"""
	swLicense_suffix: String
	"""
	prefix comparison operator
	"""
	swLicense_prefix: String
	"""
	exists comparison operator
	"""
	path_exists: Boolean
	"""
	not comparison operator
	"""
	path_not: String
	"""
	eq comparison operator
	"""
	path_eq: String
	"""
	neq comparison operator
	"""
	path_neq: String
	"""
	in comparison operator
	"""
	path_in: [String]
	"""
	not_in comparison operator
	"""
	path_not_in: [String]
	"""
	like comparison operator
	"""
	path_like: String
	"""
	not_like comparison operator
	"""
	path_not_like: String
	"""
	ilike comparison operator
	"""
	path_ilike: String
	"""
	not_ilike comparison operator
	"""
	path_not_ilike: String
	"""
	suffix comparison operator
	"""
	path_suffix: String
	"""
	prefix comparison operator
	"""
	path_prefix: String
	AND: [installed_software_bool_exp!]
	OR: [installed_software_bool_exp!]
	NOT: [installed_software_bool_exp!]
}
"""
Order for InstalledSoftware
"""
enum installed_software_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by version in an ascending order
	"""
	version_ASC
	"""
	Order by version in a descending order
	"""
	version_DESC
	"""
	Order by description in an ascending order
	"""
	description_ASC
	"""
	Order by description in a descending order
	"""
	description_DESC
	"""
	Order by vendor in an ascending order
	"""
	vendor_ASC
	"""
	Order by vendor in a descending order
	"""
	vendor_DESC
	"""
	Order by publisher in an ascending order
	"""
	publisher_ASC
	"""
	Order by publisher in a descending order
	"""
	publisher_DESC
	"""
	Order by cveCount in an ascending order
	"""
	cveCount_ASC
	"""
	Order by cveCount in a descending order
	"""
	cveCount_DESC
	"""
	Order by swLicense in an ascending order
	"""
	swLicense_ASC
	"""
	Order by swLicense in a descending order
	"""
	swLicense_DESC
	"""
	Order by path in an ascending order
	"""
	path_ASC
	"""
	Order by path in a descending order
	"""
	path_DESC
}
type interfacesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [interfaces_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [interfaces_aggregate_max_columns!]!): Map
	interfaces("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [NetworkInterface] @relation(name: "network_interfaces", fkName: ["id","fetch_cycle"], relationFkName: ["deviceId","fetch_cycle"], relType: ONE_TO_MANY)
}
enum interfaces_aggregate_columns {
	"""
	groupBy by deviceId
	"""
	deviceId
	"""
	groupBy by macAddr
	"""
	macAddr
}
enum interfaces_aggregate_max_columns {
	"""
	max by deviceId
	"""
	deviceId
	"""
	max by macAddr
	"""
	macAddr
}
enum interfaces_aggregate_min_columns {
	"""
	min by deviceId
	"""
	deviceId
	"""
	min by macAddr
	"""
	macAddr
}
"""
Boolean filter expression for NetworkInterface
"""
input network_interface_bool_exp {
	"""
	exists comparison operator
	"""
	deviceId_exists: Boolean
	"""
	eq comparison operator
	"""
	deviceId_eq: UUID
	"""
	neq comparison operator
	"""
	deviceId_neq: UUID
	"""
	in comparison operator
	"""
	deviceId_in: [UUID]
	"""
	not_in comparison operator
	"""
	deviceId_not_in: [UUID]
	"""
	gt comparison operator
	"""
	deviceId_gt: UUID
	"""
	gte comparison operator
	"""
	deviceId_gte: UUID
	"""
	lt comparison operator
	"""
	deviceId_lt: UUID
	"""
	lte comparison operator
	"""
	deviceId_lte: UUID
	"""
	exists comparison operator
	"""
	macAddr_exists: Boolean
	"""
	eq comparison operator
	"""
	macAddr_eq: Mac
	"""
	neq comparison operator
	"""
	macAddr_neq: Mac
	"""
	in comparison operator
	"""
	macAddr_in: [Mac]
	"""
	not_in comparison operator
	"""
	macAddr_not_in: [Mac]
	"""
	contains comparison operator
	"""
	ipAddrs_contains: [IP]
	"""
	contained_by comparison operator
	"""
	ipAddrs_contained_by: [IP]
	"""
	overlap comparison operator
	"""
	ipAddrs_overlap: [IP]
	"""
	size comparison operator
	"""
	ipAddrs_size: Int
	"""
	in_subnet comparison operator
	"""
	ipAddrs_in_subnet: CIDR
	"""
	ip_family comparison operator
	"""
	ipAddrs_ip_family: IPFamily
	AND: [network_interface_bool_exp!]
	OR: [network_interface_bool_exp!]
	NOT: [network_interface_bool_exp!]
}
"""
Boolean filter expression for OperatingSystem
"""
input operating_system_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	eq comparison operator
	"""
	id_eq: UUID
	"""
	neq comparison operator
	"""
	id_neq: UUID
	"""
	in comparison operator
	"""
	id_in: [UUID]
	"""
	not_in comparison operator
	"""
	id_not_in: [UUID]
	"""
	gt comparison operator
	"""
	id_gt: UUID
	"""
	gte comparison operator
	"""
	id_gte: UUID
	"""
	lt comparison operator
	"""
	id_lt: UUID
	"""
	lte comparison operator
	"""
	id_lte: UUID
	"""
	exists comparison operator
	"""
	type_exists: Boolean
	"""
	not comparison operator
	"""
	type_not: String
	"""
	eq comparison operator
	"""
	type_eq: String
	"""
	neq comparison operator
	"""
	type_neq: String
	"""
	in comparison operator
	"""
	type_in: [String]
	"""
	not_in comparison operator
	"""
	type_not_in: [String]
	"""
	like comparison operator
	"""
	type_like: String
	"""
	not_like comparison operator
	"""
	type_not_like: String
	"""
	ilike comparison operator
	"""
	type_ilike: String
	"""
	not_ilike comparison operator
	"""
	type_not_ilike: String
	"""
	suffix comparison operator
	"""
	type_suffix: String
	"""
	prefix comparison operator
	"""
	type_prefix: String
	"""
	exists comparison operator
	"""
	distribution_exists: Boolean
	"""
	not comparison operator
	"""
	distribution_not: String
	"""
	eq comparison operator
	"""
	distribution_eq: String
	"""
	neq comparison operator
	"""
	distribution_neq: String
	"""
	in comparison operator
	"""
	distribution_in: [String]
	"""
	not_in comparison operator
	"""
	distribution_not_in: [String]
	"""
	like comparison operator
	"""
	distribution_like: String
	"""
	not_like comparison operator
	"""
	distribution_not_like: String
	"""
	ilike comparison operator
	"""
	distribution_ilike: String
	"""
	not_ilike comparison operator
	"""
	distribution_not_ilike: String
	"""
	suffix comparison operator
	"""
	distribution_suffix: String
	"""
	prefix comparison operator
	"""
	distribution_prefix: String
	"""
	exists comparison operator
	"""
	architecture_exists: Boolean
	"""
	eq comparison operator
	"""
	architecture_eq: Int
	"""
	neq comparison operator
	"""
	architecture_neq: Int
	"""
	in comparison operator
	"""
	architecture_in: [Int]
	"""
	not_in comparison operator
	"""
	architecture_not_in: [Int]
	"""
	gt comparison operator
	"""
	architecture_gt: Int
	"""
	gte comparison operator
	"""
	architecture_gte: Int
	"""
	lt comparison operator
	"""
	architecture_lt: Int
	"""
	lte comparison operator
	"""
	architecture_lte: Int
	"""
	exists comparison operator
	"""
	servicePack_exists: Boolean
	"""
	not comparison operator
	"""
	servicePack_not: String
	"""
	eq comparison operator
	"""
	servicePack_eq: String
	"""
	neq comparison operator
	"""
	servicePack_neq: String
	"""
	in comparison operator
	"""
	servicePack_in: [String]
	"""
	not_in comparison operator
	"""
	servicePack_not_in: [String]
	"""
	like comparison operator
	"""
	servicePack_like: String
	"""
	not_like comparison operator
	"""
	servicePack_not_like: String
	"""
	ilike comparison operator
	"""
	servicePack_ilike: String
	"""
	not_ilike comparison operator
	"""
	servicePack_not_ilike: String
	"""
	suffix comparison operator
	"""
	servicePack_suffix: String
	"""
	prefix comparison operator
	"""
	servicePack_prefix: String
	"""
	exists comparison operator
	"""
	installDate_exists: Boolean
	"""
	eq comparison operator
	"""
	installDate_eq: Epoch
	"""
	neq comparison operator
	"""
	installDate_neq: Epoch
	"""
	in comparison operator
	"""
	installDate_in: [Epoch]
	"""
	not_in comparison operator
	"""
	installDate_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	installDate_gt: Epoch
	"""
	gte comparison operator
	"""
	installDate_gte: Epoch
	"""
	lt comparison operator
	"""
	installDate_lt: Epoch
	"""
	lte comparison operator
	"""
	installDate_lte: Epoch
	"""
	days comparison operator
	"""
	installDate_days: Int
	"""
	exists comparison operator
	"""
	kernelVersion_exists: Boolean
	"""
	not comparison operator
	"""
	kernelVersion_not: String
	"""
	eq comparison operator
	"""
	kernelVersion_eq: String
	"""
	neq comparison operator
	"""
	kernelVersion_neq: String
	"""
	in comparison operator
	"""
	kernelVersion_in: [String]
	"""
	not_in comparison operator
	"""
	kernelVersion_not_in: [String]
	"""
	like comparison operator
	"""
	kernelVersion_like: String
	"""
	not_like comparison operator
	"""
	kernelVersion_not_like: String
	"""
	ilike comparison operator
	"""
	kernelVersion_ilike: String
	"""
	not_ilike comparison operator
	"""
	kernelVersion_not_ilike: String
	"""
	suffix comparison operator
	"""
	kernelVersion_suffix: String
	"""
	prefix comparison operator
	"""
	kernelVersion_prefix: String
	"""
	exists comparison operator
	"""
	codeName_exists: Boolean
	"""
	not comparison operator
	"""
	codeName_not: String
	"""
	eq comparison operator
	"""
	codeName_eq: String
	"""
	neq comparison operator
	"""
	codeName_neq: String
	"""
	in comparison operator
	"""
	codeName_in: [String]
	"""
	not_in comparison operator
	"""
	codeName_not_in: [String]
	"""
	like comparison operator
	"""
	codeName_like: String
	"""
	not_like comparison operator
	"""
	codeName_not_like: String
	"""
	ilike comparison operator
	"""
	codeName_ilike: String
	"""
	not_ilike comparison operator
	"""
	codeName_not_ilike: String
	"""
	suffix comparison operator
	"""
	codeName_suffix: String
	"""
	prefix comparison operator
	"""
	codeName_prefix: String
	"""
	exists comparison operator
	"""
	major_exists: Boolean
	"""
	eq comparison operator
	"""
	major_eq: Int
	"""
	neq comparison operator
	"""
	major_neq: Int
	"""
	in comparison operator
	"""
	major_in: [Int]
	"""
	not_in comparison operator
	"""
	major_not_in: [Int]
	"""
	gt comparison operator
	"""
	major_gt: Int
	"""
	gte comparison operator
	"""
	major_gte: Int
	"""
	lt comparison operator
	"""
	major_lt: Int
	"""
	lte comparison operator
	"""
	major_lte: Int
	"""
	exists comparison operator
	"""
	minor_exists: Boolean
	"""
	eq comparison operator
	"""
	minor_eq: Int
	"""
	neq comparison operator
	"""
	minor_neq: Int
	"""
	in comparison operator
	"""
	minor_in: [Int]
	"""
	not_in comparison operator
	"""
	minor_not_in: [Int]
	"""
	gt comparison operator
	"""
	minor_gt: Int
	"""
	gte comparison operator
	"""
	minor_gte: Int
	"""
	lt comparison operator
	"""
	minor_lt: Int
	"""
	lte comparison operator
	"""
	minor_lte: Int
	"""
	exists comparison operator
	"""
	build_exists: Boolean
	"""
	not comparison operator
	"""
	build_not: String
	"""
	eq comparison operator
	"""
	build_eq: String
	"""
	neq comparison operator
	"""
	build_neq: String
	"""
	in comparison operator
	"""
	build_in: [String]
	"""
	not_in comparison operator
	"""
	build_not_in: [String]
	"""
	like comparison operator
	"""
	build_like: String
	"""
	not_like comparison operator
	"""
	build_not_like: String
	"""
	ilike comparison operator
	"""
	build_ilike: String
	"""
	not_ilike comparison operator
	"""
	build_not_ilike: String
	"""
	suffix comparison operator
	"""
	build_suffix: String
	"""
	prefix comparison operator
	"""
	build_prefix: String
	"""
	exists comparison operator
	"""
	RawName_exists: Boolean
	"""
	not comparison operator
	"""
	RawName_not: String
	"""
	eq comparison operator
	"""
	RawName_eq: String
	"""
	neq comparison operator
	"""
	RawName_neq: String
	"""
	in comparison operator
	"""
	RawName_in: [String]
	"""
	not_in comparison operator
	"""
	RawName_not_in: [String]
	"""
	like comparison operator
	"""
	RawName_like: String
	"""
	not_like comparison operator
	"""
	RawName_not_like: String
	"""
	ilike comparison operator
	"""
	RawName_ilike: String
	"""
	not_ilike comparison operator
	"""
	RawName_not_ilike: String
	"""
	suffix comparison operator
	"""
	RawName_suffix: String
	"""
	prefix comparison operator
	"""
	RawName_prefix: String
	AND: [operating_system_bool_exp!]
	OR: [operating_system_bool_exp!]
	NOT: [operating_system_bool_exp!]
}
"""
Order for OperatingSystem
"""
enum operating_system_order_by {
	"""
	Order by type in an ascending order
	"""
	type_ASC
	"""
	Order by type in a descending order
	"""
	type_DESC
	"""
	Order by distribution in an ascending order
	"""
	distribution_ASC
	"""
	Order by distribution in a descending order
	"""
	distribution_DESC
	"""
	Order by architecture in an ascending order
	"""
	architecture_ASC
	"""
	Order by architecture in a descending order
	"""
	architecture_DESC
	"""
	Order by servicePack in an ascending order
	"""
	servicePack_ASC
	"""
	Order by servicePack in a descending order
	"""
	servicePack_DESC
	"""
	Order by installDate in an ascending order
	"""
	installDate_ASC
	"""
	Order by installDate in a descending order
	"""
	installDate_DESC
	"""
	Order by kernelVersion in an ascending order
	"""
	kernelVersion_ASC
	"""
	Order by kernelVersion in a descending order
	"""
	kernelVersion_DESC
	"""
	Order by codeName in an ascending order
	"""
	codeName_ASC
	"""
	Order by codeName in a descending order
	"""
	codeName_DESC
	"""
	Order by major in an ascending order
	"""
	major_ASC
	"""
	Order by major in a descending order
	"""
	major_DESC
	"""
	Order by minor in an ascending order
	"""
	minor_ASC
	"""
	Order by minor in a descending order
	"""
	minor_DESC
	"""
	Order by build in an ascending order
	"""
	build_ASC
	"""
	Order by build in a descending order
	"""
	build_DESC
	"""
	Order by RawName in an ascending order
	"""
	RawName_ASC
	"""
	Order by RawName in a descending order
	"""
	RawName_DESC
}
type preventionSettingsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [preventionSettings_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [preventionSettings_aggregate_max_columns!]!): Map
	preventionSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_prevention_settings_bool_exp): [csPreventionSettings]
}
enum preventionSettings_aggregate_columns {
	"""
	groupBy by name
	"""
	name
}
enum preventionSettings_aggregate_max_columns {
	"""
	max by name
	"""
	name
}
enum preventionSettings_aggregate_min_columns {
	"""
	min by name
	"""
	name
}
type sensorUpdateSettingsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [sensorUpdateSettings_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [sensorUpdateSettings_aggregate_max_columns!]!): Map
	sensorUpdateSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_sensor_update_settings_bool_exp): [csSensorUpdateSettings]
}
enum sensorUpdateSettings_aggregate_columns {
	"""
	groupBy by build
	"""
	build
}
enum sensorUpdateSettings_aggregate_max_columns {
	"""
	max by build
	"""
	build
}
enum sensorUpdateSettings_aggregate_min_columns {
	"""
	min by build
	"""
	build
}
"""
Boolean filter expression for Tag
"""
input tag_bool_exp {
	"""
	exists comparison operator
	"""
	name_exists: Boolean
	"""
	not comparison operator
	"""
	name_not: String
	"""
	eq comparison operator
	"""
	name_eq: String
	"""
	neq comparison operator
	"""
	name_neq: String
	"""
	in comparison operator
	"""
	name_in: [String]
	"""
	not_in comparison operator
	"""
	name_not_in: [String]
	"""
	like comparison operator
	"""
	name_like: String
	"""
	not_like comparison operator
	"""
	name_not_like: String
	"""
	ilike comparison operator
	"""
	name_ilike: String
	"""
	not_ilike comparison operator
	"""
	name_not_ilike: String
	"""
	suffix comparison operator
	"""
	name_suffix: String
	"""
	prefix comparison operator
	"""
	name_prefix: String
	"""
	exists comparison operator
	"""
	creator_exists: Boolean
	"""
	not comparison operator
	"""
	creator_not: String
	"""
	eq comparison operator
	"""
	creator_eq: String
	"""
	neq comparison operator
	"""
	creator_neq: String
	"""
	in comparison operator
	"""
	creator_in: [String]
	"""
	not_in comparison operator
	"""
	creator_not_in: [String]
	"""
	like comparison operator
	"""
	creator_like: String
	"""
	not_like comparison operator
	"""
	creator_not_like: String
	"""
	ilike comparison operator
	"""
	creator_ilike: String
	"""
	not_ilike comparison operator
	"""
	creator_not_ilike: String
	"""
	suffix comparison operator
	"""
	creator_suffix: String
	"""
	prefix comparison operator
	"""
	creator_prefix: String
	"""
	exists comparison operator
	"""
	level_exists: Boolean
	"""
	not comparison operator
	"""
	level_not: String
	"""
	eq comparison operator
	"""
	level_eq: String
	"""
	neq comparison operator
	"""
	level_neq: String
	"""
	in comparison operator
	"""
	level_in: [String]
	"""
	not_in comparison operator
	"""
	level_not_in: [String]
	"""
	like comparison operator
	"""
	level_like: String
	"""
	not_like comparison operator
	"""
	level_not_like: String
	"""
	ilike comparison operator
	"""
	level_ilike: String
	"""
	not_ilike comparison operator
	"""
	level_not_ilike: String
	"""
	suffix comparison operator
	"""
	level_suffix: String
	"""
	prefix comparison operator
	"""
	level_prefix: String
	AND: [tag_bool_exp!]
	OR: [tag_bool_exp!]
	NOT: [tag_bool_exp!]
}
"""
Order for Tag
"""
enum tag_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by creator in an ascending order
	"""
	creator_ASC
	"""
	Order by creator in a descending order
	"""
	creator_DESC
	"""
	Order by level in an ascending order
	"""
	level_ASC
	"""
	Order by level in a descending order
	"""
	level_DESC
}
type tagsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [tags_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [tags_aggregate_max_columns!]!): Map
	tags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [Tag] @relation(name: "adapter_device_tags", fkName: ["id"], relationFkName: ["adapter_device_id"], relType: MANY_TO_MANY, manyToManyTableName: "tags", joinOn: ["name"])
}
enum tags_aggregate_columns {
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by creator
	"""
	creator
	"""
	groupBy by level
	"""
	level
}
enum tags_aggregate_max_columns {
	"""
	max by name
	"""
	name
	"""
	max by creator
	"""
	creator
	"""
	max by level
	"""
	level
}
enum tags_aggregate_min_columns {
	"""
	min by name
	"""
	name
	"""
	min by creator
	"""
	creator
	"""
	min by level
	"""
	level
}
"""
Boolean filter expression for User
"""
input user_bool_exp {
	"""
	exists comparison operator
	"""
	id_exists: Boolean
	"""
	eq comparison operator
	"""
	id_eq: UUID
	"""
	neq comparison operator
	"""
	id_neq: UUID
	"""
	in comparison operator
	"""
	id_in: [UUID]
	"""
	not_in comparison operator
	"""
	id_not_in: [UUID]
	"""
	gt comparison operator
	"""
	id_gt: UUID
	"""
	gte comparison operator
	"""
	id_gte: UUID
	"""
	lt comparison operator
	"""
	id_lt: UUID
	"""
	lte comparison operator
	"""
	id_lte: UUID
	"""
	exists comparison operator
	"""
	fetchCycle_exists: Boolean
	"""
	eq comparison operator
	"""
	fetchCycle_eq: Int
	"""
	neq comparison operator
	"""
	fetchCycle_neq: Int
	"""
	in comparison operator
	"""
	fetchCycle_in: [Int]
	"""
	not_in comparison operator
	"""
	fetchCycle_not_in: [Int]
	"""
	gt comparison operator
	"""
	fetchCycle_gt: Int
	"""
	gte comparison operator
	"""
	fetchCycle_gte: Int
	"""
	lt comparison operator
	"""
	fetchCycle_lt: Int
	"""
	lte comparison operator
	"""
	fetchCycle_lte: Int
	"""
	exists comparison operator
	"""
	adapterCount_exists: Boolean
	"""
	eq comparison operator
	"""
	adapterCount_eq: Int
	"""
	neq comparison operator
	"""
	adapterCount_neq: Int
	"""
	in comparison operator
	"""
	adapterCount_in: [Int]
	"""
	not_in comparison operator
	"""
	adapterCount_not_in: [Int]
	"""
	gt comparison operator
	"""
	adapterCount_gt: Int
	"""
	gte comparison operator
	"""
	adapterCount_gte: Int
	"""
	lt comparison operator
	"""
	adapterCount_lt: Int
	"""
	lte comparison operator
	"""
	adapterCount_lte: Int
	"""
	contains comparison operator
	"""
	adapterNames_contains: [String]
	"""
	contained_by comparison operator
	"""
	adapterNames_contained_by: [String]
	"""
	overlap comparison operator
	"""
	adapterNames_overlap: [String]
	"""
	size comparison operator
	"""
	adapterNames_size: Int
	"""
	contains_regex comparison operator
	"""
	adapterNames_contains_regex: String
	"""
	contains comparison operator
	"""
	usernames_contains: [String]
	"""
	contained_by comparison operator
	"""
	usernames_contained_by: [String]
	"""
	overlap comparison operator
	"""
	usernames_overlap: [String]
	"""
	size comparison operator
	"""
	usernames_size: Int
	"""
	contains_regex comparison operator
	"""
	usernames_contains_regex: String
	"""
	exists comparison operator
	"""
	lastSeen_exists: Boolean
	"""
	eq comparison operator
	"""
	lastSeen_eq: Epoch
	"""
	neq comparison operator
	"""
	lastSeen_neq: Epoch
	"""
	in comparison operator
	"""
	lastSeen_in: [Epoch]
	"""
	not_in comparison operator
	"""
	lastSeen_not_in: [Epoch]
	"""
	gt comparison operator
	"""
	lastSeen_gt: Epoch
	"""
	gte comparison operator
	"""
	lastSeen_gte: Epoch
	"""
	lt comparison operator
	"""
	lastSeen_lt: Epoch
	"""
	lte comparison operator
	"""
	lastSeen_lte: Epoch
	"""
	days comparison operator
	"""
	lastSeen_days: Int
	"""
	filter by adapterUsers
	"""
	adapterUsers: adapter_user_bool_exp
	AND: [user_bool_exp!]
	OR: [user_bool_exp!]
	NOT: [user_bool_exp!]
}
"""
Order for User
"""
enum user_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterCount in an ascending order
	"""
	adapterCount_ASC
	"""
	Order by adapterCount in a descending order
	"""
	adapterCount_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
}
type usersAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_max_columns!]!): Map
	users("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: user_bool_exp): [User]
}
enum users_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by adapterCount
	"""
	adapterCount
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum users_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterCount
	"""
	adapterCount
	"""
	groupBy by lastSeen
	"""
	lastSeen
}
enum users_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterCount
	"""
	adapterCount
	"""
	max by lastSeen
	"""
	lastSeen
}
enum users_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterCount
	"""
	adapterCount
	"""
	min by lastSeen
	"""
	lastSeen
}
enum users_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by adapterCount
	"""
	adapterCount
	"""
	sum by lastSeen
	"""
	lastSeen
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_generateInputs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	return args, nil
}

func (ec *executionContext) dir_jsonpath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []*string
	if tmp, ok := rawArgs["depends"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["depends"] = arg1
	return args, nil
}

func (ec *executionContext) dir_relation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["fkName"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fkName"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["relationFkName"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["relationFkName"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["relType"]; ok {
		arg3, err = ec.unmarshalNRelationType2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["relType"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["manyToManyTableName"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["manyToManyTableName"] = arg4
	var arg5 []string
	if tmp, ok := rawArgs["joinOn"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["joinOn"] = arg5
	return args, nil
}

func (ec *executionContext) dir_viewFunction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []*string
	if tmp, ok := rawArgs["arguments"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["arguments"] = arg1
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_adapterData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterDataBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_adapter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_deviceUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_firewallRules_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []FirewallRulesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *FirewallRuleBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_firewallRules_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *FirewallRuleBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_installedSoftware_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []InstalledSoftwareAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *InstalledSoftwareBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_installedSoftware_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *InstalledSoftwareBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_interfaces_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_localAdmins_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceAdminBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_os_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *OperatingSystemBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_tags_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []TagsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_tags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterUser_adapterData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterDataBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterUser_adapter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_groups_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []GroupsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_groups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_preventionPolicy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CsPolicyBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_sensorUpdatePolicy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Device_adapterDevices_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Device_adapterDevices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_Device_interfaces_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Device_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_Device_tags_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []TagsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Device_tags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_GCETagsAggregate_GCETags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *GceTagsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_GCETagsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GCETagsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_GCETagsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GCETagsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_GoogleCloudData_GCETags_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GCETagsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []GCETagsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *GceTagsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_GoogleCloudData_GCETags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *GceTagsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_adapterDevices_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_adapterDevices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []AdapterDeviceOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_adapterUsers_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_adapterUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []AdapterUserOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_devices_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []DevicesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *DeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_devices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *DeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []DeviceOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_users_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []UsersAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *UserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *UserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []UserOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOuser_order_by2bandicootpkggqlUserOrderBy(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_User_adapterUsers_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_User_adapterUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_adapterDevices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_adapterUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_csPolicy_groups_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []GroupsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_csPolicy_groups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_csPolicy_preventionSettings_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []PreventionSettingsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []PreventionSettingsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsPreventionSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_csPolicy_preventionSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsPreventionSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_csPolicy_sensorUpdateSettings_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []SensorUpdateSettingsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []SensorUpdateSettingsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsSensorUpdateSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_csPolicy_sensorUpdateSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsSensorUpdateSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_csPreventionSettings_settings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsPolicySettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_devices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *DeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_firewallRules_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *FirewallRuleBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_groups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_installedSoftware_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *InstalledSoftwareBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_interfacesAggregate_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_interfacesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_interfacesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_preventionSettingsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []PreventionSettingsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_preventionSettingsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []PreventionSettingsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_preventionSettingsAggregate_preventionSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsPreventionSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_sensorUpdateSettingsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []SensorUpdateSettingsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_sensorUpdateSettingsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []SensorUpdateSettingsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_sensorUpdateSettingsAggregate_sensorUpdateSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsSensorUpdateSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_tagsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_tagsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_tagsAggregate_tags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_usersAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *UserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ActiveDirectoryData_adCn(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdCn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adSid(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdSid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adGuid(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdGUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adSAMAccountName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdSAMAccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adUserPrincipalName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdUserPrincipalName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adDisplayName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adDistinguishedName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdDistinguishedName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adCanonicalName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdCanonicalName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adAccountExpires(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdAccountExpires, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adObjectClass(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdObjectClass, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adObjectCategory(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdObjectCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adOrganizationalUnit(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdOrganizationalUnit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adLastLogoff(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdLastLogoff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adLastLogon(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdLastLogon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adLastLogonTimestamp(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdLastLogonTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adBadPasswordTime(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdBadPasswordTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_ad_bad_pwd_count(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdBadPwdCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adManagedBy(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdManagedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPasswordLastSet(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPasswordLastSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPrimaryGroupId(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPrimaryGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPrimaryGroupDn(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPrimaryGroupDn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMemberOf(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMemberOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMemberOfFull(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMemberOfFull, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adUsnChanged(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdUsnChanged, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adUsnCreated(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdUsnCreated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adWhenChanged(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdWhenChanged, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adWhenCreated(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdWhenCreated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adIsCriticalSystemObject(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdIsCriticalSystemObject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMsdsAllowedToDelegateTo(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMsdsAllowedToDelegateTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPwdMustChange(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPwdMustChange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMsdsResultantPso(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMsdsResultantPso, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Adapter_id(ctx context.Context, field graphql.CollectedField, obj *Adapter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Adapter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domain.AdapterType)
	fc.Result = res
	return ec.marshalNAdapterType2bandicootpkgdomainAdapterType(ctx, field.Selections, res)
}

func (ec *executionContext) _Adapter_name(ctx context.Context, field graphql.CollectedField, obj *Adapter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Adapter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Adapter_properties(ctx context.Context, field graphql.CollectedField, obj *Adapter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Adapter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_id(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapterId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domain.AdapterType)
	fc.Result = res
	return ec.marshalNAdapterType2bandicootpkgdomainAdapterType(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapter(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_adapter_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Adapter, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapters")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_ONE")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Adapter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bandicoot/pkg/gql.Adapter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Adapter)
	fc.Result = res
	return ec.marshalOAdapter2bandicootpkggqlAdapter(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapterName(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_deviceId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapterData(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_adapterData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.AdapterDevice().AdapterData(rctx, obj, args["where"].(*AdapterDataBoolExp))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "data")
			if err != nil {
				return nil, err
			}
			depends, err := ec.unmarshalOString2string(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, depends)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(AdapterData); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bandicoot/pkg/gql.AdapterData`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(AdapterData)
	fc.Result = res
	return ec.marshalOAdapterData2bandicootpkggqlAdapterData(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_data(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_fetchTime(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_hostname(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_name(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_lastSeen(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_osId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OsID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_os(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_os_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Os, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "operating_systems")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"osId"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_ONE")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*OperatingSystem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bandicoot/pkg/gql.OperatingSystem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*OperatingSystem)
	fc.Result = res
	return ec.marshalOOperatingSystem2bandicootpkggqlOperatingSystem(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_prettyId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrettyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_tags(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_tags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tags, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_tags")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "tags")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalOTag2bandicootpkggqlTag(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_interfaces(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Interfaces, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"deviceId", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]NetworkInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.NetworkInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]NetworkInterface)
	fc.Result = res
	return ec.marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_lastUsedUsers(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUsedUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_domain(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_partOfDomain(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartOfDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_deviceUsers(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_deviceUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DeviceUsers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "deviceUsers")
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AdapterDeviceUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.AdapterDeviceUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterDeviceUser)
	fc.Result = res
	return ec.marshalOAdapterDeviceUser2bandicootpkggqlAdapterDeviceUser(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_localAdmins(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_localAdmins_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LocalAdmins, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "localAdmins")
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AdapterDeviceAdmin); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.AdapterDeviceAdmin`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterDeviceAdmin)
	fc.Result = res
	return ec.marshalOAdapterDeviceAdmin2bandicootpkggqlAdapterDeviceAdmin(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_firewallRules(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_firewallRules_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FirewallRules, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_firewall_rules")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "firewall_rules")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*FirewallRule); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.FirewallRule`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FirewallRule)
	fc.Result = res
	return ec.marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_installedSoftware(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_installedSoftware_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InstalledSoftware, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_installed_software")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "installed_software")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name", "version"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InstalledSoftware); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.InstalledSoftware`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*InstalledSoftware)
	fc.Result = res
	return ec.marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_agentVersion(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_agentStatus(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_agentName(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_model(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_manufacturer(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manufacturer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_serial(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Serial, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_family(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Family, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_biosVersion(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BiosVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_biosSerial(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BiosSerial, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_tags_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_tags_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TagsAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_tags")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "tags")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]TagsAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.TagsAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]TagsAggregate)
	fc.Result = res
	return ec.marshalOtagsAggregate2bandicootpkggqlTagsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_interfaces_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_interfaces_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InterfacesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"deviceId", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]InterfacesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.InterfacesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]InterfacesAggregate)
	fc.Result = res
	return ec.marshalOinterfacesAggregate2bandicootpkggqlInterfacesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_firewallRules_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_firewallRules_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FirewallRulesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_firewall_rules")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "firewall_rules")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]FirewallRulesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.FirewallRulesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]FirewallRulesAggregate)
	fc.Result = res
	return ec.marshalOfirewallRulesAggregate2bandicootpkggqlFirewallRulesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_installedSoftware_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_installedSoftware_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InstalledSoftwareAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_installed_software")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "installed_software")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name", "version"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]InstalledSoftwareAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.InstalledSoftwareAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]InstalledSoftwareAggregate)
	fc.Result = res
	return ec.marshalOinstalledSoftwareAggregate2bandicootpkggqlInstalledSoftwareAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceAdmin_name(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceAdmin_type(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AdminType)
	fc.Result = res
	return ec.marshalOAdminType2bandicootpkggqlAdminType(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_deviceId(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_sid(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_username(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_lastUseDate(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUseDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_isLocal(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsLocal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_isDisabled(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_isAdmin(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAdmin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_userDepartment(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserDepartment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_passwordMaxAge(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PasswordMaxAge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_interpreter(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interpreter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_id(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapterId(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domain.AdapterType)
	fc.Result = res
	return ec.marshalNAdapterType2bandicootpkgdomainAdapterType(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapter(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterUser_adapter_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Adapter, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapters")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_ONE")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Adapter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bandicoot/pkg/gql.Adapter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Adapter)
	fc.Result = res
	return ec.marshalOAdapter2bandicootpkggqlAdapter(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapterName(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_userId(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapterData(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterUser_adapterData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.AdapterUser().AdapterData(rctx, obj, args["where"].(*AdapterDataBoolExp))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "data")
			if err != nil {
				return nil, err
			}
			depends, err := ec.unmarshalOString2string(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, depends)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(AdapterData); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bandicoot/pkg/gql.AdapterData`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(AdapterData)
	fc.Result = res
	return ec.marshalOAdapterData2bandicootpkggqlAdapterData(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_data(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_fetchTime(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_lastSeen(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_username(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_firstName(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_lastName(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_mail(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_admin(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_local(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Local, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_delegated_admin(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DelegatedAdmin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_mfa_enforced(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MfaEnforced, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_mfa_enrolled(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MfaEnrolled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_suspended(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suspended, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_locked(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_disabled(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_id(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_name(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_manfacturer(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manfacturer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_bitness(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bitness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_family(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Family, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_cores(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cores, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_coresThreads(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoresThreads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_ghz(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ghz, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_externalIp(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_groups(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_groups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2bandicootpkggqlCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_preventionPolicy(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_preventionPolicy_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CsPolicy)
	fc.Result = res
	return ec.marshalOcsPolicy2bandicootpkggqlCsPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_sensorUpdatePolicy(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_sensorUpdatePolicy_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdatePolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2bandicootpkggqlCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_csAgentVersion(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CsAgentVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_groups_aggregate(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_groups_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]GroupsAggregate)
	fc.Result = res
	return ec.marshalOgroupsAggregate2bandicootpkggqlGroupsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_isSafe(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSafe, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_deviceState(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CylanceDeviceState)
	fc.Result = res
	return ec.marshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_policyId(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PolicyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_policyName(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PolicyName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_policiesDetails(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PoliciesDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_tenantTag(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantTag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_zoneNames(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZoneNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_agentVersion(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_id(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterCount(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterNames(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_hostnames(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostnames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_lastSeen(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterDevices(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_adapterDevices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterDevices, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_devices")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterDevice); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterDevice`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterDevice)
	fc.Result = res
	return ec.marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_interfaces(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Interfaces, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "device_network_interfaces")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]NetworkInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.NetworkInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]NetworkInterface)
	fc.Result = res
	return ec.marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_tags(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_tags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tags, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "device_tags")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Tag)
	fc.Result = res
	return ec.marshalOTag2bandicootpkggqlTag(ctx, field.Selections, res)
}

func (ec *executionContext) _Device__compatibilityAPI(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Device().CompatibilityAPI(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterDevices_aggregate(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_adapterDevices_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterDevicesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_devices")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterDevicesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterDevicesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterDevicesAggregate)
	fc.Result = res
	return ec.marshalOadapterDevicesAggregate2bandicootpkggqlAdapterDevicesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_interfaces_aggregate(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_interfaces_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InterfacesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "device_network_interfaces")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]InterfacesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.InterfacesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]InterfacesAggregate)
	fc.Result = res
	return ec.marshalOinterfacesAggregate2bandicootpkggqlInterfacesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_tags_aggregate(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_tags_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TagsAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "device_tags")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]TagsAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.TagsAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]TagsAggregate)
	fc.Result = res
	return ec.marshalOtagsAggregate2bandicootpkggqlTagsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_name(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_source(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_type(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AccessType)
	fc.Result = res
	return ec.marshalOAccessType2bandicootpkggqlAccessType(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_direction(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Direction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Direction)
	fc.Result = res
	return ec.marshalODirection2bandicootpkggqlDirection(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_target(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_protocol(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_srcPort(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SrcPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_dstPort(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DstPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GCETagsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GCETagsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_GCETags(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GCETagsAggregate_GCETags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCETags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*GceTags)
	fc.Result = res
	return ec.marshalOGceTags2bandicootpkggqlGceTags(ctx, field.Selections, res)
}

func (ec *executionContext) _GceTags_gceKey(ctx context.Context, field graphql.CollectedField, obj *GceTags) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GceTags",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GceKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GceTags_gceValue(ctx context.Context, field graphql.CollectedField, obj *GceTags) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GceTags",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GceValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_Id(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_Size(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_Image(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_GCETags(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GoogleCloudData_GCETags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCETags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*GceTags)
	fc.Result = res
	return ec.marshalOGceTags2bandicootpkggqlGceTags(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_GCETags_aggregate(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GoogleCloudData_GCETags_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCETagsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]GCETagsAggregate)
	fc.Result = res
	return ec.marshalOGCETagsAggregate2bandicootpkggqlGCETagsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_name(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_version(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_architecture(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Architecture)
	fc.Result = res
	return ec.marshalOArchitecture2bandicootpkggqlArchitecture(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_description(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_vendor(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vendor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_publisher(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Publisher, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_cveCount(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CveCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_swLicense(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SwLicense, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_path(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_deviceId(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_macAddr(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MacAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOMac2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_ipAddrs(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddrs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]net.IP)
	fc.Result = res
	return ec.marshalOIP2netIP(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_id(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_type(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_distribution(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distribution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_architecture(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_servicePack(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServicePack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_installDate(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstallDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_kernelVersion(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KernelVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_codeName(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CodeName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_major(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Major, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_minor(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Minor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_build(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_RawName(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterDevices(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterDevices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterDevices(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp), args["orderBy"].([]AdapterDeviceOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]AdapterDevice)
	fc.Result = res
	return ec.marshalNAdapterDevice2bandicootpkggqlAdapterDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_devices(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_devices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Devices(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp), args["orderBy"].([]DeviceOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Device)
	fc.Result = res
	return ec.marshalNDevice2bandicootpkggqlDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterUsers(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp), args["orderBy"].([]AdapterUserOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]AdapterUser)
	fc.Result = res
	return ec.marshalNAdapterUser2bandicootpkggqlAdapterUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_users_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp), args["orderBy"].([]UserOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]User)
	fc.Result = res
	return ec.marshalNUser2bandicootpkggqlUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterDevices_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterDevices_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterDevicesAggregate(rctx, args["groupBy"].([]AdapterDevicesAggregateColumns), args["distinctOn"].([]AdapterDevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterDevicesAggregate)
	fc.Result = res
	return ec.marshalOadapterDevicesAggregate2bandicootpkggqlAdapterDevicesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_devices_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_devices_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DevicesAggregate(rctx, args["groupBy"].([]DevicesAggregateColumns), args["distinctOn"].([]DevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]DevicesAggregate)
	fc.Result = res
	return ec.marshalOdevicesAggregate2bandicootpkggqlDevicesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterUsers_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterUsers_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterUsersAggregate(rctx, args["groupBy"].([]AdapterUsersAggregateColumns), args["distinctOn"].([]AdapterUsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterUsersAggregate)
	fc.Result = res
	return ec.marshalOadapterUsersAggregate2bandicootpkggqlAdapterUsersAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_users_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_users_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UsersAggregate(rctx, args["groupBy"].([]UsersAggregateColumns), args["distinctOn"].([]UsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]UsersAggregate)
	fc.Result = res
	return ec.marshalOusersAggregate2bandicootpkggqlUsersAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_deviceId(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_path(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_name(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_totalSize(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_freeSize(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FreeSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_isEncrypted(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsEncrypted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_description(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Tag_name(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Tag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Tag_creator(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Tag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Tag_level(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Tag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _User_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterCount(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterNames(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_usernames(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Usernames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_lastSeen(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterUsers(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_User_adapterUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterUsers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_users")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"user_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterUser)
	fc.Result = res
	return ec.marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx, field.Selections, res)
}

func (ec *executionContext) _User__compatibilityAPI(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().CompatibilityAPI(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterUsers_aggregate(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_User_adapterUsers_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterUsersAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_users")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"user_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterUsersAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterUsersAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterUsersAggregate)
	fc.Result = res
	return ec.marshalOadapterUsersAggregate2bandicootpkggqlAdapterUsersAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_adapterDevices(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_adapterDevices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterDevices, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_devices")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AdapterDevice); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.AdapterDevice`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterDevice)
	fc.Result = res
	return ec.marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_group(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_count(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_min(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_max(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_adapterUsers(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_adapterUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterUsers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_users")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"user_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AdapterUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.AdapterUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterUser)
	fc.Result = res
	return ec.marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_id(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_name(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_createdBy(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_createdTimestamp(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_description(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_groupType(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_modifiedBy(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_modifiedTime(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_name(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_description(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_platformName(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlatformName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_groups(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_groups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2bandicootpkggqlCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_enabled(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_createdBy(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_createdTime(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_preventionSettings(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_preventionSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsPreventionSettings)
	fc.Result = res
	return ec.marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_sensorUpdateSettings(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_sensorUpdateSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdateSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsSensorUpdateSettings)
	fc.Result = res
	return ec.marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_groups_aggregate(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_groups_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]GroupsAggregate)
	fc.Result = res
	return ec.marshalOgroupsAggregate2bandicootpkggqlGroupsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_preventionSettings_aggregate(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_preventionSettings_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionSettingsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]PreventionSettingsAggregate)
	fc.Result = res
	return ec.marshalOpreventionSettingsAggregate2bandicootpkggqlPreventionSettingsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_sensorUpdateSettings_aggregate(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_sensorUpdateSettings_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdateSettingsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]SensorUpdateSettingsAggregate)
	fc.Result = res
	return ec.marshalOsensorUpdateSettingsAggregate2bandicootpkggqlSensorUpdateSettingsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicySettings_enabled(ctx context.Context, field graphql.CollectedField, obj *CsPolicySettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicySettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _csPreventionSettings_name(ctx context.Context, field graphql.CollectedField, obj *CsPreventionSettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPreventionSettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csPreventionSettings_settings(ctx context.Context, field graphql.CollectedField, obj *CsPreventionSettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPreventionSettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPreventionSettings_settings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Settings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsPolicySettings)
	fc.Result = res
	return ec.marshalOcsPolicySettings2bandicootpkggqlCsPolicySettings(ctx, field.Selections, res)
}

func (ec *executionContext) _csSensorUpdateSettings_build(ctx context.Context, field graphql.CollectedField, obj *CsSensorUpdateSettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csSensorUpdateSettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_devices(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_devices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Devices, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Device)
	fc.Result = res
	return ec.marshalODevice2bandicootpkggqlDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_firewallRules(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_firewallRules_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FirewallRules, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_firewall_rules")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "firewall_rules")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*FirewallRule); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.FirewallRule`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FirewallRule)
	fc.Result = res
	return ec.marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_groups(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_groups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2bandicootpkggqlCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_group(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_count(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_min(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_max(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_installedSoftware(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_installedSoftware_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InstalledSoftware, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_installed_software")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "installed_software")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name", "version"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InstalledSoftware); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.InstalledSoftware`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*InstalledSoftware)
	fc.Result = res
	return ec.marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_interfacesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_interfacesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_interfaces(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_interfacesAggregate_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Interfaces, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"deviceId", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*NetworkInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.NetworkInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*NetworkInterface)
	fc.Result = res
	return ec.marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_preventionSettingsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_preventionSettingsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_preventionSettings(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_preventionSettingsAggregate_preventionSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsPreventionSettings)
	fc.Result = res
	return ec.marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_sensorUpdateSettingsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_sensorUpdateSettingsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_sensorUpdateSettings(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_sensorUpdateSettingsAggregate_sensorUpdateSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdateSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsSensorUpdateSettings)
	fc.Result = res
	return ec.marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_tagsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_tagsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_tags(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_tagsAggregate_tags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tags, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_tags")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "tags")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalOTag2bandicootpkggqlTag(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_group(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_count(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_min(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_max(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_users(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_users_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*User)
	fc.Result = res
	return ec.marshalOUser2bandicootpkggqlUser(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputadapter_bool_exp(ctx context.Context, obj interface{}) (AdapterBoolExp, error) {
	var it AdapterBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties_contains":
			var err error
			it.PropertiesContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties_contained_by":
			var err error
			it.PropertiesContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties_overlap":
			var err error
			it.PropertiesOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties_size":
			var err error
			it.PropertiesSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties_contains_regex":
			var err error
			it.PropertiesContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_data_bool_exp(ctx context.Context, obj interface{}) (AdapterDataBoolExp, error) {
	var it AdapterDataBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "adCn_exists":
			var err error
			it.AdCnExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_not":
			var err error
			it.AdCnNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_eq":
			var err error
			it.AdCnEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_neq":
			var err error
			it.AdCnNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_in":
			var err error
			it.AdCnIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_not_in":
			var err error
			it.AdCnNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_like":
			var err error
			it.AdCnLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_not_like":
			var err error
			it.AdCnNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_ilike":
			var err error
			it.AdCnIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_not_ilike":
			var err error
			it.AdCnNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_suffix":
			var err error
			it.AdCnSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCn_prefix":
			var err error
			it.AdCnPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_exists":
			var err error
			it.AdSidExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_not":
			var err error
			it.AdSidNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_eq":
			var err error
			it.AdSidEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_neq":
			var err error
			it.AdSidNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_in":
			var err error
			it.AdSidIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_not_in":
			var err error
			it.AdSidNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_like":
			var err error
			it.AdSidLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_not_like":
			var err error
			it.AdSidNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_ilike":
			var err error
			it.AdSidIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_not_ilike":
			var err error
			it.AdSidNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_suffix":
			var err error
			it.AdSidSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid_prefix":
			var err error
			it.AdSidPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_exists":
			var err error
			it.AdGUIDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_not":
			var err error
			it.AdGUIDNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_eq":
			var err error
			it.AdGUIDEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_neq":
			var err error
			it.AdGUIDNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_in":
			var err error
			it.AdGUIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_not_in":
			var err error
			it.AdGUIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_like":
			var err error
			it.AdGUIDLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_not_like":
			var err error
			it.AdGUIDNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_ilike":
			var err error
			it.AdGUIDIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_not_ilike":
			var err error
			it.AdGUIDNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_suffix":
			var err error
			it.AdGUIDSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid_prefix":
			var err error
			it.AdGUIDPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_exists":
			var err error
			it.AdNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_not":
			var err error
			it.AdNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_eq":
			var err error
			it.AdNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_neq":
			var err error
			it.AdNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_in":
			var err error
			it.AdNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_not_in":
			var err error
			it.AdNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_like":
			var err error
			it.AdNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_not_like":
			var err error
			it.AdNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_ilike":
			var err error
			it.AdNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_not_ilike":
			var err error
			it.AdNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_suffix":
			var err error
			it.AdNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName_prefix":
			var err error
			it.AdNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_exists":
			var err error
			it.AdSAMAccountNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_not":
			var err error
			it.AdSAMAccountNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_eq":
			var err error
			it.AdSAMAccountNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_neq":
			var err error
			it.AdSAMAccountNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_in":
			var err error
			it.AdSAMAccountNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_not_in":
			var err error
			it.AdSAMAccountNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_like":
			var err error
			it.AdSAMAccountNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_not_like":
			var err error
			it.AdSAMAccountNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_ilike":
			var err error
			it.AdSAMAccountNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_not_ilike":
			var err error
			it.AdSAMAccountNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_suffix":
			var err error
			it.AdSAMAccountNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName_prefix":
			var err error
			it.AdSAMAccountNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_exists":
			var err error
			it.AdUserPrincipalNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_not":
			var err error
			it.AdUserPrincipalNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_eq":
			var err error
			it.AdUserPrincipalNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_neq":
			var err error
			it.AdUserPrincipalNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_in":
			var err error
			it.AdUserPrincipalNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_not_in":
			var err error
			it.AdUserPrincipalNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_like":
			var err error
			it.AdUserPrincipalNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_not_like":
			var err error
			it.AdUserPrincipalNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_ilike":
			var err error
			it.AdUserPrincipalNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_not_ilike":
			var err error
			it.AdUserPrincipalNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_suffix":
			var err error
			it.AdUserPrincipalNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName_prefix":
			var err error
			it.AdUserPrincipalNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_exists":
			var err error
			it.AdDisplayNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_not":
			var err error
			it.AdDisplayNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_eq":
			var err error
			it.AdDisplayNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_neq":
			var err error
			it.AdDisplayNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_in":
			var err error
			it.AdDisplayNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_not_in":
			var err error
			it.AdDisplayNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_like":
			var err error
			it.AdDisplayNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_not_like":
			var err error
			it.AdDisplayNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_ilike":
			var err error
			it.AdDisplayNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_not_ilike":
			var err error
			it.AdDisplayNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_suffix":
			var err error
			it.AdDisplayNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName_prefix":
			var err error
			it.AdDisplayNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_exists":
			var err error
			it.AdDistinguishedNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_not":
			var err error
			it.AdDistinguishedNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_eq":
			var err error
			it.AdDistinguishedNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_neq":
			var err error
			it.AdDistinguishedNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_in":
			var err error
			it.AdDistinguishedNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_not_in":
			var err error
			it.AdDistinguishedNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_like":
			var err error
			it.AdDistinguishedNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_not_like":
			var err error
			it.AdDistinguishedNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_ilike":
			var err error
			it.AdDistinguishedNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_not_ilike":
			var err error
			it.AdDistinguishedNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_suffix":
			var err error
			it.AdDistinguishedNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName_prefix":
			var err error
			it.AdDistinguishedNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_exists":
			var err error
			it.AdCanonicalNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_not":
			var err error
			it.AdCanonicalNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_eq":
			var err error
			it.AdCanonicalNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_neq":
			var err error
			it.AdCanonicalNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_in":
			var err error
			it.AdCanonicalNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_not_in":
			var err error
			it.AdCanonicalNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_like":
			var err error
			it.AdCanonicalNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_not_like":
			var err error
			it.AdCanonicalNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_ilike":
			var err error
			it.AdCanonicalNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_not_ilike":
			var err error
			it.AdCanonicalNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_suffix":
			var err error
			it.AdCanonicalNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName_prefix":
			var err error
			it.AdCanonicalNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_exists":
			var err error
			it.AdAccountExpiresExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_eq":
			var err error
			it.AdAccountExpiresEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_neq":
			var err error
			it.AdAccountExpiresNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_in":
			var err error
			it.AdAccountExpiresIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_not_in":
			var err error
			it.AdAccountExpiresNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_gt":
			var err error
			it.AdAccountExpiresGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_gte":
			var err error
			it.AdAccountExpiresGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_lt":
			var err error
			it.AdAccountExpiresLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_lte":
			var err error
			it.AdAccountExpiresLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires_days":
			var err error
			it.AdAccountExpiresDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectClass_contains":
			var err error
			it.AdObjectClassContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectClass_contained_by":
			var err error
			it.AdObjectClassContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectClass_overlap":
			var err error
			it.AdObjectClassOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectClass_size":
			var err error
			it.AdObjectClassSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectClass_contains_regex":
			var err error
			it.AdObjectClassContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_exists":
			var err error
			it.AdObjectCategoryExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_not":
			var err error
			it.AdObjectCategoryNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_eq":
			var err error
			it.AdObjectCategoryEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_neq":
			var err error
			it.AdObjectCategoryNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_in":
			var err error
			it.AdObjectCategoryIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_not_in":
			var err error
			it.AdObjectCategoryNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_like":
			var err error
			it.AdObjectCategoryLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_not_like":
			var err error
			it.AdObjectCategoryNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_ilike":
			var err error
			it.AdObjectCategoryIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_not_ilike":
			var err error
			it.AdObjectCategoryNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_suffix":
			var err error
			it.AdObjectCategorySuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory_prefix":
			var err error
			it.AdObjectCategoryPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adOrganizationalUnit_contains":
			var err error
			it.AdOrganizationalUnitContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adOrganizationalUnit_contained_by":
			var err error
			it.AdOrganizationalUnitContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adOrganizationalUnit_overlap":
			var err error
			it.AdOrganizationalUnitOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adOrganizationalUnit_size":
			var err error
			it.AdOrganizationalUnitSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adOrganizationalUnit_contains_regex":
			var err error
			it.AdOrganizationalUnitContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_exists":
			var err error
			it.AdLastLogoffExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_eq":
			var err error
			it.AdLastLogoffEq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_neq":
			var err error
			it.AdLastLogoffNeq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_in":
			var err error
			it.AdLastLogoffIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_not_in":
			var err error
			it.AdLastLogoffNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_gt":
			var err error
			it.AdLastLogoffGt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_gte":
			var err error
			it.AdLastLogoffGte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_lt":
			var err error
			it.AdLastLogoffLt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_lte":
			var err error
			it.AdLastLogoffLte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogoff_days":
			var err error
			it.AdLastLogoffDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_exists":
			var err error
			it.AdLastLogonExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_eq":
			var err error
			it.AdLastLogonEq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_neq":
			var err error
			it.AdLastLogonNeq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_in":
			var err error
			it.AdLastLogonIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_not_in":
			var err error
			it.AdLastLogonNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_gt":
			var err error
			it.AdLastLogonGt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_gte":
			var err error
			it.AdLastLogonGte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_lt":
			var err error
			it.AdLastLogonLt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_lte":
			var err error
			it.AdLastLogonLte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogon_days":
			var err error
			it.AdLastLogonDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_exists":
			var err error
			it.AdLastLogonTimestampExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_eq":
			var err error
			it.AdLastLogonTimestampEq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_neq":
			var err error
			it.AdLastLogonTimestampNeq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_in":
			var err error
			it.AdLastLogonTimestampIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_not_in":
			var err error
			it.AdLastLogonTimestampNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_gt":
			var err error
			it.AdLastLogonTimestampGt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_gte":
			var err error
			it.AdLastLogonTimestampGte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_lt":
			var err error
			it.AdLastLogonTimestampLt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_lte":
			var err error
			it.AdLastLogonTimestampLte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adLastLogonTimestamp_days":
			var err error
			it.AdLastLogonTimestampDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_exists":
			var err error
			it.AdBadPasswordTimeExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_eq":
			var err error
			it.AdBadPasswordTimeEq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_neq":
			var err error
			it.AdBadPasswordTimeNeq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_in":
			var err error
			it.AdBadPasswordTimeIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_not_in":
			var err error
			it.AdBadPasswordTimeNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_gt":
			var err error
			it.AdBadPasswordTimeGt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_gte":
			var err error
			it.AdBadPasswordTimeGte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_lt":
			var err error
			it.AdBadPasswordTimeLt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_lte":
			var err error
			it.AdBadPasswordTimeLte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adBadPasswordTime_days":
			var err error
			it.AdBadPasswordTimeDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_exists":
			var err error
			it.AdBadPwdCountExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_eq":
			var err error
			it.AdBadPwdCountEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_neq":
			var err error
			it.AdBadPwdCountNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_in":
			var err error
			it.AdBadPwdCountIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_not_in":
			var err error
			it.AdBadPwdCountNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_gt":
			var err error
			it.AdBadPwdCountGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_gte":
			var err error
			it.AdBadPwdCountGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_lt":
			var err error
			it.AdBadPwdCountLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count_lte":
			var err error
			it.AdBadPwdCountLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_exists":
			var err error
			it.AdManagedByExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_not":
			var err error
			it.AdManagedByNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_eq":
			var err error
			it.AdManagedByEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_neq":
			var err error
			it.AdManagedByNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_in":
			var err error
			it.AdManagedByIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_not_in":
			var err error
			it.AdManagedByNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_like":
			var err error
			it.AdManagedByLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_not_like":
			var err error
			it.AdManagedByNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_ilike":
			var err error
			it.AdManagedByIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_not_ilike":
			var err error
			it.AdManagedByNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_suffix":
			var err error
			it.AdManagedBySuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy_prefix":
			var err error
			it.AdManagedByPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_exists":
			var err error
			it.AdPasswordLastSetExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_eq":
			var err error
			it.AdPasswordLastSetEq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_neq":
			var err error
			it.AdPasswordLastSetNeq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_in":
			var err error
			it.AdPasswordLastSetIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_not_in":
			var err error
			it.AdPasswordLastSetNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_gt":
			var err error
			it.AdPasswordLastSetGt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_gte":
			var err error
			it.AdPasswordLastSetGte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_lt":
			var err error
			it.AdPasswordLastSetLt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_lte":
			var err error
			it.AdPasswordLastSetLte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPasswordLastSet_days":
			var err error
			it.AdPasswordLastSetDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_exists":
			var err error
			it.AdPrimaryGroupIDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_eq":
			var err error
			it.AdPrimaryGroupIDEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_neq":
			var err error
			it.AdPrimaryGroupIDNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_in":
			var err error
			it.AdPrimaryGroupIDIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_not_in":
			var err error
			it.AdPrimaryGroupIDNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_gt":
			var err error
			it.AdPrimaryGroupIDGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_gte":
			var err error
			it.AdPrimaryGroupIDGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_lt":
			var err error
			it.AdPrimaryGroupIDLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId_lte":
			var err error
			it.AdPrimaryGroupIDLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_exists":
			var err error
			it.AdPrimaryGroupDnExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_not":
			var err error
			it.AdPrimaryGroupDnNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_eq":
			var err error
			it.AdPrimaryGroupDnEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_neq":
			var err error
			it.AdPrimaryGroupDnNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_in":
			var err error
			it.AdPrimaryGroupDnIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_not_in":
			var err error
			it.AdPrimaryGroupDnNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_like":
			var err error
			it.AdPrimaryGroupDnLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_not_like":
			var err error
			it.AdPrimaryGroupDnNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_ilike":
			var err error
			it.AdPrimaryGroupDnIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_not_ilike":
			var err error
			it.AdPrimaryGroupDnNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_suffix":
			var err error
			it.AdPrimaryGroupDnSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn_prefix":
			var err error
			it.AdPrimaryGroupDnPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOf_contains":
			var err error
			it.AdMemberOfContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOf_contained_by":
			var err error
			it.AdMemberOfContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOf_overlap":
			var err error
			it.AdMemberOfOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOf_size":
			var err error
			it.AdMemberOfSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOf_contains_regex":
			var err error
			it.AdMemberOfContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOfFull_contains":
			var err error
			it.AdMemberOfFullContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOfFull_contained_by":
			var err error
			it.AdMemberOfFullContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOfFull_overlap":
			var err error
			it.AdMemberOfFullOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOfFull_size":
			var err error
			it.AdMemberOfFullSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOfFull_contains_regex":
			var err error
			it.AdMemberOfFullContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_exists":
			var err error
			it.AdUsnChangedExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_eq":
			var err error
			it.AdUsnChangedEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_neq":
			var err error
			it.AdUsnChangedNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_in":
			var err error
			it.AdUsnChangedIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_not_in":
			var err error
			it.AdUsnChangedNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_gt":
			var err error
			it.AdUsnChangedGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_gte":
			var err error
			it.AdUsnChangedGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_lt":
			var err error
			it.AdUsnChangedLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged_lte":
			var err error
			it.AdUsnChangedLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_exists":
			var err error
			it.AdUsnCreatedExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_eq":
			var err error
			it.AdUsnCreatedEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_neq":
			var err error
			it.AdUsnCreatedNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_in":
			var err error
			it.AdUsnCreatedIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_not_in":
			var err error
			it.AdUsnCreatedNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_gt":
			var err error
			it.AdUsnCreatedGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_gte":
			var err error
			it.AdUsnCreatedGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_lt":
			var err error
			it.AdUsnCreatedLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated_lte":
			var err error
			it.AdUsnCreatedLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_exists":
			var err error
			it.AdWhenChangedExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_eq":
			var err error
			it.AdWhenChangedEq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_neq":
			var err error
			it.AdWhenChangedNeq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_in":
			var err error
			it.AdWhenChangedIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_not_in":
			var err error
			it.AdWhenChangedNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_gt":
			var err error
			it.AdWhenChangedGt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_gte":
			var err error
			it.AdWhenChangedGte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_lt":
			var err error
			it.AdWhenChangedLt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_lte":
			var err error
			it.AdWhenChangedLte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenChanged_days":
			var err error
			it.AdWhenChangedDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_exists":
			var err error
			it.AdWhenCreatedExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_eq":
			var err error
			it.AdWhenCreatedEq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_neq":
			var err error
			it.AdWhenCreatedNeq, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_in":
			var err error
			it.AdWhenCreatedIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_not_in":
			var err error
			it.AdWhenCreatedNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_gt":
			var err error
			it.AdWhenCreatedGt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_gte":
			var err error
			it.AdWhenCreatedGte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_lt":
			var err error
			it.AdWhenCreatedLt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_lte":
			var err error
			it.AdWhenCreatedLte, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "adWhenCreated_days":
			var err error
			it.AdWhenCreatedDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adIsCriticalSystemObject_exists":
			var err error
			it.AdIsCriticalSystemObjectExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adIsCriticalSystemObject_eq":
			var err error
			it.AdIsCriticalSystemObjectEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adIsCriticalSystemObject_neq":
			var err error
			it.AdIsCriticalSystemObjectNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsAllowedToDelegateTo_contains":
			var err error
			it.AdMsdsAllowedToDelegateToContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsAllowedToDelegateTo_contained_by":
			var err error
			it.AdMsdsAllowedToDelegateToContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsAllowedToDelegateTo_overlap":
			var err error
			it.AdMsdsAllowedToDelegateToOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsAllowedToDelegateTo_size":
			var err error
			it.AdMsdsAllowedToDelegateToSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsAllowedToDelegateTo_contains_regex":
			var err error
			it.AdMsdsAllowedToDelegateToContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPwdMustChange_exists":
			var err error
			it.AdPwdMustChangeExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPwdMustChange_eq":
			var err error
			it.AdPwdMustChangeEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPwdMustChange_neq":
			var err error
			it.AdPwdMustChangeNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_exists":
			var err error
			it.AdMsdsResultantPsoExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_not":
			var err error
			it.AdMsdsResultantPsoNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_eq":
			var err error
			it.AdMsdsResultantPsoEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_neq":
			var err error
			it.AdMsdsResultantPsoNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_in":
			var err error
			it.AdMsdsResultantPsoIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_not_in":
			var err error
			it.AdMsdsResultantPsoNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_like":
			var err error
			it.AdMsdsResultantPsoLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_not_like":
			var err error
			it.AdMsdsResultantPsoNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_ilike":
			var err error
			it.AdMsdsResultantPsoIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_not_ilike":
			var err error
			it.AdMsdsResultantPsoNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_suffix":
			var err error
			it.AdMsdsResultantPsoSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso_prefix":
			var err error
			it.AdMsdsResultantPsoPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_exists":
			var err error
			it.IsSafeExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_not":
			var err error
			it.IsSafeNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_eq":
			var err error
			it.IsSafeEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_neq":
			var err error
			it.IsSafeNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_in":
			var err error
			it.IsSafeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_not_in":
			var err error
			it.IsSafeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_like":
			var err error
			it.IsSafeLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_not_like":
			var err error
			it.IsSafeNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_ilike":
			var err error
			it.IsSafeIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_not_ilike":
			var err error
			it.IsSafeNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_suffix":
			var err error
			it.IsSafeSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe_prefix":
			var err error
			it.IsSafePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceState_eq":
			var err error
			it.DeviceStateEq, err = ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceState_neq":
			var err error
			it.DeviceStateNeq, err = ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceState_in":
			var err error
			it.DeviceStateIn, err = ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceState_not_in":
			var err error
			it.DeviceStateNotIn, err = ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_exists":
			var err error
			it.PolicyIDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_not":
			var err error
			it.PolicyIDNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_eq":
			var err error
			it.PolicyIDEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_neq":
			var err error
			it.PolicyIDNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_in":
			var err error
			it.PolicyIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_not_in":
			var err error
			it.PolicyIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_like":
			var err error
			it.PolicyIDLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_not_like":
			var err error
			it.PolicyIDNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_ilike":
			var err error
			it.PolicyIDIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_not_ilike":
			var err error
			it.PolicyIDNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_suffix":
			var err error
			it.PolicyIDSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId_prefix":
			var err error
			it.PolicyIDPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_exists":
			var err error
			it.PolicyNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_not":
			var err error
			it.PolicyNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_eq":
			var err error
			it.PolicyNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_neq":
			var err error
			it.PolicyNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_in":
			var err error
			it.PolicyNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_not_in":
			var err error
			it.PolicyNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_like":
			var err error
			it.PolicyNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_not_like":
			var err error
			it.PolicyNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_ilike":
			var err error
			it.PolicyNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_not_ilike":
			var err error
			it.PolicyNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_suffix":
			var err error
			it.PolicyNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName_prefix":
			var err error
			it.PolicyNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policiesDetails_contains":
			var err error
			it.PoliciesDetailsContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policiesDetails_contained_by":
			var err error
			it.PoliciesDetailsContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policiesDetails_overlap":
			var err error
			it.PoliciesDetailsOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policiesDetails_size":
			var err error
			it.PoliciesDetailsSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "policiesDetails_contains_regex":
			var err error
			it.PoliciesDetailsContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_exists":
			var err error
			it.TenantTagExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_not":
			var err error
			it.TenantTagNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_eq":
			var err error
			it.TenantTagEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_neq":
			var err error
			it.TenantTagNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_in":
			var err error
			it.TenantTagIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_not_in":
			var err error
			it.TenantTagNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_like":
			var err error
			it.TenantTagLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_not_like":
			var err error
			it.TenantTagNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_ilike":
			var err error
			it.TenantTagIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_not_ilike":
			var err error
			it.TenantTagNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_suffix":
			var err error
			it.TenantTagSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag_prefix":
			var err error
			it.TenantTagPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "zoneNames_contains":
			var err error
			it.ZoneNamesContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "zoneNames_contained_by":
			var err error
			it.ZoneNamesContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "zoneNames_overlap":
			var err error
			it.ZoneNamesOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "zoneNames_size":
			var err error
			it.ZoneNamesSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "zoneNames_contains_regex":
			var err error
			it.ZoneNamesContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_exists":
			var err error
			it.AgentVersionExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not":
			var err error
			it.AgentVersionNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_eq":
			var err error
			it.AgentVersionEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_neq":
			var err error
			it.AgentVersionNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_in":
			var err error
			it.AgentVersionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_in":
			var err error
			it.AgentVersionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_like":
			var err error
			it.AgentVersionLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_like":
			var err error
			it.AgentVersionNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_ilike":
			var err error
			it.AgentVersionIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_ilike":
			var err error
			it.AgentVersionNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_suffix":
			var err error
			it.AgentVersionSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_prefix":
			var err error
			it.AgentVersionPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_exists":
			var err error
			it.ExternalIPExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_not":
			var err error
			it.ExternalIPNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_eq":
			var err error
			it.ExternalIPEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_neq":
			var err error
			it.ExternalIPNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_in":
			var err error
			it.ExternalIPIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_not_in":
			var err error
			it.ExternalIPNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_like":
			var err error
			it.ExternalIPLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_not_like":
			var err error
			it.ExternalIPNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_ilike":
			var err error
			it.ExternalIPIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_not_ilike":
			var err error
			it.ExternalIPNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_suffix":
			var err error
			it.ExternalIPSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp_prefix":
			var err error
			it.ExternalIPPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groups":
			var err error
			it.Groups, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "preventionPolicy":
			var err error
			it.PreventionPolicy, err = ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "sensorUpdatePolicy":
			var err error
			it.SensorUpdatePolicy, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_exists":
			var err error
			it.CsAgentVersionExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_not":
			var err error
			it.CsAgentVersionNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_eq":
			var err error
			it.CsAgentVersionEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_neq":
			var err error
			it.CsAgentVersionNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_in":
			var err error
			it.CsAgentVersionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_not_in":
			var err error
			it.CsAgentVersionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_like":
			var err error
			it.CsAgentVersionLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_not_like":
			var err error
			it.CsAgentVersionNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_ilike":
			var err error
			it.CsAgentVersionIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_not_ilike":
			var err error
			it.CsAgentVersionNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_suffix":
			var err error
			it.CsAgentVersionSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion_prefix":
			var err error
			it.CsAgentVersionPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_device_admin_bool_exp(ctx context.Context, obj interface{}) (AdapterDeviceAdminBoolExp, error) {
	var it AdapterDeviceAdminBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_eq":
			var err error
			it.TypeEq, err = ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_neq":
			var err error
			it.TypeNeq, err = ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_in":
			var err error
			it.TypeIn, err = ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not_in":
			var err error
			it.TypeNotIn, err = ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_device_bool_exp(ctx context.Context, obj interface{}) (AdapterDeviceBoolExp, error) {
	var it AdapterDeviceBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_exists":
			var err error
			it.FetchCycleExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_eq":
			var err error
			it.FetchCycleEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_neq":
			var err error
			it.FetchCycleNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_in":
			var err error
			it.FetchCycleIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_not_in":
			var err error
			it.FetchCycleNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gt":
			var err error
			it.FetchCycleGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gte":
			var err error
			it.FetchCycleGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lt":
			var err error
			it.FetchCycleLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lte":
			var err error
			it.FetchCycleLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_eq":
			var err error
			it.AdapterIDEq, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_neq":
			var err error
			it.AdapterIDNeq, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_in":
			var err error
			it.AdapterIDIn, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_not_in":
			var err error
			it.AdapterIDNotIn, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapter":
			var err error
			it.Adapter, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_exists":
			var err error
			it.AdapterNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not":
			var err error
			it.AdapterNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_eq":
			var err error
			it.AdapterNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_neq":
			var err error
			it.AdapterNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_in":
			var err error
			it.AdapterNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_in":
			var err error
			it.AdapterNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_like":
			var err error
			it.AdapterNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_like":
			var err error
			it.AdapterNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_ilike":
			var err error
			it.AdapterNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_ilike":
			var err error
			it.AdapterNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_suffix":
			var err error
			it.AdapterNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_prefix":
			var err error
			it.AdapterNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_exists":
			var err error
			it.DeviceIDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_eq":
			var err error
			it.DeviceIDEq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_neq":
			var err error
			it.DeviceIDNeq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_in":
			var err error
			it.DeviceIDIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_not_in":
			var err error
			it.DeviceIDNotIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gt":
			var err error
			it.DeviceIDGt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gte":
			var err error
			it.DeviceIDGte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lt":
			var err error
			it.DeviceIDLt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lte":
			var err error
			it.DeviceIDLte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterData":
			var err error
			it.AdapterData, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_exists":
			var err error
			it.FetchTimeExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_eq":
			var err error
			it.FetchTimeEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_neq":
			var err error
			it.FetchTimeNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_in":
			var err error
			it.FetchTimeIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_not_in":
			var err error
			it.FetchTimeNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_gt":
			var err error
			it.FetchTimeGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_gte":
			var err error
			it.FetchTimeGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_lt":
			var err error
			it.FetchTimeLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_lte":
			var err error
			it.FetchTimeLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_days":
			var err error
			it.FetchTimeDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_exists":
			var err error
			it.HostnameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_not":
			var err error
			it.HostnameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_eq":
			var err error
			it.HostnameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_neq":
			var err error
			it.HostnameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_in":
			var err error
			it.HostnameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_not_in":
			var err error
			it.HostnameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_like":
			var err error
			it.HostnameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_not_like":
			var err error
			it.HostnameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_ilike":
			var err error
			it.HostnameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_not_ilike":
			var err error
			it.HostnameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_suffix":
			var err error
			it.HostnameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname_prefix":
			var err error
			it.HostnamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_exists":
			var err error
			it.LastSeenExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_eq":
			var err error
			it.LastSeenEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_neq":
			var err error
			it.LastSeenNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_in":
			var err error
			it.LastSeenIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_not_in":
			var err error
			it.LastSeenNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gt":
			var err error
			it.LastSeenGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gte":
			var err error
			it.LastSeenGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lt":
			var err error
			it.LastSeenLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lte":
			var err error
			it.LastSeenLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_days":
			var err error
			it.LastSeenDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_exists":
			var err error
			it.OsIDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_eq":
			var err error
			it.OsIDEq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_neq":
			var err error
			it.OsIDNeq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_in":
			var err error
			it.OsIDIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_not_in":
			var err error
			it.OsIDNotIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_gt":
			var err error
			it.OsIDGt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_gte":
			var err error
			it.OsIDGte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_lt":
			var err error
			it.OsIDLt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId_lte":
			var err error
			it.OsIDLte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "os":
			var err error
			it.Os, err = ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_exists":
			var err error
			it.PrettyIDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_not":
			var err error
			it.PrettyIDNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_eq":
			var err error
			it.PrettyIDEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_neq":
			var err error
			it.PrettyIDNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_in":
			var err error
			it.PrettyIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_not_in":
			var err error
			it.PrettyIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_like":
			var err error
			it.PrettyIDLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_not_like":
			var err error
			it.PrettyIDNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_ilike":
			var err error
			it.PrettyIDIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_not_ilike":
			var err error
			it.PrettyIDNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_suffix":
			var err error
			it.PrettyIDSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId_prefix":
			var err error
			it.PrettyIDPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "interfaces":
			var err error
			it.Interfaces, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUsedUsers_contains":
			var err error
			it.LastUsedUsersContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUsedUsers_contained_by":
			var err error
			it.LastUsedUsersContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUsedUsers_overlap":
			var err error
			it.LastUsedUsersOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUsedUsers_size":
			var err error
			it.LastUsedUsersSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUsedUsers_contains_regex":
			var err error
			it.LastUsedUsersContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_exists":
			var err error
			it.DomainExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_not":
			var err error
			it.DomainNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_eq":
			var err error
			it.DomainEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_neq":
			var err error
			it.DomainNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_in":
			var err error
			it.DomainIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_not_in":
			var err error
			it.DomainNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_like":
			var err error
			it.DomainLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_not_like":
			var err error
			it.DomainNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_ilike":
			var err error
			it.DomainIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_not_ilike":
			var err error
			it.DomainNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_suffix":
			var err error
			it.DomainSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain_prefix":
			var err error
			it.DomainPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "partOfDomain_exists":
			var err error
			it.PartOfDomainExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "partOfDomain_eq":
			var err error
			it.PartOfDomainEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "partOfDomain_neq":
			var err error
			it.PartOfDomainNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceUsers":
			var err error
			it.DeviceUsers, err = ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "localAdmins":
			var err error
			it.LocalAdmins, err = ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "firewallRules":
			var err error
			it.FirewallRules, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "installedSoftware":
			var err error
			it.InstalledSoftware, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_exists":
			var err error
			it.AgentVersionExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not":
			var err error
			it.AgentVersionNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_eq":
			var err error
			it.AgentVersionEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_neq":
			var err error
			it.AgentVersionNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_in":
			var err error
			it.AgentVersionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_in":
			var err error
			it.AgentVersionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_like":
			var err error
			it.AgentVersionLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_like":
			var err error
			it.AgentVersionNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_ilike":
			var err error
			it.AgentVersionIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_not_ilike":
			var err error
			it.AgentVersionNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_suffix":
			var err error
			it.AgentVersionSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion_prefix":
			var err error
			it.AgentVersionPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_exists":
			var err error
			it.AgentStatusExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_not":
			var err error
			it.AgentStatusNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_eq":
			var err error
			it.AgentStatusEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_neq":
			var err error
			it.AgentStatusNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_in":
			var err error
			it.AgentStatusIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_not_in":
			var err error
			it.AgentStatusNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_like":
			var err error
			it.AgentStatusLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_not_like":
			var err error
			it.AgentStatusNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_ilike":
			var err error
			it.AgentStatusIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_not_ilike":
			var err error
			it.AgentStatusNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_suffix":
			var err error
			it.AgentStatusSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus_prefix":
			var err error
			it.AgentStatusPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_exists":
			var err error
			it.AgentNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_not":
			var err error
			it.AgentNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_eq":
			var err error
			it.AgentNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_neq":
			var err error
			it.AgentNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_in":
			var err error
			it.AgentNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_not_in":
			var err error
			it.AgentNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_like":
			var err error
			it.AgentNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_not_like":
			var err error
			it.AgentNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_ilike":
			var err error
			it.AgentNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_not_ilike":
			var err error
			it.AgentNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_suffix":
			var err error
			it.AgentNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName_prefix":
			var err error
			it.AgentNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_exists":
			var err error
			it.ModelExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_not":
			var err error
			it.ModelNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_eq":
			var err error
			it.ModelEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_neq":
			var err error
			it.ModelNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_in":
			var err error
			it.ModelIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_not_in":
			var err error
			it.ModelNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_like":
			var err error
			it.ModelLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_not_like":
			var err error
			it.ModelNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_ilike":
			var err error
			it.ModelIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_not_ilike":
			var err error
			it.ModelNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_suffix":
			var err error
			it.ModelSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "model_prefix":
			var err error
			it.ModelPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_exists":
			var err error
			it.ManufacturerExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_not":
			var err error
			it.ManufacturerNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_eq":
			var err error
			it.ManufacturerEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_neq":
			var err error
			it.ManufacturerNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_in":
			var err error
			it.ManufacturerIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_not_in":
			var err error
			it.ManufacturerNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_like":
			var err error
			it.ManufacturerLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_not_like":
			var err error
			it.ManufacturerNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_ilike":
			var err error
			it.ManufacturerIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_not_ilike":
			var err error
			it.ManufacturerNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_suffix":
			var err error
			it.ManufacturerSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer_prefix":
			var err error
			it.ManufacturerPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_exists":
			var err error
			it.SerialExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_not":
			var err error
			it.SerialNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_eq":
			var err error
			it.SerialEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_neq":
			var err error
			it.SerialNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_in":
			var err error
			it.SerialIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_not_in":
			var err error
			it.SerialNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_like":
			var err error
			it.SerialLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_not_like":
			var err error
			it.SerialNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_ilike":
			var err error
			it.SerialIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_not_ilike":
			var err error
			it.SerialNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_suffix":
			var err error
			it.SerialSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial_prefix":
			var err error
			it.SerialPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_exists":
			var err error
			it.FamilyExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_not":
			var err error
			it.FamilyNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_eq":
			var err error
			it.FamilyEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_neq":
			var err error
			it.FamilyNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_in":
			var err error
			it.FamilyIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_not_in":
			var err error
			it.FamilyNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_like":
			var err error
			it.FamilyLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_not_like":
			var err error
			it.FamilyNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_ilike":
			var err error
			it.FamilyIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_not_ilike":
			var err error
			it.FamilyNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_suffix":
			var err error
			it.FamilySuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "family_prefix":
			var err error
			it.FamilyPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_exists":
			var err error
			it.BiosVersionExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_not":
			var err error
			it.BiosVersionNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_eq":
			var err error
			it.BiosVersionEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_neq":
			var err error
			it.BiosVersionNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_in":
			var err error
			it.BiosVersionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_not_in":
			var err error
			it.BiosVersionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_like":
			var err error
			it.BiosVersionLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_not_like":
			var err error
			it.BiosVersionNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_ilike":
			var err error
			it.BiosVersionIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_not_ilike":
			var err error
			it.BiosVersionNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_suffix":
			var err error
			it.BiosVersionSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion_prefix":
			var err error
			it.BiosVersionPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_exists":
			var err error
			it.BiosSerialExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_not":
			var err error
			it.BiosSerialNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_eq":
			var err error
			it.BiosSerialEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_neq":
			var err error
			it.BiosSerialNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_in":
			var err error
			it.BiosSerialIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_not_in":
			var err error
			it.BiosSerialNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_like":
			var err error
			it.BiosSerialLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_not_like":
			var err error
			it.BiosSerialNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_ilike":
			var err error
			it.BiosSerialIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_not_ilike":
			var err error
			it.BiosSerialNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_suffix":
			var err error
			it.BiosSerialSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial_prefix":
			var err error
			it.BiosSerialPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_device_user_bool_exp(ctx context.Context, obj interface{}) (AdapterDeviceUserBoolExp, error) {
	var it AdapterDeviceUserBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "deviceId_exists":
			var err error
			it.DeviceIDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_eq":
			var err error
			it.DeviceIDEq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_neq":
			var err error
			it.DeviceIDNeq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_in":
			var err error
			it.DeviceIDIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_not_in":
			var err error
			it.DeviceIDNotIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gt":
			var err error
			it.DeviceIDGt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gte":
			var err error
			it.DeviceIDGte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lt":
			var err error
			it.DeviceIDLt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lte":
			var err error
			it.DeviceIDLte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_exists":
			var err error
			it.SidExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_not":
			var err error
			it.SidNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_eq":
			var err error
			it.SidEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_neq":
			var err error
			it.SidNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_in":
			var err error
			it.SidIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_not_in":
			var err error
			it.SidNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_like":
			var err error
			it.SidLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_not_like":
			var err error
			it.SidNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_ilike":
			var err error
			it.SidIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_not_ilike":
			var err error
			it.SidNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_suffix":
			var err error
			it.SidSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid_prefix":
			var err error
			it.SidPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_exists":
			var err error
			it.UsernameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not":
			var err error
			it.UsernameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_eq":
			var err error
			it.UsernameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_neq":
			var err error
			it.UsernameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_in":
			var err error
			it.UsernameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_in":
			var err error
			it.UsernameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_like":
			var err error
			it.UsernameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_like":
			var err error
			it.UsernameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_ilike":
			var err error
			it.UsernameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_ilike":
			var err error
			it.UsernameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_suffix":
			var err error
			it.UsernameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_prefix":
			var err error
			it.UsernamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_exists":
			var err error
			it.LastUseDateExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_eq":
			var err error
			it.LastUseDateEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_neq":
			var err error
			it.LastUseDateNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_in":
			var err error
			it.LastUseDateIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_not_in":
			var err error
			it.LastUseDateNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_gt":
			var err error
			it.LastUseDateGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_gte":
			var err error
			it.LastUseDateGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_lt":
			var err error
			it.LastUseDateLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_lte":
			var err error
			it.LastUseDateLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate_days":
			var err error
			it.LastUseDateDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "isLocal_exists":
			var err error
			it.IsLocalExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isLocal_eq":
			var err error
			it.IsLocalEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isLocal_neq":
			var err error
			it.IsLocalNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isDisabled_exists":
			var err error
			it.IsDisabledExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isDisabled_eq":
			var err error
			it.IsDisabledEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isDisabled_neq":
			var err error
			it.IsDisabledNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAdmin_exists":
			var err error
			it.IsAdminExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAdmin_eq":
			var err error
			it.IsAdminEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAdmin_neq":
			var err error
			it.IsAdminNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "userDepartment_exists":
			var err error
			it.UserDepartmentExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "userDepartment_eq":
			var err error
			it.UserDepartmentEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "userDepartment_neq":
			var err error
			it.UserDepartmentNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_exists":
			var err error
			it.PasswordMaxAgeExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_eq":
			var err error
			it.PasswordMaxAgeEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_neq":
			var err error
			it.PasswordMaxAgeNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_in":
			var err error
			it.PasswordMaxAgeIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_not_in":
			var err error
			it.PasswordMaxAgeNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_gt":
			var err error
			it.PasswordMaxAgeGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_gte":
			var err error
			it.PasswordMaxAgeGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_lt":
			var err error
			it.PasswordMaxAgeLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge_lte":
			var err error
			it.PasswordMaxAgeLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_exists":
			var err error
			it.InterpreterExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_not":
			var err error
			it.InterpreterNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_eq":
			var err error
			it.InterpreterEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_neq":
			var err error
			it.InterpreterNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_in":
			var err error
			it.InterpreterIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_not_in":
			var err error
			it.InterpreterNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_like":
			var err error
			it.InterpreterLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_not_like":
			var err error
			it.InterpreterNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_ilike":
			var err error
			it.InterpreterIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_not_ilike":
			var err error
			it.InterpreterNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_suffix":
			var err error
			it.InterpreterSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter_prefix":
			var err error
			it.InterpreterPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_user_bool_exp(ctx context.Context, obj interface{}) (AdapterUserBoolExp, error) {
	var it AdapterUserBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_exists":
			var err error
			it.FetchCycleExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_eq":
			var err error
			it.FetchCycleEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_neq":
			var err error
			it.FetchCycleNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_in":
			var err error
			it.FetchCycleIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_not_in":
			var err error
			it.FetchCycleNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gt":
			var err error
			it.FetchCycleGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gte":
			var err error
			it.FetchCycleGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lt":
			var err error
			it.FetchCycleLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lte":
			var err error
			it.FetchCycleLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_eq":
			var err error
			it.AdapterIDEq, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_neq":
			var err error
			it.AdapterIDNeq, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_in":
			var err error
			it.AdapterIDIn, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId_not_in":
			var err error
			it.AdapterIDNotIn, err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapter":
			var err error
			it.Adapter, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_exists":
			var err error
			it.AdapterNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not":
			var err error
			it.AdapterNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_eq":
			var err error
			it.AdapterNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_neq":
			var err error
			it.AdapterNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_in":
			var err error
			it.AdapterNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_in":
			var err error
			it.AdapterNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_like":
			var err error
			it.AdapterNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_like":
			var err error
			it.AdapterNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_ilike":
			var err error
			it.AdapterNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_not_ilike":
			var err error
			it.AdapterNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_suffix":
			var err error
			it.AdapterNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName_prefix":
			var err error
			it.AdapterNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_exists":
			var err error
			it.UserIDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_eq":
			var err error
			it.UserIDEq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_neq":
			var err error
			it.UserIDNeq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_in":
			var err error
			it.UserIDIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_not_in":
			var err error
			it.UserIDNotIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_gt":
			var err error
			it.UserIDGt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_gte":
			var err error
			it.UserIDGte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_lt":
			var err error
			it.UserIDLt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId_lte":
			var err error
			it.UserIDLte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterData":
			var err error
			it.AdapterData, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_exists":
			var err error
			it.FetchTimeExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_eq":
			var err error
			it.FetchTimeEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_neq":
			var err error
			it.FetchTimeNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_in":
			var err error
			it.FetchTimeIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_not_in":
			var err error
			it.FetchTimeNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_gt":
			var err error
			it.FetchTimeGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_gte":
			var err error
			it.FetchTimeGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_lt":
			var err error
			it.FetchTimeLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_lte":
			var err error
			it.FetchTimeLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime_days":
			var err error
			it.FetchTimeDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_exists":
			var err error
			it.LastSeenExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_eq":
			var err error
			it.LastSeenEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_neq":
			var err error
			it.LastSeenNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_in":
			var err error
			it.LastSeenIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_not_in":
			var err error
			it.LastSeenNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gt":
			var err error
			it.LastSeenGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gte":
			var err error
			it.LastSeenGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lt":
			var err error
			it.LastSeenLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lte":
			var err error
			it.LastSeenLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_days":
			var err error
			it.LastSeenDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_exists":
			var err error
			it.UsernameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not":
			var err error
			it.UsernameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_eq":
			var err error
			it.UsernameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_neq":
			var err error
			it.UsernameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_in":
			var err error
			it.UsernameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_in":
			var err error
			it.UsernameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_like":
			var err error
			it.UsernameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_like":
			var err error
			it.UsernameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_ilike":
			var err error
			it.UsernameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_not_ilike":
			var err error
			it.UsernameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_suffix":
			var err error
			it.UsernameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username_prefix":
			var err error
			it.UsernamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_exists":
			var err error
			it.FirstNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_not":
			var err error
			it.FirstNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_eq":
			var err error
			it.FirstNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_neq":
			var err error
			it.FirstNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_in":
			var err error
			it.FirstNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_not_in":
			var err error
			it.FirstNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_like":
			var err error
			it.FirstNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_not_like":
			var err error
			it.FirstNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_ilike":
			var err error
			it.FirstNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_not_ilike":
			var err error
			it.FirstNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_suffix":
			var err error
			it.FirstNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName_prefix":
			var err error
			it.FirstNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_exists":
			var err error
			it.LastNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_not":
			var err error
			it.LastNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_eq":
			var err error
			it.LastNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_neq":
			var err error
			it.LastNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_in":
			var err error
			it.LastNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_not_in":
			var err error
			it.LastNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_like":
			var err error
			it.LastNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_not_like":
			var err error
			it.LastNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_ilike":
			var err error
			it.LastNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_not_ilike":
			var err error
			it.LastNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_suffix":
			var err error
			it.LastNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName_prefix":
			var err error
			it.LastNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_exists":
			var err error
			it.MailExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_not":
			var err error
			it.MailNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_eq":
			var err error
			it.MailEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_neq":
			var err error
			it.MailNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_in":
			var err error
			it.MailIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_not_in":
			var err error
			it.MailNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_like":
			var err error
			it.MailLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_not_like":
			var err error
			it.MailNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_ilike":
			var err error
			it.MailIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_not_ilike":
			var err error
			it.MailNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_suffix":
			var err error
			it.MailSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail_prefix":
			var err error
			it.MailPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "admin_exists":
			var err error
			it.AdminExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "admin_eq":
			var err error
			it.AdminEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "admin_neq":
			var err error
			it.AdminNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "local_exists":
			var err error
			it.LocalExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "local_eq":
			var err error
			it.LocalEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "local_neq":
			var err error
			it.LocalNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "delegated_admin_exists":
			var err error
			it.DelegatedAdminExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "delegated_admin_eq":
			var err error
			it.DelegatedAdminEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "delegated_admin_neq":
			var err error
			it.DelegatedAdminNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enforced_exists":
			var err error
			it.MfaEnforcedExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enforced_eq":
			var err error
			it.MfaEnforcedEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enforced_neq":
			var err error
			it.MfaEnforcedNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enrolled_exists":
			var err error
			it.MfaEnrolledExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enrolled_eq":
			var err error
			it.MfaEnrolledEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfa_enrolled_neq":
			var err error
			it.MfaEnrolledNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "suspended_exists":
			var err error
			it.SuspendedExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "suspended_eq":
			var err error
			it.SuspendedEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "suspended_neq":
			var err error
			it.SuspendedNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "locked_exists":
			var err error
			it.LockedExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "locked_eq":
			var err error
			it.LockedEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "locked_neq":
			var err error
			it.LockedNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "disabled_exists":
			var err error
			it.DisabledExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "disabled_eq":
			var err error
			it.DisabledEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "disabled_neq":
			var err error
			it.DisabledNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_group_bool_exp(ctx context.Context, obj interface{}) (CsGroupBoolExp, error) {
	var it CsGroupBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not":
			var err error
			it.IDNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_like":
			var err error
			it.IDLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_like":
			var err error
			it.IDNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ilike":
			var err error
			it.IDIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_ilike":
			var err error
			it.IDNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_suffix":
			var err error
			it.IDSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_prefix":
			var err error
			it.IDPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_exists":
			var err error
			it.CreatedByExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not":
			var err error
			it.CreatedByNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_eq":
			var err error
			it.CreatedByEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_neq":
			var err error
			it.CreatedByNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_in":
			var err error
			it.CreatedByIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_in":
			var err error
			it.CreatedByNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_like":
			var err error
			it.CreatedByLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_like":
			var err error
			it.CreatedByNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_ilike":
			var err error
			it.CreatedByIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_ilike":
			var err error
			it.CreatedByNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_suffix":
			var err error
			it.CreatedBySuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_prefix":
			var err error
			it.CreatedByPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_exists":
			var err error
			it.CreatedTimestampExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_eq":
			var err error
			it.CreatedTimestampEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_neq":
			var err error
			it.CreatedTimestampNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_in":
			var err error
			it.CreatedTimestampIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_not_in":
			var err error
			it.CreatedTimestampNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_gt":
			var err error
			it.CreatedTimestampGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_gte":
			var err error
			it.CreatedTimestampGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_lt":
			var err error
			it.CreatedTimestampLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_lte":
			var err error
			it.CreatedTimestampLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp_days":
			var err error
			it.CreatedTimestampDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_exists":
			var err error
			it.DescriptionExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not":
			var err error
			it.DescriptionNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_eq":
			var err error
			it.DescriptionEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_neq":
			var err error
			it.DescriptionNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_in":
			var err error
			it.DescriptionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_in":
			var err error
			it.DescriptionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_like":
			var err error
			it.DescriptionLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_like":
			var err error
			it.DescriptionNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_ilike":
			var err error
			it.DescriptionIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_ilike":
			var err error
			it.DescriptionNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_suffix":
			var err error
			it.DescriptionSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_prefix":
			var err error
			it.DescriptionPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_exists":
			var err error
			it.GroupTypeExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_not":
			var err error
			it.GroupTypeNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_eq":
			var err error
			it.GroupTypeEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_neq":
			var err error
			it.GroupTypeNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_in":
			var err error
			it.GroupTypeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_not_in":
			var err error
			it.GroupTypeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_like":
			var err error
			it.GroupTypeLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_not_like":
			var err error
			it.GroupTypeNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_ilike":
			var err error
			it.GroupTypeIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_not_ilike":
			var err error
			it.GroupTypeNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_suffix":
			var err error
			it.GroupTypeSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType_prefix":
			var err error
			it.GroupTypePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_exists":
			var err error
			it.ModifiedByExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_not":
			var err error
			it.ModifiedByNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_eq":
			var err error
			it.ModifiedByEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_neq":
			var err error
			it.ModifiedByNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_in":
			var err error
			it.ModifiedByIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_not_in":
			var err error
			it.ModifiedByNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_like":
			var err error
			it.ModifiedByLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_not_like":
			var err error
			it.ModifiedByNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_ilike":
			var err error
			it.ModifiedByIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_not_ilike":
			var err error
			it.ModifiedByNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_suffix":
			var err error
			it.ModifiedBySuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy_prefix":
			var err error
			it.ModifiedByPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_exists":
			var err error
			it.ModifiedTimeExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_eq":
			var err error
			it.ModifiedTimeEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_neq":
			var err error
			it.ModifiedTimeNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_in":
			var err error
			it.ModifiedTimeIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_not_in":
			var err error
			it.ModifiedTimeNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_gt":
			var err error
			it.ModifiedTimeGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_gte":
			var err error
			it.ModifiedTimeGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_lt":
			var err error
			it.ModifiedTimeLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_lte":
			var err error
			it.ModifiedTimeLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime_days":
			var err error
			it.ModifiedTimeDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_policy_bool_exp(ctx context.Context, obj interface{}) (CsPolicyBoolExp, error) {
	var it CsPolicyBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_exists":
			var err error
			it.DescriptionExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not":
			var err error
			it.DescriptionNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_eq":
			var err error
			it.DescriptionEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_neq":
			var err error
			it.DescriptionNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_in":
			var err error
			it.DescriptionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_in":
			var err error
			it.DescriptionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_like":
			var err error
			it.DescriptionLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_like":
			var err error
			it.DescriptionNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_ilike":
			var err error
			it.DescriptionIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_ilike":
			var err error
			it.DescriptionNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_suffix":
			var err error
			it.DescriptionSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_prefix":
			var err error
			it.DescriptionPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_exists":
			var err error
			it.PlatformNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_not":
			var err error
			it.PlatformNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_eq":
			var err error
			it.PlatformNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_neq":
			var err error
			it.PlatformNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_in":
			var err error
			it.PlatformNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_not_in":
			var err error
			it.PlatformNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_like":
			var err error
			it.PlatformNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_not_like":
			var err error
			it.PlatformNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_ilike":
			var err error
			it.PlatformNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_not_ilike":
			var err error
			it.PlatformNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_suffix":
			var err error
			it.PlatformNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName_prefix":
			var err error
			it.PlatformNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groups":
			var err error
			it.Groups, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "enabled_exists":
			var err error
			it.EnabledExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "enabled_eq":
			var err error
			it.EnabledEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "enabled_neq":
			var err error
			it.EnabledNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_exists":
			var err error
			it.CreatedByExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not":
			var err error
			it.CreatedByNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_eq":
			var err error
			it.CreatedByEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_neq":
			var err error
			it.CreatedByNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_in":
			var err error
			it.CreatedByIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_in":
			var err error
			it.CreatedByNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_like":
			var err error
			it.CreatedByLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_like":
			var err error
			it.CreatedByNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_ilike":
			var err error
			it.CreatedByIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_ilike":
			var err error
			it.CreatedByNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_suffix":
			var err error
			it.CreatedBySuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_prefix":
			var err error
			it.CreatedByPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_exists":
			var err error
			it.CreatedTimeExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_eq":
			var err error
			it.CreatedTimeEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_neq":
			var err error
			it.CreatedTimeNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_in":
			var err error
			it.CreatedTimeIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_not_in":
			var err error
			it.CreatedTimeNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_gt":
			var err error
			it.CreatedTimeGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_gte":
			var err error
			it.CreatedTimeGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_lt":
			var err error
			it.CreatedTimeLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_lte":
			var err error
			it.CreatedTimeLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime_days":
			var err error
			it.CreatedTimeDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "preventionSettings":
			var err error
			it.PreventionSettings, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "sensorUpdateSettings":
			var err error
			it.SensorUpdateSettings, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_policy_settings_bool_exp(ctx context.Context, obj interface{}) (CsPolicySettingsBoolExp, error) {
	var it CsPolicySettingsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "enabled_exists":
			var err error
			it.EnabledExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "enabled_eq":
			var err error
			it.EnabledEq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "enabled_neq":
			var err error
			it.EnabledNeq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_prevention_settings_bool_exp(ctx context.Context, obj interface{}) (CsPreventionSettingsBoolExp, error) {
	var it CsPreventionSettingsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "settings":
			var err error
			it.Settings, err = ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_sensor_update_settings_bool_exp(ctx context.Context, obj interface{}) (CsSensorUpdateSettingsBoolExp, error) {
	var it CsSensorUpdateSettingsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "build_exists":
			var err error
			it.BuildExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not":
			var err error
			it.BuildNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_eq":
			var err error
			it.BuildEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_neq":
			var err error
			it.BuildNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_in":
			var err error
			it.BuildIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_in":
			var err error
			it.BuildNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_like":
			var err error
			it.BuildLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_like":
			var err error
			it.BuildNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_ilike":
			var err error
			it.BuildIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_ilike":
			var err error
			it.BuildNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_suffix":
			var err error
			it.BuildSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_prefix":
			var err error
			it.BuildPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputdevice_bool_exp(ctx context.Context, obj interface{}) (DeviceBoolExp, error) {
	var it DeviceBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_exists":
			var err error
			it.FetchCycleExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_eq":
			var err error
			it.FetchCycleEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_neq":
			var err error
			it.FetchCycleNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_in":
			var err error
			it.FetchCycleIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_not_in":
			var err error
			it.FetchCycleNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gt":
			var err error
			it.FetchCycleGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gte":
			var err error
			it.FetchCycleGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lt":
			var err error
			it.FetchCycleLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lte":
			var err error
			it.FetchCycleLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_exists":
			var err error
			it.AdapterCountExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_eq":
			var err error
			it.AdapterCountEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_neq":
			var err error
			it.AdapterCountNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_in":
			var err error
			it.AdapterCountIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_not_in":
			var err error
			it.AdapterCountNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_gt":
			var err error
			it.AdapterCountGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_gte":
			var err error
			it.AdapterCountGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_lt":
			var err error
			it.AdapterCountLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_lte":
			var err error
			it.AdapterCountLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contains":
			var err error
			it.AdapterNamesContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contained_by":
			var err error
			it.AdapterNamesContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_overlap":
			var err error
			it.AdapterNamesOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_size":
			var err error
			it.AdapterNamesSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contains_regex":
			var err error
			it.AdapterNamesContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostnames_contains":
			var err error
			it.HostnamesContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostnames_contained_by":
			var err error
			it.HostnamesContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostnames_overlap":
			var err error
			it.HostnamesOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostnames_size":
			var err error
			it.HostnamesSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostnames_contains_regex":
			var err error
			it.HostnamesContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_exists":
			var err error
			it.LastSeenExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_eq":
			var err error
			it.LastSeenEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_neq":
			var err error
			it.LastSeenNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_in":
			var err error
			it.LastSeenIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_not_in":
			var err error
			it.LastSeenNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gt":
			var err error
			it.LastSeenGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gte":
			var err error
			it.LastSeenGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lt":
			var err error
			it.LastSeenLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lte":
			var err error
			it.LastSeenLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_days":
			var err error
			it.LastSeenDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterDevices":
			var err error
			it.AdapterDevices, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "interfaces":
			var err error
			it.Interfaces, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputfirewall_rule_bool_exp(ctx context.Context, obj interface{}) (FirewallRuleBoolExp, error) {
	var it FirewallRuleBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_exists":
			var err error
			it.SourceExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_not":
			var err error
			it.SourceNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_eq":
			var err error
			it.SourceEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_neq":
			var err error
			it.SourceNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_in":
			var err error
			it.SourceIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_not_in":
			var err error
			it.SourceNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_like":
			var err error
			it.SourceLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_not_like":
			var err error
			it.SourceNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_ilike":
			var err error
			it.SourceIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_not_ilike":
			var err error
			it.SourceNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_suffix":
			var err error
			it.SourceSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_prefix":
			var err error
			it.SourcePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_eq":
			var err error
			it.TypeEq, err = ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_neq":
			var err error
			it.TypeNeq, err = ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_in":
			var err error
			it.TypeIn, err = ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not_in":
			var err error
			it.TypeNotIn, err = ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		case "direction_eq":
			var err error
			it.DirectionEq, err = ec.unmarshalODirection2bandicootpkggqlDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "direction_neq":
			var err error
			it.DirectionNeq, err = ec.unmarshalODirection2bandicootpkggqlDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "direction_in":
			var err error
			it.DirectionIn, err = ec.unmarshalODirection2bandicootpkggqlDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "direction_not_in":
			var err error
			it.DirectionNotIn, err = ec.unmarshalODirection2bandicootpkggqlDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_exists":
			var err error
			it.TargetExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_not":
			var err error
			it.TargetNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_eq":
			var err error
			it.TargetEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_neq":
			var err error
			it.TargetNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_in":
			var err error
			it.TargetIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_not_in":
			var err error
			it.TargetNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_like":
			var err error
			it.TargetLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_not_like":
			var err error
			it.TargetNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_ilike":
			var err error
			it.TargetIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_not_ilike":
			var err error
			it.TargetNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_suffix":
			var err error
			it.TargetSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_prefix":
			var err error
			it.TargetPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_exists":
			var err error
			it.ProtocolExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_not":
			var err error
			it.ProtocolNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_eq":
			var err error
			it.ProtocolEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_neq":
			var err error
			it.ProtocolNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_in":
			var err error
			it.ProtocolIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_not_in":
			var err error
			it.ProtocolNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_like":
			var err error
			it.ProtocolLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_not_like":
			var err error
			it.ProtocolNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_ilike":
			var err error
			it.ProtocolIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_not_ilike":
			var err error
			it.ProtocolNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_suffix":
			var err error
			it.ProtocolSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol_prefix":
			var err error
			it.ProtocolPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_exists":
			var err error
			it.SrcPortExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_eq":
			var err error
			it.SrcPortEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_neq":
			var err error
			it.SrcPortNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_in":
			var err error
			it.SrcPortIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_not_in":
			var err error
			it.SrcPortNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_gt":
			var err error
			it.SrcPortGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_gte":
			var err error
			it.SrcPortGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_lt":
			var err error
			it.SrcPortLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort_lte":
			var err error
			it.SrcPortLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_exists":
			var err error
			it.DstPortExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_eq":
			var err error
			it.DstPortEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_neq":
			var err error
			it.DstPortNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_in":
			var err error
			it.DstPortIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_not_in":
			var err error
			it.DstPortNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_gt":
			var err error
			it.DstPortGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_gte":
			var err error
			it.DstPortGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_lt":
			var err error
			it.DstPortLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort_lte":
			var err error
			it.DstPortLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputgce_tags_bool_exp(ctx context.Context, obj interface{}) (GceTagsBoolExp, error) {
	var it GceTagsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "gceKey_exists":
			var err error
			it.GceKeyExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_not":
			var err error
			it.GceKeyNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_eq":
			var err error
			it.GceKeyEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_neq":
			var err error
			it.GceKeyNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_in":
			var err error
			it.GceKeyIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_not_in":
			var err error
			it.GceKeyNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_like":
			var err error
			it.GceKeyLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_not_like":
			var err error
			it.GceKeyNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_ilike":
			var err error
			it.GceKeyIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_not_ilike":
			var err error
			it.GceKeyNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_suffix":
			var err error
			it.GceKeySuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceKey_prefix":
			var err error
			it.GceKeyPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_exists":
			var err error
			it.GceValueExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_not":
			var err error
			it.GceValueNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_eq":
			var err error
			it.GceValueEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_neq":
			var err error
			it.GceValueNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_in":
			var err error
			it.GceValueIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_not_in":
			var err error
			it.GceValueNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_like":
			var err error
			it.GceValueLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_not_like":
			var err error
			it.GceValueNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_ilike":
			var err error
			it.GceValueIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_not_ilike":
			var err error
			it.GceValueNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_suffix":
			var err error
			it.GceValueSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue_prefix":
			var err error
			it.GceValuePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputinstalled_software_bool_exp(ctx context.Context, obj interface{}) (InstalledSoftwareBoolExp, error) {
	var it InstalledSoftwareBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_exists":
			var err error
			it.VersionExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_not":
			var err error
			it.VersionNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_eq":
			var err error
			it.VersionEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_neq":
			var err error
			it.VersionNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_in":
			var err error
			it.VersionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_not_in":
			var err error
			it.VersionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_like":
			var err error
			it.VersionLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_not_like":
			var err error
			it.VersionNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_ilike":
			var err error
			it.VersionIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_not_ilike":
			var err error
			it.VersionNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_suffix":
			var err error
			it.VersionSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version_prefix":
			var err error
			it.VersionPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_eq":
			var err error
			it.ArchitectureEq, err = ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_neq":
			var err error
			it.ArchitectureNeq, err = ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_in":
			var err error
			it.ArchitectureIn, err = ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_not_in":
			var err error
			it.ArchitectureNotIn, err = ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_exists":
			var err error
			it.DescriptionExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not":
			var err error
			it.DescriptionNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_eq":
			var err error
			it.DescriptionEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_neq":
			var err error
			it.DescriptionNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_in":
			var err error
			it.DescriptionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_in":
			var err error
			it.DescriptionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_like":
			var err error
			it.DescriptionLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_like":
			var err error
			it.DescriptionNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_ilike":
			var err error
			it.DescriptionIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_ilike":
			var err error
			it.DescriptionNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_suffix":
			var err error
			it.DescriptionSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_prefix":
			var err error
			it.DescriptionPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_exists":
			var err error
			it.VendorExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_not":
			var err error
			it.VendorNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_eq":
			var err error
			it.VendorEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_neq":
			var err error
			it.VendorNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_in":
			var err error
			it.VendorIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_not_in":
			var err error
			it.VendorNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_like":
			var err error
			it.VendorLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_not_like":
			var err error
			it.VendorNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_ilike":
			var err error
			it.VendorIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_not_ilike":
			var err error
			it.VendorNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_suffix":
			var err error
			it.VendorSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor_prefix":
			var err error
			it.VendorPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_exists":
			var err error
			it.PublisherExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_not":
			var err error
			it.PublisherNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_eq":
			var err error
			it.PublisherEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_neq":
			var err error
			it.PublisherNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_in":
			var err error
			it.PublisherIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_not_in":
			var err error
			it.PublisherNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_like":
			var err error
			it.PublisherLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_not_like":
			var err error
			it.PublisherNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_ilike":
			var err error
			it.PublisherIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_not_ilike":
			var err error
			it.PublisherNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_suffix":
			var err error
			it.PublisherSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher_prefix":
			var err error
			it.PublisherPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_exists":
			var err error
			it.CveCountExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_eq":
			var err error
			it.CveCountEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_neq":
			var err error
			it.CveCountNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_in":
			var err error
			it.CveCountIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_not_in":
			var err error
			it.CveCountNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_gt":
			var err error
			it.CveCountGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_gte":
			var err error
			it.CveCountGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_lt":
			var err error
			it.CveCountLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount_lte":
			var err error
			it.CveCountLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_exists":
			var err error
			it.SwLicenseExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_not":
			var err error
			it.SwLicenseNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_eq":
			var err error
			it.SwLicenseEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_neq":
			var err error
			it.SwLicenseNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_in":
			var err error
			it.SwLicenseIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_not_in":
			var err error
			it.SwLicenseNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_like":
			var err error
			it.SwLicenseLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_not_like":
			var err error
			it.SwLicenseNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_ilike":
			var err error
			it.SwLicenseIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_not_ilike":
			var err error
			it.SwLicenseNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_suffix":
			var err error
			it.SwLicenseSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense_prefix":
			var err error
			it.SwLicensePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_exists":
			var err error
			it.PathExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_not":
			var err error
			it.PathNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_eq":
			var err error
			it.PathEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_neq":
			var err error
			it.PathNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_in":
			var err error
			it.PathIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_not_in":
			var err error
			it.PathNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_like":
			var err error
			it.PathLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_not_like":
			var err error
			it.PathNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_ilike":
			var err error
			it.PathIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_not_ilike":
			var err error
			it.PathNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_suffix":
			var err error
			it.PathSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "path_prefix":
			var err error
			it.PathPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputnetwork_interface_bool_exp(ctx context.Context, obj interface{}) (NetworkInterfaceBoolExp, error) {
	var it NetworkInterfaceBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "deviceId_exists":
			var err error
			it.DeviceIDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_eq":
			var err error
			it.DeviceIDEq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_neq":
			var err error
			it.DeviceIDNeq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_in":
			var err error
			it.DeviceIDIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_not_in":
			var err error
			it.DeviceIDNotIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gt":
			var err error
			it.DeviceIDGt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_gte":
			var err error
			it.DeviceIDGte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lt":
			var err error
			it.DeviceIDLt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId_lte":
			var err error
			it.DeviceIDLte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "macAddr_exists":
			var err error
			it.MacAddrExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "macAddr_eq":
			var err error
			it.MacAddrEq, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "macAddr_neq":
			var err error
			it.MacAddrNeq, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "macAddr_in":
			var err error
			it.MacAddrIn, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "macAddr_not_in":
			var err error
			it.MacAddrNotIn, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_contains":
			var err error
			it.IPAddrsContains, err = ec.unmarshalOIP2netIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_contained_by":
			var err error
			it.IPAddrsContainedBy, err = ec.unmarshalOIP2netIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_overlap":
			var err error
			it.IPAddrsOverlap, err = ec.unmarshalOIP2netIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_size":
			var err error
			it.IPAddrsSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_in_subnet":
			var err error
			it.IPAddrsInSubnet, err = ec.unmarshalOCIDR2netIPNet(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs_ip_family":
			var err error
			it.IPAddrsIPFamily, err = ec.unmarshalOIPFamily2bandicootpkggqlIPFamily(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputoperating_system_bool_exp(ctx context.Context, obj interface{}) (OperatingSystemBoolExp, error) {
	var it OperatingSystemBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_exists":
			var err error
			it.TypeExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not":
			var err error
			it.TypeNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_eq":
			var err error
			it.TypeEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_neq":
			var err error
			it.TypeNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_in":
			var err error
			it.TypeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not_in":
			var err error
			it.TypeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_like":
			var err error
			it.TypeLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not_like":
			var err error
			it.TypeNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_ilike":
			var err error
			it.TypeIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not_ilike":
			var err error
			it.TypeNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_suffix":
			var err error
			it.TypeSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_prefix":
			var err error
			it.TypePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_exists":
			var err error
			it.DistributionExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_not":
			var err error
			it.DistributionNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_eq":
			var err error
			it.DistributionEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_neq":
			var err error
			it.DistributionNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_in":
			var err error
			it.DistributionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_not_in":
			var err error
			it.DistributionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_like":
			var err error
			it.DistributionLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_not_like":
			var err error
			it.DistributionNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_ilike":
			var err error
			it.DistributionIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_not_ilike":
			var err error
			it.DistributionNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_suffix":
			var err error
			it.DistributionSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution_prefix":
			var err error
			it.DistributionPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_exists":
			var err error
			it.ArchitectureExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_eq":
			var err error
			it.ArchitectureEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_neq":
			var err error
			it.ArchitectureNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_in":
			var err error
			it.ArchitectureIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_not_in":
			var err error
			it.ArchitectureNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_gt":
			var err error
			it.ArchitectureGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_gte":
			var err error
			it.ArchitectureGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_lt":
			var err error
			it.ArchitectureLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture_lte":
			var err error
			it.ArchitectureLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_exists":
			var err error
			it.ServicePackExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_not":
			var err error
			it.ServicePackNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_eq":
			var err error
			it.ServicePackEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_neq":
			var err error
			it.ServicePackNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_in":
			var err error
			it.ServicePackIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_not_in":
			var err error
			it.ServicePackNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_like":
			var err error
			it.ServicePackLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_not_like":
			var err error
			it.ServicePackNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_ilike":
			var err error
			it.ServicePackIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_not_ilike":
			var err error
			it.ServicePackNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_suffix":
			var err error
			it.ServicePackSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack_prefix":
			var err error
			it.ServicePackPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_exists":
			var err error
			it.InstallDateExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_eq":
			var err error
			it.InstallDateEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_neq":
			var err error
			it.InstallDateNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_in":
			var err error
			it.InstallDateIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_not_in":
			var err error
			it.InstallDateNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_gt":
			var err error
			it.InstallDateGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_gte":
			var err error
			it.InstallDateGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_lt":
			var err error
			it.InstallDateLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_lte":
			var err error
			it.InstallDateLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate_days":
			var err error
			it.InstallDateDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_exists":
			var err error
			it.KernelVersionExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_not":
			var err error
			it.KernelVersionNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_eq":
			var err error
			it.KernelVersionEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_neq":
			var err error
			it.KernelVersionNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_in":
			var err error
			it.KernelVersionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_not_in":
			var err error
			it.KernelVersionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_like":
			var err error
			it.KernelVersionLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_not_like":
			var err error
			it.KernelVersionNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_ilike":
			var err error
			it.KernelVersionIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_not_ilike":
			var err error
			it.KernelVersionNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_suffix":
			var err error
			it.KernelVersionSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion_prefix":
			var err error
			it.KernelVersionPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_exists":
			var err error
			it.CodeNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_not":
			var err error
			it.CodeNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_eq":
			var err error
			it.CodeNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_neq":
			var err error
			it.CodeNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_in":
			var err error
			it.CodeNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_not_in":
			var err error
			it.CodeNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_like":
			var err error
			it.CodeNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_not_like":
			var err error
			it.CodeNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_ilike":
			var err error
			it.CodeNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_not_ilike":
			var err error
			it.CodeNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_suffix":
			var err error
			it.CodeNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName_prefix":
			var err error
			it.CodeNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_exists":
			var err error
			it.MajorExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_eq":
			var err error
			it.MajorEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_neq":
			var err error
			it.MajorNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_in":
			var err error
			it.MajorIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_not_in":
			var err error
			it.MajorNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_gt":
			var err error
			it.MajorGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_gte":
			var err error
			it.MajorGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_lt":
			var err error
			it.MajorLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "major_lte":
			var err error
			it.MajorLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_exists":
			var err error
			it.MinorExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_eq":
			var err error
			it.MinorEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_neq":
			var err error
			it.MinorNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_in":
			var err error
			it.MinorIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_not_in":
			var err error
			it.MinorNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_gt":
			var err error
			it.MinorGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_gte":
			var err error
			it.MinorGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_lt":
			var err error
			it.MinorLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor_lte":
			var err error
			it.MinorLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_exists":
			var err error
			it.BuildExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not":
			var err error
			it.BuildNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_eq":
			var err error
			it.BuildEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_neq":
			var err error
			it.BuildNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_in":
			var err error
			it.BuildIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_in":
			var err error
			it.BuildNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_like":
			var err error
			it.BuildLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_like":
			var err error
			it.BuildNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_ilike":
			var err error
			it.BuildIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_not_ilike":
			var err error
			it.BuildNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_suffix":
			var err error
			it.BuildSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "build_prefix":
			var err error
			it.BuildPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_exists":
			var err error
			it.RawNameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_not":
			var err error
			it.RawNameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_eq":
			var err error
			it.RawNameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_neq":
			var err error
			it.RawNameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_in":
			var err error
			it.RawNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_not_in":
			var err error
			it.RawNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_like":
			var err error
			it.RawNameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_not_like":
			var err error
			it.RawNameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_ilike":
			var err error
			it.RawNameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_not_ilike":
			var err error
			it.RawNameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_suffix":
			var err error
			it.RawNameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "RawName_prefix":
			var err error
			it.RawNamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputtag_bool_exp(ctx context.Context, obj interface{}) (TagBoolExp, error) {
	var it TagBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name_exists":
			var err error
			it.NameExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_eq":
			var err error
			it.NameEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_neq":
			var err error
			it.NameNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_like":
			var err error
			it.NameLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_like":
			var err error
			it.NameNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ilike":
			var err error
			it.NameIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ilike":
			var err error
			it.NameNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_suffix":
			var err error
			it.NameSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_prefix":
			var err error
			it.NamePrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_exists":
			var err error
			it.CreatorExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_not":
			var err error
			it.CreatorNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_eq":
			var err error
			it.CreatorEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_neq":
			var err error
			it.CreatorNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_in":
			var err error
			it.CreatorIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_not_in":
			var err error
			it.CreatorNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_like":
			var err error
			it.CreatorLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_not_like":
			var err error
			it.CreatorNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_ilike":
			var err error
			it.CreatorIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_not_ilike":
			var err error
			it.CreatorNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_suffix":
			var err error
			it.CreatorSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator_prefix":
			var err error
			it.CreatorPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_exists":
			var err error
			it.LevelExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_not":
			var err error
			it.LevelNot, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_eq":
			var err error
			it.LevelEq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_neq":
			var err error
			it.LevelNeq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_in":
			var err error
			it.LevelIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_not_in":
			var err error
			it.LevelNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_like":
			var err error
			it.LevelLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_not_like":
			var err error
			it.LevelNotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_ilike":
			var err error
			it.LevelIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_not_ilike":
			var err error
			it.LevelNotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_suffix":
			var err error
			it.LevelSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "level_prefix":
			var err error
			it.LevelPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputuser_bool_exp(ctx context.Context, obj interface{}) (UserBoolExp, error) {
	var it UserBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id_exists":
			var err error
			it.IDExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_eq":
			var err error
			it.IDEq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			it.IDNeq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_exists":
			var err error
			it.FetchCycleExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_eq":
			var err error
			it.FetchCycleEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_neq":
			var err error
			it.FetchCycleNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_in":
			var err error
			it.FetchCycleIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_not_in":
			var err error
			it.FetchCycleNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gt":
			var err error
			it.FetchCycleGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_gte":
			var err error
			it.FetchCycleGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lt":
			var err error
			it.FetchCycleLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle_lte":
			var err error
			it.FetchCycleLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_exists":
			var err error
			it.AdapterCountExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_eq":
			var err error
			it.AdapterCountEq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_neq":
			var err error
			it.AdapterCountNeq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_in":
			var err error
			it.AdapterCountIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_not_in":
			var err error
			it.AdapterCountNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_gt":
			var err error
			it.AdapterCountGt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_gte":
			var err error
			it.AdapterCountGte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_lt":
			var err error
			it.AdapterCountLt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount_lte":
			var err error
			it.AdapterCountLte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contains":
			var err error
			it.AdapterNamesContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contained_by":
			var err error
			it.AdapterNamesContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_overlap":
			var err error
			it.AdapterNamesOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_size":
			var err error
			it.AdapterNamesSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames_contains_regex":
			var err error
			it.AdapterNamesContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernames_contains":
			var err error
			it.UsernamesContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernames_contained_by":
			var err error
			it.UsernamesContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernames_overlap":
			var err error
			it.UsernamesOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernames_size":
			var err error
			it.UsernamesSize, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernames_contains_regex":
			var err error
			it.UsernamesContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_exists":
			var err error
			it.LastSeenExists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_eq":
			var err error
			it.LastSeenEq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_neq":
			var err error
			it.LastSeenNeq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_in":
			var err error
			it.LastSeenIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_not_in":
			var err error
			it.LastSeenNotIn, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gt":
			var err error
			it.LastSeenGt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_gte":
			var err error
			it.LastSeenGte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lt":
			var err error
			it.LastSeenLt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_lte":
			var err error
			it.LastSeenLte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen_days":
			var err error
			it.LastSeenDays, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterUsers":
			var err error
			it.AdapterUsers, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _AdapterData(ctx context.Context, sel ast.SelectionSet, obj AdapterData) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case ActiveDirectoryData:
		return ec._ActiveDirectoryData(ctx, sel, &obj)
	case *ActiveDirectoryData:
		if obj == nil {
			return graphql.Null
		}
		return ec._ActiveDirectoryData(ctx, sel, obj)
	case CylanceData:
		return ec._CylanceData(ctx, sel, &obj)
	case *CylanceData:
		if obj == nil {
			return graphql.Null
		}
		return ec._CylanceData(ctx, sel, obj)
	case CrowdStrikeData:
		return ec._CrowdStrikeData(ctx, sel, &obj)
	case *CrowdStrikeData:
		if obj == nil {
			return graphql.Null
		}
		return ec._CrowdStrikeData(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Aggregate(ctx context.Context, sel ast.SelectionSet, obj Aggregate) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var activeDirectoryDataImplementors = []string{"ActiveDirectoryData", "AdapterData"}

func (ec *executionContext) _ActiveDirectoryData(ctx context.Context, sel ast.SelectionSet, obj *ActiveDirectoryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, activeDirectoryDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActiveDirectoryData")
		case "adCn":
			out.Values[i] = ec._ActiveDirectoryData_adCn(ctx, field, obj)
		case "adSid":
			out.Values[i] = ec._ActiveDirectoryData_adSid(ctx, field, obj)
		case "adGuid":
			out.Values[i] = ec._ActiveDirectoryData_adGuid(ctx, field, obj)
		case "adName":
			out.Values[i] = ec._ActiveDirectoryData_adName(ctx, field, obj)
		case "adSAMAccountName":
			out.Values[i] = ec._ActiveDirectoryData_adSAMAccountName(ctx, field, obj)
		case "adUserPrincipalName":
			out.Values[i] = ec._ActiveDirectoryData_adUserPrincipalName(ctx, field, obj)
		case "adDisplayName":
			out.Values[i] = ec._ActiveDirectoryData_adDisplayName(ctx, field, obj)
		case "adDistinguishedName":
			out.Values[i] = ec._ActiveDirectoryData_adDistinguishedName(ctx, field, obj)
		case "adCanonicalName":
			out.Values[i] = ec._ActiveDirectoryData_adCanonicalName(ctx, field, obj)
		case "adAccountExpires":
			out.Values[i] = ec._ActiveDirectoryData_adAccountExpires(ctx, field, obj)
		case "adObjectClass":
			out.Values[i] = ec._ActiveDirectoryData_adObjectClass(ctx, field, obj)
		case "adObjectCategory":
			out.Values[i] = ec._ActiveDirectoryData_adObjectCategory(ctx, field, obj)
		case "adOrganizationalUnit":
			out.Values[i] = ec._ActiveDirectoryData_adOrganizationalUnit(ctx, field, obj)
		case "adLastLogoff":
			out.Values[i] = ec._ActiveDirectoryData_adLastLogoff(ctx, field, obj)
		case "adLastLogon":
			out.Values[i] = ec._ActiveDirectoryData_adLastLogon(ctx, field, obj)
		case "adLastLogonTimestamp":
			out.Values[i] = ec._ActiveDirectoryData_adLastLogonTimestamp(ctx, field, obj)
		case "adBadPasswordTime":
			out.Values[i] = ec._ActiveDirectoryData_adBadPasswordTime(ctx, field, obj)
		case "ad_bad_pwd_count":
			out.Values[i] = ec._ActiveDirectoryData_ad_bad_pwd_count(ctx, field, obj)
		case "adManagedBy":
			out.Values[i] = ec._ActiveDirectoryData_adManagedBy(ctx, field, obj)
		case "adPasswordLastSet":
			out.Values[i] = ec._ActiveDirectoryData_adPasswordLastSet(ctx, field, obj)
		case "adPrimaryGroupId":
			out.Values[i] = ec._ActiveDirectoryData_adPrimaryGroupId(ctx, field, obj)
		case "adPrimaryGroupDn":
			out.Values[i] = ec._ActiveDirectoryData_adPrimaryGroupDn(ctx, field, obj)
		case "adMemberOf":
			out.Values[i] = ec._ActiveDirectoryData_adMemberOf(ctx, field, obj)
		case "adMemberOfFull":
			out.Values[i] = ec._ActiveDirectoryData_adMemberOfFull(ctx, field, obj)
		case "adUsnChanged":
			out.Values[i] = ec._ActiveDirectoryData_adUsnChanged(ctx, field, obj)
		case "adUsnCreated":
			out.Values[i] = ec._ActiveDirectoryData_adUsnCreated(ctx, field, obj)
		case "adWhenChanged":
			out.Values[i] = ec._ActiveDirectoryData_adWhenChanged(ctx, field, obj)
		case "adWhenCreated":
			out.Values[i] = ec._ActiveDirectoryData_adWhenCreated(ctx, field, obj)
		case "adIsCriticalSystemObject":
			out.Values[i] = ec._ActiveDirectoryData_adIsCriticalSystemObject(ctx, field, obj)
		case "adMsdsAllowedToDelegateTo":
			out.Values[i] = ec._ActiveDirectoryData_adMsdsAllowedToDelegateTo(ctx, field, obj)
		case "adPwdMustChange":
			out.Values[i] = ec._ActiveDirectoryData_adPwdMustChange(ctx, field, obj)
		case "adMsdsResultantPso":
			out.Values[i] = ec._ActiveDirectoryData_adMsdsResultantPso(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterImplementors = []string{"Adapter"}

func (ec *executionContext) _Adapter(ctx context.Context, sel ast.SelectionSet, obj *Adapter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Adapter")
		case "id":
			out.Values[i] = ec._Adapter_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Adapter_name(ctx, field, obj)
		case "properties":
			out.Values[i] = ec._Adapter_properties(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDeviceImplementors = []string{"AdapterDevice"}

func (ec *executionContext) _AdapterDevice(ctx context.Context, sel ast.SelectionSet, obj *AdapterDevice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDeviceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterDevice")
		case "id":
			out.Values[i] = ec._AdapterDevice_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._AdapterDevice_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterId":
			out.Values[i] = ec._AdapterDevice_adapterId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapter":
			out.Values[i] = ec._AdapterDevice_adapter(ctx, field, obj)
		case "adapterName":
			out.Values[i] = ec._AdapterDevice_adapterName(ctx, field, obj)
		case "deviceId":
			out.Values[i] = ec._AdapterDevice_deviceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdapterDevice_adapterData(ctx, field, obj)
				return res
			})
		case "data":
			out.Values[i] = ec._AdapterDevice_data(ctx, field, obj)
		case "fetchTime":
			out.Values[i] = ec._AdapterDevice_fetchTime(ctx, field, obj)
		case "hostname":
			out.Values[i] = ec._AdapterDevice_hostname(ctx, field, obj)
		case "name":
			out.Values[i] = ec._AdapterDevice_name(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._AdapterDevice_lastSeen(ctx, field, obj)
		case "osId":
			out.Values[i] = ec._AdapterDevice_osId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "os":
			out.Values[i] = ec._AdapterDevice_os(ctx, field, obj)
		case "prettyId":
			out.Values[i] = ec._AdapterDevice_prettyId(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._AdapterDevice_tags(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec._AdapterDevice_interfaces(ctx, field, obj)
		case "lastUsedUsers":
			out.Values[i] = ec._AdapterDevice_lastUsedUsers(ctx, field, obj)
		case "domain":
			out.Values[i] = ec._AdapterDevice_domain(ctx, field, obj)
		case "partOfDomain":
			out.Values[i] = ec._AdapterDevice_partOfDomain(ctx, field, obj)
		case "deviceUsers":
			out.Values[i] = ec._AdapterDevice_deviceUsers(ctx, field, obj)
		case "localAdmins":
			out.Values[i] = ec._AdapterDevice_localAdmins(ctx, field, obj)
		case "firewallRules":
			out.Values[i] = ec._AdapterDevice_firewallRules(ctx, field, obj)
		case "installedSoftware":
			out.Values[i] = ec._AdapterDevice_installedSoftware(ctx, field, obj)
		case "agentVersion":
			out.Values[i] = ec._AdapterDevice_agentVersion(ctx, field, obj)
		case "agentStatus":
			out.Values[i] = ec._AdapterDevice_agentStatus(ctx, field, obj)
		case "agentName":
			out.Values[i] = ec._AdapterDevice_agentName(ctx, field, obj)
		case "model":
			out.Values[i] = ec._AdapterDevice_model(ctx, field, obj)
		case "manufacturer":
			out.Values[i] = ec._AdapterDevice_manufacturer(ctx, field, obj)
		case "serial":
			out.Values[i] = ec._AdapterDevice_serial(ctx, field, obj)
		case "family":
			out.Values[i] = ec._AdapterDevice_family(ctx, field, obj)
		case "biosVersion":
			out.Values[i] = ec._AdapterDevice_biosVersion(ctx, field, obj)
		case "biosSerial":
			out.Values[i] = ec._AdapterDevice_biosSerial(ctx, field, obj)
		case "tags_aggregate":
			out.Values[i] = ec._AdapterDevice_tags_aggregate(ctx, field, obj)
		case "interfaces_aggregate":
			out.Values[i] = ec._AdapterDevice_interfaces_aggregate(ctx, field, obj)
		case "firewallRules_aggregate":
			out.Values[i] = ec._AdapterDevice_firewallRules_aggregate(ctx, field, obj)
		case "installedSoftware_aggregate":
			out.Values[i] = ec._AdapterDevice_installedSoftware_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDeviceAdminImplementors = []string{"AdapterDeviceAdmin"}

func (ec *executionContext) _AdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, obj *AdapterDeviceAdmin) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDeviceAdminImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterDeviceAdmin")
		case "name":
			out.Values[i] = ec._AdapterDeviceAdmin_name(ctx, field, obj)
		case "type":
			out.Values[i] = ec._AdapterDeviceAdmin_type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDeviceUserImplementors = []string{"AdapterDeviceUser"}

func (ec *executionContext) _AdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, obj *AdapterDeviceUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDeviceUserImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterDeviceUser")
		case "deviceId":
			out.Values[i] = ec._AdapterDeviceUser_deviceId(ctx, field, obj)
		case "sid":
			out.Values[i] = ec._AdapterDeviceUser_sid(ctx, field, obj)
		case "username":
			out.Values[i] = ec._AdapterDeviceUser_username(ctx, field, obj)
		case "lastUseDate":
			out.Values[i] = ec._AdapterDeviceUser_lastUseDate(ctx, field, obj)
		case "isLocal":
			out.Values[i] = ec._AdapterDeviceUser_isLocal(ctx, field, obj)
		case "isDisabled":
			out.Values[i] = ec._AdapterDeviceUser_isDisabled(ctx, field, obj)
		case "isAdmin":
			out.Values[i] = ec._AdapterDeviceUser_isAdmin(ctx, field, obj)
		case "userDepartment":
			out.Values[i] = ec._AdapterDeviceUser_userDepartment(ctx, field, obj)
		case "passwordMaxAge":
			out.Values[i] = ec._AdapterDeviceUser_passwordMaxAge(ctx, field, obj)
		case "interpreter":
			out.Values[i] = ec._AdapterDeviceUser_interpreter(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterUserImplementors = []string{"AdapterUser"}

func (ec *executionContext) _AdapterUser(ctx context.Context, sel ast.SelectionSet, obj *AdapterUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterUserImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterUser")
		case "id":
			out.Values[i] = ec._AdapterUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._AdapterUser_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterId":
			out.Values[i] = ec._AdapterUser_adapterId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapter":
			out.Values[i] = ec._AdapterUser_adapter(ctx, field, obj)
		case "adapterName":
			out.Values[i] = ec._AdapterUser_adapterName(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._AdapterUser_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdapterUser_adapterData(ctx, field, obj)
				return res
			})
		case "data":
			out.Values[i] = ec._AdapterUser_data(ctx, field, obj)
		case "fetchTime":
			out.Values[i] = ec._AdapterUser_fetchTime(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._AdapterUser_lastSeen(ctx, field, obj)
		case "username":
			out.Values[i] = ec._AdapterUser_username(ctx, field, obj)
		case "firstName":
			out.Values[i] = ec._AdapterUser_firstName(ctx, field, obj)
		case "lastName":
			out.Values[i] = ec._AdapterUser_lastName(ctx, field, obj)
		case "mail":
			out.Values[i] = ec._AdapterUser_mail(ctx, field, obj)
		case "admin":
			out.Values[i] = ec._AdapterUser_admin(ctx, field, obj)
		case "local":
			out.Values[i] = ec._AdapterUser_local(ctx, field, obj)
		case "delegated_admin":
			out.Values[i] = ec._AdapterUser_delegated_admin(ctx, field, obj)
		case "mfa_enforced":
			out.Values[i] = ec._AdapterUser_mfa_enforced(ctx, field, obj)
		case "mfa_enrolled":
			out.Values[i] = ec._AdapterUser_mfa_enrolled(ctx, field, obj)
		case "suspended":
			out.Values[i] = ec._AdapterUser_suspended(ctx, field, obj)
		case "locked":
			out.Values[i] = ec._AdapterUser_locked(ctx, field, obj)
		case "disabled":
			out.Values[i] = ec._AdapterUser_disabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cPUImplementors = []string{"CPU"}

func (ec *executionContext) _CPU(ctx context.Context, sel ast.SelectionSet, obj *CPU) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cPUImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CPU")
		case "id":
			out.Values[i] = ec._CPU_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._CPU_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manfacturer":
			out.Values[i] = ec._CPU_manfacturer(ctx, field, obj)
		case "bitness":
			out.Values[i] = ec._CPU_bitness(ctx, field, obj)
		case "family":
			out.Values[i] = ec._CPU_family(ctx, field, obj)
		case "cores":
			out.Values[i] = ec._CPU_cores(ctx, field, obj)
		case "coresThreads":
			out.Values[i] = ec._CPU_coresThreads(ctx, field, obj)
		case "ghz":
			out.Values[i] = ec._CPU_ghz(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var crowdStrikeDataImplementors = []string{"CrowdStrikeData", "AdapterData"}

func (ec *executionContext) _CrowdStrikeData(ctx context.Context, sel ast.SelectionSet, obj *CrowdStrikeData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, crowdStrikeDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CrowdStrikeData")
		case "externalIp":
			out.Values[i] = ec._CrowdStrikeData_externalIp(ctx, field, obj)
		case "groups":
			out.Values[i] = ec._CrowdStrikeData_groups(ctx, field, obj)
		case "preventionPolicy":
			out.Values[i] = ec._CrowdStrikeData_preventionPolicy(ctx, field, obj)
		case "sensorUpdatePolicy":
			out.Values[i] = ec._CrowdStrikeData_sensorUpdatePolicy(ctx, field, obj)
		case "csAgentVersion":
			out.Values[i] = ec._CrowdStrikeData_csAgentVersion(ctx, field, obj)
		case "groups_aggregate":
			out.Values[i] = ec._CrowdStrikeData_groups_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cylanceDataImplementors = []string{"CylanceData", "AdapterData"}

func (ec *executionContext) _CylanceData(ctx context.Context, sel ast.SelectionSet, obj *CylanceData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cylanceDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CylanceData")
		case "isSafe":
			out.Values[i] = ec._CylanceData_isSafe(ctx, field, obj)
		case "deviceState":
			out.Values[i] = ec._CylanceData_deviceState(ctx, field, obj)
		case "policyId":
			out.Values[i] = ec._CylanceData_policyId(ctx, field, obj)
		case "policyName":
			out.Values[i] = ec._CylanceData_policyName(ctx, field, obj)
		case "policiesDetails":
			out.Values[i] = ec._CylanceData_policiesDetails(ctx, field, obj)
		case "tenantTag":
			out.Values[i] = ec._CylanceData_tenantTag(ctx, field, obj)
		case "zoneNames":
			out.Values[i] = ec._CylanceData_zoneNames(ctx, field, obj)
		case "agentVersion":
			out.Values[i] = ec._CylanceData_agentVersion(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deviceImplementors = []string{"Device"}

func (ec *executionContext) _Device(ctx context.Context, sel ast.SelectionSet, obj *Device) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deviceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Device")
		case "id":
			out.Values[i] = ec._Device_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._Device_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterCount":
			out.Values[i] = ec._Device_adapterCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterNames":
			out.Values[i] = ec._Device_adapterNames(ctx, field, obj)
		case "hostnames":
			out.Values[i] = ec._Device_hostnames(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._Device_lastSeen(ctx, field, obj)
		case "adapterDevices":
			out.Values[i] = ec._Device_adapterDevices(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec._Device_interfaces(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._Device_tags(ctx, field, obj)
		case "_compatibilityAPI":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Device__compatibilityAPI(ctx, field, obj)
				return res
			})
		case "adapterDevices_aggregate":
			out.Values[i] = ec._Device_adapterDevices_aggregate(ctx, field, obj)
		case "interfaces_aggregate":
			out.Values[i] = ec._Device_interfaces_aggregate(ctx, field, obj)
		case "tags_aggregate":
			out.Values[i] = ec._Device_tags_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var firewallRuleImplementors = []string{"FirewallRule"}

func (ec *executionContext) _FirewallRule(ctx context.Context, sel ast.SelectionSet, obj *FirewallRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, firewallRuleImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FirewallRule")
		case "name":
			out.Values[i] = ec._FirewallRule_name(ctx, field, obj)
		case "source":
			out.Values[i] = ec._FirewallRule_source(ctx, field, obj)
		case "type":
			out.Values[i] = ec._FirewallRule_type(ctx, field, obj)
		case "direction":
			out.Values[i] = ec._FirewallRule_direction(ctx, field, obj)
		case "target":
			out.Values[i] = ec._FirewallRule_target(ctx, field, obj)
		case "protocol":
			out.Values[i] = ec._FirewallRule_protocol(ctx, field, obj)
		case "srcPort":
			out.Values[i] = ec._FirewallRule_srcPort(ctx, field, obj)
		case "dstPort":
			out.Values[i] = ec._FirewallRule_dstPort(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gCETagsAggregateImplementors = []string{"GCETagsAggregate"}

func (ec *executionContext) _GCETagsAggregate(ctx context.Context, sel ast.SelectionSet, obj *GCETagsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gCETagsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GCETagsAggregate")
		case "group":
			out.Values[i] = ec._GCETagsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._GCETagsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._GCETagsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._GCETagsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._GCETagsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._GCETagsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._GCETagsAggregate_max(ctx, field, obj)
		case "GCETags":
			out.Values[i] = ec._GCETagsAggregate_GCETags(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gceTagsImplementors = []string{"GceTags"}

func (ec *executionContext) _GceTags(ctx context.Context, sel ast.SelectionSet, obj *GceTags) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gceTagsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GceTags")
		case "gceKey":
			out.Values[i] = ec._GceTags_gceKey(ctx, field, obj)
		case "gceValue":
			out.Values[i] = ec._GceTags_gceValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var googleCloudDataImplementors = []string{"GoogleCloudData"}

func (ec *executionContext) _GoogleCloudData(ctx context.Context, sel ast.SelectionSet, obj *GoogleCloudData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, googleCloudDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GoogleCloudData")
		case "Id":
			out.Values[i] = ec._GoogleCloudData_Id(ctx, field, obj)
		case "Size":
			out.Values[i] = ec._GoogleCloudData_Size(ctx, field, obj)
		case "Image":
			out.Values[i] = ec._GoogleCloudData_Image(ctx, field, obj)
		case "GCETags":
			out.Values[i] = ec._GoogleCloudData_GCETags(ctx, field, obj)
		case "GCETags_aggregate":
			out.Values[i] = ec._GoogleCloudData_GCETags_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var installedSoftwareImplementors = []string{"InstalledSoftware"}

func (ec *executionContext) _InstalledSoftware(ctx context.Context, sel ast.SelectionSet, obj *InstalledSoftware) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, installedSoftwareImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InstalledSoftware")
		case "name":
			out.Values[i] = ec._InstalledSoftware_name(ctx, field, obj)
		case "version":
			out.Values[i] = ec._InstalledSoftware_version(ctx, field, obj)
		case "architecture":
			out.Values[i] = ec._InstalledSoftware_architecture(ctx, field, obj)
		case "description":
			out.Values[i] = ec._InstalledSoftware_description(ctx, field, obj)
		case "vendor":
			out.Values[i] = ec._InstalledSoftware_vendor(ctx, field, obj)
		case "publisher":
			out.Values[i] = ec._InstalledSoftware_publisher(ctx, field, obj)
		case "cveCount":
			out.Values[i] = ec._InstalledSoftware_cveCount(ctx, field, obj)
		case "swLicense":
			out.Values[i] = ec._InstalledSoftware_swLicense(ctx, field, obj)
		case "path":
			out.Values[i] = ec._InstalledSoftware_path(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var networkInterfaceImplementors = []string{"NetworkInterface"}

func (ec *executionContext) _NetworkInterface(ctx context.Context, sel ast.SelectionSet, obj *NetworkInterface) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkInterfaceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkInterface")
		case "deviceId":
			out.Values[i] = ec._NetworkInterface_deviceId(ctx, field, obj)
		case "macAddr":
			out.Values[i] = ec._NetworkInterface_macAddr(ctx, field, obj)
		case "ipAddrs":
			out.Values[i] = ec._NetworkInterface_ipAddrs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var operatingSystemImplementors = []string{"OperatingSystem"}

func (ec *executionContext) _OperatingSystem(ctx context.Context, sel ast.SelectionSet, obj *OperatingSystem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, operatingSystemImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperatingSystem")
		case "id":
			out.Values[i] = ec._OperatingSystem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec._OperatingSystem_type(ctx, field, obj)
		case "distribution":
			out.Values[i] = ec._OperatingSystem_distribution(ctx, field, obj)
		case "architecture":
			out.Values[i] = ec._OperatingSystem_architecture(ctx, field, obj)
		case "servicePack":
			out.Values[i] = ec._OperatingSystem_servicePack(ctx, field, obj)
		case "installDate":
			out.Values[i] = ec._OperatingSystem_installDate(ctx, field, obj)
		case "kernelVersion":
			out.Values[i] = ec._OperatingSystem_kernelVersion(ctx, field, obj)
		case "codeName":
			out.Values[i] = ec._OperatingSystem_codeName(ctx, field, obj)
		case "major":
			out.Values[i] = ec._OperatingSystem_major(ctx, field, obj)
		case "minor":
			out.Values[i] = ec._OperatingSystem_minor(ctx, field, obj)
		case "build":
			out.Values[i] = ec._OperatingSystem_build(ctx, field, obj)
		case "RawName":
			out.Values[i] = ec._OperatingSystem_RawName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "adapterDevices":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterDevices(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "devices":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_devices(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "adapterUsers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "users":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "adapterDevices_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterDevices_aggregate(ctx, field)
				return res
			})
		case "devices_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_devices_aggregate(ctx, field)
				return res
			})
		case "adapterUsers_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterUsers_aggregate(ctx, field)
				return res
			})
		case "users_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users_aggregate(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var storageImplementors = []string{"Storage"}

func (ec *executionContext) _Storage(ctx context.Context, sel ast.SelectionSet, obj *Storage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Storage")
		case "deviceId":
			out.Values[i] = ec._Storage_deviceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "path":
			out.Values[i] = ec._Storage_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Storage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalSize":
			out.Values[i] = ec._Storage_totalSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "freeSize":
			out.Values[i] = ec._Storage_freeSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isEncrypted":
			out.Values[i] = ec._Storage_isEncrypted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Storage_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagImplementors = []string{"Tag"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "name":
			out.Values[i] = ec._Tag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "creator":
			out.Values[i] = ec._Tag_creator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "level":
			out.Values[i] = ec._Tag_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._User_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterCount":
			out.Values[i] = ec._User_adapterCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterNames":
			out.Values[i] = ec._User_adapterNames(ctx, field, obj)
		case "usernames":
			out.Values[i] = ec._User_usernames(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._User_lastSeen(ctx, field, obj)
		case "adapterUsers":
			out.Values[i] = ec._User_adapterUsers(ctx, field, obj)
		case "_compatibilityAPI":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User__compatibilityAPI(ctx, field, obj)
				return res
			})
		case "adapterUsers_aggregate":
			out.Values[i] = ec._User_adapterUsers_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDevicesAggregateImplementors = []string{"adapterDevicesAggregate"}

func (ec *executionContext) _adapterDevicesAggregate(ctx context.Context, sel ast.SelectionSet, obj *AdapterDevicesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDevicesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("adapterDevicesAggregate")
		case "group":
			out.Values[i] = ec._adapterDevicesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._adapterDevicesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._adapterDevicesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._adapterDevicesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._adapterDevicesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._adapterDevicesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._adapterDevicesAggregate_max(ctx, field, obj)
		case "adapterDevices":
			out.Values[i] = ec._adapterDevicesAggregate_adapterDevices(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterUsersAggregateImplementors = []string{"adapterUsersAggregate"}

func (ec *executionContext) _adapterUsersAggregate(ctx context.Context, sel ast.SelectionSet, obj *AdapterUsersAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterUsersAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("adapterUsersAggregate")
		case "group":
			out.Values[i] = ec._adapterUsersAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._adapterUsersAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._adapterUsersAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._adapterUsersAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._adapterUsersAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._adapterUsersAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._adapterUsersAggregate_max(ctx, field, obj)
		case "adapterUsers":
			out.Values[i] = ec._adapterUsersAggregate_adapterUsers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csGroupImplementors = []string{"csGroup"}

func (ec *executionContext) _csGroup(ctx context.Context, sel ast.SelectionSet, obj *CsGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csGroupImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csGroup")
		case "id":
			out.Values[i] = ec._csGroup_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._csGroup_name(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._csGroup_createdBy(ctx, field, obj)
		case "createdTimestamp":
			out.Values[i] = ec._csGroup_createdTimestamp(ctx, field, obj)
		case "description":
			out.Values[i] = ec._csGroup_description(ctx, field, obj)
		case "groupType":
			out.Values[i] = ec._csGroup_groupType(ctx, field, obj)
		case "modifiedBy":
			out.Values[i] = ec._csGroup_modifiedBy(ctx, field, obj)
		case "modifiedTime":
			out.Values[i] = ec._csGroup_modifiedTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csPolicyImplementors = []string{"csPolicy"}

func (ec *executionContext) _csPolicy(ctx context.Context, sel ast.SelectionSet, obj *CsPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csPolicy")
		case "name":
			out.Values[i] = ec._csPolicy_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._csPolicy_description(ctx, field, obj)
		case "platformName":
			out.Values[i] = ec._csPolicy_platformName(ctx, field, obj)
		case "groups":
			out.Values[i] = ec._csPolicy_groups(ctx, field, obj)
		case "enabled":
			out.Values[i] = ec._csPolicy_enabled(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._csPolicy_createdBy(ctx, field, obj)
		case "createdTime":
			out.Values[i] = ec._csPolicy_createdTime(ctx, field, obj)
		case "preventionSettings":
			out.Values[i] = ec._csPolicy_preventionSettings(ctx, field, obj)
		case "sensorUpdateSettings":
			out.Values[i] = ec._csPolicy_sensorUpdateSettings(ctx, field, obj)
		case "groups_aggregate":
			out.Values[i] = ec._csPolicy_groups_aggregate(ctx, field, obj)
		case "preventionSettings_aggregate":
			out.Values[i] = ec._csPolicy_preventionSettings_aggregate(ctx, field, obj)
		case "sensorUpdateSettings_aggregate":
			out.Values[i] = ec._csPolicy_sensorUpdateSettings_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csPolicySettingsImplementors = []string{"csPolicySettings"}

func (ec *executionContext) _csPolicySettings(ctx context.Context, sel ast.SelectionSet, obj *CsPolicySettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csPolicySettingsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csPolicySettings")
		case "enabled":
			out.Values[i] = ec._csPolicySettings_enabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csPreventionSettingsImplementors = []string{"csPreventionSettings"}

func (ec *executionContext) _csPreventionSettings(ctx context.Context, sel ast.SelectionSet, obj *CsPreventionSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csPreventionSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csPreventionSettings")
		case "name":
			out.Values[i] = ec._csPreventionSettings_name(ctx, field, obj)
		case "settings":
			out.Values[i] = ec._csPreventionSettings_settings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csSensorUpdateSettingsImplementors = []string{"csSensorUpdateSettings"}

func (ec *executionContext) _csSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, obj *CsSensorUpdateSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csSensorUpdateSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csSensorUpdateSettings")
		case "build":
			out.Values[i] = ec._csSensorUpdateSettings_build(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var devicesAggregateImplementors = []string{"devicesAggregate"}

func (ec *executionContext) _devicesAggregate(ctx context.Context, sel ast.SelectionSet, obj *DevicesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, devicesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("devicesAggregate")
		case "group":
			out.Values[i] = ec._devicesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._devicesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._devicesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._devicesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._devicesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._devicesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._devicesAggregate_max(ctx, field, obj)
		case "devices":
			out.Values[i] = ec._devicesAggregate_devices(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var firewallRulesAggregateImplementors = []string{"firewallRulesAggregate"}

func (ec *executionContext) _firewallRulesAggregate(ctx context.Context, sel ast.SelectionSet, obj *FirewallRulesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, firewallRulesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("firewallRulesAggregate")
		case "group":
			out.Values[i] = ec._firewallRulesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._firewallRulesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._firewallRulesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._firewallRulesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._firewallRulesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._firewallRulesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._firewallRulesAggregate_max(ctx, field, obj)
		case "firewallRules":
			out.Values[i] = ec._firewallRulesAggregate_firewallRules(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var groupsAggregateImplementors = []string{"groupsAggregate"}

func (ec *executionContext) _groupsAggregate(ctx context.Context, sel ast.SelectionSet, obj *GroupsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("groupsAggregate")
		case "group":
			out.Values[i] = ec._groupsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._groupsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._groupsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._groupsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._groupsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._groupsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._groupsAggregate_max(ctx, field, obj)
		case "groups":
			out.Values[i] = ec._groupsAggregate_groups(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var installedSoftwareAggregateImplementors = []string{"installedSoftwareAggregate"}

func (ec *executionContext) _installedSoftwareAggregate(ctx context.Context, sel ast.SelectionSet, obj *InstalledSoftwareAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, installedSoftwareAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("installedSoftwareAggregate")
		case "group":
			out.Values[i] = ec._installedSoftwareAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._installedSoftwareAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._installedSoftwareAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._installedSoftwareAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._installedSoftwareAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._installedSoftwareAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._installedSoftwareAggregate_max(ctx, field, obj)
		case "installedSoftware":
			out.Values[i] = ec._installedSoftwareAggregate_installedSoftware(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfacesAggregateImplementors = []string{"interfacesAggregate"}

func (ec *executionContext) _interfacesAggregate(ctx context.Context, sel ast.SelectionSet, obj *InterfacesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfacesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("interfacesAggregate")
		case "group":
			out.Values[i] = ec._interfacesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._interfacesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._interfacesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._interfacesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._interfacesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._interfacesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._interfacesAggregate_max(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec._interfacesAggregate_interfaces(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var preventionSettingsAggregateImplementors = []string{"preventionSettingsAggregate"}

func (ec *executionContext) _preventionSettingsAggregate(ctx context.Context, sel ast.SelectionSet, obj *PreventionSettingsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preventionSettingsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("preventionSettingsAggregate")
		case "group":
			out.Values[i] = ec._preventionSettingsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._preventionSettingsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._preventionSettingsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._preventionSettingsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._preventionSettingsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._preventionSettingsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._preventionSettingsAggregate_max(ctx, field, obj)
		case "preventionSettings":
			out.Values[i] = ec._preventionSettingsAggregate_preventionSettings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sensorUpdateSettingsAggregateImplementors = []string{"sensorUpdateSettingsAggregate"}

func (ec *executionContext) _sensorUpdateSettingsAggregate(ctx context.Context, sel ast.SelectionSet, obj *SensorUpdateSettingsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sensorUpdateSettingsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("sensorUpdateSettingsAggregate")
		case "group":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_max(ctx, field, obj)
		case "sensorUpdateSettings":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_sensorUpdateSettings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagsAggregateImplementors = []string{"tagsAggregate"}

func (ec *executionContext) _tagsAggregate(ctx context.Context, sel ast.SelectionSet, obj *TagsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("tagsAggregate")
		case "group":
			out.Values[i] = ec._tagsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._tagsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._tagsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._tagsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._tagsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._tagsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._tagsAggregate_max(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._tagsAggregate_tags(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var usersAggregateImplementors = []string{"usersAggregate"}

func (ec *executionContext) _usersAggregate(ctx context.Context, sel ast.SelectionSet, obj *UsersAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, usersAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("usersAggregate")
		case "group":
			out.Values[i] = ec._usersAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._usersAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._usersAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._usersAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._usersAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._usersAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._usersAggregate_max(ctx, field, obj)
		case "users":
			out.Values[i] = ec._usersAggregate_users(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v AdapterDevice) graphql.Marshaler {
	return ec._AdapterDevice(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v []AdapterDevice) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterDevice2bandicootpkggqlAdapterDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNAdapterType2bandicootpkgdomainAdapterType(ctx context.Context, v interface{}) (domain.AdapterType, error) {
	tmp, err := graphql.UnmarshalString(v)
	return domain.AdapterType(tmp), err
}

func (ec *executionContext) marshalNAdapterType2bandicootpkgdomainAdapterType(ctx context.Context, sel ast.SelectionSet, v domain.AdapterType) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v AdapterUser) graphql.Marshaler {
	return ec._AdapterUser(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v []AdapterUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterUser2bandicootpkggqlAdapterUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx context.Context, v interface{}) (AggregateOrdering, error) {
	var res AggregateOrdering
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx context.Context, sel ast.SelectionSet, v AggregateOrdering) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNDevice2bandicootpkggqlDevice(ctx context.Context, sel ast.SelectionSet, v Device) graphql.Marshaler {
	return ec._Device(ctx, sel, &v)
}

func (ec *executionContext) marshalNDevice2bandicootpkggqlDevice(ctx context.Context, sel ast.SelectionSet, v []Device) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDevice2bandicootpkggqlDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNGCETagsAggregate2bandicootpkggqlGCETagsAggregate(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregate) graphql.Marshaler {
	return ec._GCETagsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx context.Context, v interface{}) (GCETagsAggregateColumns, error) {
	var res GCETagsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx context.Context, v interface{}) (GCETagsAggregateMaxColumns, error) {
	var res GCETagsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx context.Context, v interface{}) ([]GCETagsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GCETagsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx context.Context, v interface{}) (GCETagsAggregateMinColumns, error) {
	var res GCETagsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx context.Context, v interface{}) ([]GCETagsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GCETagsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNIP2netIP(ctx context.Context, v interface{}) (net.IP, error) {
	return UnmarshalIPScalar(v)
}

func (ec *executionContext) marshalNIP2netIP(ctx context.Context, sel ast.SelectionSet, v net.IP) graphql.Marshaler {
	res := MarshalIPScalar(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNNetworkInterface2bandicootpkggqlNetworkInterface(ctx context.Context, sel ast.SelectionSet, v NetworkInterface) graphql.Marshaler {
	return ec._NetworkInterface(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNRelationType2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNRelationType2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalNTag2bandicootpkggqlTag(ctx context.Context, sel ast.SelectionSet, v Tag) graphql.Marshaler {
	return ec._Tag(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNUUID2githubcomsatorigouuidUUID(ctx context.Context, v interface{}) (uuid.UUID, error) {
	return UnmarshalUUIDScalar(v)
}

func (ec *executionContext) marshalNUUID2githubcomsatorigouuidUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	res := MarshalUUIDScalar(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2bandicootpkggqlUser(ctx context.Context, sel ast.SelectionSet, v User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2bandicootpkggqlUser(ctx context.Context, sel ast.SelectionSet, v []User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2bandicootpkggqlUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNadapterDevicesAggregate2bandicootpkggqlAdapterDevicesAggregate(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregate) graphql.Marshaler {
	return ec._adapterDevicesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateAvgColumns, error) {
	var res AdapterDevicesAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateColumns, error) {
	var res AdapterDevicesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateMaxColumns, error) {
	var res AdapterDevicesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateMinColumns, error) {
	var res AdapterDevicesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateSumColumns, error) {
	var res AdapterDevicesAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNadapterUsersAggregate2bandicootpkggqlAdapterUsersAggregate(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregate) graphql.Marshaler {
	return ec._adapterUsersAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateAvgColumns, error) {
	var res AdapterUsersAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx context.Context, v interface{}) ([]AdapterUsersAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateColumns, error) {
	var res AdapterUsersAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateMaxColumns, error) {
	var res AdapterUsersAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx context.Context, v interface{}) ([]AdapterUsersAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateMinColumns, error) {
	var res AdapterUsersAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx context.Context, v interface{}) ([]AdapterUsersAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateSumColumns, error) {
	var res AdapterUsersAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx context.Context, v interface{}) ([]AdapterUsersAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx context.Context, v interface{}) (AdapterBoolExp, error) {
	return ec.unmarshalInputadapter_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx context.Context, v interface{}) (AdapterDataBoolExp, error) {
	return ec.unmarshalInputadapter_data_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx context.Context, v interface{}) (AdapterDeviceAdminBoolExp, error) {
	return ec.unmarshalInputadapter_device_admin_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx context.Context, v interface{}) (AdapterDeviceBoolExp, error) {
	return ec.unmarshalInputadapter_device_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx context.Context, v interface{}) (AdapterDeviceOrderBy, error) {
	var res AdapterDeviceOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx context.Context, sel ast.SelectionSet, v AdapterDeviceOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx context.Context, v interface{}) (AdapterDeviceUserBoolExp, error) {
	return ec.unmarshalInputadapter_device_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx context.Context, v interface{}) (AdapterUserBoolExp, error) {
	return ec.unmarshalInputadapter_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx context.Context, v interface{}) (AdapterUserOrderBy, error) {
	var res AdapterUserOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx context.Context, sel ast.SelectionSet, v AdapterUserOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx context.Context, v interface{}) (CsGroupBoolExp, error) {
	return ec.unmarshalInputcs_group_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx context.Context, v interface{}) (CsPolicyBoolExp, error) {
	return ec.unmarshalInputcs_policy_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx context.Context, v interface{}) (CsPolicySettingsBoolExp, error) {
	return ec.unmarshalInputcs_policy_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx context.Context, v interface{}) (CsPreventionSettingsBoolExp, error) {
	return ec.unmarshalInputcs_prevention_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx context.Context, v interface{}) (CsSensorUpdateSettingsBoolExp, error) {
	return ec.unmarshalInputcs_sensor_update_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx context.Context, v interface{}) (DeviceBoolExp, error) {
	return ec.unmarshalInputdevice_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx context.Context, v interface{}) (DeviceOrderBy, error) {
	var res DeviceOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx context.Context, sel ast.SelectionSet, v DeviceOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNdevicesAggregate2bandicootpkggqlDevicesAggregate(ctx context.Context, sel ast.SelectionSet, v DevicesAggregate) graphql.Marshaler {
	return ec._devicesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx context.Context, v interface{}) (DevicesAggregateAvgColumns, error) {
	var res DevicesAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx context.Context, v interface{}) ([]DevicesAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx context.Context, v interface{}) (DevicesAggregateColumns, error) {
	var res DevicesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx context.Context, v interface{}) (DevicesAggregateMaxColumns, error) {
	var res DevicesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx context.Context, v interface{}) ([]DevicesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx context.Context, v interface{}) (DevicesAggregateMinColumns, error) {
	var res DevicesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx context.Context, v interface{}) ([]DevicesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx context.Context, v interface{}) (DevicesAggregateSumColumns, error) {
	var res DevicesAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx context.Context, v interface{}) ([]DevicesAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNfirewallRulesAggregate2bandicootpkggqlFirewallRulesAggregate(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregate) graphql.Marshaler {
	return ec._firewallRulesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateAvgColumns, error) {
	var res FirewallRulesAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx context.Context, v interface{}) ([]FirewallRulesAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateColumns, error) {
	var res FirewallRulesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateMaxColumns, error) {
	var res FirewallRulesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx context.Context, v interface{}) ([]FirewallRulesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateMinColumns, error) {
	var res FirewallRulesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx context.Context, v interface{}) ([]FirewallRulesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateSumColumns, error) {
	var res FirewallRulesAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx context.Context, v interface{}) ([]FirewallRulesAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx context.Context, v interface{}) (FirewallRuleBoolExp, error) {
	return ec.unmarshalInputfirewall_rule_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx context.Context, v interface{}) (GceTagsBoolExp, error) {
	return ec.unmarshalInputgce_tags_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNgroupsAggregate2bandicootpkggqlGroupsAggregate(ctx context.Context, sel ast.SelectionSet, v GroupsAggregate) graphql.Marshaler {
	return ec._groupsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx context.Context, v interface{}) (GroupsAggregateAvgColumns, error) {
	var res GroupsAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx context.Context, v interface{}) ([]GroupsAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx context.Context, v interface{}) (GroupsAggregateColumns, error) {
	var res GroupsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx context.Context, v interface{}) (GroupsAggregateMaxColumns, error) {
	var res GroupsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx context.Context, v interface{}) ([]GroupsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx context.Context, v interface{}) (GroupsAggregateMinColumns, error) {
	var res GroupsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx context.Context, v interface{}) ([]GroupsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx context.Context, v interface{}) (GroupsAggregateSumColumns, error) {
	var res GroupsAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx context.Context, v interface{}) ([]GroupsAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNinstalledSoftwareAggregate2bandicootpkggqlInstalledSoftwareAggregate(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregate) graphql.Marshaler {
	return ec._installedSoftwareAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateAvgColumns, error) {
	var res InstalledSoftwareAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateColumns, error) {
	var res InstalledSoftwareAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateMaxColumns, error) {
	var res InstalledSoftwareAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateMinColumns, error) {
	var res InstalledSoftwareAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateSumColumns, error) {
	var res InstalledSoftwareAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx context.Context, v interface{}) (InstalledSoftwareBoolExp, error) {
	return ec.unmarshalInputinstalled_software_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNinterfacesAggregate2bandicootpkggqlInterfacesAggregate(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregate) graphql.Marshaler {
	return ec._interfacesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx context.Context, v interface{}) (InterfacesAggregateColumns, error) {
	var res InterfacesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx context.Context, v interface{}) (InterfacesAggregateMaxColumns, error) {
	var res InterfacesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx context.Context, v interface{}) ([]InterfacesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InterfacesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx context.Context, v interface{}) (InterfacesAggregateMinColumns, error) {
	var res InterfacesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx context.Context, v interface{}) ([]InterfacesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InterfacesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx context.Context, v interface{}) (NetworkInterfaceBoolExp, error) {
	return ec.unmarshalInputnetwork_interface_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx context.Context, v interface{}) (OperatingSystemBoolExp, error) {
	return ec.unmarshalInputoperating_system_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNpreventionSettingsAggregate2bandicootpkggqlPreventionSettingsAggregate(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregate) graphql.Marshaler {
	return ec._preventionSettingsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx context.Context, v interface{}) (PreventionSettingsAggregateColumns, error) {
	var res PreventionSettingsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx context.Context, v interface{}) (PreventionSettingsAggregateMaxColumns, error) {
	var res PreventionSettingsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx context.Context, v interface{}) ([]PreventionSettingsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]PreventionSettingsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx context.Context, v interface{}) (PreventionSettingsAggregateMinColumns, error) {
	var res PreventionSettingsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx context.Context, v interface{}) ([]PreventionSettingsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]PreventionSettingsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNsensorUpdateSettingsAggregate2bandicootpkggqlSensorUpdateSettingsAggregate(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregate) graphql.Marshaler {
	return ec._sensorUpdateSettingsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx context.Context, v interface{}) (SensorUpdateSettingsAggregateColumns, error) {
	var res SensorUpdateSettingsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx context.Context, v interface{}) (SensorUpdateSettingsAggregateMaxColumns, error) {
	var res SensorUpdateSettingsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx context.Context, v interface{}) ([]SensorUpdateSettingsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]SensorUpdateSettingsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx context.Context, v interface{}) (SensorUpdateSettingsAggregateMinColumns, error) {
	var res SensorUpdateSettingsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx context.Context, v interface{}) ([]SensorUpdateSettingsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]SensorUpdateSettingsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNtag_bool_exp2bandicootpkggqlTagBoolExp(ctx context.Context, v interface{}) (TagBoolExp, error) {
	return ec.unmarshalInputtag_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNtagsAggregate2bandicootpkggqlTagsAggregate(ctx context.Context, sel ast.SelectionSet, v TagsAggregate) graphql.Marshaler {
	return ec._tagsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx context.Context, v interface{}) (TagsAggregateColumns, error) {
	var res TagsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v TagsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx context.Context, v interface{}) (TagsAggregateMaxColumns, error) {
	var res TagsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v TagsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx context.Context, v interface{}) ([]TagsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []TagsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx context.Context, v interface{}) (TagsAggregateMinColumns, error) {
	var res TagsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v TagsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx context.Context, v interface{}) ([]TagsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []TagsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNuser_bool_exp2bandicootpkggqlUserBoolExp(ctx context.Context, v interface{}) (UserBoolExp, error) {
	return ec.unmarshalInputuser_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNuser_order_by2bandicootpkggqlUserOrderBy(ctx context.Context, v interface{}) (UserOrderBy, error) {
	var res UserOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNuser_order_by2bandicootpkggqlUserOrderBy(ctx context.Context, sel ast.SelectionSet, v UserOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNusersAggregate2bandicootpkggqlUsersAggregate(ctx context.Context, sel ast.SelectionSet, v UsersAggregate) graphql.Marshaler {
	return ec._usersAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx context.Context, v interface{}) (UsersAggregateAvgColumns, error) {
	var res UsersAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx context.Context, v interface{}) ([]UsersAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx context.Context, v interface{}) (UsersAggregateColumns, error) {
	var res UsersAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx context.Context, v interface{}) (UsersAggregateMaxColumns, error) {
	var res UsersAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx context.Context, v interface{}) ([]UsersAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx context.Context, v interface{}) (UsersAggregateMinColumns, error) {
	var res UsersAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx context.Context, v interface{}) ([]UsersAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx context.Context, v interface{}) (UsersAggregateSumColumns, error) {
	var res UsersAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx context.Context, v interface{}) ([]UsersAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, v interface{}) (AccessType, error) {
	var res AccessType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, sel ast.SelectionSet, v AccessType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, v interface{}) ([]*AccessType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*AccessType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, sel ast.SelectionSet, v []*AccessType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAccessType2bandicootpkggqlAccessType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, v interface{}) (*AccessType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, sel ast.SelectionSet, v *AccessType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOAdapter2bandicootpkggqlAdapter(ctx context.Context, sel ast.SelectionSet, v Adapter) graphql.Marshaler {
	return ec._Adapter(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapter2bandicootpkggqlAdapter(ctx context.Context, sel ast.SelectionSet, v *Adapter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Adapter(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterData2bandicootpkggqlAdapterData(ctx context.Context, sel ast.SelectionSet, v AdapterData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterData(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v AdapterDevice) graphql.Marshaler {
	return ec._AdapterDevice(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v []AdapterDevice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterDevice2bandicootpkggqlAdapterDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v []*AdapterDevice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v *AdapterDevice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterDevice(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterDeviceAdmin2bandicootpkggqlAdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, v AdapterDeviceAdmin) graphql.Marshaler {
	return ec._AdapterDeviceAdmin(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterDeviceAdmin2bandicootpkggqlAdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, v []*AdapterDeviceAdmin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterDeviceAdmin2bandicootpkggqlAdapterDeviceAdmin(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDeviceAdmin2bandicootpkggqlAdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, v *AdapterDeviceAdmin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterDeviceAdmin(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterDeviceUser2bandicootpkggqlAdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, v AdapterDeviceUser) graphql.Marshaler {
	return ec._AdapterDeviceUser(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterDeviceUser2bandicootpkggqlAdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, v []*AdapterDeviceUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterDeviceUser2bandicootpkggqlAdapterDeviceUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDeviceUser2bandicootpkggqlAdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, v *AdapterDeviceUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterDeviceUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx context.Context, v interface{}) (domain.AdapterType, error) {
	tmp, err := graphql.UnmarshalString(v)
	return domain.AdapterType(tmp), err
}

func (ec *executionContext) marshalOAdapterType2bandicootpkgdomainAdapterType(ctx context.Context, sel ast.SelectionSet, v domain.AdapterType) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx context.Context, v interface{}) ([]*domain.AdapterType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*domain.AdapterType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAdapterType2bandicootpkgdomainAdapterType(ctx context.Context, sel ast.SelectionSet, v []*domain.AdapterType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterType2bandicootpkgdomainAdapterType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx context.Context, v interface{}) (*domain.AdapterType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAdapterType2bandicootpkgdomainAdapterType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAdapterType2bandicootpkgdomainAdapterType(ctx context.Context, sel ast.SelectionSet, v *domain.AdapterType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOAdapterType2bandicootpkgdomainAdapterType(ctx, sel, *v)
}

func (ec *executionContext) marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v AdapterUser) graphql.Marshaler {
	return ec._AdapterUser(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v []AdapterUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterUser2bandicootpkggqlAdapterUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v []*AdapterUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v *AdapterUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, v interface{}) (AdminType, error) {
	var res AdminType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, sel ast.SelectionSet, v AdminType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, v interface{}) ([]*AdminType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*AdminType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, sel ast.SelectionSet, v []*AdminType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdminType2bandicootpkggqlAdminType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, v interface{}) (*AdminType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, sel ast.SelectionSet, v *AdminType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx context.Context, v interface{}) ([]AggregateOrdering, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AggregateOrdering, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx context.Context, sel ast.SelectionSet, v []AggregateOrdering) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, v interface{}) (Architecture, error) {
	var res Architecture
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, sel ast.SelectionSet, v Architecture) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, v interface{}) ([]*Architecture, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*Architecture, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, sel ast.SelectionSet, v []*Architecture) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOArchitecture2bandicootpkggqlArchitecture(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, v interface{}) (*Architecture, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, sel ast.SelectionSet, v *Architecture) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOCIDR2netIPNet(ctx context.Context, v interface{}) (net.IPNet, error) {
	return UnmarshalCIDRScalar(v)
}

func (ec *executionContext) marshalOCIDR2netIPNet(ctx context.Context, sel ast.SelectionSet, v net.IPNet) graphql.Marshaler {
	return MarshalCIDRScalar(v)
}

func (ec *executionContext) unmarshalOCIDR2netIPNet(ctx context.Context, v interface{}) (*net.IPNet, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCIDR2netIPNet(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOCIDR2netIPNet(ctx context.Context, sel ast.SelectionSet, v *net.IPNet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOCIDR2netIPNet(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, v interface{}) (CylanceDeviceState, error) {
	var res CylanceDeviceState
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, sel ast.SelectionSet, v CylanceDeviceState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, v interface{}) ([]*CylanceDeviceState, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*CylanceDeviceState, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, sel ast.SelectionSet, v []*CylanceDeviceState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, v interface{}) (*CylanceDeviceState, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, sel ast.SelectionSet, v *CylanceDeviceState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODevice2bandicootpkggqlDevice(ctx context.Context, sel ast.SelectionSet, v Device) graphql.Marshaler {
	return ec._Device(ctx, sel, &v)
}

func (ec *executionContext) marshalODevice2bandicootpkggqlDevice(ctx context.Context, sel ast.SelectionSet, v []*Device) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODevice2bandicootpkggqlDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalODevice2bandicootpkggqlDevice(ctx context.Context, sel ast.SelectionSet, v *Device) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Device(ctx, sel, v)
}

func (ec *executionContext) unmarshalODirection2bandicootpkggqlDirection(ctx context.Context, v interface{}) (Direction, error) {
	var res Direction
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalODirection2bandicootpkggqlDirection(ctx context.Context, sel ast.SelectionSet, v Direction) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalODirection2bandicootpkggqlDirection(ctx context.Context, v interface{}) ([]*Direction, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*Direction, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalODirection2bandicootpkggqlDirection(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODirection2bandicootpkggqlDirection(ctx context.Context, sel ast.SelectionSet, v []*Direction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODirection2bandicootpkggqlDirection(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalODirection2bandicootpkggqlDirection(ctx context.Context, v interface{}) (*Direction, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODirection2bandicootpkggqlDirection(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODirection2bandicootpkggqlDirection(ctx context.Context, sel ast.SelectionSet, v *Direction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEpoch2bandicootinternalEpoch(ctx context.Context, v interface{}) (internal.Epoch, error) {
	return UnmarshalEpochScalar(v)
}

func (ec *executionContext) marshalOEpoch2bandicootinternalEpoch(ctx context.Context, sel ast.SelectionSet, v internal.Epoch) graphql.Marshaler {
	return MarshalEpochScalar(v)
}

func (ec *executionContext) unmarshalOEpoch2bandicootinternalEpoch(ctx context.Context, v interface{}) ([]*internal.Epoch, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*internal.Epoch, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEpoch2bandicootinternalEpoch(ctx context.Context, sel ast.SelectionSet, v []*internal.Epoch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOEpoch2bandicootinternalEpoch(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOEpoch2bandicootinternalEpoch(ctx context.Context, v interface{}) (*internal.Epoch, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOEpoch2bandicootinternalEpoch(ctx context.Context, sel ast.SelectionSet, v *internal.Epoch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, sel, *v)
}

func (ec *executionContext) marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx context.Context, sel ast.SelectionSet, v FirewallRule) graphql.Marshaler {
	return ec._FirewallRule(ctx, sel, &v)
}

func (ec *executionContext) marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx context.Context, sel ast.SelectionSet, v []*FirewallRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx context.Context, sel ast.SelectionSet, v *FirewallRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FirewallRule(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFloat2float64(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOFloat2float64(ctx, sel, *v)
}

func (ec *executionContext) marshalOGCETagsAggregate2bandicootpkggqlGCETagsAggregate(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETagsAggregate2bandicootpkggqlGCETagsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx context.Context, v interface{}) ([]GCETagsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GCETagsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOGceTags2bandicootpkggqlGceTags(ctx context.Context, sel ast.SelectionSet, v GceTags) graphql.Marshaler {
	return ec._GceTags(ctx, sel, &v)
}

func (ec *executionContext) marshalOGceTags2bandicootpkggqlGceTags(ctx context.Context, sel ast.SelectionSet, v []*GceTags) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGceTags2bandicootpkggqlGceTags(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOGceTags2bandicootpkggqlGceTags(ctx context.Context, sel ast.SelectionSet, v *GceTags) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GceTags(ctx, sel, v)
}

func (ec *executionContext) unmarshalOIP2netIP(ctx context.Context, v interface{}) (net.IP, error) {
	return UnmarshalIPScalar(v)
}

func (ec *executionContext) marshalOIP2netIP(ctx context.Context, sel ast.SelectionSet, v net.IP) graphql.Marshaler {
	return MarshalIPScalar(v)
}

func (ec *executionContext) unmarshalOIP2netIP(ctx context.Context, v interface{}) ([]net.IP, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]net.IP, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNIP2netIP(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOIP2netIP(ctx context.Context, sel ast.SelectionSet, v []net.IP) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNIP2netIP(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOIP2netIP(ctx context.Context, v interface{}) ([]*net.IP, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*net.IP, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOIP2netIP(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOIP2netIP(ctx context.Context, sel ast.SelectionSet, v []*net.IP) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOIP2netIP(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOIP2netIP(ctx context.Context, v interface{}) (*net.IP, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOIP2netIP(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOIP2netIP(ctx context.Context, sel ast.SelectionSet, v *net.IP) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOIP2netIP(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOIPFamily2bandicootpkggqlIPFamily(ctx context.Context, v interface{}) (IPFamily, error) {
	var res IPFamily
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOIPFamily2bandicootpkggqlIPFamily(ctx context.Context, sel ast.SelectionSet, v IPFamily) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOIPFamily2bandicootpkggqlIPFamily(ctx context.Context, v interface{}) (*IPFamily, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOIPFamily2bandicootpkggqlIPFamily(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOIPFamily2bandicootpkggqlIPFamily(ctx context.Context, sel ast.SelectionSet, v *IPFamily) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx context.Context, sel ast.SelectionSet, v InstalledSoftware) graphql.Marshaler {
	return ec._InstalledSoftware(ctx, sel, &v)
}

func (ec *executionContext) marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx context.Context, sel ast.SelectionSet, v []*InstalledSoftware) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx context.Context, sel ast.SelectionSet, v *InstalledSoftware) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InstalledSoftware(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]*int, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*int, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []*int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOInt2int(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOMac2string(ctx context.Context, v interface{}) (string, error) {
	return UnmarshalMacScalar(v)
}

func (ec *executionContext) marshalOMac2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return MarshalMacScalar(v)
}

func (ec *executionContext) unmarshalOMac2string(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOMac2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMac2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOMac2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOMac2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMac2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOMac2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOMac2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return graphql.UnmarshalMap(v)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalMap(v)
}

func (ec *executionContext) marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx context.Context, sel ast.SelectionSet, v NetworkInterface) graphql.Marshaler {
	return ec._NetworkInterface(ctx, sel, &v)
}

func (ec *executionContext) marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx context.Context, sel ast.SelectionSet, v []NetworkInterface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNetworkInterface2bandicootpkggqlNetworkInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx context.Context, sel ast.SelectionSet, v []*NetworkInterface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx context.Context, sel ast.SelectionSet, v *NetworkInterface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NetworkInterface(ctx, sel, v)
}

func (ec *executionContext) marshalOOperatingSystem2bandicootpkggqlOperatingSystem(ctx context.Context, sel ast.SelectionSet, v OperatingSystem) graphql.Marshaler {
	return ec._OperatingSystem(ctx, sel, &v)
}

func (ec *executionContext) marshalOOperatingSystem2bandicootpkggqlOperatingSystem(ctx context.Context, sel ast.SelectionSet, v *OperatingSystem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OperatingSystem(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOTag2bandicootpkggqlTag(ctx context.Context, sel ast.SelectionSet, v Tag) graphql.Marshaler {
	return ec._Tag(ctx, sel, &v)
}

func (ec *executionContext) marshalOTag2bandicootpkggqlTag(ctx context.Context, sel ast.SelectionSet, v []Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2bandicootpkggqlTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTag2bandicootpkggqlTag(ctx context.Context, sel ast.SelectionSet, v []*Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTag2bandicootpkggqlTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTag2bandicootpkggqlTag(ctx context.Context, sel ast.SelectionSet, v *Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return graphql.MarshalTime(v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) ([]*time.Time, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*time.Time, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []*time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOTime2timeTime(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTime2timeTime(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTime2timeTime(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, v interface{}) (uuid.UUID, error) {
	return UnmarshalUUIDScalar(v)
}

func (ec *executionContext) marshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	return MarshalUUIDScalar(v)
}

func (ec *executionContext) unmarshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, v interface{}) ([]*uuid.UUID, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*uuid.UUID, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, sel ast.SelectionSet, v []*uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOUUID2githubcomsatorigouuidUUID(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, v interface{}) (*uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, sel ast.SelectionSet, v *uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOUUID2githubcomsatorigouuidUUID(ctx, sel, *v)
}

func (ec *executionContext) marshalOUser2bandicootpkggqlUser(ctx context.Context, sel ast.SelectionSet, v User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2bandicootpkggqlUser(ctx context.Context, sel ast.SelectionSet, v []*User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2bandicootpkggqlUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOUser2bandicootpkggqlUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) marshalOadapterDevicesAggregate2bandicootpkggqlAdapterDevicesAggregate(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevicesAggregate2bandicootpkggqlAdapterDevicesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOadapterUsersAggregate2bandicootpkggqlAdapterUsersAggregate(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsersAggregate2bandicootpkggqlAdapterUsersAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx context.Context, v interface{}) ([]AdapterUsersAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx context.Context, v interface{}) (AdapterBoolExp, error) {
	return ec.unmarshalInputadapter_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx context.Context, v interface{}) ([]AdapterBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx context.Context, v interface{}) (*AdapterBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx context.Context, v interface{}) (AdapterDataBoolExp, error) {
	return ec.unmarshalInputadapter_data_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx context.Context, v interface{}) ([]AdapterDataBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDataBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx context.Context, v interface{}) (*AdapterDataBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx context.Context, v interface{}) (AdapterDeviceAdminBoolExp, error) {
	return ec.unmarshalInputadapter_device_admin_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx context.Context, v interface{}) ([]AdapterDeviceAdminBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceAdminBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx context.Context, v interface{}) (*AdapterDeviceAdminBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx context.Context, v interface{}) (AdapterDeviceBoolExp, error) {
	return ec.unmarshalInputadapter_device_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx context.Context, v interface{}) ([]AdapterDeviceBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx context.Context, v interface{}) (*AdapterDeviceBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx context.Context, v interface{}) ([]AdapterDeviceOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx context.Context, sel ast.SelectionSet, v []AdapterDeviceOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx context.Context, v interface{}) (AdapterDeviceUserBoolExp, error) {
	return ec.unmarshalInputadapter_device_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx context.Context, v interface{}) ([]AdapterDeviceUserBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceUserBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx context.Context, v interface{}) (*AdapterDeviceUserBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx context.Context, v interface{}) (AdapterUserBoolExp, error) {
	return ec.unmarshalInputadapter_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx context.Context, v interface{}) ([]AdapterUserBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUserBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx context.Context, v interface{}) (*AdapterUserBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx context.Context, v interface{}) ([]AdapterUserOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUserOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx context.Context, sel ast.SelectionSet, v []AdapterUserOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsGroup2bandicootpkggqlCsGroup(ctx context.Context, sel ast.SelectionSet, v CsGroup) graphql.Marshaler {
	return ec._csGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsGroup2bandicootpkggqlCsGroup(ctx context.Context, sel ast.SelectionSet, v []*CsGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsGroup2bandicootpkggqlCsGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsGroup2bandicootpkggqlCsGroup(ctx context.Context, sel ast.SelectionSet, v *CsGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csGroup(ctx, sel, v)
}

func (ec *executionContext) marshalOcsPolicy2bandicootpkggqlCsPolicy(ctx context.Context, sel ast.SelectionSet, v CsPolicy) graphql.Marshaler {
	return ec._csPolicy(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsPolicy2bandicootpkggqlCsPolicy(ctx context.Context, sel ast.SelectionSet, v *CsPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csPolicy(ctx, sel, v)
}

func (ec *executionContext) marshalOcsPolicySettings2bandicootpkggqlCsPolicySettings(ctx context.Context, sel ast.SelectionSet, v CsPolicySettings) graphql.Marshaler {
	return ec._csPolicySettings(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsPolicySettings2bandicootpkggqlCsPolicySettings(ctx context.Context, sel ast.SelectionSet, v []*CsPolicySettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsPolicySettings2bandicootpkggqlCsPolicySettings(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsPolicySettings2bandicootpkggqlCsPolicySettings(ctx context.Context, sel ast.SelectionSet, v *CsPolicySettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csPolicySettings(ctx, sel, v)
}

func (ec *executionContext) marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx context.Context, sel ast.SelectionSet, v CsPreventionSettings) graphql.Marshaler {
	return ec._csPreventionSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx context.Context, sel ast.SelectionSet, v []*CsPreventionSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx context.Context, sel ast.SelectionSet, v *CsPreventionSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csPreventionSettings(ctx, sel, v)
}

func (ec *executionContext) marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, v CsSensorUpdateSettings) graphql.Marshaler {
	return ec._csSensorUpdateSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, v []*CsSensorUpdateSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, v *CsSensorUpdateSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csSensorUpdateSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx context.Context, v interface{}) (CsGroupBoolExp, error) {
	return ec.unmarshalInputcs_group_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx context.Context, v interface{}) ([]CsGroupBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsGroupBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx context.Context, v interface{}) (*CsGroupBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx context.Context, v interface{}) (CsPolicyBoolExp, error) {
	return ec.unmarshalInputcs_policy_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx context.Context, v interface{}) ([]CsPolicyBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsPolicyBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx context.Context, v interface{}) (*CsPolicyBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx context.Context, v interface{}) (CsPolicySettingsBoolExp, error) {
	return ec.unmarshalInputcs_policy_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx context.Context, v interface{}) ([]CsPolicySettingsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsPolicySettingsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx context.Context, v interface{}) (*CsPolicySettingsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx context.Context, v interface{}) (CsPreventionSettingsBoolExp, error) {
	return ec.unmarshalInputcs_prevention_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx context.Context, v interface{}) ([]CsPreventionSettingsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsPreventionSettingsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx context.Context, v interface{}) (*CsPreventionSettingsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx context.Context, v interface{}) (CsSensorUpdateSettingsBoolExp, error) {
	return ec.unmarshalInputcs_sensor_update_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx context.Context, v interface{}) ([]CsSensorUpdateSettingsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsSensorUpdateSettingsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx context.Context, v interface{}) (*CsSensorUpdateSettingsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx context.Context, v interface{}) (DeviceBoolExp, error) {
	return ec.unmarshalInputdevice_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx context.Context, v interface{}) ([]DeviceBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DeviceBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx context.Context, v interface{}) (*DeviceBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx context.Context, v interface{}) ([]DeviceOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DeviceOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx context.Context, sel ast.SelectionSet, v []DeviceOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOdevicesAggregate2bandicootpkggqlDevicesAggregate(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevicesAggregate2bandicootpkggqlDevicesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx context.Context, v interface{}) ([]DevicesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOfirewallRulesAggregate2bandicootpkggqlFirewallRulesAggregate(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRulesAggregate2bandicootpkggqlFirewallRulesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx context.Context, v interface{}) ([]FirewallRulesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx context.Context, v interface{}) (FirewallRuleBoolExp, error) {
	return ec.unmarshalInputfirewall_rule_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx context.Context, v interface{}) ([]FirewallRuleBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRuleBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx context.Context, v interface{}) (*FirewallRuleBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx context.Context, v interface{}) (GceTagsBoolExp, error) {
	return ec.unmarshalInputgce_tags_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx context.Context, v interface{}) ([]GceTagsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GceTagsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx context.Context, v interface{}) (*GceTagsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOgroupsAggregate2bandicootpkggqlGroupsAggregate(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroupsAggregate2bandicootpkggqlGroupsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx context.Context, v interface{}) ([]GroupsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOinstalledSoftwareAggregate2bandicootpkggqlInstalledSoftwareAggregate(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftwareAggregate2bandicootpkggqlInstalledSoftwareAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx context.Context, v interface{}) (InstalledSoftwareBoolExp, error) {
	return ec.unmarshalInputinstalled_software_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx context.Context, v interface{}) ([]InstalledSoftwareBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx context.Context, v interface{}) (*InstalledSoftwareBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOinterfacesAggregate2bandicootpkggqlInterfacesAggregate(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfacesAggregate2bandicootpkggqlInterfacesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx context.Context, v interface{}) ([]InterfacesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InterfacesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx context.Context, v interface{}) (NetworkInterfaceBoolExp, error) {
	return ec.unmarshalInputnetwork_interface_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx context.Context, v interface{}) ([]NetworkInterfaceBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]NetworkInterfaceBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx context.Context, v interface{}) (*NetworkInterfaceBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx context.Context, v interface{}) (OperatingSystemBoolExp, error) {
	return ec.unmarshalInputoperating_system_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx context.Context, v interface{}) ([]OperatingSystemBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]OperatingSystemBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx context.Context, v interface{}) (*OperatingSystemBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOpreventionSettingsAggregate2bandicootpkggqlPreventionSettingsAggregate(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettingsAggregate2bandicootpkggqlPreventionSettingsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx context.Context, v interface{}) ([]PreventionSettingsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]PreventionSettingsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOsensorUpdateSettingsAggregate2bandicootpkggqlSensorUpdateSettingsAggregate(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettingsAggregate2bandicootpkggqlSensorUpdateSettingsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx context.Context, v interface{}) ([]SensorUpdateSettingsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]SensorUpdateSettingsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx context.Context, v interface{}) (TagBoolExp, error) {
	return ec.unmarshalInputtag_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx context.Context, v interface{}) ([]TagBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx context.Context, v interface{}) (*TagBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOtagsAggregate2bandicootpkggqlTagsAggregate(ctx context.Context, sel ast.SelectionSet, v []TagsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtagsAggregate2bandicootpkggqlTagsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx context.Context, v interface{}) ([]TagsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []TagsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx context.Context, v interface{}) (UserBoolExp, error) {
	return ec.unmarshalInputuser_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx context.Context, v interface{}) ([]UserBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UserBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx context.Context, v interface{}) (*UserBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOuser_order_by2bandicootpkggqlUserOrderBy(ctx context.Context, v interface{}) ([]UserOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UserOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNuser_order_by2bandicootpkggqlUserOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOuser_order_by2bandicootpkggqlUserOrderBy(ctx context.Context, sel ast.SelectionSet, v []UserOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNuser_order_by2bandicootpkggqlUserOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOusersAggregate2bandicootpkggqlUsersAggregate(ctx context.Context, sel ast.SelectionSet, v []UsersAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusersAggregate2bandicootpkggqlUsersAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx context.Context, v interface{}) ([]UsersAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

// endregion ***************************** type.gotpl *****************************
