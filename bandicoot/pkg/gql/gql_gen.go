// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bandicoot/internal"
	"bytes"
	"context"
	"errors"
	"fmt"
	"net"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/satori/go.uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AdapterDevice() AdapterDeviceResolver
	AdapterUser() AdapterUserResolver
	Device() DeviceResolver
	Query() QueryResolver
	User() UserResolver
}

type DirectiveRoot struct {
	GenerateInputs func(ctx context.Context, obj interface{}, next graphql.Resolver, where *string, orderBy *string) (res interface{}, err error)
	Jsonpath       func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string, depends []*string) (res interface{}, err error)
	Relation       func(ctx context.Context, obj interface{}, next graphql.Resolver, name string, fkName []string, relationFkName []string, relType string, manyToManyTableName *string, joinOn []string) (res interface{}, err error)
	Sqlgen         func(ctx context.Context, obj interface{}, next graphql.Resolver, skip bool) (res interface{}, err error)
	ViewFunction   func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string, arguments []*string) (res interface{}, err error)
}

type ComplexityRoot struct {
	ActiveDirectoryData struct {
		AdAccountExpires          func(childComplexity int) int
		AdBadPasswordTime         func(childComplexity int) int
		AdBadPwdCount             func(childComplexity int) int
		AdCanonicalName           func(childComplexity int) int
		AdCn                      func(childComplexity int) int
		AdDisplayName             func(childComplexity int) int
		AdDistinguishedName       func(childComplexity int) int
		AdGUID                    func(childComplexity int) int
		AdIsCriticalSystemObject  func(childComplexity int) int
		AdLastLogoff              func(childComplexity int) int
		AdLastLogon               func(childComplexity int) int
		AdLastLogonTimestamp      func(childComplexity int) int
		AdManagedBy               func(childComplexity int) int
		AdMemberOf                func(childComplexity int) int
		AdMemberOfFull            func(childComplexity int) int
		AdMsdsAllowedToDelegateTo func(childComplexity int) int
		AdMsdsResultantPso        func(childComplexity int) int
		AdName                    func(childComplexity int) int
		AdObjectCategory          func(childComplexity int) int
		AdObjectClass             func(childComplexity int) int
		AdOrganizationalUnit      func(childComplexity int) int
		AdPasswordLastSet         func(childComplexity int) int
		AdPrimaryGroupDn          func(childComplexity int) int
		AdPrimaryGroupID          func(childComplexity int) int
		AdPwdMustChange           func(childComplexity int) int
		AdSAMAccountName          func(childComplexity int) int
		AdSid                     func(childComplexity int) int
		AdUserPrincipalName       func(childComplexity int) int
		AdUsnChanged              func(childComplexity int) int
		AdUsnCreated              func(childComplexity int) int
		AdWhenChanged             func(childComplexity int) int
		AdWhenCreated             func(childComplexity int) int
	}

	Adapter struct {
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		Properties func(childComplexity int) int
	}

	AdapterDevice struct {
		Adapter                    func(childComplexity int, where *AdapterBoolExp) int
		AdapterData                func(childComplexity int, where *AdapterDataBoolExp) int
		AdapterID                  func(childComplexity int) int
		AdapterName                func(childComplexity int) int
		AgentName                  func(childComplexity int) int
		AgentStatus                func(childComplexity int) int
		AgentVersion               func(childComplexity int) int
		BiosSerial                 func(childComplexity int) int
		BiosVersion                func(childComplexity int) int
		Data                       func(childComplexity int) int
		DeviceID                   func(childComplexity int) int
		DeviceUsers                func(childComplexity int, limit *int, offset *int, where *AdapterDeviceUserBoolExp) int
		Domain                     func(childComplexity int) int
		Family                     func(childComplexity int) int
		FetchCycle                 func(childComplexity int) int
		FetchTime                  func(childComplexity int) int
		FirewallRules              func(childComplexity int, limit *int, offset *int, where *FirewallRuleBoolExp) int
		FirewallRulesAggregate     func(childComplexity int, groupBy []FirewallRulesAggregateColumns, distinctOn []FirewallRulesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *FirewallRuleBoolExp) int
		Hostname                   func(childComplexity int) int
		ID                         func(childComplexity int) int
		InstalledSoftware          func(childComplexity int, limit *int, offset *int, where *InstalledSoftwareBoolExp) int
		InstalledSoftwareAggregate func(childComplexity int, groupBy []InstalledSoftwareAggregateColumns, distinctOn []InstalledSoftwareAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *InstalledSoftwareBoolExp) int
		Interfaces                 func(childComplexity int, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		InterfacesAggregate        func(childComplexity int, groupBy []InterfacesAggregateColumns, distinctOn []InterfacesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		LastSeen                   func(childComplexity int) int
		LastUsedUsers              func(childComplexity int) int
		LocalAdmins                func(childComplexity int, limit *int, offset *int, where *AdapterDeviceAdminBoolExp) int
		Manufacturer               func(childComplexity int) int
		Model                      func(childComplexity int) int
		Name                       func(childComplexity int) int
		Os                         func(childComplexity int, where *OperatingSystemBoolExp) int
		OsID                       func(childComplexity int) int
		PartOfDomain               func(childComplexity int) int
		PrettyID                   func(childComplexity int) int
		Serial                     func(childComplexity int) int
		Tags                       func(childComplexity int, limit *int, offset *int, where *TagBoolExp) int
		TagsAggregate              func(childComplexity int, groupBy []TagsAggregateColumns, distinctOn []TagsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *TagBoolExp) int
	}

	AdapterDeviceAdmin struct {
		Name func(childComplexity int) int
		Type func(childComplexity int) int
	}

	AdapterDeviceUser struct {
		DeviceID       func(childComplexity int) int
		Interpreter    func(childComplexity int) int
		IsAdmin        func(childComplexity int) int
		IsDisabled     func(childComplexity int) int
		IsLocal        func(childComplexity int) int
		LastUseDate    func(childComplexity int) int
		PasswordMaxAge func(childComplexity int) int
		Sid            func(childComplexity int) int
		UserDepartment func(childComplexity int) int
		Username       func(childComplexity int) int
	}

	AdapterUser struct {
		Adapter        func(childComplexity int, where *AdapterBoolExp) int
		AdapterData    func(childComplexity int, where *AdapterDataBoolExp) int
		AdapterID      func(childComplexity int) int
		AdapterName    func(childComplexity int) int
		Admin          func(childComplexity int) int
		Data           func(childComplexity int) int
		DelegatedAdmin func(childComplexity int) int
		Description    func(childComplexity int) int
		Disabled       func(childComplexity int) int
		DisplayName    func(childComplexity int) int
		Domain         func(childComplexity int) int
		FetchCycle     func(childComplexity int) int
		FetchTime      func(childComplexity int) int
		FirstName      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastName       func(childComplexity int) int
		LastSeen       func(childComplexity int) int
		Local          func(childComplexity int) int
		Locked         func(childComplexity int) int
		Mail           func(childComplexity int) int
		MfaEnforced    func(childComplexity int) int
		MfaEnrolled    func(childComplexity int) int
		Suspended      func(childComplexity int) int
		UserID         func(childComplexity int) int
		UserSid        func(childComplexity int) int
		Username       func(childComplexity int) int
	}

	CPU struct {
		Bitness      func(childComplexity int) int
		Cores        func(childComplexity int) int
		CoresThreads func(childComplexity int) int
		Family       func(childComplexity int) int
		Ghz          func(childComplexity int) int
		ID           func(childComplexity int) int
		Manfacturer  func(childComplexity int) int
		Name         func(childComplexity int) int
	}

	CrowdStrikeData struct {
		CsAgentVersion     func(childComplexity int) int
		ExternalIP         func(childComplexity int) int
		Groups             func(childComplexity int, limit *int, offset *int, where *CsGroupBoolExp) int
		GroupsAggregate    func(childComplexity int, groupBy []GroupsAggregateColumns, distinctOn []GroupsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsGroupBoolExp) int
		PreventionPolicy   func(childComplexity int, where *CsPolicyBoolExp) int
		SensorUpdatePolicy func(childComplexity int, where *CsGroupBoolExp) int
	}

	CylanceData struct {
		AgentVersion    func(childComplexity int) int
		DeviceState     func(childComplexity int) int
		IsSafe          func(childComplexity int) int
		PoliciesDetails func(childComplexity int) int
		PolicyID        func(childComplexity int) int
		PolicyName      func(childComplexity int) int
		TenantTag       func(childComplexity int) int
		ZoneNames       func(childComplexity int) int
	}

	Device struct {
		AdapterCount            func(childComplexity int) int
		AdapterDevices          func(childComplexity int, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		AdapterDevicesAggregate func(childComplexity int, groupBy []AdapterDevicesAggregateColumns, distinctOn []AdapterDevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		AdapterNames            func(childComplexity int) int
		CompatibilityAPI        func(childComplexity int) int
		FetchCycle              func(childComplexity int) int
		Hostnames               func(childComplexity int) int
		ID                      func(childComplexity int) int
		Interfaces              func(childComplexity int, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		InterfacesAggregate     func(childComplexity int, groupBy []InterfacesAggregateColumns, distinctOn []InterfacesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		LastSeen                func(childComplexity int) int
		Tags                    func(childComplexity int, limit *int, offset *int, where *TagBoolExp) int
		TagsAggregate           func(childComplexity int, groupBy []TagsAggregateColumns, distinctOn []TagsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *TagBoolExp) int
	}

	FirewallRule struct {
		Direction func(childComplexity int) int
		DstPort   func(childComplexity int) int
		Name      func(childComplexity int) int
		Protocol  func(childComplexity int) int
		Source    func(childComplexity int) int
		SrcPort   func(childComplexity int) int
		Target    func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	GCETagsAggregate struct {
		Avg      func(childComplexity int) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		GCETags  func(childComplexity int, limit *int, offset *int, where *GceTagsBoolExp) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []GCETagsAggregateMaxColumns) int
		Min      func(childComplexity int, column []GCETagsAggregateMinColumns) int
		Sum      func(childComplexity int) int
	}

	GceTags struct {
		GceKey   func(childComplexity int) int
		GceValue func(childComplexity int) int
	}

	GoogleCloudData struct {
		GCETags          func(childComplexity int, limit *int, offset *int, where *GceTagsBoolExp) int
		GCETagsAggregate func(childComplexity int, groupBy []GCETagsAggregateColumns, distinctOn []GCETagsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *GceTagsBoolExp) int
		ID               func(childComplexity int) int
		Image            func(childComplexity int) int
		Size             func(childComplexity int) int
	}

	InstalledSoftware struct {
		Architecture func(childComplexity int) int
		CveCount     func(childComplexity int) int
		Description  func(childComplexity int) int
		Name         func(childComplexity int) int
		Path         func(childComplexity int) int
		Publisher    func(childComplexity int) int
		SwLicense    func(childComplexity int) int
		Vendor       func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	NetworkInterface struct {
		AdminStatus       func(childComplexity int) int
		DeviceID          func(childComplexity int) int
		Gateway           func(childComplexity int) int
		IPAddrs           func(childComplexity int) int
		MacAddr           func(childComplexity int) int
		Manufacturer      func(childComplexity int) int
		Mtu               func(childComplexity int) int
		Name              func(childComplexity int) int
		OperationalStatus func(childComplexity int) int
		Port              func(childComplexity int) int
		PortType          func(childComplexity int) int
		Subnets           func(childComplexity int) int
		Vlans             func(childComplexity int, limit *int, offset *int, where *NetworkInterfaceVlanBoolExp) int
		VlansAggregate    func(childComplexity int, groupBy []VlansAggregateColumns, distinctOn []VlansAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *NetworkInterfaceVlanBoolExp) int
	}

	NetworkInterfaceVlan struct {
		MacAddr func(childComplexity int) int
		Name    func(childComplexity int) int
		TagID   func(childComplexity int) int
		Tagged  func(childComplexity int) int
	}

	ObjectFilter struct {
		Description func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Filters     func(childComplexity int) int
		Name        func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	OperatingSystem struct {
		Architecture  func(childComplexity int) int
		Build         func(childComplexity int) int
		CodeName      func(childComplexity int) int
		Distribution  func(childComplexity int) int
		ID            func(childComplexity int) int
		InstallDate   func(childComplexity int) int
		KernelVersion func(childComplexity int) int
		Major         func(childComplexity int) int
		Minor         func(childComplexity int) int
		RawName       func(childComplexity int) int
		ServicePack   func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	Operator struct {
		Description   func(childComplexity int) int
		DisplayName   func(childComplexity int) int
		FormatDisplay func(childComplexity int) int
		Name          func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	Query struct {
		AdapterDevices          func(childComplexity int, limit *int, offset *int, where *AdapterDeviceBoolExp, orderBy []AdapterDeviceOrderBy) int
		AdapterDevicesAggregate func(childComplexity int, groupBy []AdapterDevicesAggregateColumns, distinctOn []AdapterDevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		AdapterUsers            func(childComplexity int, limit *int, offset *int, where *AdapterUserBoolExp, orderBy []AdapterUserOrderBy) int
		AdapterUsersAggregate   func(childComplexity int, groupBy []AdapterUsersAggregateColumns, distinctOn []AdapterUsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterUserBoolExp) int
		Devices                 func(childComplexity int, limit *int, offset *int, where *DeviceBoolExp, orderBy []DeviceOrderBy) int
		DevicesAggregate        func(childComplexity int, groupBy []DevicesAggregateColumns, distinctOn []DevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *DeviceBoolExp) int
		Users                   func(childComplexity int, limit *int, offset *int, where *UserBoolExp, orderBy []UserOrderBy) int
		UsersAggregate          func(childComplexity int, groupBy []UsersAggregateColumns, distinctOn []UsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *UserBoolExp) int
		WizardFilters           func(childComplexity int, typeArg string) int
	}

	ScalarFilter struct {
		Description func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Name        func(childComplexity int) int
		Operators   func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Storage struct {
		Description func(childComplexity int) int
		DeviceID    func(childComplexity int) int
		FreeSize    func(childComplexity int) int
		IsEncrypted func(childComplexity int) int
		Name        func(childComplexity int) int
		Path        func(childComplexity int) int
		TotalSize   func(childComplexity int) int
	}

	Tag struct {
		Creator func(childComplexity int) int
		Level   func(childComplexity int) int
		Name    func(childComplexity int) int
	}

	UnionFilter struct {
		Description func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Name        func(childComplexity int) int
		Objects     func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	User struct {
		AdapterCount          func(childComplexity int) int
		AdapterNames          func(childComplexity int) int
		AdapterUsers          func(childComplexity int, limit *int, offset *int, where *AdapterUserBoolExp) int
		AdapterUsersAggregate func(childComplexity int, groupBy []AdapterUsersAggregateColumns, distinctOn []AdapterUsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterUserBoolExp) int
		CompatibilityAPI      func(childComplexity int) int
		FetchCycle            func(childComplexity int) int
		ID                    func(childComplexity int) int
		LastSeen              func(childComplexity int) int
		Usernames             func(childComplexity int) int
	}

	AdapterDevicesAggregate struct {
		AdapterDevices func(childComplexity int, limit *int, offset *int, where *AdapterDeviceBoolExp) int
		Avg            func(childComplexity int, column []AdapterDevicesAggregateAvgColumns) int
		Count          func(childComplexity int) int
		Distinct       func(childComplexity int) int
		Group          func(childComplexity int) int
		Max            func(childComplexity int, column []AdapterDevicesAggregateMaxColumns) int
		Min            func(childComplexity int, column []AdapterDevicesAggregateMinColumns) int
		Sum            func(childComplexity int, column []AdapterDevicesAggregateSumColumns) int
	}

	AdapterUsersAggregate struct {
		AdapterUsers func(childComplexity int, limit *int, offset *int, where *AdapterUserBoolExp) int
		Avg          func(childComplexity int, column []AdapterUsersAggregateAvgColumns) int
		Count        func(childComplexity int) int
		Distinct     func(childComplexity int) int
		Group        func(childComplexity int) int
		Max          func(childComplexity int, column []AdapterUsersAggregateMaxColumns) int
		Min          func(childComplexity int, column []AdapterUsersAggregateMinColumns) int
		Sum          func(childComplexity int, column []AdapterUsersAggregateSumColumns) int
	}

	CsGroup struct {
		CreatedBy        func(childComplexity int) int
		CreatedTimestamp func(childComplexity int) int
		Description      func(childComplexity int) int
		GroupType        func(childComplexity int) int
		ID               func(childComplexity int) int
		ModifiedBy       func(childComplexity int) int
		ModifiedTime     func(childComplexity int) int
		Name             func(childComplexity int) int
	}

	CsPolicy struct {
		CreatedBy                     func(childComplexity int) int
		CreatedTime                   func(childComplexity int) int
		Description                   func(childComplexity int) int
		Enabled                       func(childComplexity int) int
		Groups                        func(childComplexity int, limit *int, offset *int, where *CsGroupBoolExp) int
		GroupsAggregate               func(childComplexity int, groupBy []GroupsAggregateColumns, distinctOn []GroupsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsGroupBoolExp) int
		Name                          func(childComplexity int) int
		PlatformName                  func(childComplexity int) int
		PreventionSettings            func(childComplexity int, limit *int, offset *int, where *CsPreventionSettingsBoolExp) int
		PreventionSettingsAggregate   func(childComplexity int, groupBy []PreventionSettingsAggregateColumns, distinctOn []PreventionSettingsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsPreventionSettingsBoolExp) int
		SensorUpdateSettings          func(childComplexity int, limit *int, offset *int, where *CsSensorUpdateSettingsBoolExp) int
		SensorUpdateSettingsAggregate func(childComplexity int, groupBy []SensorUpdateSettingsAggregateColumns, distinctOn []SensorUpdateSettingsAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *CsSensorUpdateSettingsBoolExp) int
	}

	CsPolicySettings struct {
		Enabled func(childComplexity int) int
	}

	CsPreventionSettings struct {
		Name     func(childComplexity int) int
		Settings func(childComplexity int, limit *int, offset *int, where *CsPolicySettingsBoolExp) int
	}

	CsSensorUpdateSettings struct {
		Build func(childComplexity int) int
	}

	DevicesAggregate struct {
		Avg      func(childComplexity int, column []DevicesAggregateAvgColumns) int
		Count    func(childComplexity int) int
		Devices  func(childComplexity int, limit *int, offset *int, where *DeviceBoolExp) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []DevicesAggregateMaxColumns) int
		Min      func(childComplexity int, column []DevicesAggregateMinColumns) int
		Sum      func(childComplexity int, column []DevicesAggregateSumColumns) int
	}

	FirewallRulesAggregate struct {
		Avg           func(childComplexity int, column []FirewallRulesAggregateAvgColumns) int
		Count         func(childComplexity int) int
		Distinct      func(childComplexity int) int
		FirewallRules func(childComplexity int, limit *int, offset *int, where *FirewallRuleBoolExp) int
		Group         func(childComplexity int) int
		Max           func(childComplexity int, column []FirewallRulesAggregateMaxColumns) int
		Min           func(childComplexity int, column []FirewallRulesAggregateMinColumns) int
		Sum           func(childComplexity int, column []FirewallRulesAggregateSumColumns) int
	}

	GroupsAggregate struct {
		Avg      func(childComplexity int, column []GroupsAggregateAvgColumns) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Groups   func(childComplexity int, limit *int, offset *int, where *CsGroupBoolExp) int
		Max      func(childComplexity int, column []GroupsAggregateMaxColumns) int
		Min      func(childComplexity int, column []GroupsAggregateMinColumns) int
		Sum      func(childComplexity int, column []GroupsAggregateSumColumns) int
	}

	InstalledSoftwareAggregate struct {
		Avg               func(childComplexity int, column []InstalledSoftwareAggregateAvgColumns) int
		Count             func(childComplexity int) int
		Distinct          func(childComplexity int) int
		Group             func(childComplexity int) int
		InstalledSoftware func(childComplexity int, limit *int, offset *int, where *InstalledSoftwareBoolExp) int
		Max               func(childComplexity int, column []InstalledSoftwareAggregateMaxColumns) int
		Min               func(childComplexity int, column []InstalledSoftwareAggregateMinColumns) int
		Sum               func(childComplexity int, column []InstalledSoftwareAggregateSumColumns) int
	}

	InterfacesAggregate struct {
		Avg        func(childComplexity int) int
		Count      func(childComplexity int) int
		Distinct   func(childComplexity int) int
		Group      func(childComplexity int) int
		Interfaces func(childComplexity int, limit *int, offset *int, where *NetworkInterfaceBoolExp) int
		Max        func(childComplexity int, column []InterfacesAggregateMaxColumns) int
		Min        func(childComplexity int, column []InterfacesAggregateMinColumns) int
		Sum        func(childComplexity int) int
	}

	PreventionSettingsAggregate struct {
		Avg                func(childComplexity int) int
		Count              func(childComplexity int) int
		Distinct           func(childComplexity int) int
		Group              func(childComplexity int) int
		Max                func(childComplexity int, column []PreventionSettingsAggregateMaxColumns) int
		Min                func(childComplexity int, column []PreventionSettingsAggregateMinColumns) int
		PreventionSettings func(childComplexity int, limit *int, offset *int, where *CsPreventionSettingsBoolExp) int
		Sum                func(childComplexity int) int
	}

	SensorUpdateSettingsAggregate struct {
		Avg                  func(childComplexity int) int
		Count                func(childComplexity int) int
		Distinct             func(childComplexity int) int
		Group                func(childComplexity int) int
		Max                  func(childComplexity int, column []SensorUpdateSettingsAggregateMaxColumns) int
		Min                  func(childComplexity int, column []SensorUpdateSettingsAggregateMinColumns) int
		SensorUpdateSettings func(childComplexity int, limit *int, offset *int, where *CsSensorUpdateSettingsBoolExp) int
		Sum                  func(childComplexity int) int
	}

	TagsAggregate struct {
		Avg      func(childComplexity int) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []TagsAggregateMaxColumns) int
		Min      func(childComplexity int, column []TagsAggregateMinColumns) int
		Sum      func(childComplexity int) int
		Tags     func(childComplexity int, limit *int, offset *int, where *TagBoolExp) int
	}

	UsersAggregate struct {
		Avg      func(childComplexity int, column []UsersAggregateAvgColumns) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []UsersAggregateMaxColumns) int
		Min      func(childComplexity int, column []UsersAggregateMinColumns) int
		Sum      func(childComplexity int, column []UsersAggregateSumColumns) int
		Users    func(childComplexity int, limit *int, offset *int, where *UserBoolExp) int
	}

	VlansAggregate struct {
		Avg      func(childComplexity int, column []VlansAggregateAvgColumns) int
		Count    func(childComplexity int) int
		Distinct func(childComplexity int) int
		Group    func(childComplexity int) int
		Max      func(childComplexity int, column []VlansAggregateMaxColumns) int
		Min      func(childComplexity int, column []VlansAggregateMinColumns) int
		Sum      func(childComplexity int, column []VlansAggregateSumColumns) int
		Vlans    func(childComplexity int, limit *int, offset *int, where *NetworkInterfaceVlanBoolExp) int
	}
}

type AdapterDeviceResolver interface {
	AdapterData(ctx context.Context, obj *AdapterDevice, where *AdapterDataBoolExp) (AdapterData, error)
}
type AdapterUserResolver interface {
	AdapterData(ctx context.Context, obj *AdapterUser, where *AdapterDataBoolExp) (AdapterData, error)
}
type DeviceResolver interface {
	CompatibilityAPI(ctx context.Context, obj *Device) (map[string]interface{}, error)
}
type QueryResolver interface {
	AdapterDevices(ctx context.Context, limit *int, offset *int, where *AdapterDeviceBoolExp, orderBy []AdapterDeviceOrderBy) ([]AdapterDevice, error)
	Devices(ctx context.Context, limit *int, offset *int, where *DeviceBoolExp, orderBy []DeviceOrderBy) ([]Device, error)
	AdapterUsers(ctx context.Context, limit *int, offset *int, where *AdapterUserBoolExp, orderBy []AdapterUserOrderBy) ([]AdapterUser, error)
	Users(ctx context.Context, limit *int, offset *int, where *UserBoolExp, orderBy []UserOrderBy) ([]User, error)
	WizardFilters(ctx context.Context, typeArg string) (*ObjectFilter, error)
	AdapterDevicesAggregate(ctx context.Context, groupBy []AdapterDevicesAggregateColumns, distinctOn []AdapterDevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterDeviceBoolExp) ([]AdapterDevicesAggregate, error)
	DevicesAggregate(ctx context.Context, groupBy []DevicesAggregateColumns, distinctOn []DevicesAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *DeviceBoolExp) ([]DevicesAggregate, error)
	AdapterUsersAggregate(ctx context.Context, groupBy []AdapterUsersAggregateColumns, distinctOn []AdapterUsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *AdapterUserBoolExp) ([]AdapterUsersAggregate, error)
	UsersAggregate(ctx context.Context, groupBy []UsersAggregateColumns, distinctOn []UsersAggregateColumns, orderBy []AggregateOrdering, limit *int, offset *int, where *UserBoolExp) ([]UsersAggregate, error)
}
type UserResolver interface {
	CompatibilityAPI(ctx context.Context, obj *User) (map[string]interface{}, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "ActiveDirectoryData.adAccountExpires":
		if e.complexity.ActiveDirectoryData.AdAccountExpires == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdAccountExpires(childComplexity), true

	case "ActiveDirectoryData.adBadPasswordTime":
		if e.complexity.ActiveDirectoryData.AdBadPasswordTime == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdBadPasswordTime(childComplexity), true

	case "ActiveDirectoryData.ad_bad_pwd_count":
		if e.complexity.ActiveDirectoryData.AdBadPwdCount == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdBadPwdCount(childComplexity), true

	case "ActiveDirectoryData.adCanonicalName":
		if e.complexity.ActiveDirectoryData.AdCanonicalName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdCanonicalName(childComplexity), true

	case "ActiveDirectoryData.adCn":
		if e.complexity.ActiveDirectoryData.AdCn == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdCn(childComplexity), true

	case "ActiveDirectoryData.adDisplayName":
		if e.complexity.ActiveDirectoryData.AdDisplayName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdDisplayName(childComplexity), true

	case "ActiveDirectoryData.adDistinguishedName":
		if e.complexity.ActiveDirectoryData.AdDistinguishedName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdDistinguishedName(childComplexity), true

	case "ActiveDirectoryData.adGuid":
		if e.complexity.ActiveDirectoryData.AdGUID == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdGUID(childComplexity), true

	case "ActiveDirectoryData.adIsCriticalSystemObject":
		if e.complexity.ActiveDirectoryData.AdIsCriticalSystemObject == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdIsCriticalSystemObject(childComplexity), true

	case "ActiveDirectoryData.adLastLogoff":
		if e.complexity.ActiveDirectoryData.AdLastLogoff == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdLastLogoff(childComplexity), true

	case "ActiveDirectoryData.adLastLogon":
		if e.complexity.ActiveDirectoryData.AdLastLogon == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdLastLogon(childComplexity), true

	case "ActiveDirectoryData.adLastLogonTimestamp":
		if e.complexity.ActiveDirectoryData.AdLastLogonTimestamp == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdLastLogonTimestamp(childComplexity), true

	case "ActiveDirectoryData.adManagedBy":
		if e.complexity.ActiveDirectoryData.AdManagedBy == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdManagedBy(childComplexity), true

	case "ActiveDirectoryData.adMemberOf":
		if e.complexity.ActiveDirectoryData.AdMemberOf == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMemberOf(childComplexity), true

	case "ActiveDirectoryData.adMemberOfFull":
		if e.complexity.ActiveDirectoryData.AdMemberOfFull == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMemberOfFull(childComplexity), true

	case "ActiveDirectoryData.adMsdsAllowedToDelegateTo":
		if e.complexity.ActiveDirectoryData.AdMsdsAllowedToDelegateTo == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMsdsAllowedToDelegateTo(childComplexity), true

	case "ActiveDirectoryData.adMsdsResultantPso":
		if e.complexity.ActiveDirectoryData.AdMsdsResultantPso == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdMsdsResultantPso(childComplexity), true

	case "ActiveDirectoryData.adName":
		if e.complexity.ActiveDirectoryData.AdName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdName(childComplexity), true

	case "ActiveDirectoryData.adObjectCategory":
		if e.complexity.ActiveDirectoryData.AdObjectCategory == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdObjectCategory(childComplexity), true

	case "ActiveDirectoryData.adObjectClass":
		if e.complexity.ActiveDirectoryData.AdObjectClass == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdObjectClass(childComplexity), true

	case "ActiveDirectoryData.adOrganizationalUnit":
		if e.complexity.ActiveDirectoryData.AdOrganizationalUnit == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdOrganizationalUnit(childComplexity), true

	case "ActiveDirectoryData.adPasswordLastSet":
		if e.complexity.ActiveDirectoryData.AdPasswordLastSet == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPasswordLastSet(childComplexity), true

	case "ActiveDirectoryData.adPrimaryGroupDn":
		if e.complexity.ActiveDirectoryData.AdPrimaryGroupDn == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPrimaryGroupDn(childComplexity), true

	case "ActiveDirectoryData.adPrimaryGroupId":
		if e.complexity.ActiveDirectoryData.AdPrimaryGroupID == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPrimaryGroupID(childComplexity), true

	case "ActiveDirectoryData.adPwdMustChange":
		if e.complexity.ActiveDirectoryData.AdPwdMustChange == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdPwdMustChange(childComplexity), true

	case "ActiveDirectoryData.adSAMAccountName":
		if e.complexity.ActiveDirectoryData.AdSAMAccountName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdSAMAccountName(childComplexity), true

	case "ActiveDirectoryData.adSid":
		if e.complexity.ActiveDirectoryData.AdSid == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdSid(childComplexity), true

	case "ActiveDirectoryData.adUserPrincipalName":
		if e.complexity.ActiveDirectoryData.AdUserPrincipalName == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdUserPrincipalName(childComplexity), true

	case "ActiveDirectoryData.adUsnChanged":
		if e.complexity.ActiveDirectoryData.AdUsnChanged == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdUsnChanged(childComplexity), true

	case "ActiveDirectoryData.adUsnCreated":
		if e.complexity.ActiveDirectoryData.AdUsnCreated == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdUsnCreated(childComplexity), true

	case "ActiveDirectoryData.adWhenChanged":
		if e.complexity.ActiveDirectoryData.AdWhenChanged == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdWhenChanged(childComplexity), true

	case "ActiveDirectoryData.adWhenCreated":
		if e.complexity.ActiveDirectoryData.AdWhenCreated == nil {
			break
		}

		return e.complexity.ActiveDirectoryData.AdWhenCreated(childComplexity), true

	case "Adapter.id":
		if e.complexity.Adapter.ID == nil {
			break
		}

		return e.complexity.Adapter.ID(childComplexity), true

	case "Adapter.name":
		if e.complexity.Adapter.Name == nil {
			break
		}

		return e.complexity.Adapter.Name(childComplexity), true

	case "Adapter.properties":
		if e.complexity.Adapter.Properties == nil {
			break
		}

		return e.complexity.Adapter.Properties(childComplexity), true

	case "AdapterDevice.adapter":
		if e.complexity.AdapterDevice.Adapter == nil {
			break
		}

		args, err := ec.field_AdapterDevice_adapter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Adapter(childComplexity, args["where"].(*AdapterBoolExp)), true

	case "AdapterDevice.adapterData":
		if e.complexity.AdapterDevice.AdapterData == nil {
			break
		}

		args, err := ec.field_AdapterDevice_adapterData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.AdapterData(childComplexity, args["where"].(*AdapterDataBoolExp)), true

	case "AdapterDevice.adapterId":
		if e.complexity.AdapterDevice.AdapterID == nil {
			break
		}

		return e.complexity.AdapterDevice.AdapterID(childComplexity), true

	case "AdapterDevice.adapterName":
		if e.complexity.AdapterDevice.AdapterName == nil {
			break
		}

		return e.complexity.AdapterDevice.AdapterName(childComplexity), true

	case "AdapterDevice.agentName":
		if e.complexity.AdapterDevice.AgentName == nil {
			break
		}

		return e.complexity.AdapterDevice.AgentName(childComplexity), true

	case "AdapterDevice.agentStatus":
		if e.complexity.AdapterDevice.AgentStatus == nil {
			break
		}

		return e.complexity.AdapterDevice.AgentStatus(childComplexity), true

	case "AdapterDevice.agentVersion":
		if e.complexity.AdapterDevice.AgentVersion == nil {
			break
		}

		return e.complexity.AdapterDevice.AgentVersion(childComplexity), true

	case "AdapterDevice.biosSerial":
		if e.complexity.AdapterDevice.BiosSerial == nil {
			break
		}

		return e.complexity.AdapterDevice.BiosSerial(childComplexity), true

	case "AdapterDevice.biosVersion":
		if e.complexity.AdapterDevice.BiosVersion == nil {
			break
		}

		return e.complexity.AdapterDevice.BiosVersion(childComplexity), true

	case "AdapterDevice.data":
		if e.complexity.AdapterDevice.Data == nil {
			break
		}

		return e.complexity.AdapterDevice.Data(childComplexity), true

	case "AdapterDevice.deviceId":
		if e.complexity.AdapterDevice.DeviceID == nil {
			break
		}

		return e.complexity.AdapterDevice.DeviceID(childComplexity), true

	case "AdapterDevice.deviceUsers":
		if e.complexity.AdapterDevice.DeviceUsers == nil {
			break
		}

		args, err := ec.field_AdapterDevice_deviceUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.DeviceUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceUserBoolExp)), true

	case "AdapterDevice.domain":
		if e.complexity.AdapterDevice.Domain == nil {
			break
		}

		return e.complexity.AdapterDevice.Domain(childComplexity), true

	case "AdapterDevice.family":
		if e.complexity.AdapterDevice.Family == nil {
			break
		}

		return e.complexity.AdapterDevice.Family(childComplexity), true

	case "AdapterDevice.fetchCycle":
		if e.complexity.AdapterDevice.FetchCycle == nil {
			break
		}

		return e.complexity.AdapterDevice.FetchCycle(childComplexity), true

	case "AdapterDevice.fetchTime":
		if e.complexity.AdapterDevice.FetchTime == nil {
			break
		}

		return e.complexity.AdapterDevice.FetchTime(childComplexity), true

	case "AdapterDevice.firewallRules":
		if e.complexity.AdapterDevice.FirewallRules == nil {
			break
		}

		args, err := ec.field_AdapterDevice_firewallRules_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.FirewallRules(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*FirewallRuleBoolExp)), true

	case "AdapterDevice.firewallRules_aggregate":
		if e.complexity.AdapterDevice.FirewallRulesAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_firewallRules_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.FirewallRulesAggregate(childComplexity, args["groupBy"].([]FirewallRulesAggregateColumns), args["distinctOn"].([]FirewallRulesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*FirewallRuleBoolExp)), true

	case "AdapterDevice.hostname":
		if e.complexity.AdapterDevice.Hostname == nil {
			break
		}

		return e.complexity.AdapterDevice.Hostname(childComplexity), true

	case "AdapterDevice.id":
		if e.complexity.AdapterDevice.ID == nil {
			break
		}

		return e.complexity.AdapterDevice.ID(childComplexity), true

	case "AdapterDevice.installedSoftware":
		if e.complexity.AdapterDevice.InstalledSoftware == nil {
			break
		}

		args, err := ec.field_AdapterDevice_installedSoftware_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.InstalledSoftware(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*InstalledSoftwareBoolExp)), true

	case "AdapterDevice.installedSoftware_aggregate":
		if e.complexity.AdapterDevice.InstalledSoftwareAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_installedSoftware_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.InstalledSoftwareAggregate(childComplexity, args["groupBy"].([]InstalledSoftwareAggregateColumns), args["distinctOn"].([]InstalledSoftwareAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*InstalledSoftwareBoolExp)), true

	case "AdapterDevice.interfaces":
		if e.complexity.AdapterDevice.Interfaces == nil {
			break
		}

		args, err := ec.field_AdapterDevice_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Interfaces(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "AdapterDevice.interfaces_aggregate":
		if e.complexity.AdapterDevice.InterfacesAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_interfaces_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.InterfacesAggregate(childComplexity, args["groupBy"].([]InterfacesAggregateColumns), args["distinctOn"].([]InterfacesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "AdapterDevice.lastSeen":
		if e.complexity.AdapterDevice.LastSeen == nil {
			break
		}

		return e.complexity.AdapterDevice.LastSeen(childComplexity), true

	case "AdapterDevice.lastUsedUsers":
		if e.complexity.AdapterDevice.LastUsedUsers == nil {
			break
		}

		return e.complexity.AdapterDevice.LastUsedUsers(childComplexity), true

	case "AdapterDevice.localAdmins":
		if e.complexity.AdapterDevice.LocalAdmins == nil {
			break
		}

		args, err := ec.field_AdapterDevice_localAdmins_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.LocalAdmins(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceAdminBoolExp)), true

	case "AdapterDevice.manufacturer":
		if e.complexity.AdapterDevice.Manufacturer == nil {
			break
		}

		return e.complexity.AdapterDevice.Manufacturer(childComplexity), true

	case "AdapterDevice.model":
		if e.complexity.AdapterDevice.Model == nil {
			break
		}

		return e.complexity.AdapterDevice.Model(childComplexity), true

	case "AdapterDevice.name":
		if e.complexity.AdapterDevice.Name == nil {
			break
		}

		return e.complexity.AdapterDevice.Name(childComplexity), true

	case "AdapterDevice.os":
		if e.complexity.AdapterDevice.Os == nil {
			break
		}

		args, err := ec.field_AdapterDevice_os_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Os(childComplexity, args["where"].(*OperatingSystemBoolExp)), true

	case "AdapterDevice.osId":
		if e.complexity.AdapterDevice.OsID == nil {
			break
		}

		return e.complexity.AdapterDevice.OsID(childComplexity), true

	case "AdapterDevice.partOfDomain":
		if e.complexity.AdapterDevice.PartOfDomain == nil {
			break
		}

		return e.complexity.AdapterDevice.PartOfDomain(childComplexity), true

	case "AdapterDevice.prettyId":
		if e.complexity.AdapterDevice.PrettyID == nil {
			break
		}

		return e.complexity.AdapterDevice.PrettyID(childComplexity), true

	case "AdapterDevice.serial":
		if e.complexity.AdapterDevice.Serial == nil {
			break
		}

		return e.complexity.AdapterDevice.Serial(childComplexity), true

	case "AdapterDevice.tags":
		if e.complexity.AdapterDevice.Tags == nil {
			break
		}

		args, err := ec.field_AdapterDevice_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.Tags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "AdapterDevice.tags_aggregate":
		if e.complexity.AdapterDevice.TagsAggregate == nil {
			break
		}

		args, err := ec.field_AdapterDevice_tags_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevice.TagsAggregate(childComplexity, args["groupBy"].([]TagsAggregateColumns), args["distinctOn"].([]TagsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "AdapterDeviceAdmin.name":
		if e.complexity.AdapterDeviceAdmin.Name == nil {
			break
		}

		return e.complexity.AdapterDeviceAdmin.Name(childComplexity), true

	case "AdapterDeviceAdmin.type":
		if e.complexity.AdapterDeviceAdmin.Type == nil {
			break
		}

		return e.complexity.AdapterDeviceAdmin.Type(childComplexity), true

	case "AdapterDeviceUser.deviceId":
		if e.complexity.AdapterDeviceUser.DeviceID == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.DeviceID(childComplexity), true

	case "AdapterDeviceUser.interpreter":
		if e.complexity.AdapterDeviceUser.Interpreter == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.Interpreter(childComplexity), true

	case "AdapterDeviceUser.isAdmin":
		if e.complexity.AdapterDeviceUser.IsAdmin == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.IsAdmin(childComplexity), true

	case "AdapterDeviceUser.isDisabled":
		if e.complexity.AdapterDeviceUser.IsDisabled == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.IsDisabled(childComplexity), true

	case "AdapterDeviceUser.isLocal":
		if e.complexity.AdapterDeviceUser.IsLocal == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.IsLocal(childComplexity), true

	case "AdapterDeviceUser.lastUseDate":
		if e.complexity.AdapterDeviceUser.LastUseDate == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.LastUseDate(childComplexity), true

	case "AdapterDeviceUser.passwordMaxAge":
		if e.complexity.AdapterDeviceUser.PasswordMaxAge == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.PasswordMaxAge(childComplexity), true

	case "AdapterDeviceUser.sid":
		if e.complexity.AdapterDeviceUser.Sid == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.Sid(childComplexity), true

	case "AdapterDeviceUser.userDepartment":
		if e.complexity.AdapterDeviceUser.UserDepartment == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.UserDepartment(childComplexity), true

	case "AdapterDeviceUser.username":
		if e.complexity.AdapterDeviceUser.Username == nil {
			break
		}

		return e.complexity.AdapterDeviceUser.Username(childComplexity), true

	case "AdapterUser.adapter":
		if e.complexity.AdapterUser.Adapter == nil {
			break
		}

		args, err := ec.field_AdapterUser_adapter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUser.Adapter(childComplexity, args["where"].(*AdapterBoolExp)), true

	case "AdapterUser.adapterData":
		if e.complexity.AdapterUser.AdapterData == nil {
			break
		}

		args, err := ec.field_AdapterUser_adapterData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUser.AdapterData(childComplexity, args["where"].(*AdapterDataBoolExp)), true

	case "AdapterUser.adapterId":
		if e.complexity.AdapterUser.AdapterID == nil {
			break
		}

		return e.complexity.AdapterUser.AdapterID(childComplexity), true

	case "AdapterUser.adapterName":
		if e.complexity.AdapterUser.AdapterName == nil {
			break
		}

		return e.complexity.AdapterUser.AdapterName(childComplexity), true

	case "AdapterUser.admin":
		if e.complexity.AdapterUser.Admin == nil {
			break
		}

		return e.complexity.AdapterUser.Admin(childComplexity), true

	case "AdapterUser.data":
		if e.complexity.AdapterUser.Data == nil {
			break
		}

		return e.complexity.AdapterUser.Data(childComplexity), true

	case "AdapterUser.delegatedAdmin":
		if e.complexity.AdapterUser.DelegatedAdmin == nil {
			break
		}

		return e.complexity.AdapterUser.DelegatedAdmin(childComplexity), true

	case "AdapterUser.description":
		if e.complexity.AdapterUser.Description == nil {
			break
		}

		return e.complexity.AdapterUser.Description(childComplexity), true

	case "AdapterUser.disabled":
		if e.complexity.AdapterUser.Disabled == nil {
			break
		}

		return e.complexity.AdapterUser.Disabled(childComplexity), true

	case "AdapterUser.displayName":
		if e.complexity.AdapterUser.DisplayName == nil {
			break
		}

		return e.complexity.AdapterUser.DisplayName(childComplexity), true

	case "AdapterUser.domain":
		if e.complexity.AdapterUser.Domain == nil {
			break
		}

		return e.complexity.AdapterUser.Domain(childComplexity), true

	case "AdapterUser.fetchCycle":
		if e.complexity.AdapterUser.FetchCycle == nil {
			break
		}

		return e.complexity.AdapterUser.FetchCycle(childComplexity), true

	case "AdapterUser.fetchTime":
		if e.complexity.AdapterUser.FetchTime == nil {
			break
		}

		return e.complexity.AdapterUser.FetchTime(childComplexity), true

	case "AdapterUser.firstName":
		if e.complexity.AdapterUser.FirstName == nil {
			break
		}

		return e.complexity.AdapterUser.FirstName(childComplexity), true

	case "AdapterUser.id":
		if e.complexity.AdapterUser.ID == nil {
			break
		}

		return e.complexity.AdapterUser.ID(childComplexity), true

	case "AdapterUser.lastName":
		if e.complexity.AdapterUser.LastName == nil {
			break
		}

		return e.complexity.AdapterUser.LastName(childComplexity), true

	case "AdapterUser.lastSeen":
		if e.complexity.AdapterUser.LastSeen == nil {
			break
		}

		return e.complexity.AdapterUser.LastSeen(childComplexity), true

	case "AdapterUser.local":
		if e.complexity.AdapterUser.Local == nil {
			break
		}

		return e.complexity.AdapterUser.Local(childComplexity), true

	case "AdapterUser.locked":
		if e.complexity.AdapterUser.Locked == nil {
			break
		}

		return e.complexity.AdapterUser.Locked(childComplexity), true

	case "AdapterUser.mail":
		if e.complexity.AdapterUser.Mail == nil {
			break
		}

		return e.complexity.AdapterUser.Mail(childComplexity), true

	case "AdapterUser.mfaEnforced":
		if e.complexity.AdapterUser.MfaEnforced == nil {
			break
		}

		return e.complexity.AdapterUser.MfaEnforced(childComplexity), true

	case "AdapterUser.mfaEnrolled":
		if e.complexity.AdapterUser.MfaEnrolled == nil {
			break
		}

		return e.complexity.AdapterUser.MfaEnrolled(childComplexity), true

	case "AdapterUser.suspended":
		if e.complexity.AdapterUser.Suspended == nil {
			break
		}

		return e.complexity.AdapterUser.Suspended(childComplexity), true

	case "AdapterUser.userId":
		if e.complexity.AdapterUser.UserID == nil {
			break
		}

		return e.complexity.AdapterUser.UserID(childComplexity), true

	case "AdapterUser.userSid":
		if e.complexity.AdapterUser.UserSid == nil {
			break
		}

		return e.complexity.AdapterUser.UserSid(childComplexity), true

	case "AdapterUser.username":
		if e.complexity.AdapterUser.Username == nil {
			break
		}

		return e.complexity.AdapterUser.Username(childComplexity), true

	case "CPU.bitness":
		if e.complexity.CPU.Bitness == nil {
			break
		}

		return e.complexity.CPU.Bitness(childComplexity), true

	case "CPU.cores":
		if e.complexity.CPU.Cores == nil {
			break
		}

		return e.complexity.CPU.Cores(childComplexity), true

	case "CPU.coresThreads":
		if e.complexity.CPU.CoresThreads == nil {
			break
		}

		return e.complexity.CPU.CoresThreads(childComplexity), true

	case "CPU.family":
		if e.complexity.CPU.Family == nil {
			break
		}

		return e.complexity.CPU.Family(childComplexity), true

	case "CPU.ghz":
		if e.complexity.CPU.Ghz == nil {
			break
		}

		return e.complexity.CPU.Ghz(childComplexity), true

	case "CPU.id":
		if e.complexity.CPU.ID == nil {
			break
		}

		return e.complexity.CPU.ID(childComplexity), true

	case "CPU.manfacturer":
		if e.complexity.CPU.Manfacturer == nil {
			break
		}

		return e.complexity.CPU.Manfacturer(childComplexity), true

	case "CPU.name":
		if e.complexity.CPU.Name == nil {
			break
		}

		return e.complexity.CPU.Name(childComplexity), true

	case "CrowdStrikeData.csAgentVersion":
		if e.complexity.CrowdStrikeData.CsAgentVersion == nil {
			break
		}

		return e.complexity.CrowdStrikeData.CsAgentVersion(childComplexity), true

	case "CrowdStrikeData.externalIp":
		if e.complexity.CrowdStrikeData.ExternalIP == nil {
			break
		}

		return e.complexity.CrowdStrikeData.ExternalIP(childComplexity), true

	case "CrowdStrikeData.groups":
		if e.complexity.CrowdStrikeData.Groups == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_groups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.Groups(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "CrowdStrikeData.groups_aggregate":
		if e.complexity.CrowdStrikeData.GroupsAggregate == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_groups_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.GroupsAggregate(childComplexity, args["groupBy"].([]GroupsAggregateColumns), args["distinctOn"].([]GroupsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "CrowdStrikeData.preventionPolicy":
		if e.complexity.CrowdStrikeData.PreventionPolicy == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_preventionPolicy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.PreventionPolicy(childComplexity, args["where"].(*CsPolicyBoolExp)), true

	case "CrowdStrikeData.sensorUpdatePolicy":
		if e.complexity.CrowdStrikeData.SensorUpdatePolicy == nil {
			break
		}

		args, err := ec.field_CrowdStrikeData_sensorUpdatePolicy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CrowdStrikeData.SensorUpdatePolicy(childComplexity, args["where"].(*CsGroupBoolExp)), true

	case "CylanceData.agentVersion":
		if e.complexity.CylanceData.AgentVersion == nil {
			break
		}

		return e.complexity.CylanceData.AgentVersion(childComplexity), true

	case "CylanceData.deviceState":
		if e.complexity.CylanceData.DeviceState == nil {
			break
		}

		return e.complexity.CylanceData.DeviceState(childComplexity), true

	case "CylanceData.isSafe":
		if e.complexity.CylanceData.IsSafe == nil {
			break
		}

		return e.complexity.CylanceData.IsSafe(childComplexity), true

	case "CylanceData.policiesDetails":
		if e.complexity.CylanceData.PoliciesDetails == nil {
			break
		}

		return e.complexity.CylanceData.PoliciesDetails(childComplexity), true

	case "CylanceData.policyId":
		if e.complexity.CylanceData.PolicyID == nil {
			break
		}

		return e.complexity.CylanceData.PolicyID(childComplexity), true

	case "CylanceData.policyName":
		if e.complexity.CylanceData.PolicyName == nil {
			break
		}

		return e.complexity.CylanceData.PolicyName(childComplexity), true

	case "CylanceData.tenantTag":
		if e.complexity.CylanceData.TenantTag == nil {
			break
		}

		return e.complexity.CylanceData.TenantTag(childComplexity), true

	case "CylanceData.zoneNames":
		if e.complexity.CylanceData.ZoneNames == nil {
			break
		}

		return e.complexity.CylanceData.ZoneNames(childComplexity), true

	case "Device.adapterCount":
		if e.complexity.Device.AdapterCount == nil {
			break
		}

		return e.complexity.Device.AdapterCount(childComplexity), true

	case "Device.adapterDevices":
		if e.complexity.Device.AdapterDevices == nil {
			break
		}

		args, err := ec.field_Device_adapterDevices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.AdapterDevices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "Device.adapterDevices_aggregate":
		if e.complexity.Device.AdapterDevicesAggregate == nil {
			break
		}

		args, err := ec.field_Device_adapterDevices_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.AdapterDevicesAggregate(childComplexity, args["groupBy"].([]AdapterDevicesAggregateColumns), args["distinctOn"].([]AdapterDevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "Device.adapterNames":
		if e.complexity.Device.AdapterNames == nil {
			break
		}

		return e.complexity.Device.AdapterNames(childComplexity), true

	case "Device._compatibilityAPI":
		if e.complexity.Device.CompatibilityAPI == nil {
			break
		}

		return e.complexity.Device.CompatibilityAPI(childComplexity), true

	case "Device.fetchCycle":
		if e.complexity.Device.FetchCycle == nil {
			break
		}

		return e.complexity.Device.FetchCycle(childComplexity), true

	case "Device.hostnames":
		if e.complexity.Device.Hostnames == nil {
			break
		}

		return e.complexity.Device.Hostnames(childComplexity), true

	case "Device.id":
		if e.complexity.Device.ID == nil {
			break
		}

		return e.complexity.Device.ID(childComplexity), true

	case "Device.interfaces":
		if e.complexity.Device.Interfaces == nil {
			break
		}

		args, err := ec.field_Device_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.Interfaces(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "Device.interfaces_aggregate":
		if e.complexity.Device.InterfacesAggregate == nil {
			break
		}

		args, err := ec.field_Device_interfaces_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.InterfacesAggregate(childComplexity, args["groupBy"].([]InterfacesAggregateColumns), args["distinctOn"].([]InterfacesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "Device.lastSeen":
		if e.complexity.Device.LastSeen == nil {
			break
		}

		return e.complexity.Device.LastSeen(childComplexity), true

	case "Device.tags":
		if e.complexity.Device.Tags == nil {
			break
		}

		args, err := ec.field_Device_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.Tags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "Device.tags_aggregate":
		if e.complexity.Device.TagsAggregate == nil {
			break
		}

		args, err := ec.field_Device_tags_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Device.TagsAggregate(childComplexity, args["groupBy"].([]TagsAggregateColumns), args["distinctOn"].([]TagsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "FirewallRule.direction":
		if e.complexity.FirewallRule.Direction == nil {
			break
		}

		return e.complexity.FirewallRule.Direction(childComplexity), true

	case "FirewallRule.dstPort":
		if e.complexity.FirewallRule.DstPort == nil {
			break
		}

		return e.complexity.FirewallRule.DstPort(childComplexity), true

	case "FirewallRule.name":
		if e.complexity.FirewallRule.Name == nil {
			break
		}

		return e.complexity.FirewallRule.Name(childComplexity), true

	case "FirewallRule.protocol":
		if e.complexity.FirewallRule.Protocol == nil {
			break
		}

		return e.complexity.FirewallRule.Protocol(childComplexity), true

	case "FirewallRule.source":
		if e.complexity.FirewallRule.Source == nil {
			break
		}

		return e.complexity.FirewallRule.Source(childComplexity), true

	case "FirewallRule.srcPort":
		if e.complexity.FirewallRule.SrcPort == nil {
			break
		}

		return e.complexity.FirewallRule.SrcPort(childComplexity), true

	case "FirewallRule.target":
		if e.complexity.FirewallRule.Target == nil {
			break
		}

		return e.complexity.FirewallRule.Target(childComplexity), true

	case "FirewallRule.type":
		if e.complexity.FirewallRule.Type == nil {
			break
		}

		return e.complexity.FirewallRule.Type(childComplexity), true

	case "GCETagsAggregate.avg":
		if e.complexity.GCETagsAggregate.Avg == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Avg(childComplexity), true

	case "GCETagsAggregate.count":
		if e.complexity.GCETagsAggregate.Count == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Count(childComplexity), true

	case "GCETagsAggregate.distinct":
		if e.complexity.GCETagsAggregate.Distinct == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Distinct(childComplexity), true

	case "GCETagsAggregate.GCETags":
		if e.complexity.GCETagsAggregate.GCETags == nil {
			break
		}

		args, err := ec.field_GCETagsAggregate_GCETags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GCETagsAggregate.GCETags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*GceTagsBoolExp)), true

	case "GCETagsAggregate.group":
		if e.complexity.GCETagsAggregate.Group == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Group(childComplexity), true

	case "GCETagsAggregate.max":
		if e.complexity.GCETagsAggregate.Max == nil {
			break
		}

		args, err := ec.field_GCETagsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GCETagsAggregate.Max(childComplexity, args["column"].([]GCETagsAggregateMaxColumns)), true

	case "GCETagsAggregate.min":
		if e.complexity.GCETagsAggregate.Min == nil {
			break
		}

		args, err := ec.field_GCETagsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GCETagsAggregate.Min(childComplexity, args["column"].([]GCETagsAggregateMinColumns)), true

	case "GCETagsAggregate.sum":
		if e.complexity.GCETagsAggregate.Sum == nil {
			break
		}

		return e.complexity.GCETagsAggregate.Sum(childComplexity), true

	case "GceTags.gceKey":
		if e.complexity.GceTags.GceKey == nil {
			break
		}

		return e.complexity.GceTags.GceKey(childComplexity), true

	case "GceTags.gceValue":
		if e.complexity.GceTags.GceValue == nil {
			break
		}

		return e.complexity.GceTags.GceValue(childComplexity), true

	case "GoogleCloudData.GCETags":
		if e.complexity.GoogleCloudData.GCETags == nil {
			break
		}

		args, err := ec.field_GoogleCloudData_GCETags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GoogleCloudData.GCETags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*GceTagsBoolExp)), true

	case "GoogleCloudData.GCETags_aggregate":
		if e.complexity.GoogleCloudData.GCETagsAggregate == nil {
			break
		}

		args, err := ec.field_GoogleCloudData_GCETags_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GoogleCloudData.GCETagsAggregate(childComplexity, args["groupBy"].([]GCETagsAggregateColumns), args["distinctOn"].([]GCETagsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*GceTagsBoolExp)), true

	case "GoogleCloudData.Id":
		if e.complexity.GoogleCloudData.ID == nil {
			break
		}

		return e.complexity.GoogleCloudData.ID(childComplexity), true

	case "GoogleCloudData.Image":
		if e.complexity.GoogleCloudData.Image == nil {
			break
		}

		return e.complexity.GoogleCloudData.Image(childComplexity), true

	case "GoogleCloudData.Size":
		if e.complexity.GoogleCloudData.Size == nil {
			break
		}

		return e.complexity.GoogleCloudData.Size(childComplexity), true

	case "InstalledSoftware.architecture":
		if e.complexity.InstalledSoftware.Architecture == nil {
			break
		}

		return e.complexity.InstalledSoftware.Architecture(childComplexity), true

	case "InstalledSoftware.cveCount":
		if e.complexity.InstalledSoftware.CveCount == nil {
			break
		}

		return e.complexity.InstalledSoftware.CveCount(childComplexity), true

	case "InstalledSoftware.description":
		if e.complexity.InstalledSoftware.Description == nil {
			break
		}

		return e.complexity.InstalledSoftware.Description(childComplexity), true

	case "InstalledSoftware.name":
		if e.complexity.InstalledSoftware.Name == nil {
			break
		}

		return e.complexity.InstalledSoftware.Name(childComplexity), true

	case "InstalledSoftware.path":
		if e.complexity.InstalledSoftware.Path == nil {
			break
		}

		return e.complexity.InstalledSoftware.Path(childComplexity), true

	case "InstalledSoftware.publisher":
		if e.complexity.InstalledSoftware.Publisher == nil {
			break
		}

		return e.complexity.InstalledSoftware.Publisher(childComplexity), true

	case "InstalledSoftware.swLicense":
		if e.complexity.InstalledSoftware.SwLicense == nil {
			break
		}

		return e.complexity.InstalledSoftware.SwLicense(childComplexity), true

	case "InstalledSoftware.vendor":
		if e.complexity.InstalledSoftware.Vendor == nil {
			break
		}

		return e.complexity.InstalledSoftware.Vendor(childComplexity), true

	case "InstalledSoftware.version":
		if e.complexity.InstalledSoftware.Version == nil {
			break
		}

		return e.complexity.InstalledSoftware.Version(childComplexity), true

	case "NetworkInterface.adminStatus":
		if e.complexity.NetworkInterface.AdminStatus == nil {
			break
		}

		return e.complexity.NetworkInterface.AdminStatus(childComplexity), true

	case "NetworkInterface.deviceId":
		if e.complexity.NetworkInterface.DeviceID == nil {
			break
		}

		return e.complexity.NetworkInterface.DeviceID(childComplexity), true

	case "NetworkInterface.gateway":
		if e.complexity.NetworkInterface.Gateway == nil {
			break
		}

		return e.complexity.NetworkInterface.Gateway(childComplexity), true

	case "NetworkInterface.ipAddrs":
		if e.complexity.NetworkInterface.IPAddrs == nil {
			break
		}

		return e.complexity.NetworkInterface.IPAddrs(childComplexity), true

	case "NetworkInterface.macAddr":
		if e.complexity.NetworkInterface.MacAddr == nil {
			break
		}

		return e.complexity.NetworkInterface.MacAddr(childComplexity), true

	case "NetworkInterface.manufacturer":
		if e.complexity.NetworkInterface.Manufacturer == nil {
			break
		}

		return e.complexity.NetworkInterface.Manufacturer(childComplexity), true

	case "NetworkInterface.mtu":
		if e.complexity.NetworkInterface.Mtu == nil {
			break
		}

		return e.complexity.NetworkInterface.Mtu(childComplexity), true

	case "NetworkInterface.name":
		if e.complexity.NetworkInterface.Name == nil {
			break
		}

		return e.complexity.NetworkInterface.Name(childComplexity), true

	case "NetworkInterface.operationalStatus":
		if e.complexity.NetworkInterface.OperationalStatus == nil {
			break
		}

		return e.complexity.NetworkInterface.OperationalStatus(childComplexity), true

	case "NetworkInterface.port":
		if e.complexity.NetworkInterface.Port == nil {
			break
		}

		return e.complexity.NetworkInterface.Port(childComplexity), true

	case "NetworkInterface.portType":
		if e.complexity.NetworkInterface.PortType == nil {
			break
		}

		return e.complexity.NetworkInterface.PortType(childComplexity), true

	case "NetworkInterface.subnets":
		if e.complexity.NetworkInterface.Subnets == nil {
			break
		}

		return e.complexity.NetworkInterface.Subnets(childComplexity), true

	case "NetworkInterface.vlans":
		if e.complexity.NetworkInterface.Vlans == nil {
			break
		}

		args, err := ec.field_NetworkInterface_vlans_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.NetworkInterface.Vlans(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceVlanBoolExp)), true

	case "NetworkInterface.vlans_aggregate":
		if e.complexity.NetworkInterface.VlansAggregate == nil {
			break
		}

		args, err := ec.field_NetworkInterface_vlans_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.NetworkInterface.VlansAggregate(childComplexity, args["groupBy"].([]VlansAggregateColumns), args["distinctOn"].([]VlansAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceVlanBoolExp)), true

	case "NetworkInterfaceVlan.macAddr":
		if e.complexity.NetworkInterfaceVlan.MacAddr == nil {
			break
		}

		return e.complexity.NetworkInterfaceVlan.MacAddr(childComplexity), true

	case "NetworkInterfaceVlan.name":
		if e.complexity.NetworkInterfaceVlan.Name == nil {
			break
		}

		return e.complexity.NetworkInterfaceVlan.Name(childComplexity), true

	case "NetworkInterfaceVlan.tagId":
		if e.complexity.NetworkInterfaceVlan.TagID == nil {
			break
		}

		return e.complexity.NetworkInterfaceVlan.TagID(childComplexity), true

	case "NetworkInterfaceVlan.tagged":
		if e.complexity.NetworkInterfaceVlan.Tagged == nil {
			break
		}

		return e.complexity.NetworkInterfaceVlan.Tagged(childComplexity), true

	case "ObjectFilter.description":
		if e.complexity.ObjectFilter.Description == nil {
			break
		}

		return e.complexity.ObjectFilter.Description(childComplexity), true

	case "ObjectFilter.displayName":
		if e.complexity.ObjectFilter.DisplayName == nil {
			break
		}

		return e.complexity.ObjectFilter.DisplayName(childComplexity), true

	case "ObjectFilter.filters":
		if e.complexity.ObjectFilter.Filters == nil {
			break
		}

		return e.complexity.ObjectFilter.Filters(childComplexity), true

	case "ObjectFilter.name":
		if e.complexity.ObjectFilter.Name == nil {
			break
		}

		return e.complexity.ObjectFilter.Name(childComplexity), true

	case "ObjectFilter.type":
		if e.complexity.ObjectFilter.Type == nil {
			break
		}

		return e.complexity.ObjectFilter.Type(childComplexity), true

	case "OperatingSystem.architecture":
		if e.complexity.OperatingSystem.Architecture == nil {
			break
		}

		return e.complexity.OperatingSystem.Architecture(childComplexity), true

	case "OperatingSystem.build":
		if e.complexity.OperatingSystem.Build == nil {
			break
		}

		return e.complexity.OperatingSystem.Build(childComplexity), true

	case "OperatingSystem.codeName":
		if e.complexity.OperatingSystem.CodeName == nil {
			break
		}

		return e.complexity.OperatingSystem.CodeName(childComplexity), true

	case "OperatingSystem.distribution":
		if e.complexity.OperatingSystem.Distribution == nil {
			break
		}

		return e.complexity.OperatingSystem.Distribution(childComplexity), true

	case "OperatingSystem.id":
		if e.complexity.OperatingSystem.ID == nil {
			break
		}

		return e.complexity.OperatingSystem.ID(childComplexity), true

	case "OperatingSystem.installDate":
		if e.complexity.OperatingSystem.InstallDate == nil {
			break
		}

		return e.complexity.OperatingSystem.InstallDate(childComplexity), true

	case "OperatingSystem.kernelVersion":
		if e.complexity.OperatingSystem.KernelVersion == nil {
			break
		}

		return e.complexity.OperatingSystem.KernelVersion(childComplexity), true

	case "OperatingSystem.major":
		if e.complexity.OperatingSystem.Major == nil {
			break
		}

		return e.complexity.OperatingSystem.Major(childComplexity), true

	case "OperatingSystem.minor":
		if e.complexity.OperatingSystem.Minor == nil {
			break
		}

		return e.complexity.OperatingSystem.Minor(childComplexity), true

	case "OperatingSystem.rawName":
		if e.complexity.OperatingSystem.RawName == nil {
			break
		}

		return e.complexity.OperatingSystem.RawName(childComplexity), true

	case "OperatingSystem.servicePack":
		if e.complexity.OperatingSystem.ServicePack == nil {
			break
		}

		return e.complexity.OperatingSystem.ServicePack(childComplexity), true

	case "OperatingSystem.type":
		if e.complexity.OperatingSystem.Type == nil {
			break
		}

		return e.complexity.OperatingSystem.Type(childComplexity), true

	case "Operator.description":
		if e.complexity.Operator.Description == nil {
			break
		}

		return e.complexity.Operator.Description(childComplexity), true

	case "Operator.displayName":
		if e.complexity.Operator.DisplayName == nil {
			break
		}

		return e.complexity.Operator.DisplayName(childComplexity), true

	case "Operator.formatDisplay":
		if e.complexity.Operator.FormatDisplay == nil {
			break
		}

		return e.complexity.Operator.FormatDisplay(childComplexity), true

	case "Operator.name":
		if e.complexity.Operator.Name == nil {
			break
		}

		return e.complexity.Operator.Name(childComplexity), true

	case "Operator.type":
		if e.complexity.Operator.Type == nil {
			break
		}

		return e.complexity.Operator.Type(childComplexity), true

	case "Query.adapterDevices":
		if e.complexity.Query.AdapterDevices == nil {
			break
		}

		args, err := ec.field_Query_adapterDevices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterDevices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp), args["orderBy"].([]AdapterDeviceOrderBy)), true

	case "Query.adapterDevices_aggregate":
		if e.complexity.Query.AdapterDevicesAggregate == nil {
			break
		}

		args, err := ec.field_Query_adapterDevices_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterDevicesAggregate(childComplexity, args["groupBy"].([]AdapterDevicesAggregateColumns), args["distinctOn"].([]AdapterDevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "Query.adapterUsers":
		if e.complexity.Query.AdapterUsers == nil {
			break
		}

		args, err := ec.field_Query_adapterUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp), args["orderBy"].([]AdapterUserOrderBy)), true

	case "Query.adapterUsers_aggregate":
		if e.complexity.Query.AdapterUsersAggregate == nil {
			break
		}

		args, err := ec.field_Query_adapterUsers_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdapterUsersAggregate(childComplexity, args["groupBy"].([]AdapterUsersAggregateColumns), args["distinctOn"].([]AdapterUsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "Query.devices":
		if e.complexity.Query.Devices == nil {
			break
		}

		args, err := ec.field_Query_devices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Devices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp), args["orderBy"].([]DeviceOrderBy)), true

	case "Query.devices_aggregate":
		if e.complexity.Query.DevicesAggregate == nil {
			break
		}

		args, err := ec.field_Query_devices_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DevicesAggregate(childComplexity, args["groupBy"].([]DevicesAggregateColumns), args["distinctOn"].([]DevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp), args["orderBy"].([]UserOrderBy)), true

	case "Query.users_aggregate":
		if e.complexity.Query.UsersAggregate == nil {
			break
		}

		args, err := ec.field_Query_users_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UsersAggregate(childComplexity, args["groupBy"].([]UsersAggregateColumns), args["distinctOn"].([]UsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp)), true

	case "Query._wizardFilters":
		if e.complexity.Query.WizardFilters == nil {
			break
		}

		args, err := ec.field_Query__wizardFilters_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WizardFilters(childComplexity, args["type"].(string)), true

	case "ScalarFilter.description":
		if e.complexity.ScalarFilter.Description == nil {
			break
		}

		return e.complexity.ScalarFilter.Description(childComplexity), true

	case "ScalarFilter.displayName":
		if e.complexity.ScalarFilter.DisplayName == nil {
			break
		}

		return e.complexity.ScalarFilter.DisplayName(childComplexity), true

	case "ScalarFilter.name":
		if e.complexity.ScalarFilter.Name == nil {
			break
		}

		return e.complexity.ScalarFilter.Name(childComplexity), true

	case "ScalarFilter.operators":
		if e.complexity.ScalarFilter.Operators == nil {
			break
		}

		return e.complexity.ScalarFilter.Operators(childComplexity), true

	case "ScalarFilter.type":
		if e.complexity.ScalarFilter.Type == nil {
			break
		}

		return e.complexity.ScalarFilter.Type(childComplexity), true

	case "Storage.description":
		if e.complexity.Storage.Description == nil {
			break
		}

		return e.complexity.Storage.Description(childComplexity), true

	case "Storage.deviceId":
		if e.complexity.Storage.DeviceID == nil {
			break
		}

		return e.complexity.Storage.DeviceID(childComplexity), true

	case "Storage.freeSize":
		if e.complexity.Storage.FreeSize == nil {
			break
		}

		return e.complexity.Storage.FreeSize(childComplexity), true

	case "Storage.isEncrypted":
		if e.complexity.Storage.IsEncrypted == nil {
			break
		}

		return e.complexity.Storage.IsEncrypted(childComplexity), true

	case "Storage.name":
		if e.complexity.Storage.Name == nil {
			break
		}

		return e.complexity.Storage.Name(childComplexity), true

	case "Storage.path":
		if e.complexity.Storage.Path == nil {
			break
		}

		return e.complexity.Storage.Path(childComplexity), true

	case "Storage.totalSize":
		if e.complexity.Storage.TotalSize == nil {
			break
		}

		return e.complexity.Storage.TotalSize(childComplexity), true

	case "Tag.creator":
		if e.complexity.Tag.Creator == nil {
			break
		}

		return e.complexity.Tag.Creator(childComplexity), true

	case "Tag.level":
		if e.complexity.Tag.Level == nil {
			break
		}

		return e.complexity.Tag.Level(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "UnionFilter.description":
		if e.complexity.UnionFilter.Description == nil {
			break
		}

		return e.complexity.UnionFilter.Description(childComplexity), true

	case "UnionFilter.displayName":
		if e.complexity.UnionFilter.DisplayName == nil {
			break
		}

		return e.complexity.UnionFilter.DisplayName(childComplexity), true

	case "UnionFilter.name":
		if e.complexity.UnionFilter.Name == nil {
			break
		}

		return e.complexity.UnionFilter.Name(childComplexity), true

	case "UnionFilter.objects":
		if e.complexity.UnionFilter.Objects == nil {
			break
		}

		return e.complexity.UnionFilter.Objects(childComplexity), true

	case "UnionFilter.type":
		if e.complexity.UnionFilter.Type == nil {
			break
		}

		return e.complexity.UnionFilter.Type(childComplexity), true

	case "User.adapterCount":
		if e.complexity.User.AdapterCount == nil {
			break
		}

		return e.complexity.User.AdapterCount(childComplexity), true

	case "User.adapterNames":
		if e.complexity.User.AdapterNames == nil {
			break
		}

		return e.complexity.User.AdapterNames(childComplexity), true

	case "User.adapterUsers":
		if e.complexity.User.AdapterUsers == nil {
			break
		}

		args, err := ec.field_User_adapterUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.AdapterUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "User.adapterUsers_aggregate":
		if e.complexity.User.AdapterUsersAggregate == nil {
			break
		}

		args, err := ec.field_User_adapterUsers_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.AdapterUsersAggregate(childComplexity, args["groupBy"].([]AdapterUsersAggregateColumns), args["distinctOn"].([]AdapterUsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "User._compatibilityAPI":
		if e.complexity.User.CompatibilityAPI == nil {
			break
		}

		return e.complexity.User.CompatibilityAPI(childComplexity), true

	case "User.fetchCycle":
		if e.complexity.User.FetchCycle == nil {
			break
		}

		return e.complexity.User.FetchCycle(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lastSeen":
		if e.complexity.User.LastSeen == nil {
			break
		}

		return e.complexity.User.LastSeen(childComplexity), true

	case "User.usernames":
		if e.complexity.User.Usernames == nil {
			break
		}

		return e.complexity.User.Usernames(childComplexity), true

	case "adapterDevicesAggregate.adapterDevices":
		if e.complexity.AdapterDevicesAggregate.AdapterDevices == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_adapterDevices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.AdapterDevices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp)), true

	case "adapterDevicesAggregate.avg":
		if e.complexity.AdapterDevicesAggregate.Avg == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Avg(childComplexity, args["column"].([]AdapterDevicesAggregateAvgColumns)), true

	case "adapterDevicesAggregate.count":
		if e.complexity.AdapterDevicesAggregate.Count == nil {
			break
		}

		return e.complexity.AdapterDevicesAggregate.Count(childComplexity), true

	case "adapterDevicesAggregate.distinct":
		if e.complexity.AdapterDevicesAggregate.Distinct == nil {
			break
		}

		return e.complexity.AdapterDevicesAggregate.Distinct(childComplexity), true

	case "adapterDevicesAggregate.group":
		if e.complexity.AdapterDevicesAggregate.Group == nil {
			break
		}

		return e.complexity.AdapterDevicesAggregate.Group(childComplexity), true

	case "adapterDevicesAggregate.max":
		if e.complexity.AdapterDevicesAggregate.Max == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Max(childComplexity, args["column"].([]AdapterDevicesAggregateMaxColumns)), true

	case "adapterDevicesAggregate.min":
		if e.complexity.AdapterDevicesAggregate.Min == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Min(childComplexity, args["column"].([]AdapterDevicesAggregateMinColumns)), true

	case "adapterDevicesAggregate.sum":
		if e.complexity.AdapterDevicesAggregate.Sum == nil {
			break
		}

		args, err := ec.field_adapterDevicesAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterDevicesAggregate.Sum(childComplexity, args["column"].([]AdapterDevicesAggregateSumColumns)), true

	case "adapterUsersAggregate.adapterUsers":
		if e.complexity.AdapterUsersAggregate.AdapterUsers == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_adapterUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.AdapterUsers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp)), true

	case "adapterUsersAggregate.avg":
		if e.complexity.AdapterUsersAggregate.Avg == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Avg(childComplexity, args["column"].([]AdapterUsersAggregateAvgColumns)), true

	case "adapterUsersAggregate.count":
		if e.complexity.AdapterUsersAggregate.Count == nil {
			break
		}

		return e.complexity.AdapterUsersAggregate.Count(childComplexity), true

	case "adapterUsersAggregate.distinct":
		if e.complexity.AdapterUsersAggregate.Distinct == nil {
			break
		}

		return e.complexity.AdapterUsersAggregate.Distinct(childComplexity), true

	case "adapterUsersAggregate.group":
		if e.complexity.AdapterUsersAggregate.Group == nil {
			break
		}

		return e.complexity.AdapterUsersAggregate.Group(childComplexity), true

	case "adapterUsersAggregate.max":
		if e.complexity.AdapterUsersAggregate.Max == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Max(childComplexity, args["column"].([]AdapterUsersAggregateMaxColumns)), true

	case "adapterUsersAggregate.min":
		if e.complexity.AdapterUsersAggregate.Min == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Min(childComplexity, args["column"].([]AdapterUsersAggregateMinColumns)), true

	case "adapterUsersAggregate.sum":
		if e.complexity.AdapterUsersAggregate.Sum == nil {
			break
		}

		args, err := ec.field_adapterUsersAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AdapterUsersAggregate.Sum(childComplexity, args["column"].([]AdapterUsersAggregateSumColumns)), true

	case "csGroup.createdBy":
		if e.complexity.CsGroup.CreatedBy == nil {
			break
		}

		return e.complexity.CsGroup.CreatedBy(childComplexity), true

	case "csGroup.createdTimestamp":
		if e.complexity.CsGroup.CreatedTimestamp == nil {
			break
		}

		return e.complexity.CsGroup.CreatedTimestamp(childComplexity), true

	case "csGroup.description":
		if e.complexity.CsGroup.Description == nil {
			break
		}

		return e.complexity.CsGroup.Description(childComplexity), true

	case "csGroup.groupType":
		if e.complexity.CsGroup.GroupType == nil {
			break
		}

		return e.complexity.CsGroup.GroupType(childComplexity), true

	case "csGroup.id":
		if e.complexity.CsGroup.ID == nil {
			break
		}

		return e.complexity.CsGroup.ID(childComplexity), true

	case "csGroup.modifiedBy":
		if e.complexity.CsGroup.ModifiedBy == nil {
			break
		}

		return e.complexity.CsGroup.ModifiedBy(childComplexity), true

	case "csGroup.modifiedTime":
		if e.complexity.CsGroup.ModifiedTime == nil {
			break
		}

		return e.complexity.CsGroup.ModifiedTime(childComplexity), true

	case "csGroup.name":
		if e.complexity.CsGroup.Name == nil {
			break
		}

		return e.complexity.CsGroup.Name(childComplexity), true

	case "csPolicy.createdBy":
		if e.complexity.CsPolicy.CreatedBy == nil {
			break
		}

		return e.complexity.CsPolicy.CreatedBy(childComplexity), true

	case "csPolicy.createdTime":
		if e.complexity.CsPolicy.CreatedTime == nil {
			break
		}

		return e.complexity.CsPolicy.CreatedTime(childComplexity), true

	case "csPolicy.description":
		if e.complexity.CsPolicy.Description == nil {
			break
		}

		return e.complexity.CsPolicy.Description(childComplexity), true

	case "csPolicy.enabled":
		if e.complexity.CsPolicy.Enabled == nil {
			break
		}

		return e.complexity.CsPolicy.Enabled(childComplexity), true

	case "csPolicy.groups":
		if e.complexity.CsPolicy.Groups == nil {
			break
		}

		args, err := ec.field_csPolicy_groups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.Groups(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "csPolicy.groups_aggregate":
		if e.complexity.CsPolicy.GroupsAggregate == nil {
			break
		}

		args, err := ec.field_csPolicy_groups_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.GroupsAggregate(childComplexity, args["groupBy"].([]GroupsAggregateColumns), args["distinctOn"].([]GroupsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "csPolicy.name":
		if e.complexity.CsPolicy.Name == nil {
			break
		}

		return e.complexity.CsPolicy.Name(childComplexity), true

	case "csPolicy.platformName":
		if e.complexity.CsPolicy.PlatformName == nil {
			break
		}

		return e.complexity.CsPolicy.PlatformName(childComplexity), true

	case "csPolicy.preventionSettings":
		if e.complexity.CsPolicy.PreventionSettings == nil {
			break
		}

		args, err := ec.field_csPolicy_preventionSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.PreventionSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPreventionSettingsBoolExp)), true

	case "csPolicy.preventionSettings_aggregate":
		if e.complexity.CsPolicy.PreventionSettingsAggregate == nil {
			break
		}

		args, err := ec.field_csPolicy_preventionSettings_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.PreventionSettingsAggregate(childComplexity, args["groupBy"].([]PreventionSettingsAggregateColumns), args["distinctOn"].([]PreventionSettingsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPreventionSettingsBoolExp)), true

	case "csPolicy.sensorUpdateSettings":
		if e.complexity.CsPolicy.SensorUpdateSettings == nil {
			break
		}

		args, err := ec.field_csPolicy_sensorUpdateSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.SensorUpdateSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsSensorUpdateSettingsBoolExp)), true

	case "csPolicy.sensorUpdateSettings_aggregate":
		if e.complexity.CsPolicy.SensorUpdateSettingsAggregate == nil {
			break
		}

		args, err := ec.field_csPolicy_sensorUpdateSettings_aggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPolicy.SensorUpdateSettingsAggregate(childComplexity, args["groupBy"].([]SensorUpdateSettingsAggregateColumns), args["distinctOn"].([]SensorUpdateSettingsAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*CsSensorUpdateSettingsBoolExp)), true

	case "csPolicySettings.enabled":
		if e.complexity.CsPolicySettings.Enabled == nil {
			break
		}

		return e.complexity.CsPolicySettings.Enabled(childComplexity), true

	case "csPreventionSettings.name":
		if e.complexity.CsPreventionSettings.Name == nil {
			break
		}

		return e.complexity.CsPreventionSettings.Name(childComplexity), true

	case "csPreventionSettings.settings":
		if e.complexity.CsPreventionSettings.Settings == nil {
			break
		}

		args, err := ec.field_csPreventionSettings_settings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CsPreventionSettings.Settings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPolicySettingsBoolExp)), true

	case "csSensorUpdateSettings.build":
		if e.complexity.CsSensorUpdateSettings.Build == nil {
			break
		}

		return e.complexity.CsSensorUpdateSettings.Build(childComplexity), true

	case "devicesAggregate.avg":
		if e.complexity.DevicesAggregate.Avg == nil {
			break
		}

		args, err := ec.field_devicesAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Avg(childComplexity, args["column"].([]DevicesAggregateAvgColumns)), true

	case "devicesAggregate.count":
		if e.complexity.DevicesAggregate.Count == nil {
			break
		}

		return e.complexity.DevicesAggregate.Count(childComplexity), true

	case "devicesAggregate.devices":
		if e.complexity.DevicesAggregate.Devices == nil {
			break
		}

		args, err := ec.field_devicesAggregate_devices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Devices(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp)), true

	case "devicesAggregate.distinct":
		if e.complexity.DevicesAggregate.Distinct == nil {
			break
		}

		return e.complexity.DevicesAggregate.Distinct(childComplexity), true

	case "devicesAggregate.group":
		if e.complexity.DevicesAggregate.Group == nil {
			break
		}

		return e.complexity.DevicesAggregate.Group(childComplexity), true

	case "devicesAggregate.max":
		if e.complexity.DevicesAggregate.Max == nil {
			break
		}

		args, err := ec.field_devicesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Max(childComplexity, args["column"].([]DevicesAggregateMaxColumns)), true

	case "devicesAggregate.min":
		if e.complexity.DevicesAggregate.Min == nil {
			break
		}

		args, err := ec.field_devicesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Min(childComplexity, args["column"].([]DevicesAggregateMinColumns)), true

	case "devicesAggregate.sum":
		if e.complexity.DevicesAggregate.Sum == nil {
			break
		}

		args, err := ec.field_devicesAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DevicesAggregate.Sum(childComplexity, args["column"].([]DevicesAggregateSumColumns)), true

	case "firewallRulesAggregate.avg":
		if e.complexity.FirewallRulesAggregate.Avg == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Avg(childComplexity, args["column"].([]FirewallRulesAggregateAvgColumns)), true

	case "firewallRulesAggregate.count":
		if e.complexity.FirewallRulesAggregate.Count == nil {
			break
		}

		return e.complexity.FirewallRulesAggregate.Count(childComplexity), true

	case "firewallRulesAggregate.distinct":
		if e.complexity.FirewallRulesAggregate.Distinct == nil {
			break
		}

		return e.complexity.FirewallRulesAggregate.Distinct(childComplexity), true

	case "firewallRulesAggregate.firewallRules":
		if e.complexity.FirewallRulesAggregate.FirewallRules == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_firewallRules_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.FirewallRules(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*FirewallRuleBoolExp)), true

	case "firewallRulesAggregate.group":
		if e.complexity.FirewallRulesAggregate.Group == nil {
			break
		}

		return e.complexity.FirewallRulesAggregate.Group(childComplexity), true

	case "firewallRulesAggregate.max":
		if e.complexity.FirewallRulesAggregate.Max == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Max(childComplexity, args["column"].([]FirewallRulesAggregateMaxColumns)), true

	case "firewallRulesAggregate.min":
		if e.complexity.FirewallRulesAggregate.Min == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Min(childComplexity, args["column"].([]FirewallRulesAggregateMinColumns)), true

	case "firewallRulesAggregate.sum":
		if e.complexity.FirewallRulesAggregate.Sum == nil {
			break
		}

		args, err := ec.field_firewallRulesAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FirewallRulesAggregate.Sum(childComplexity, args["column"].([]FirewallRulesAggregateSumColumns)), true

	case "groupsAggregate.avg":
		if e.complexity.GroupsAggregate.Avg == nil {
			break
		}

		args, err := ec.field_groupsAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Avg(childComplexity, args["column"].([]GroupsAggregateAvgColumns)), true

	case "groupsAggregate.count":
		if e.complexity.GroupsAggregate.Count == nil {
			break
		}

		return e.complexity.GroupsAggregate.Count(childComplexity), true

	case "groupsAggregate.distinct":
		if e.complexity.GroupsAggregate.Distinct == nil {
			break
		}

		return e.complexity.GroupsAggregate.Distinct(childComplexity), true

	case "groupsAggregate.group":
		if e.complexity.GroupsAggregate.Group == nil {
			break
		}

		return e.complexity.GroupsAggregate.Group(childComplexity), true

	case "groupsAggregate.groups":
		if e.complexity.GroupsAggregate.Groups == nil {
			break
		}

		args, err := ec.field_groupsAggregate_groups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Groups(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsGroupBoolExp)), true

	case "groupsAggregate.max":
		if e.complexity.GroupsAggregate.Max == nil {
			break
		}

		args, err := ec.field_groupsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Max(childComplexity, args["column"].([]GroupsAggregateMaxColumns)), true

	case "groupsAggregate.min":
		if e.complexity.GroupsAggregate.Min == nil {
			break
		}

		args, err := ec.field_groupsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Min(childComplexity, args["column"].([]GroupsAggregateMinColumns)), true

	case "groupsAggregate.sum":
		if e.complexity.GroupsAggregate.Sum == nil {
			break
		}

		args, err := ec.field_groupsAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GroupsAggregate.Sum(childComplexity, args["column"].([]GroupsAggregateSumColumns)), true

	case "installedSoftwareAggregate.avg":
		if e.complexity.InstalledSoftwareAggregate.Avg == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Avg(childComplexity, args["column"].([]InstalledSoftwareAggregateAvgColumns)), true

	case "installedSoftwareAggregate.count":
		if e.complexity.InstalledSoftwareAggregate.Count == nil {
			break
		}

		return e.complexity.InstalledSoftwareAggregate.Count(childComplexity), true

	case "installedSoftwareAggregate.distinct":
		if e.complexity.InstalledSoftwareAggregate.Distinct == nil {
			break
		}

		return e.complexity.InstalledSoftwareAggregate.Distinct(childComplexity), true

	case "installedSoftwareAggregate.group":
		if e.complexity.InstalledSoftwareAggregate.Group == nil {
			break
		}

		return e.complexity.InstalledSoftwareAggregate.Group(childComplexity), true

	case "installedSoftwareAggregate.installedSoftware":
		if e.complexity.InstalledSoftwareAggregate.InstalledSoftware == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_installedSoftware_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.InstalledSoftware(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*InstalledSoftwareBoolExp)), true

	case "installedSoftwareAggregate.max":
		if e.complexity.InstalledSoftwareAggregate.Max == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Max(childComplexity, args["column"].([]InstalledSoftwareAggregateMaxColumns)), true

	case "installedSoftwareAggregate.min":
		if e.complexity.InstalledSoftwareAggregate.Min == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Min(childComplexity, args["column"].([]InstalledSoftwareAggregateMinColumns)), true

	case "installedSoftwareAggregate.sum":
		if e.complexity.InstalledSoftwareAggregate.Sum == nil {
			break
		}

		args, err := ec.field_installedSoftwareAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InstalledSoftwareAggregate.Sum(childComplexity, args["column"].([]InstalledSoftwareAggregateSumColumns)), true

	case "interfacesAggregate.avg":
		if e.complexity.InterfacesAggregate.Avg == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Avg(childComplexity), true

	case "interfacesAggregate.count":
		if e.complexity.InterfacesAggregate.Count == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Count(childComplexity), true

	case "interfacesAggregate.distinct":
		if e.complexity.InterfacesAggregate.Distinct == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Distinct(childComplexity), true

	case "interfacesAggregate.group":
		if e.complexity.InterfacesAggregate.Group == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Group(childComplexity), true

	case "interfacesAggregate.interfaces":
		if e.complexity.InterfacesAggregate.Interfaces == nil {
			break
		}

		args, err := ec.field_interfacesAggregate_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfacesAggregate.Interfaces(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceBoolExp)), true

	case "interfacesAggregate.max":
		if e.complexity.InterfacesAggregate.Max == nil {
			break
		}

		args, err := ec.field_interfacesAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfacesAggregate.Max(childComplexity, args["column"].([]InterfacesAggregateMaxColumns)), true

	case "interfacesAggregate.min":
		if e.complexity.InterfacesAggregate.Min == nil {
			break
		}

		args, err := ec.field_interfacesAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfacesAggregate.Min(childComplexity, args["column"].([]InterfacesAggregateMinColumns)), true

	case "interfacesAggregate.sum":
		if e.complexity.InterfacesAggregate.Sum == nil {
			break
		}

		return e.complexity.InterfacesAggregate.Sum(childComplexity), true

	case "preventionSettingsAggregate.avg":
		if e.complexity.PreventionSettingsAggregate.Avg == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Avg(childComplexity), true

	case "preventionSettingsAggregate.count":
		if e.complexity.PreventionSettingsAggregate.Count == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Count(childComplexity), true

	case "preventionSettingsAggregate.distinct":
		if e.complexity.PreventionSettingsAggregate.Distinct == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Distinct(childComplexity), true

	case "preventionSettingsAggregate.group":
		if e.complexity.PreventionSettingsAggregate.Group == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Group(childComplexity), true

	case "preventionSettingsAggregate.max":
		if e.complexity.PreventionSettingsAggregate.Max == nil {
			break
		}

		args, err := ec.field_preventionSettingsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PreventionSettingsAggregate.Max(childComplexity, args["column"].([]PreventionSettingsAggregateMaxColumns)), true

	case "preventionSettingsAggregate.min":
		if e.complexity.PreventionSettingsAggregate.Min == nil {
			break
		}

		args, err := ec.field_preventionSettingsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PreventionSettingsAggregate.Min(childComplexity, args["column"].([]PreventionSettingsAggregateMinColumns)), true

	case "preventionSettingsAggregate.preventionSettings":
		if e.complexity.PreventionSettingsAggregate.PreventionSettings == nil {
			break
		}

		args, err := ec.field_preventionSettingsAggregate_preventionSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PreventionSettingsAggregate.PreventionSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsPreventionSettingsBoolExp)), true

	case "preventionSettingsAggregate.sum":
		if e.complexity.PreventionSettingsAggregate.Sum == nil {
			break
		}

		return e.complexity.PreventionSettingsAggregate.Sum(childComplexity), true

	case "sensorUpdateSettingsAggregate.avg":
		if e.complexity.SensorUpdateSettingsAggregate.Avg == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Avg(childComplexity), true

	case "sensorUpdateSettingsAggregate.count":
		if e.complexity.SensorUpdateSettingsAggregate.Count == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Count(childComplexity), true

	case "sensorUpdateSettingsAggregate.distinct":
		if e.complexity.SensorUpdateSettingsAggregate.Distinct == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Distinct(childComplexity), true

	case "sensorUpdateSettingsAggregate.group":
		if e.complexity.SensorUpdateSettingsAggregate.Group == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Group(childComplexity), true

	case "sensorUpdateSettingsAggregate.max":
		if e.complexity.SensorUpdateSettingsAggregate.Max == nil {
			break
		}

		args, err := ec.field_sensorUpdateSettingsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SensorUpdateSettingsAggregate.Max(childComplexity, args["column"].([]SensorUpdateSettingsAggregateMaxColumns)), true

	case "sensorUpdateSettingsAggregate.min":
		if e.complexity.SensorUpdateSettingsAggregate.Min == nil {
			break
		}

		args, err := ec.field_sensorUpdateSettingsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SensorUpdateSettingsAggregate.Min(childComplexity, args["column"].([]SensorUpdateSettingsAggregateMinColumns)), true

	case "sensorUpdateSettingsAggregate.sensorUpdateSettings":
		if e.complexity.SensorUpdateSettingsAggregate.SensorUpdateSettings == nil {
			break
		}

		args, err := ec.field_sensorUpdateSettingsAggregate_sensorUpdateSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SensorUpdateSettingsAggregate.SensorUpdateSettings(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*CsSensorUpdateSettingsBoolExp)), true

	case "sensorUpdateSettingsAggregate.sum":
		if e.complexity.SensorUpdateSettingsAggregate.Sum == nil {
			break
		}

		return e.complexity.SensorUpdateSettingsAggregate.Sum(childComplexity), true

	case "tagsAggregate.avg":
		if e.complexity.TagsAggregate.Avg == nil {
			break
		}

		return e.complexity.TagsAggregate.Avg(childComplexity), true

	case "tagsAggregate.count":
		if e.complexity.TagsAggregate.Count == nil {
			break
		}

		return e.complexity.TagsAggregate.Count(childComplexity), true

	case "tagsAggregate.distinct":
		if e.complexity.TagsAggregate.Distinct == nil {
			break
		}

		return e.complexity.TagsAggregate.Distinct(childComplexity), true

	case "tagsAggregate.group":
		if e.complexity.TagsAggregate.Group == nil {
			break
		}

		return e.complexity.TagsAggregate.Group(childComplexity), true

	case "tagsAggregate.max":
		if e.complexity.TagsAggregate.Max == nil {
			break
		}

		args, err := ec.field_tagsAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagsAggregate.Max(childComplexity, args["column"].([]TagsAggregateMaxColumns)), true

	case "tagsAggregate.min":
		if e.complexity.TagsAggregate.Min == nil {
			break
		}

		args, err := ec.field_tagsAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagsAggregate.Min(childComplexity, args["column"].([]TagsAggregateMinColumns)), true

	case "tagsAggregate.sum":
		if e.complexity.TagsAggregate.Sum == nil {
			break
		}

		return e.complexity.TagsAggregate.Sum(childComplexity), true

	case "tagsAggregate.tags":
		if e.complexity.TagsAggregate.Tags == nil {
			break
		}

		args, err := ec.field_tagsAggregate_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagsAggregate.Tags(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*TagBoolExp)), true

	case "usersAggregate.avg":
		if e.complexity.UsersAggregate.Avg == nil {
			break
		}

		args, err := ec.field_usersAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Avg(childComplexity, args["column"].([]UsersAggregateAvgColumns)), true

	case "usersAggregate.count":
		if e.complexity.UsersAggregate.Count == nil {
			break
		}

		return e.complexity.UsersAggregate.Count(childComplexity), true

	case "usersAggregate.distinct":
		if e.complexity.UsersAggregate.Distinct == nil {
			break
		}

		return e.complexity.UsersAggregate.Distinct(childComplexity), true

	case "usersAggregate.group":
		if e.complexity.UsersAggregate.Group == nil {
			break
		}

		return e.complexity.UsersAggregate.Group(childComplexity), true

	case "usersAggregate.max":
		if e.complexity.UsersAggregate.Max == nil {
			break
		}

		args, err := ec.field_usersAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Max(childComplexity, args["column"].([]UsersAggregateMaxColumns)), true

	case "usersAggregate.min":
		if e.complexity.UsersAggregate.Min == nil {
			break
		}

		args, err := ec.field_usersAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Min(childComplexity, args["column"].([]UsersAggregateMinColumns)), true

	case "usersAggregate.sum":
		if e.complexity.UsersAggregate.Sum == nil {
			break
		}

		args, err := ec.field_usersAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Sum(childComplexity, args["column"].([]UsersAggregateSumColumns)), true

	case "usersAggregate.users":
		if e.complexity.UsersAggregate.Users == nil {
			break
		}

		args, err := ec.field_usersAggregate_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UsersAggregate.Users(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp)), true

	case "vlansAggregate.avg":
		if e.complexity.VlansAggregate.Avg == nil {
			break
		}

		args, err := ec.field_vlansAggregate_avg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VlansAggregate.Avg(childComplexity, args["column"].([]VlansAggregateAvgColumns)), true

	case "vlansAggregate.count":
		if e.complexity.VlansAggregate.Count == nil {
			break
		}

		return e.complexity.VlansAggregate.Count(childComplexity), true

	case "vlansAggregate.distinct":
		if e.complexity.VlansAggregate.Distinct == nil {
			break
		}

		return e.complexity.VlansAggregate.Distinct(childComplexity), true

	case "vlansAggregate.group":
		if e.complexity.VlansAggregate.Group == nil {
			break
		}

		return e.complexity.VlansAggregate.Group(childComplexity), true

	case "vlansAggregate.max":
		if e.complexity.VlansAggregate.Max == nil {
			break
		}

		args, err := ec.field_vlansAggregate_max_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VlansAggregate.Max(childComplexity, args["column"].([]VlansAggregateMaxColumns)), true

	case "vlansAggregate.min":
		if e.complexity.VlansAggregate.Min == nil {
			break
		}

		args, err := ec.field_vlansAggregate_min_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VlansAggregate.Min(childComplexity, args["column"].([]VlansAggregateMinColumns)), true

	case "vlansAggregate.sum":
		if e.complexity.VlansAggregate.Sum == nil {
			break
		}

		args, err := ec.field_vlansAggregate_sum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VlansAggregate.Sum(childComplexity, args["column"].([]VlansAggregateSumColumns)), true

	case "vlansAggregate.vlans":
		if e.complexity.VlansAggregate.Vlans == nil {
			break
		}

		args, err := ec.field_vlansAggregate_vlans_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VlansAggregate.Vlans(childComplexity, args["limit"].(*int), args["offset"].(*int), args["where"].(*NetworkInterfaceVlanBoolExp)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	&ast.Source{Name: "../../api/generated/augmented_schema.graphql", Input: `# Code generated by go generate; DO NOT EDIT THIS FILE. 
# This file was generated at 2020-05-12T12:53:21+03:00
directive @generateInputs(where: String, orderBy: String) on OBJECT | UNION
directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
directive @jsonpath(name: String, depends: [String]) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
directive @relation(name: String!, fkName: [String!]!, relationFkName: [String!]!, relType: RelationType!, manyToManyTableName: String, joinOn: [String!]) on FIELD_DEFINITION
directive @sqlgen(skip: Boolean!) on FIELD_DEFINITION
directive @viewFunction(name: String, arguments: [String]) on FIELD_DEFINITION
enum AccessType {
	ALLOW
	DENY
}
"""
Enum filter expression for AccessType
"""
input AccessTypeComparator {
	"""
	eq comparison operator
	"""
	eq: AccessType
	"""
	neq comparison operator
	"""
	neq: AccessType
	"""
	in comparison operator
	"""
	in: [AccessType]
	"""
	not_in comparison operator
	"""
	not_in: [AccessType]
}
type ActiveDirectoryData {
	"""
	AD Common Name (CN)
	"""
	adCn: String
	"""
	AD objectSid
	"""
	adSid: String
	"""
	AD objectGUID
	"""
	adGuid: String
	"""
	AD name
	"""
	adName: String
	"""
	AD SAMAccountName
	"""
	adSAMAccountName: String
	"""
	AD User Principal Name
	"""
	adUserPrincipalName: String
	"""
	AD displayName
	"""
	adDisplayName: String
	"""
	AD distinguishedName
	"""
	adDistinguishedName: String
	"""
	AD canonicalName
	"""
	adCanonicalName: String
	"""
	AD accountExpires
	"""
	adAccountExpires: Epoch
	"""
	AD objectClass
	"""
	adObjectClass: [String]
	"""
	AD objectCategory
	"""
	adObjectCategory: String
	"""
	AD Organizational Unit
	"""
	adOrganizationalUnit: [String]
	"""
	AD lastLogoff
	"""
	adLastLogoff: Time
	"""
	AD lastLogon
	"""
	adLastLogon: Time
	"""
	AD lastLogonTimestamp
	"""
	adLastLogonTimestamp: Time
	"""
	AD badPasswordTime
	"""
	adBadPasswordTime: Time
	"""
	AD badPwdCount
	"""
	ad_bad_pwd_count: Int
	"""
	AD managedBy
	"""
	adManagedBy: String
	"""
	AD pwdLastSet
	"""
	adPasswordLastSet: Time
	"""
	AD Primary group ID
	"""
	adPrimaryGroupId: Int
	"""
	AD Primary group ID
	"""
	adPrimaryGroupDn: String
	"""
	AD memberOf
	"""
	adMemberOf: [String]
	"""
	AD memberOf (nested full list)
	"""
	adMemberOfFull: [String]
	"""
	AD uSNChanged
	"""
	adUsnChanged: Int
	"""
	AD uSNCreated
	"""
	adUsnCreated: Int
	"""
	AD whenChanged
	"""
	adWhenChanged: Time
	"""
	AD whenCreated
	"""
	adWhenCreated: Time
	"""
	AD isCriticalSystemObject
	"""
	adIsCriticalSystemObject: Boolean
	"""
	AD msDS-AllowedToDelegateTo
	"""
	adMsdsAllowedToDelegateTo: [String]
	"""
	AD Password Must Change
	"""
	adPwdMustChange: Boolean
	"""
	AD Resultant Password Settings Object
	"""
	adMsdsResultantPso: String
}
type Adapter @generateInputs(where: "adapter_bool_exp", orderBy: "adapter_order_by") {
	id: String!
	name: String
	properties: [String]
}
union AdapterData @generateInputs(where: "adapter_data_bool_exp", orderBy: "adapter_data_order_by") = ActiveDirectoryData | CylanceData | CrowdStrikeData
"""
Adapter device is a single enitity returned from that adapter
"""
type AdapterDevice @generateInputs(where: "adapter_device_bool_exp", orderBy: "adapter_device_order_by") {
	"""
	Unique id of adapter device
	"""
	id: UUID!
	"""
	Cycle adapter device was fetched
	"""
	fetchCycle: Int!
	"""
	Idadas of adapter that fetched this device
	"""
	adapterId: String!
	adapter("""
	filter the rows returned
	"""
	where: adapter_bool_exp): Adapter @relation(name: "adapters", fkName: ["adapterId"], relationFkName: ["id"], relType: ONE_TO_ONE)
	"""
	Name of adapter that fetched this advice
	"""
	adapterName: String
	"""
	Correlated device id
	"""
	deviceId: UUID!
	"""
	Unique data returned by adapter on this device
	"""
	adapterData("""
	filter the rows returned
	"""
	where: adapter_data_bool_exp): AdapterData @jsonpath(name: "data", depends: ["adapterId"]) @goField(forceResolver: true, name: "adapterData")
	"""
	Data returned by this adapter as a json mappping
	"""
	data: Map
	"""
	Time adapter was requested to fetch device by axonius
	"""
	fetchTime: Epoch
	"""
	hostname of device
	"""
	hostname: String
	"""
	name given to device by the adapter
	"""
	name: String
	"""
	Last time device was seen by adapter in Unix time
	"""
	lastSeen: Epoch
	osId: UUID!
	"""
	Operating system adapter device is running on
	"""
	os("""
	filter the rows returned
	"""
	where: operating_system_bool_exp): OperatingSystem @relation(name: "operating_systems", fkName: ["osId"], relationFkName: ["id"], relType: ONE_TO_ONE)
	"""
	Pertty id given to adapter device when axonius created it
	"""
	prettyId: String
	tags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [Tag] @relation(name: "adapter_device_tags", fkName: ["id"], relationFkName: ["adapter_device_id"], relType: MANY_TO_MANY, manyToManyTableName: "tags", joinOn: ["name"])
	interfaces("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [NetworkInterface!] @relation(name: "network_interfaces", fkName: ["id","fetch_cycle"], relationFkName: ["deviceId","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	List of uses who last used the device
	"""
	lastUsedUsers: [String]
	"""
	Name of domain this adapter device belongs too
	"""
	domain: String
	"""
	Whether this adapter device is part of the domain
	"""
	partOfDomain: Boolean
	"""
	Users known by this device
	"""
	deviceUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_user_bool_exp): [AdapterDeviceUser] @jsonpath(name: "deviceUsers")
	"""
	local admins known by this device
	"""
	localAdmins("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_admin_bool_exp): [AdapterDeviceAdmin] @jsonpath(name: "localAdmins")
	"""
	Firewall rules defined on this adapter device
	"""
	firewallRules("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: firewall_rule_bool_exp): [FirewallRule] @relation(name: "adapter_device_firewall_rules", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "firewall_rules", joinOn: ["name"])
	"""
	Software installed on this device
	"""
	installedSoftware("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: installed_software_bool_exp): [InstalledSoftware] @relation(name: "adapter_device_installed_software", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "installed_software", joinOn: ["name","version"])
	agentVersion: String
	agentStatus: String
	agentName: String
	model: String
	manufacturer: String
	serial: String
	family: String
	biosVersion: String
	biosSerial: String
	"""
	Returns aggregate of tags
	"""
	tags_aggregate("""
	group by columns
	"""
	groupBy: [tags_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [tags_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [tagsAggregate!] @relation(name: "adapter_device_tags", fkName: ["id"], relationFkName: ["adapter_device_id"], relType: MANY_TO_MANY, manyToManyTableName: "tags", joinOn: ["name"])
	"""
	Returns aggregate of interfaces
	"""
	interfaces_aggregate("""
	group by columns
	"""
	groupBy: [interfaces_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [interfaces_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [interfacesAggregate!] @relation(name: "network_interfaces", fkName: ["id","fetch_cycle"], relationFkName: ["deviceId","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	Returns aggregate of firewallRules
	"""
	firewallRules_aggregate("""
	group by columns
	"""
	groupBy: [firewallRules_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [firewallRules_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: firewall_rule_bool_exp): [firewallRulesAggregate!] @relation(name: "adapter_device_firewall_rules", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "firewall_rules", joinOn: ["name"])
	"""
	Returns aggregate of installedSoftware
	"""
	installedSoftware_aggregate("""
	group by columns
	"""
	groupBy: [installedSoftware_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [installedSoftware_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: installed_software_bool_exp): [installedSoftwareAggregate!] @relation(name: "adapter_device_installed_software", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "installed_software", joinOn: ["name","version"])
}
type AdapterDeviceAdmin @generateInputs(where: "adapter_device_admin_bool_exp", orderBy: "adapter_device_admin_order_by") {
	name: String
	type: AdminType
}
"""
User known by an adapter device
"""
type AdapterDeviceUser @generateInputs(where: "adapter_device_user_bool_exp", orderBy: "adapter_device_user_order_by") {
	deviceId: UUID
	sid: String
	username: String
	lastUseDate: Epoch
	isLocal: Boolean
	isDisabled: Boolean
	isAdmin: Boolean
	userDepartment: Boolean
	passwordMaxAge: Int
	interpreter: String
}
enum AdapterType @goModel(model: "bandicoot/pkg/domain.AdapterType") {
	UNKNOWN
	CUSTOM
	ABSOLUTE
	ACTIVE_DIRECTORY
	AIRWATCH
	AIRWAVE
	ALERTLOGIC
	ALIBABA
	ANSIBLE_TOWER
	AQUA
	ARISTA_EOS
	ARMIS
	ARSENAL
	ARUBA
	AUTOMOX
	AWS
	AZURE_AD
	AZURE
	BAMBOOHR
	BIGFIX
	BIGFIX_INVENTORY
	BITDEFENDER
	BITLOCKER
	BITSIGHT
	BLACKBERRY_UEM
	BLUECAT
	BOMGAR
	CA_CMDB
	CA_SPECTRUM
	CARBONBLACK_DEFENSE
	CARBONBLACK_RESPONSE
	CENSYS
	CHECKPOINTR90
	CHEF
	CHERWELL
	CISCO
	CISCO_AMP
	CISCO_FIREPOWER_MANAGEMENT_CENTER
	CISCO_ISE
	CISCO_MERAKI
	CISCO_PRIME
	CISCO_STEALTHWATCH
	CISCO_UCM
	CISCO_UCSM
	CISCO_UMBERELLA
	CLAROTY
	CLEARPASS
	CLOUDFLARE
	CLOUD_PASSAGE
	CODE42
	COUNTER_ACT
	CROWD_STRIKE
	CSC_GLOBAL
	CSV
	CYBEREASON
	CYCOGNITO
	CYLANCE
	CYNET
	DATADOG
	DATTO
	DEEP_SECURITY
	DEFENDER_ATP
	DESKTOP_CENTRAL
	DEVICE42
	DIGICERT_CERTCENTRAL
	DIVVY_CLOUD
	DROPBOX
	DRUVA
	DUO
	DYNATRACE
	ECLYPSIUM
	EDGESSCAN
	ENDGAME
	ENSILO
	EPO
	ESET
	ESX
	F5_ICONTROL
	FIRE_EYE_HX
	FORCEPOINT
	FOREMAN
	FORTIGATE
	FRESH_SERVICE
	GCE
	GITHUB
	GOOGLE_BIG_QUERY
	GOOGLE_MDM
	GOTOASSIST
	GURDICORE
	GUARDIUM
	HASHICORP
	HAVEIBEENPWNED
	HP_NNMI
	HYPER_V
	IBM_TIVOLI_TADDM
	ICINGA
	IGAR
	ILLUSIVE
	IMPERVA
	INDEGY
	INFINITE_SLEEP
	INFOBLOX
	IVANTI_SM
	JAMF
	JSON
	JSON_FILE
	JUMPCLOUD
	JUNIPER
	JUNOS
	KASEYA
	KASPERSKY_SC
	LANDESK
	LANSWEEPER
	LIBERNMS
	LINUX_SSH
	LOGRYTHM
	MAAS360
	MALWAREBYTES
	MASSCAN
	MEDIGATE
	MEN_AND_MICE
	MINERVA
	MOBI_CONTROL
	MOBILE_IRON
	MSSQL
	NESSUS
	NESSUS_CSV
	NETBOX
	NETBRAIN
	NETSKOPE
	NEXPOSE
	NIMBUL
	NMAP
	NUTANIX
	OBSERVEIT
	OBSERVIUM
	OFFICE_SCAN
	OKTA
	OMNIVISTA
	OPENSTACK
	OPSWAT
	ORACLE_CLOUD
	ORACLE_VM
	ORCA
	PACKETFENCE
	PALOALTO_CORTEX
	PALOALTO_PANORAMA
	PALOALTO_XDR
	PKWARE
	PREEMPT
	PROMISEC
	PROXMOX
	PUPPET
	QCORE
	QUALYS
	QUEST_KACE
	RANDORI
	REDCANARY
	REDCLOAK
	REDSEAL
	RISK_IQ
	RIVERBED
	RUMBLE
	SALTSTACK
	SALTSTACK_ENTERPRISE
	SAMANGE
	SCCM
	SCEP
	SECDO
	SENTINELONE
	SERVICENOW
	SHOADAN
	SIGNALSCIENCES
	SKYBOX
	SNIPEIT
	SNOW
	SOFTLAYER
	SOLARWINDS_ORION
	SOPHOS
	SPACEWALK
	SPECOPS
	SPLUNK
	STRESSTEST
	SYMANTEC
	SYMANTEC_ALTIRIS
	SYMANTEC_CCS
	SYMANTEC_CLOUD_WORKLOAD
	SYMANTEC_DLP
	SYMANTEC_SEP_CLOUD
	SYSAID
	TANIUM
	TENABLE_IO
	TENABLE_SECURITY_CENTER
	TORIIHQ
	TRAIANA_LAB_MACHINES
	TRIPWIRE_ENTERPRISE
	TRUEFORT
	TWISTLOCK
	UNIFI
	VCLOUD_DIRECTOR
	WAZUH
	WEBROOT
	WEBSCAN
	WSUS
	ZABBIX
	ZSCALER
}
type AdapterUser @generateInputs(where: "adapter_user_bool_exp", orderBy: "adapter_user_order_by") {
	"""
	Unique id of adapter device
	"""
	id: UUID!
	"""
	Cycle adapter device was fetched
	"""
	fetchCycle: Int!
	"""
	Id of adapter that fetched this device
	"""
	adapterId: String!
	adapter("""
	filter the rows returned
	"""
	where: adapter_bool_exp): Adapter @relation(name: "adapters", fkName: ["adapterId"], relationFkName: ["id"], relType: ONE_TO_ONE)
	"""
	Name of adapter that fetched this advice
	"""
	adapterName: String
	"""
	Correlated device id
	"""
	userId: UUID!
	"""
	Unique data returned by adapter on this device
	"""
	adapterData("""
	filter the rows returned
	"""
	where: adapter_data_bool_exp): AdapterData @jsonpath(name: "data", depends: ["adapterId"]) @goField(forceResolver: true, name: "adapterData")
	"""
	Data returned by this adapter as a json mappping
	"""
	data: Map
	"""
	Time adapter was requested to fetch device by axonius
	"""
	fetchTime: Epoch
	"""
	Last time device was seen by adapter in Unix time
	"""
	lastSeen: Epoch
	"""
	Username
	"""
	username: String
	displayName: String
	description: String
	domain: String
	userSid: String
	"""
	User first name
	"""
	firstName: String
	"""
	User last name
	"""
	lastName: String
	"""
	User email account
	"""
	mail: String
	"""
	User account has admin privileges
	"""
	admin: Boolean
	"""
	User entity is local 
	"""
	local: Boolean
	"""
	User account is a delegated admin
	"""
	delegatedAdmin: Boolean
	"""
	User account has multi-factor authentication enforced
	"""
	mfaEnforced: Boolean
	"""
	User account is enrollled in multi-factor authenticaton
	"""
	mfaEnrolled: Boolean
	"""
	User account is suspended
	"""
	suspended: Boolean
	"""
	User account has been locked
	"""
	locked: Boolean
	"""
	User account has been disabled
	"""
	disabled: Boolean
}
enum AdminType {
	ADMIN_USER
	GROUP_MEMBERSHIP
}
"""
Enum filter expression for AdminType
"""
input AdminTypeComparator {
	"""
	eq comparison operator
	"""
	eq: AdminType
	"""
	neq comparison operator
	"""
	neq: AdminType
	"""
	in comparison operator
	"""
	in: [AdminType]
	"""
	not_in comparison operator
	"""
	not_in: [AdminType]
}
interface Aggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min: Map
	max: Map
}
enum AggregateOrdering {
	count_ASC
	count_DESC
	sum_ASC
	sum_DESC
	avg_ASC
	avg_DESC
	min_ASC
	min_DESC
	max_ASC
	max_DESC
}
scalar Any
enum Architecture {
	X86
	X64
	MIPS
	ALPHA
	ARM
	POWER_PC
	IA64
}
"""
Enum filter expression for Architecture
"""
input ArchitectureComparator {
	"""
	eq comparison operator
	"""
	eq: Architecture
	"""
	neq comparison operator
	"""
	neq: Architecture
	"""
	in comparison operator
	"""
	in: [Architecture]
	"""
	not_in comparison operator
	"""
	not_in: [Architecture]
}
input BooleanComparator {
	exists: Boolean
	eq: Boolean
	neq: Boolean
}
"""
IPv4 and IPv6 networks
"""
scalar CIDR
input CIDRComparator {
	exists: Boolean
	eq: CIDR
	neq: CIDR
}
type CPU {
	id: Int!
	name: String!
	manfacturer: String
	bitness: Int
	family: String
	"""
	Core count of CPU
	"""
	cores: Int
	coresThreads: Int
	ghz: Float
}
type CrowdStrikeData {
	externalIp: String
	groups("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [csGroup]
	preventionPolicy("""
	filter the rows returned
	"""
	where: cs_policy_bool_exp): csPolicy
	sensorUpdatePolicy("""
	filter the rows returned
	"""
	where: cs_group_bool_exp): csGroup
	csAgentVersion: String
	"""
	Returns aggregate of groups
	"""
	groups_aggregate("""
	group by columns
	"""
	groupBy: [groups_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [groups_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [groupsAggregate!]
}
type CylanceData {
	isSafe: String
	deviceState: CylanceDeviceState
	policyId: String
	policyName: String
	policiesDetails: [String]
	tenantTag: String
	zoneNames: [String]
	agentVersion: String
}
enum CylanceDeviceState {
	ONLINE
	OFFLINE
}
"""
Enum filter expression for CylanceDeviceState
"""
input CylanceDeviceStateComparator {
	"""
	eq comparison operator
	"""
	eq: CylanceDeviceState
	"""
	neq comparison operator
	"""
	neq: CylanceDeviceState
	"""
	in comparison operator
	"""
	in: [CylanceDeviceState]
	"""
	not_in comparison operator
	"""
	not_in: [CylanceDeviceState]
}
"""
Device aggregates one or more adapter device that were correlated
"""
type Device @generateInputs(where: "device_bool_exp", orderBy: "device_order_by") {
	"""
	Unique ID of correlated device
	"""
	id: UUID!
	"""
	Fetch cycle this device was collected
	"""
	fetchCycle: Int!
	"""
	Count of adapters that are correlated to this device
	"""
	adapterCount: Int!
	"""
	Names of adapters that are correlated to this device
	"""
	adapterNames: [String!]
	"""
	Unique hostnames given to device by all adapters
	"""
	hostnames: [String!]
	"""
	Last time device was seen by one of the adapters
	"""
	lastSeen: Epoch
	"""
	Adapter devices that are correlated to this device
	"""
	adapterDevices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [AdapterDevice!] @relation(name: "adapter_devices", fkName: ["id","fetch_cycle"], relationFkName: ["device_id","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	Unique set of network interfaces collected by all adapter devices
	"""
	interfaces("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [NetworkInterface!] @viewFunction(name: "device_network_interfaces", arguments: ["id","fetch_cycle"])
	"""
	Unique set tags given to all adapter devices
	"""
	tags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [Tag!] @viewFunction(name: "device_tags", arguments: ["id","fetch_cycle"])
	"""
	Allows transformation of queried data to API v1
	"""
	_compatibilityAPI: Map @goField(forceResolver: true, name: "compatabilityAPI") @deprecated
	"""
	Returns aggregate of adapterDevices
	"""
	adapterDevices_aggregate("""
	group by columns
	"""
	groupBy: [adapterDevices_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterDevices_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [adapterDevicesAggregate!] @relation(name: "adapter_devices", fkName: ["id","fetch_cycle"], relationFkName: ["device_id","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	Returns aggregate of interfaces
	"""
	interfaces_aggregate("""
	group by columns
	"""
	groupBy: [interfaces_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [interfaces_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [interfacesAggregate!] @viewFunction(name: "device_network_interfaces", arguments: ["id","fetch_cycle"])
	"""
	Returns aggregate of tags
	"""
	tags_aggregate("""
	group by columns
	"""
	groupBy: [tags_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [tags_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [tagsAggregate!] @viewFunction(name: "device_tags", arguments: ["id","fetch_cycle"])
}
enum Direction {
	INGRESS
	EGRESS
}
"""
Enum filter expression for Direction
"""
input DirectionComparator {
	"""
	eq comparison operator
	"""
	eq: Direction
	"""
	neq comparison operator
	"""
	neq: Direction
	"""
	in comparison operator
	"""
	in: [Direction]
	"""
	not_in comparison operator
	"""
	not_in: [Direction]
}
"""
Unix Time (also known as Epoch time) is a system for describing a point in time.
It is the number of seconds that have elapsed since the Unix epoch, that is the time 00:00:00 UTC on 1 January 1970,
minus leap seconds.
"""
scalar Epoch
input EpochArrayComparator {
	exists: Boolean
	eq: [Epoch]
	neq: [Epoch]
}
input EpochComparator {
	exists: Boolean
	eq: Epoch
	neq: Epoch
	lte: Epoch
	lt: Epoch
	gte: Epoch
	gt: Epoch
	days: Int
}
interface Filter {
	name: String!
	description: String
	type: String!
	displayName: String!
}
type FirewallRule @generateInputs(where: "firewall_rule_bool_exp", orderBy: "firewall_rule_order_by") {
	name: String
	source: String
	type: AccessType
	direction: Direction
	target: String
	protocol: String
	srcPort: Int
	dstPort: Int
}
input FloatArrayComparator {
	exists: Boolean
	eq: [Float]
	neq: [Float]
	contains: [Float]
	contained_by: [Float]
	overlap: [Float]
	size: Int
}
input FloatComparator {
	exists: Boolean
	eq: Float
	neq: Float
	lte: Float
	lt: Float
	gte: Float
	gt: Float
}
type GCETagsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [GCETags_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [GCETags_aggregate_max_columns!]!): Map
	GCETags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: gce_tags_bool_exp): [GceTags]
}
enum GCETags_aggregate_columns {
	"""
	groupBy by gceKey
	"""
	gceKey
	"""
	groupBy by gceValue
	"""
	gceValue
}
enum GCETags_aggregate_max_columns {
	"""
	max by gceKey
	"""
	gceKey
	"""
	max by gceValue
	"""
	gceValue
}
enum GCETags_aggregate_min_columns {
	"""
	min by gceKey
	"""
	gceKey
	"""
	min by gceValue
	"""
	gceValue
}
type GceTags @generateInputs(where: "gce_tags_bool_exp", orderBy: "gce_tags_order_by") {
	gceKey: String
	gceValue: String
}
type GoogleCloudData {
	Id: String
	Size: String
	Image: String
	GCETags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: gce_tags_bool_exp): [GceTags]
	"""
	Returns aggregate of GCETags
	"""
	GCETags_aggregate("""
	group by columns
	"""
	groupBy: [GCETags_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [GCETags_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: gce_tags_bool_exp): [GCETagsAggregate!]
}
scalar IP
input IPArrayComparator {
	exists: Boolean
	eq: [IP]
	neq: [IP]
	contains: [IP]
	contained_by: [IP]
	overlap: [IP]
	size: Int
	in_subnet: CIDR
	ip_family: IPFamily
}
input IPComparator {
	exists: Boolean
	eq: IP
	neq: IP
}
enum IPFamily {
	V4
	V6
}
type InstalledSoftware @generateInputs(where: "installed_software_bool_exp", orderBy: "installed_software_order_by") {
	"""
	Software Name
	"""
	name: String
	"""
	Software Version
	"""
	version: String
	architecture: Architecture
	description: String
	"""
	Software Vendor
	"""
	vendor: String
	publisher: String
	cveCount: Int
	swLicense: String
	path: String
}
input IntArrayComparator {
	exists: Boolean
	eq: [Int]
	neq: [Int]
	contains: [Int]
	contained_by: [Int]
	overlap: [Int]
	size: Int
}
input IntComparator {
	exists: Boolean
	eq: Int
	neq: Int
	lte: Int
	lt: Int
	gte: Int
	gt: Int
	in: [Int]
	not_in: [Int]
}
"""
A media access control address (MAC address) is a unique identifier assigned to a network interface controller (NIC)
for use as a network address in communications within a network segment.
"""
scalar Mac
input MacArrayComparator {
	exists: Boolean
	eq: [Mac]
	neq: [Mac]
	contains: [Mac]
	contained_by: [Mac]
	overlap: [Mac]
	size: Mac
}
input MacComparator {
	exists: Boolean
	eq: Mac
	neq: Mac
}
"""
JavaScript Object Notation (JSON) is an open-standard file format or data interchange format
that uses human-readable text to transmit data objects consisting of attributevalue pairs and array data types
(or any other serializable value)
"""
scalar Map
"""
Network interface is a system's interface between two pieces of equipment or protocol layers in a computer network.
"""
type NetworkInterface @generateInputs(where: "network_interface_bool_exp", orderBy: "network_interface_order_by") {
	deviceId: UUID
	macAddr: Mac
	ipAddrs: [IP!]
	"""
	Interface name
	"""
	name: String
	"""
	Manufacturer
	"""
	manufacturer: String
	"""
	A list of subnets in ip format, that correspond the ipAddrs
	"""
	subnets: [CIDR]
	"""
	Operational Status
	"""
	operationalStatus: String
	"""
	Admin Status
	"""
	adminStatus: String
	portType: String
	mtu: String
	gateway: IP
	port: String
	vlans("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_vlan_bool_exp): [NetworkInterfaceVlan] @relation(name: "network_interfaces_vlan", fkName: ["macAddr","fetch_cycle"], relationFkName: ["macAddr","fetch_cycle"], relType: ONE_TO_MANY)
	"""
	Returns aggregate of vlans
	"""
	vlans_aggregate("""
	group by columns
	"""
	groupBy: [vlans_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [vlans_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_vlan_bool_exp): [vlansAggregate!] @relation(name: "network_interfaces_vlan", fkName: ["macAddr","fetch_cycle"], relationFkName: ["macAddr","fetch_cycle"], relType: ONE_TO_MANY)
}
type NetworkInterfaceVlan @generateInputs(where: "network_interface_vlan_bool_exp", orderBy: "network_interface_vlan_order_by") {
	macAddr: Mac
	name: String
	tagId: Int
	tagged: Boolean
}
type ObjectFilter implements Filter {
	name: String!
	displayName: String!
	type: String!
	description: String
	filters: [Filter] @sqlgen(skip: true)
}
"""
Operating System is the system installed on an adapter device
"""
type OperatingSystem @generateInputs(where: "operating_system_bool_exp", orderBy: "operating_system_order_by") {
	id: UUID!
	type: String
	distribution: String
	architecture: Int
	servicePack: String
	installDate: Epoch
	kernelVersion: String
	codeName: String
	major: Int
	minor: Int
	build: String
	rawName: String
}
type Operator implements Filter {
	name: String!
	type: String!
	displayName: String!
	description: String
	formatDisplay: String
}
enum OsTypes {
	WINDOWS
	LINUX
	OS_X
	IOS
	AIR_OS
	ANDROID
	FREE_BSD
	VMWARE
	CISCO
	MIKROTIK
	VXWORKS
	F5_NETWORKS_BIG_IP
	SOLARIS
	AIX
	PRINTER
	PLAYSTATION
	CHECKPOINT
	ARISTA
}
type Query {
	adapterDevices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [adapter_device_order_by!]): [AdapterDevice!]!
	devices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: device_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [device_order_by!]): [Device!]!
	adapterUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [adapter_user_order_by!]): [AdapterUser!]!
	users("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: user_bool_exp, """
	sort the rows by one or more columns
	"""
	orderBy: [user_order_by!]): [User!]!
	_wizardFilters(type: String!): ObjectFilter @sqlgen(skip: true)
	"""
	Returns aggregate of adapterDevices
	"""
	adapterDevices_aggregate("""
	group by columns
	"""
	groupBy: [adapterDevices_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterDevices_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [adapterDevicesAggregate!]
	"""
	Returns aggregate of devices
	"""
	devices_aggregate("""
	group by columns
	"""
	groupBy: [devices_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [devices_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: device_bool_exp): [devicesAggregate!]
	"""
	Returns aggregate of adapterUsers
	"""
	adapterUsers_aggregate("""
	group by columns
	"""
	groupBy: [adapterUsers_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterUsers_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [adapterUsersAggregate!]
	"""
	Returns aggregate of users
	"""
	users_aggregate("""
	group by columns
	"""
	groupBy: [users_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [users_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: user_bool_exp): [usersAggregate!]
}
enum RelationType {
	ONE_TO_ONE
	ONE_TO_MANY
	MANY_TO_MANY
}
type ScalarFilter implements Filter {
	name: String!
	displayName: String!
	description: String
	type: String!
	operators: [Operator]! @sqlgen(skip: true)
}
type Storage {
	deviceId: UUID!
	"""
	Path
	"""
	path: String!
	"""
	Device Name
	"""
	name: String!
	"""
	Size (GB)
	"""
	totalSize: Float!
	"""
	Size (GB)
	"""
	freeSize: Float!
	"""
	Whether drive is encrypted or not
	"""
	isEncrypted: Boolean!
	"""
	Descirption of device
	"""
	description: String
}
input StringArrayComparator {
	exists: Boolean
	eq: [String]
	neq: [String]
	contains: [String]
	contained_by: [String]
	overlap: [String]
	no_overlap: [String]
	size: Int
	contains_regex: String
}
input StringComparator {
	exists: Boolean
	eq: String
	neq: String
	in: [String]
	not_in: [String]
	like: String
	ilike: String
	not_like: String
	not_ilike: String
	suffix: String
	prefix: String
}
type Tag @generateInputs(where: "tag_bool_exp", orderBy: "tag_order_by") {
	name: String!
	creator: String!
	level: String!
}
scalar Time
scalar UUID
input UUIDArrayComparator {
	exists: Boolean
	eq: [UUID]
	neq: [UUID]
	contains: [UUID]
	contained_by: [UUID]
	overlap: [UUID]
	size: Int
}
input UUIDComparator {
	exists: Boolean
	eq: UUID
	neq: UUID
	in: [UUID]
	not_in: [UUID]
}
type UnionFilter implements Filter {
	name: String!
	displayName: String!
	type: String!
	description: String
	objects: [ObjectFilter] @sqlgen(skip: true)
}
type User @generateInputs(where: "user_bool_exp", orderBy: "user_order_by") {
	id: UUID!
	fetchCycle: Int!
	adapterCount: Int!
	adapterNames: [String!]
	usernames: [String!]
	lastSeen: Epoch
	adapterUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [AdapterUser!] @relation(name: "adapter_users", fkName: ["id","fetch_cycle"], relationFkName: ["user_id","fetch_cycle"], relType: ONE_TO_MANY)
	_compatibilityAPI: Map @goField(forceResolver: true, name: "compatabilityAPI")
	"""
	Returns aggregate of adapterUsers
	"""
	adapterUsers_aggregate("""
	group by columns
	"""
	groupBy: [adapterUsers_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [adapterUsers_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [adapterUsersAggregate!] @relation(name: "adapter_users", fkName: ["id","fetch_cycle"], relationFkName: ["user_id","fetch_cycle"], relType: ONE_TO_MANY)
}
type adapterDevicesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterDevices_aggregate_max_columns!]!): Map
	adapterDevices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_device_bool_exp): [AdapterDevice]
}
enum adapterDevices_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by fetchTime
	"""
	fetchTime
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum adapterDevices_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterId
	"""
	adapterId
	"""
	groupBy by adapterName
	"""
	adapterName
	"""
	groupBy by deviceId
	"""
	deviceId
	"""
	groupBy by fetchTime
	"""
	fetchTime
	"""
	groupBy by hostname
	"""
	hostname
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by lastSeen
	"""
	lastSeen
	"""
	groupBy by osId
	"""
	osId
	"""
	groupBy by prettyId
	"""
	prettyId
	"""
	groupBy by domain
	"""
	domain
	"""
	groupBy by agentVersion
	"""
	agentVersion
	"""
	groupBy by agentStatus
	"""
	agentStatus
	"""
	groupBy by agentName
	"""
	agentName
	"""
	groupBy by model
	"""
	model
	"""
	groupBy by manufacturer
	"""
	manufacturer
	"""
	groupBy by serial
	"""
	serial
	"""
	groupBy by family
	"""
	family
	"""
	groupBy by biosVersion
	"""
	biosVersion
	"""
	groupBy by biosSerial
	"""
	biosSerial
}
enum adapterDevices_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterId
	"""
	adapterId
	"""
	max by adapterName
	"""
	adapterName
	"""
	max by deviceId
	"""
	deviceId
	"""
	max by fetchTime
	"""
	fetchTime
	"""
	max by hostname
	"""
	hostname
	"""
	max by name
	"""
	name
	"""
	max by lastSeen
	"""
	lastSeen
	"""
	max by osId
	"""
	osId
	"""
	max by prettyId
	"""
	prettyId
	"""
	max by domain
	"""
	domain
	"""
	max by agentVersion
	"""
	agentVersion
	"""
	max by agentStatus
	"""
	agentStatus
	"""
	max by agentName
	"""
	agentName
	"""
	max by model
	"""
	model
	"""
	max by manufacturer
	"""
	manufacturer
	"""
	max by serial
	"""
	serial
	"""
	max by family
	"""
	family
	"""
	max by biosVersion
	"""
	biosVersion
	"""
	max by biosSerial
	"""
	biosSerial
}
enum adapterDevices_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterId
	"""
	adapterId
	"""
	min by adapterName
	"""
	adapterName
	"""
	min by deviceId
	"""
	deviceId
	"""
	min by fetchTime
	"""
	fetchTime
	"""
	min by hostname
	"""
	hostname
	"""
	min by name
	"""
	name
	"""
	min by lastSeen
	"""
	lastSeen
	"""
	min by osId
	"""
	osId
	"""
	min by prettyId
	"""
	prettyId
	"""
	min by domain
	"""
	domain
	"""
	min by agentVersion
	"""
	agentVersion
	"""
	min by agentStatus
	"""
	agentStatus
	"""
	min by agentName
	"""
	agentName
	"""
	min by model
	"""
	model
	"""
	min by manufacturer
	"""
	manufacturer
	"""
	min by serial
	"""
	serial
	"""
	min by family
	"""
	family
	"""
	min by biosVersion
	"""
	biosVersion
	"""
	min by biosSerial
	"""
	biosSerial
}
enum adapterDevices_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by fetchTime
	"""
	fetchTime
	"""
	sum by lastSeen
	"""
	lastSeen
}
type adapterUsersAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [adapterUsers_aggregate_max_columns!]!): Map
	adapterUsers("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: adapter_user_bool_exp): [AdapterUser] @relation(name: "adapter_users", fkName: ["id","fetch_cycle"], relationFkName: ["user_id","fetch_cycle"], relType: ONE_TO_MANY)
}
enum adapterUsers_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by fetchTime
	"""
	fetchTime
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum adapterUsers_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterId
	"""
	adapterId
	"""
	groupBy by adapterName
	"""
	adapterName
	"""
	groupBy by userId
	"""
	userId
	"""
	groupBy by fetchTime
	"""
	fetchTime
	"""
	groupBy by lastSeen
	"""
	lastSeen
	"""
	groupBy by username
	"""
	username
	"""
	groupBy by displayName
	"""
	displayName
	"""
	groupBy by description
	"""
	description
	"""
	groupBy by domain
	"""
	domain
	"""
	groupBy by userSid
	"""
	userSid
	"""
	groupBy by firstName
	"""
	firstName
	"""
	groupBy by lastName
	"""
	lastName
	"""
	groupBy by mail
	"""
	mail
}
enum adapterUsers_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterId
	"""
	adapterId
	"""
	max by adapterName
	"""
	adapterName
	"""
	max by userId
	"""
	userId
	"""
	max by fetchTime
	"""
	fetchTime
	"""
	max by lastSeen
	"""
	lastSeen
	"""
	max by username
	"""
	username
	"""
	max by displayName
	"""
	displayName
	"""
	max by description
	"""
	description
	"""
	max by domain
	"""
	domain
	"""
	max by userSid
	"""
	userSid
	"""
	max by firstName
	"""
	firstName
	"""
	max by lastName
	"""
	lastName
	"""
	max by mail
	"""
	mail
}
enum adapterUsers_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterId
	"""
	adapterId
	"""
	min by adapterName
	"""
	adapterName
	"""
	min by userId
	"""
	userId
	"""
	min by fetchTime
	"""
	fetchTime
	"""
	min by lastSeen
	"""
	lastSeen
	"""
	min by username
	"""
	username
	"""
	min by displayName
	"""
	displayName
	"""
	min by description
	"""
	description
	"""
	min by domain
	"""
	domain
	"""
	min by userSid
	"""
	userSid
	"""
	min by firstName
	"""
	firstName
	"""
	min by lastName
	"""
	lastName
	"""
	min by mail
	"""
	mail
}
enum adapterUsers_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by fetchTime
	"""
	fetchTime
	"""
	sum by lastSeen
	"""
	lastSeen
}
"""
Boolean filter expression for Adapter
"""
input adapter_bool_exp {
	"""
	filter by id
	"""
	id: StringComparator
	"""
	filter by name
	"""
	name: StringComparator
	"""
	filter by properties
	"""
	properties: StringArrayComparator
	AND: [adapter_bool_exp!]
	OR: [adapter_bool_exp!]
	NOT: [adapter_bool_exp!]
}
"""
Boolean filter expression for AdapterData
"""
input adapter_data_bool_exp {
	"""
	filter by adCn
	"""
	adCn: StringComparator
	"""
	filter by adSid
	"""
	adSid: StringComparator
	"""
	filter by adGuid
	"""
	adGuid: StringComparator
	"""
	filter by adName
	"""
	adName: StringComparator
	"""
	filter by adSAMAccountName
	"""
	adSAMAccountName: StringComparator
	"""
	filter by adUserPrincipalName
	"""
	adUserPrincipalName: StringComparator
	"""
	filter by adDisplayName
	"""
	adDisplayName: StringComparator
	"""
	filter by adDistinguishedName
	"""
	adDistinguishedName: StringComparator
	"""
	filter by adCanonicalName
	"""
	adCanonicalName: StringComparator
	"""
	filter by adAccountExpires
	"""
	adAccountExpires: EpochComparator
	"""
	filter by adObjectClass
	"""
	adObjectClass: StringArrayComparator
	"""
	filter by adObjectCategory
	"""
	adObjectCategory: StringComparator
	"""
	filter by adOrganizationalUnit
	"""
	adOrganizationalUnit: StringArrayComparator
	"""
	filter by ad_bad_pwd_count
	"""
	ad_bad_pwd_count: IntComparator
	"""
	filter by adManagedBy
	"""
	adManagedBy: StringComparator
	"""
	filter by adPrimaryGroupId
	"""
	adPrimaryGroupId: IntComparator
	"""
	filter by adPrimaryGroupDn
	"""
	adPrimaryGroupDn: StringComparator
	"""
	filter by adMemberOf
	"""
	adMemberOf: StringArrayComparator
	"""
	filter by adMemberOfFull
	"""
	adMemberOfFull: StringArrayComparator
	"""
	filter by adUsnChanged
	"""
	adUsnChanged: IntComparator
	"""
	filter by adUsnCreated
	"""
	adUsnCreated: IntComparator
	"""
	filter by adIsCriticalSystemObject
	"""
	adIsCriticalSystemObject: BooleanComparator
	"""
	filter by adMsdsAllowedToDelegateTo
	"""
	adMsdsAllowedToDelegateTo: StringArrayComparator
	"""
	filter by adPwdMustChange
	"""
	adPwdMustChange: BooleanComparator
	"""
	filter by adMsdsResultantPso
	"""
	adMsdsResultantPso: StringComparator
	"""
	filter by isSafe
	"""
	isSafe: StringComparator
	"""
	filter by deviceState
	"""
	deviceState: CylanceDeviceStateComparator
	"""
	filter by policyId
	"""
	policyId: StringComparator
	"""
	filter by policyName
	"""
	policyName: StringComparator
	"""
	filter by policiesDetails
	"""
	policiesDetails: StringArrayComparator
	"""
	filter by tenantTag
	"""
	tenantTag: StringComparator
	"""
	filter by zoneNames
	"""
	zoneNames: StringArrayComparator
	"""
	filter by agentVersion
	"""
	agentVersion: StringComparator
	"""
	filter by externalIp
	"""
	externalIp: StringComparator
	"""
	filter by groups
	"""
	groups: cs_group_bool_exp
	"""
	filter by preventionPolicy
	"""
	preventionPolicy: cs_policy_bool_exp
	"""
	filter by sensorUpdatePolicy
	"""
	sensorUpdatePolicy: cs_group_bool_exp
	"""
	filter by csAgentVersion
	"""
	csAgentVersion: StringComparator
	AND: [adapter_data_bool_exp!]
	OR: [adapter_data_bool_exp!]
	NOT: [adapter_data_bool_exp!]
}
"""
Boolean filter expression for AdapterDeviceAdmin
"""
input adapter_device_admin_bool_exp {
	"""
	filter by name
	"""
	name: StringComparator
	"""
	filter by type
	"""
	type: AdminTypeComparator
	AND: [adapter_device_admin_bool_exp!]
	OR: [adapter_device_admin_bool_exp!]
	NOT: [adapter_device_admin_bool_exp!]
}
"""
Order for AdapterDeviceAdmin
"""
enum adapter_device_admin_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
}
"""
Boolean filter expression for AdapterDevice
"""
input adapter_device_bool_exp {
	"""
	filter by id
	"""
	id: UUIDComparator
	"""
	filter by fetchCycle
	"""
	fetchCycle: IntComparator
	"""
	filter by adapterId
	"""
	adapterId: StringComparator
	"""
	filter by adapter
	"""
	adapter: adapter_bool_exp
	"""
	filter by adapterName
	"""
	adapterName: StringComparator
	"""
	filter by deviceId
	"""
	deviceId: UUIDComparator
	"""
	filter by adapterData
	"""
	adapterData: adapter_data_bool_exp
	"""
	filter by fetchTime
	"""
	fetchTime: EpochComparator
	"""
	filter by hostname
	"""
	hostname: StringComparator
	"""
	filter by name
	"""
	name: StringComparator
	"""
	filter by lastSeen
	"""
	lastSeen: EpochComparator
	"""
	filter by osId
	"""
	osId: UUIDComparator
	"""
	filter by os
	"""
	os: operating_system_bool_exp
	"""
	filter by prettyId
	"""
	prettyId: StringComparator
	"""
	filter by tags
	"""
	tags: tag_bool_exp
	"""
	filter by interfaces
	"""
	interfaces: network_interface_bool_exp
	"""
	filter by lastUsedUsers
	"""
	lastUsedUsers: StringArrayComparator
	"""
	filter by domain
	"""
	domain: StringComparator
	"""
	filter by partOfDomain
	"""
	partOfDomain: BooleanComparator
	"""
	filter by deviceUsers
	"""
	deviceUsers: adapter_device_user_bool_exp
	"""
	filter by localAdmins
	"""
	localAdmins: adapter_device_admin_bool_exp
	"""
	filter by firewallRules
	"""
	firewallRules: firewall_rule_bool_exp
	"""
	filter by installedSoftware
	"""
	installedSoftware: installed_software_bool_exp
	"""
	filter by agentVersion
	"""
	agentVersion: StringComparator
	"""
	filter by agentStatus
	"""
	agentStatus: StringComparator
	"""
	filter by agentName
	"""
	agentName: StringComparator
	"""
	filter by model
	"""
	model: StringComparator
	"""
	filter by manufacturer
	"""
	manufacturer: StringComparator
	"""
	filter by serial
	"""
	serial: StringComparator
	"""
	filter by family
	"""
	family: StringComparator
	"""
	filter by biosVersion
	"""
	biosVersion: StringComparator
	"""
	filter by biosSerial
	"""
	biosSerial: StringComparator
	AND: [adapter_device_bool_exp!]
	OR: [adapter_device_bool_exp!]
	NOT: [adapter_device_bool_exp!]
}
"""
Order for AdapterDevice
"""
enum adapter_device_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterId in an ascending order
	"""
	adapterId_ASC
	"""
	Order by adapterId in a descending order
	"""
	adapterId_DESC
	"""
	Order by adapterName in an ascending order
	"""
	adapterName_ASC
	"""
	Order by adapterName in a descending order
	"""
	adapterName_DESC
	"""
	Order by fetchTime in an ascending order
	"""
	fetchTime_ASC
	"""
	Order by fetchTime in a descending order
	"""
	fetchTime_DESC
	"""
	Order by hostname in an ascending order
	"""
	hostname_ASC
	"""
	Order by hostname in a descending order
	"""
	hostname_DESC
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
	"""
	Order by prettyId in an ascending order
	"""
	prettyId_ASC
	"""
	Order by prettyId in a descending order
	"""
	prettyId_DESC
	"""
	Order by domain in an ascending order
	"""
	domain_ASC
	"""
	Order by domain in a descending order
	"""
	domain_DESC
	"""
	Order by agentVersion in an ascending order
	"""
	agentVersion_ASC
	"""
	Order by agentVersion in a descending order
	"""
	agentVersion_DESC
	"""
	Order by agentStatus in an ascending order
	"""
	agentStatus_ASC
	"""
	Order by agentStatus in a descending order
	"""
	agentStatus_DESC
	"""
	Order by agentName in an ascending order
	"""
	agentName_ASC
	"""
	Order by agentName in a descending order
	"""
	agentName_DESC
	"""
	Order by model in an ascending order
	"""
	model_ASC
	"""
	Order by model in a descending order
	"""
	model_DESC
	"""
	Order by manufacturer in an ascending order
	"""
	manufacturer_ASC
	"""
	Order by manufacturer in a descending order
	"""
	manufacturer_DESC
	"""
	Order by serial in an ascending order
	"""
	serial_ASC
	"""
	Order by serial in a descending order
	"""
	serial_DESC
	"""
	Order by family in an ascending order
	"""
	family_ASC
	"""
	Order by family in a descending order
	"""
	family_DESC
	"""
	Order by biosVersion in an ascending order
	"""
	biosVersion_ASC
	"""
	Order by biosVersion in a descending order
	"""
	biosVersion_DESC
	"""
	Order by biosSerial in an ascending order
	"""
	biosSerial_ASC
	"""
	Order by biosSerial in a descending order
	"""
	biosSerial_DESC
}
"""
Boolean filter expression for AdapterDeviceUser
"""
input adapter_device_user_bool_exp {
	"""
	filter by deviceId
	"""
	deviceId: UUIDComparator
	"""
	filter by sid
	"""
	sid: StringComparator
	"""
	filter by username
	"""
	username: StringComparator
	"""
	filter by lastUseDate
	"""
	lastUseDate: EpochComparator
	"""
	filter by isLocal
	"""
	isLocal: BooleanComparator
	"""
	filter by isDisabled
	"""
	isDisabled: BooleanComparator
	"""
	filter by isAdmin
	"""
	isAdmin: BooleanComparator
	"""
	filter by userDepartment
	"""
	userDepartment: BooleanComparator
	"""
	filter by passwordMaxAge
	"""
	passwordMaxAge: IntComparator
	"""
	filter by interpreter
	"""
	interpreter: StringComparator
	AND: [adapter_device_user_bool_exp!]
	OR: [adapter_device_user_bool_exp!]
	NOT: [adapter_device_user_bool_exp!]
}
"""
Order for AdapterDeviceUser
"""
enum adapter_device_user_order_by {
	"""
	Order by sid in an ascending order
	"""
	sid_ASC
	"""
	Order by sid in a descending order
	"""
	sid_DESC
	"""
	Order by username in an ascending order
	"""
	username_ASC
	"""
	Order by username in a descending order
	"""
	username_DESC
	"""
	Order by lastUseDate in an ascending order
	"""
	lastUseDate_ASC
	"""
	Order by lastUseDate in a descending order
	"""
	lastUseDate_DESC
	"""
	Order by passwordMaxAge in an ascending order
	"""
	passwordMaxAge_ASC
	"""
	Order by passwordMaxAge in a descending order
	"""
	passwordMaxAge_DESC
	"""
	Order by interpreter in an ascending order
	"""
	interpreter_ASC
	"""
	Order by interpreter in a descending order
	"""
	interpreter_DESC
}
"""
Order for Adapter
"""
enum adapter_order_by {
	"""
	Order by id in an ascending order
	"""
	id_ASC
	"""
	Order by id in a descending order
	"""
	id_DESC
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
}
"""
Boolean filter expression for AdapterUser
"""
input adapter_user_bool_exp {
	"""
	filter by id
	"""
	id: UUIDComparator
	"""
	filter by fetchCycle
	"""
	fetchCycle: IntComparator
	"""
	filter by adapterId
	"""
	adapterId: StringComparator
	"""
	filter by adapter
	"""
	adapter: adapter_bool_exp
	"""
	filter by adapterName
	"""
	adapterName: StringComparator
	"""
	filter by userId
	"""
	userId: UUIDComparator
	"""
	filter by adapterData
	"""
	adapterData: adapter_data_bool_exp
	"""
	filter by fetchTime
	"""
	fetchTime: EpochComparator
	"""
	filter by lastSeen
	"""
	lastSeen: EpochComparator
	"""
	filter by username
	"""
	username: StringComparator
	"""
	filter by displayName
	"""
	displayName: StringComparator
	"""
	filter by description
	"""
	description: StringComparator
	"""
	filter by domain
	"""
	domain: StringComparator
	"""
	filter by userSid
	"""
	userSid: StringComparator
	"""
	filter by firstName
	"""
	firstName: StringComparator
	"""
	filter by lastName
	"""
	lastName: StringComparator
	"""
	filter by mail
	"""
	mail: StringComparator
	"""
	filter by admin
	"""
	admin: BooleanComparator
	"""
	filter by local
	"""
	local: BooleanComparator
	"""
	filter by delegatedAdmin
	"""
	delegatedAdmin: BooleanComparator
	"""
	filter by mfaEnforced
	"""
	mfaEnforced: BooleanComparator
	"""
	filter by mfaEnrolled
	"""
	mfaEnrolled: BooleanComparator
	"""
	filter by suspended
	"""
	suspended: BooleanComparator
	"""
	filter by locked
	"""
	locked: BooleanComparator
	"""
	filter by disabled
	"""
	disabled: BooleanComparator
	AND: [adapter_user_bool_exp!]
	OR: [adapter_user_bool_exp!]
	NOT: [adapter_user_bool_exp!]
}
"""
Order for AdapterUser
"""
enum adapter_user_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterId in an ascending order
	"""
	adapterId_ASC
	"""
	Order by adapterId in a descending order
	"""
	adapterId_DESC
	"""
	Order by adapterName in an ascending order
	"""
	adapterName_ASC
	"""
	Order by adapterName in a descending order
	"""
	adapterName_DESC
	"""
	Order by fetchTime in an ascending order
	"""
	fetchTime_ASC
	"""
	Order by fetchTime in a descending order
	"""
	fetchTime_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
	"""
	Order by username in an ascending order
	"""
	username_ASC
	"""
	Order by username in a descending order
	"""
	username_DESC
	"""
	Order by displayName in an ascending order
	"""
	displayName_ASC
	"""
	Order by displayName in a descending order
	"""
	displayName_DESC
	"""
	Order by description in an ascending order
	"""
	description_ASC
	"""
	Order by description in a descending order
	"""
	description_DESC
	"""
	Order by domain in an ascending order
	"""
	domain_ASC
	"""
	Order by domain in a descending order
	"""
	domain_DESC
	"""
	Order by userSid in an ascending order
	"""
	userSid_ASC
	"""
	Order by userSid in a descending order
	"""
	userSid_DESC
	"""
	Order by firstName in an ascending order
	"""
	firstName_ASC
	"""
	Order by firstName in a descending order
	"""
	firstName_DESC
	"""
	Order by lastName in an ascending order
	"""
	lastName_ASC
	"""
	Order by lastName in a descending order
	"""
	lastName_DESC
	"""
	Order by mail in an ascending order
	"""
	mail_ASC
	"""
	Order by mail in a descending order
	"""
	mail_DESC
}
type csGroup @generateInputs(where: "cs_group_bool_exp", orderBy: "cs_group_order_by") {
	id: String
	name: String
	createdBy: String
	createdTimestamp: Epoch
	description: String
	groupType: String
	modifiedBy: String
	modifiedTime: Epoch
}
type csPolicy @generateInputs(where: "cs_policy_bool_exp", orderBy: "cs_policy_order_by") {
	name: String
	description: String
	platformName: String
	groups("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [csGroup]
	enabled: Boolean
	createdBy: String
	createdTime: Epoch
	preventionSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_prevention_settings_bool_exp): [csPreventionSettings]
	sensorUpdateSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_sensor_update_settings_bool_exp): [csSensorUpdateSettings]
	"""
	Returns aggregate of groups
	"""
	groups_aggregate("""
	group by columns
	"""
	groupBy: [groups_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [groups_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [groupsAggregate!]
	"""
	Returns aggregate of preventionSettings
	"""
	preventionSettings_aggregate("""
	group by columns
	"""
	groupBy: [preventionSettings_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [preventionSettings_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_prevention_settings_bool_exp): [preventionSettingsAggregate!]
	"""
	Returns aggregate of sensorUpdateSettings
	"""
	sensorUpdateSettings_aggregate("""
	group by columns
	"""
	groupBy: [sensorUpdateSettings_aggregate_columns!], """
	distinct on columns
	"""
	distinctOn: [sensorUpdateSettings_aggregate_columns!], """
	order by aggregation columns
	"""
	orderBy: [AggregateOrdering!], """
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_sensor_update_settings_bool_exp): [sensorUpdateSettingsAggregate!]
}
type csPolicySettings @generateInputs(where: "cs_policy_settings_bool_exp", orderBy: "cs_policy_settings_order_by") {
	enabled: Boolean
}
type csPreventionSettings @generateInputs(where: "cs_prevention_settings_bool_exp", orderBy: "cs_prevention_settings_order_by") {
	name: String
	settings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_policy_settings_bool_exp): [csPolicySettings]
}
type csSensorUpdateSettings @generateInputs(where: "cs_sensor_update_settings_bool_exp", orderBy: "cs_sensor_update_settings_order_by") {
	build: String
}
"""
Boolean filter expression for csGroup
"""
input cs_group_bool_exp {
	"""
	filter by id
	"""
	id: StringComparator
	"""
	filter by name
	"""
	name: StringComparator
	"""
	filter by createdBy
	"""
	createdBy: StringComparator
	"""
	filter by createdTimestamp
	"""
	createdTimestamp: EpochComparator
	"""
	filter by description
	"""
	description: StringComparator
	"""
	filter by groupType
	"""
	groupType: StringComparator
	"""
	filter by modifiedBy
	"""
	modifiedBy: StringComparator
	"""
	filter by modifiedTime
	"""
	modifiedTime: EpochComparator
	AND: [cs_group_bool_exp!]
	OR: [cs_group_bool_exp!]
	NOT: [cs_group_bool_exp!]
}
"""
Order for csGroup
"""
enum cs_group_order_by {
	"""
	Order by id in an ascending order
	"""
	id_ASC
	"""
	Order by id in a descending order
	"""
	id_DESC
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by createdBy in an ascending order
	"""
	createdBy_ASC
	"""
	Order by createdBy in a descending order
	"""
	createdBy_DESC
	"""
	Order by createdTimestamp in an ascending order
	"""
	createdTimestamp_ASC
	"""
	Order by createdTimestamp in a descending order
	"""
	createdTimestamp_DESC
	"""
	Order by description in an ascending order
	"""
	description_ASC
	"""
	Order by description in a descending order
	"""
	description_DESC
	"""
	Order by groupType in an ascending order
	"""
	groupType_ASC
	"""
	Order by groupType in a descending order
	"""
	groupType_DESC
	"""
	Order by modifiedBy in an ascending order
	"""
	modifiedBy_ASC
	"""
	Order by modifiedBy in a descending order
	"""
	modifiedBy_DESC
	"""
	Order by modifiedTime in an ascending order
	"""
	modifiedTime_ASC
	"""
	Order by modifiedTime in a descending order
	"""
	modifiedTime_DESC
}
"""
Boolean filter expression for csPolicy
"""
input cs_policy_bool_exp {
	"""
	filter by name
	"""
	name: StringComparator
	"""
	filter by description
	"""
	description: StringComparator
	"""
	filter by platformName
	"""
	platformName: StringComparator
	"""
	filter by groups
	"""
	groups: cs_group_bool_exp
	"""
	filter by enabled
	"""
	enabled: BooleanComparator
	"""
	filter by createdBy
	"""
	createdBy: StringComparator
	"""
	filter by createdTime
	"""
	createdTime: EpochComparator
	"""
	filter by preventionSettings
	"""
	preventionSettings: cs_prevention_settings_bool_exp
	"""
	filter by sensorUpdateSettings
	"""
	sensorUpdateSettings: cs_sensor_update_settings_bool_exp
	AND: [cs_policy_bool_exp!]
	OR: [cs_policy_bool_exp!]
	NOT: [cs_policy_bool_exp!]
}
"""
Order for csPolicy
"""
enum cs_policy_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by description in an ascending order
	"""
	description_ASC
	"""
	Order by description in a descending order
	"""
	description_DESC
	"""
	Order by platformName in an ascending order
	"""
	platformName_ASC
	"""
	Order by platformName in a descending order
	"""
	platformName_DESC
	"""
	Order by createdBy in an ascending order
	"""
	createdBy_ASC
	"""
	Order by createdBy in a descending order
	"""
	createdBy_DESC
	"""
	Order by createdTime in an ascending order
	"""
	createdTime_ASC
	"""
	Order by createdTime in a descending order
	"""
	createdTime_DESC
}
"""
Boolean filter expression for csPolicySettings
"""
input cs_policy_settings_bool_exp {
	"""
	filter by enabled
	"""
	enabled: BooleanComparator
	AND: [cs_policy_settings_bool_exp!]
	OR: [cs_policy_settings_bool_exp!]
	NOT: [cs_policy_settings_bool_exp!]
}
"""
Boolean filter expression for csPreventionSettings
"""
input cs_prevention_settings_bool_exp {
	"""
	filter by name
	"""
	name: StringComparator
	"""
	filter by settings
	"""
	settings: cs_policy_settings_bool_exp
	AND: [cs_prevention_settings_bool_exp!]
	OR: [cs_prevention_settings_bool_exp!]
	NOT: [cs_prevention_settings_bool_exp!]
}
"""
Order for csPreventionSettings
"""
enum cs_prevention_settings_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
}
"""
Boolean filter expression for csSensorUpdateSettings
"""
input cs_sensor_update_settings_bool_exp {
	"""
	filter by build
	"""
	build: StringComparator
	AND: [cs_sensor_update_settings_bool_exp!]
	OR: [cs_sensor_update_settings_bool_exp!]
	NOT: [cs_sensor_update_settings_bool_exp!]
}
"""
Order for csSensorUpdateSettings
"""
enum cs_sensor_update_settings_order_by {
	"""
	Order by build in an ascending order
	"""
	build_ASC
	"""
	Order by build in a descending order
	"""
	build_DESC
}
"""
Boolean filter expression for Device
"""
input device_bool_exp {
	"""
	filter by id
	"""
	id: UUIDComparator
	"""
	filter by fetchCycle
	"""
	fetchCycle: IntComparator
	"""
	filter by adapterCount
	"""
	adapterCount: IntComparator
	"""
	filter by adapterNames
	"""
	adapterNames: StringArrayComparator
	"""
	filter by hostnames
	"""
	hostnames: StringArrayComparator
	"""
	filter by lastSeen
	"""
	lastSeen: EpochComparator
	"""
	filter by adapterDevices
	"""
	adapterDevices: adapter_device_bool_exp
	"""
	filter by interfaces
	"""
	interfaces: network_interface_bool_exp
	"""
	filter by tags
	"""
	tags: tag_bool_exp
	AND: [device_bool_exp!]
	OR: [device_bool_exp!]
	NOT: [device_bool_exp!]
}
"""
Order for Device
"""
enum device_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterCount in an ascending order
	"""
	adapterCount_ASC
	"""
	Order by adapterCount in a descending order
	"""
	adapterCount_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
}
type devicesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [devices_aggregate_max_columns!]!): Map
	devices("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: device_bool_exp): [Device]
}
enum devices_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by adapterCount
	"""
	adapterCount
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterCount
	"""
	adapterCount
	"""
	groupBy by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterCount
	"""
	adapterCount
	"""
	max by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterCount
	"""
	adapterCount
	"""
	min by lastSeen
	"""
	lastSeen
}
enum devices_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by adapterCount
	"""
	adapterCount
	"""
	sum by lastSeen
	"""
	lastSeen
}
type firewallRulesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [firewallRules_aggregate_max_columns!]!): Map
	"""
	Firewall rules defined on this adapter device
	"""
	firewallRules("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: firewall_rule_bool_exp): [FirewallRule] @relation(name: "adapter_device_firewall_rules", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "firewall_rules", joinOn: ["name"])
}
enum firewallRules_aggregate_avg_columns {
	"""
	avg by srcPort
	"""
	srcPort
	"""
	avg by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_columns {
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by source
	"""
	source
	"""
	groupBy by target
	"""
	target
	"""
	groupBy by protocol
	"""
	protocol
	"""
	groupBy by srcPort
	"""
	srcPort
	"""
	groupBy by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_max_columns {
	"""
	max by name
	"""
	name
	"""
	max by source
	"""
	source
	"""
	max by target
	"""
	target
	"""
	max by protocol
	"""
	protocol
	"""
	max by srcPort
	"""
	srcPort
	"""
	max by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_min_columns {
	"""
	min by name
	"""
	name
	"""
	min by source
	"""
	source
	"""
	min by target
	"""
	target
	"""
	min by protocol
	"""
	protocol
	"""
	min by srcPort
	"""
	srcPort
	"""
	min by dstPort
	"""
	dstPort
}
enum firewallRules_aggregate_sum_columns {
	"""
	sum by srcPort
	"""
	srcPort
	"""
	sum by dstPort
	"""
	dstPort
}
"""
Boolean filter expression for FirewallRule
"""
input firewall_rule_bool_exp {
	"""
	filter by name
	"""
	name: StringComparator
	"""
	filter by source
	"""
	source: StringComparator
	"""
	filter by type
	"""
	type: AccessTypeComparator
	"""
	filter by direction
	"""
	direction: DirectionComparator
	"""
	filter by target
	"""
	target: StringComparator
	"""
	filter by protocol
	"""
	protocol: StringComparator
	"""
	filter by srcPort
	"""
	srcPort: IntComparator
	"""
	filter by dstPort
	"""
	dstPort: IntComparator
	AND: [firewall_rule_bool_exp!]
	OR: [firewall_rule_bool_exp!]
	NOT: [firewall_rule_bool_exp!]
}
"""
Order for FirewallRule
"""
enum firewall_rule_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by source in an ascending order
	"""
	source_ASC
	"""
	Order by source in a descending order
	"""
	source_DESC
	"""
	Order by target in an ascending order
	"""
	target_ASC
	"""
	Order by target in a descending order
	"""
	target_DESC
	"""
	Order by protocol in an ascending order
	"""
	protocol_ASC
	"""
	Order by protocol in a descending order
	"""
	protocol_DESC
	"""
	Order by srcPort in an ascending order
	"""
	srcPort_ASC
	"""
	Order by srcPort in a descending order
	"""
	srcPort_DESC
	"""
	Order by dstPort in an ascending order
	"""
	dstPort_ASC
	"""
	Order by dstPort in a descending order
	"""
	dstPort_DESC
}
"""
Boolean filter expression for GceTags
"""
input gce_tags_bool_exp {
	"""
	filter by gceKey
	"""
	gceKey: StringComparator
	"""
	filter by gceValue
	"""
	gceValue: StringComparator
	AND: [gce_tags_bool_exp!]
	OR: [gce_tags_bool_exp!]
	NOT: [gce_tags_bool_exp!]
}
"""
Order for GceTags
"""
enum gce_tags_order_by {
	"""
	Order by gceKey in an ascending order
	"""
	gceKey_ASC
	"""
	Order by gceKey in a descending order
	"""
	gceKey_DESC
	"""
	Order by gceValue in an ascending order
	"""
	gceValue_ASC
	"""
	Order by gceValue in a descending order
	"""
	gceValue_DESC
}
type groupsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [groups_aggregate_max_columns!]!): Map
	groups("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_group_bool_exp): [csGroup]
}
enum groups_aggregate_avg_columns {
	"""
	avg by createdTimestamp
	"""
	createdTimestamp
	"""
	avg by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by createdBy
	"""
	createdBy
	"""
	groupBy by createdTimestamp
	"""
	createdTimestamp
	"""
	groupBy by description
	"""
	description
	"""
	groupBy by groupType
	"""
	groupType
	"""
	groupBy by modifiedBy
	"""
	modifiedBy
	"""
	groupBy by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by name
	"""
	name
	"""
	max by createdBy
	"""
	createdBy
	"""
	max by createdTimestamp
	"""
	createdTimestamp
	"""
	max by description
	"""
	description
	"""
	max by groupType
	"""
	groupType
	"""
	max by modifiedBy
	"""
	modifiedBy
	"""
	max by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by name
	"""
	name
	"""
	min by createdBy
	"""
	createdBy
	"""
	min by createdTimestamp
	"""
	createdTimestamp
	"""
	min by description
	"""
	description
	"""
	min by groupType
	"""
	groupType
	"""
	min by modifiedBy
	"""
	modifiedBy
	"""
	min by modifiedTime
	"""
	modifiedTime
}
enum groups_aggregate_sum_columns {
	"""
	sum by createdTimestamp
	"""
	createdTimestamp
	"""
	sum by modifiedTime
	"""
	modifiedTime
}
type installedSoftwareAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [installedSoftware_aggregate_max_columns!]!): Map
	"""
	Software installed on this device
	"""
	installedSoftware("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: installed_software_bool_exp): [InstalledSoftware] @relation(name: "adapter_device_installed_software", fkName: ["id","fetch_cycle"], relationFkName: ["adapter_device_id","fetch_cycle"], relType: MANY_TO_MANY, manyToManyTableName: "installed_software", joinOn: ["name","version"])
}
enum installedSoftware_aggregate_avg_columns {
	"""
	avg by cveCount
	"""
	cveCount
}
enum installedSoftware_aggregate_columns {
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by version
	"""
	version
	"""
	groupBy by description
	"""
	description
	"""
	groupBy by vendor
	"""
	vendor
	"""
	groupBy by publisher
	"""
	publisher
	"""
	groupBy by cveCount
	"""
	cveCount
	"""
	groupBy by swLicense
	"""
	swLicense
	"""
	groupBy by path
	"""
	path
}
enum installedSoftware_aggregate_max_columns {
	"""
	max by name
	"""
	name
	"""
	max by version
	"""
	version
	"""
	max by description
	"""
	description
	"""
	max by vendor
	"""
	vendor
	"""
	max by publisher
	"""
	publisher
	"""
	max by cveCount
	"""
	cveCount
	"""
	max by swLicense
	"""
	swLicense
	"""
	max by path
	"""
	path
}
enum installedSoftware_aggregate_min_columns {
	"""
	min by name
	"""
	name
	"""
	min by version
	"""
	version
	"""
	min by description
	"""
	description
	"""
	min by vendor
	"""
	vendor
	"""
	min by publisher
	"""
	publisher
	"""
	min by cveCount
	"""
	cveCount
	"""
	min by swLicense
	"""
	swLicense
	"""
	min by path
	"""
	path
}
enum installedSoftware_aggregate_sum_columns {
	"""
	sum by cveCount
	"""
	cveCount
}
"""
Boolean filter expression for InstalledSoftware
"""
input installed_software_bool_exp {
	"""
	filter by name
	"""
	name: StringComparator
	"""
	filter by version
	"""
	version: StringComparator
	"""
	filter by architecture
	"""
	architecture: ArchitectureComparator
	"""
	filter by description
	"""
	description: StringComparator
	"""
	filter by vendor
	"""
	vendor: StringComparator
	"""
	filter by publisher
	"""
	publisher: StringComparator
	"""
	filter by cveCount
	"""
	cveCount: IntComparator
	"""
	filter by swLicense
	"""
	swLicense: StringComparator
	"""
	filter by path
	"""
	path: StringComparator
	AND: [installed_software_bool_exp!]
	OR: [installed_software_bool_exp!]
	NOT: [installed_software_bool_exp!]
}
"""
Order for InstalledSoftware
"""
enum installed_software_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by version in an ascending order
	"""
	version_ASC
	"""
	Order by version in a descending order
	"""
	version_DESC
	"""
	Order by description in an ascending order
	"""
	description_ASC
	"""
	Order by description in a descending order
	"""
	description_DESC
	"""
	Order by vendor in an ascending order
	"""
	vendor_ASC
	"""
	Order by vendor in a descending order
	"""
	vendor_DESC
	"""
	Order by publisher in an ascending order
	"""
	publisher_ASC
	"""
	Order by publisher in a descending order
	"""
	publisher_DESC
	"""
	Order by cveCount in an ascending order
	"""
	cveCount_ASC
	"""
	Order by cveCount in a descending order
	"""
	cveCount_DESC
	"""
	Order by swLicense in an ascending order
	"""
	swLicense_ASC
	"""
	Order by swLicense in a descending order
	"""
	swLicense_DESC
	"""
	Order by path in an ascending order
	"""
	path_ASC
	"""
	Order by path in a descending order
	"""
	path_DESC
}
type interfacesAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [interfaces_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [interfaces_aggregate_max_columns!]!): Map
	interfaces("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_bool_exp): [NetworkInterface] @relation(name: "network_interfaces", fkName: ["id","fetch_cycle"], relationFkName: ["deviceId","fetch_cycle"], relType: ONE_TO_MANY)
}
enum interfaces_aggregate_columns {
	"""
	groupBy by deviceId
	"""
	deviceId
	"""
	groupBy by macAddr
	"""
	macAddr
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by manufacturer
	"""
	manufacturer
	"""
	groupBy by operationalStatus
	"""
	operationalStatus
	"""
	groupBy by adminStatus
	"""
	adminStatus
	"""
	groupBy by portType
	"""
	portType
	"""
	groupBy by mtu
	"""
	mtu
	"""
	groupBy by gateway
	"""
	gateway
	"""
	groupBy by port
	"""
	port
}
enum interfaces_aggregate_max_columns {
	"""
	max by deviceId
	"""
	deviceId
	"""
	max by macAddr
	"""
	macAddr
	"""
	max by name
	"""
	name
	"""
	max by manufacturer
	"""
	manufacturer
	"""
	max by operationalStatus
	"""
	operationalStatus
	"""
	max by adminStatus
	"""
	adminStatus
	"""
	max by portType
	"""
	portType
	"""
	max by mtu
	"""
	mtu
	"""
	max by gateway
	"""
	gateway
	"""
	max by port
	"""
	port
}
enum interfaces_aggregate_min_columns {
	"""
	min by deviceId
	"""
	deviceId
	"""
	min by macAddr
	"""
	macAddr
	"""
	min by name
	"""
	name
	"""
	min by manufacturer
	"""
	manufacturer
	"""
	min by operationalStatus
	"""
	operationalStatus
	"""
	min by adminStatus
	"""
	adminStatus
	"""
	min by portType
	"""
	portType
	"""
	min by mtu
	"""
	mtu
	"""
	min by gateway
	"""
	gateway
	"""
	min by port
	"""
	port
}
"""
Boolean filter expression for NetworkInterface
"""
input network_interface_bool_exp {
	"""
	filter by deviceId
	"""
	deviceId: UUIDComparator
	"""
	filter by macAddr
	"""
	macAddr: MacComparator
	"""
	filter by ipAddrs
	"""
	ipAddrs: IPArrayComparator
	"""
	filter by name
	"""
	name: StringComparator
	"""
	filter by manufacturer
	"""
	manufacturer: StringComparator
	"""
	filter by operationalStatus
	"""
	operationalStatus: StringComparator
	"""
	filter by adminStatus
	"""
	adminStatus: StringComparator
	"""
	filter by portType
	"""
	portType: StringComparator
	"""
	filter by mtu
	"""
	mtu: StringComparator
	"""
	filter by gateway
	"""
	gateway: IPComparator
	"""
	filter by port
	"""
	port: StringComparator
	"""
	filter by vlans
	"""
	vlans: network_interface_vlan_bool_exp
	AND: [network_interface_bool_exp!]
	OR: [network_interface_bool_exp!]
	NOT: [network_interface_bool_exp!]
}
"""
Order for NetworkInterface
"""
enum network_interface_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by manufacturer in an ascending order
	"""
	manufacturer_ASC
	"""
	Order by manufacturer in a descending order
	"""
	manufacturer_DESC
	"""
	Order by operationalStatus in an ascending order
	"""
	operationalStatus_ASC
	"""
	Order by operationalStatus in a descending order
	"""
	operationalStatus_DESC
	"""
	Order by adminStatus in an ascending order
	"""
	adminStatus_ASC
	"""
	Order by adminStatus in a descending order
	"""
	adminStatus_DESC
	"""
	Order by portType in an ascending order
	"""
	portType_ASC
	"""
	Order by portType in a descending order
	"""
	portType_DESC
	"""
	Order by mtu in an ascending order
	"""
	mtu_ASC
	"""
	Order by mtu in a descending order
	"""
	mtu_DESC
	"""
	Order by port in an ascending order
	"""
	port_ASC
	"""
	Order by port in a descending order
	"""
	port_DESC
}
"""
Boolean filter expression for NetworkInterfaceVlan
"""
input network_interface_vlan_bool_exp {
	"""
	filter by macAddr
	"""
	macAddr: MacComparator
	"""
	filter by name
	"""
	name: StringComparator
	"""
	filter by tagId
	"""
	tagId: IntComparator
	"""
	filter by tagged
	"""
	tagged: BooleanComparator
	AND: [network_interface_vlan_bool_exp!]
	OR: [network_interface_vlan_bool_exp!]
	NOT: [network_interface_vlan_bool_exp!]
}
"""
Order for NetworkInterfaceVlan
"""
enum network_interface_vlan_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by tagId in an ascending order
	"""
	tagId_ASC
	"""
	Order by tagId in a descending order
	"""
	tagId_DESC
}
"""
Boolean filter expression for OperatingSystem
"""
input operating_system_bool_exp {
	"""
	filter by id
	"""
	id: UUIDComparator
	"""
	filter by type
	"""
	type: StringComparator
	"""
	filter by distribution
	"""
	distribution: StringComparator
	"""
	filter by architecture
	"""
	architecture: IntComparator
	"""
	filter by servicePack
	"""
	servicePack: StringComparator
	"""
	filter by installDate
	"""
	installDate: EpochComparator
	"""
	filter by kernelVersion
	"""
	kernelVersion: StringComparator
	"""
	filter by codeName
	"""
	codeName: StringComparator
	"""
	filter by major
	"""
	major: IntComparator
	"""
	filter by minor
	"""
	minor: IntComparator
	"""
	filter by build
	"""
	build: StringComparator
	"""
	filter by rawName
	"""
	rawName: StringComparator
	AND: [operating_system_bool_exp!]
	OR: [operating_system_bool_exp!]
	NOT: [operating_system_bool_exp!]
}
"""
Order for OperatingSystem
"""
enum operating_system_order_by {
	"""
	Order by type in an ascending order
	"""
	type_ASC
	"""
	Order by type in a descending order
	"""
	type_DESC
	"""
	Order by distribution in an ascending order
	"""
	distribution_ASC
	"""
	Order by distribution in a descending order
	"""
	distribution_DESC
	"""
	Order by architecture in an ascending order
	"""
	architecture_ASC
	"""
	Order by architecture in a descending order
	"""
	architecture_DESC
	"""
	Order by servicePack in an ascending order
	"""
	servicePack_ASC
	"""
	Order by servicePack in a descending order
	"""
	servicePack_DESC
	"""
	Order by installDate in an ascending order
	"""
	installDate_ASC
	"""
	Order by installDate in a descending order
	"""
	installDate_DESC
	"""
	Order by kernelVersion in an ascending order
	"""
	kernelVersion_ASC
	"""
	Order by kernelVersion in a descending order
	"""
	kernelVersion_DESC
	"""
	Order by codeName in an ascending order
	"""
	codeName_ASC
	"""
	Order by codeName in a descending order
	"""
	codeName_DESC
	"""
	Order by major in an ascending order
	"""
	major_ASC
	"""
	Order by major in a descending order
	"""
	major_DESC
	"""
	Order by minor in an ascending order
	"""
	minor_ASC
	"""
	Order by minor in a descending order
	"""
	minor_DESC
	"""
	Order by build in an ascending order
	"""
	build_ASC
	"""
	Order by build in a descending order
	"""
	build_DESC
	"""
	Order by rawName in an ascending order
	"""
	rawName_ASC
	"""
	Order by rawName in a descending order
	"""
	rawName_DESC
}
type preventionSettingsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [preventionSettings_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [preventionSettings_aggregate_max_columns!]!): Map
	preventionSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_prevention_settings_bool_exp): [csPreventionSettings]
}
enum preventionSettings_aggregate_columns {
	"""
	groupBy by name
	"""
	name
}
enum preventionSettings_aggregate_max_columns {
	"""
	max by name
	"""
	name
}
enum preventionSettings_aggregate_min_columns {
	"""
	min by name
	"""
	name
}
type sensorUpdateSettingsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [sensorUpdateSettings_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [sensorUpdateSettings_aggregate_max_columns!]!): Map
	sensorUpdateSettings("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: cs_sensor_update_settings_bool_exp): [csSensorUpdateSettings]
}
enum sensorUpdateSettings_aggregate_columns {
	"""
	groupBy by build
	"""
	build
}
enum sensorUpdateSettings_aggregate_max_columns {
	"""
	max by build
	"""
	build
}
enum sensorUpdateSettings_aggregate_min_columns {
	"""
	min by build
	"""
	build
}
"""
Boolean filter expression for Tag
"""
input tag_bool_exp {
	"""
	filter by name
	"""
	name: StringComparator
	"""
	filter by creator
	"""
	creator: StringComparator
	"""
	filter by level
	"""
	level: StringComparator
	AND: [tag_bool_exp!]
	OR: [tag_bool_exp!]
	NOT: [tag_bool_exp!]
}
"""
Order for Tag
"""
enum tag_order_by {
	"""
	Order by name in an ascending order
	"""
	name_ASC
	"""
	Order by name in a descending order
	"""
	name_DESC
	"""
	Order by creator in an ascending order
	"""
	creator_ASC
	"""
	Order by creator in a descending order
	"""
	creator_DESC
	"""
	Order by level in an ascending order
	"""
	level_ASC
	"""
	Order by level in a descending order
	"""
	level_DESC
}
type tagsAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum: Map
	avg: Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [tags_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [tags_aggregate_max_columns!]!): Map
	tags("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: tag_bool_exp): [Tag] @relation(name: "adapter_device_tags", fkName: ["id"], relationFkName: ["adapter_device_id"], relType: MANY_TO_MANY, manyToManyTableName: "tags", joinOn: ["name"])
}
enum tags_aggregate_columns {
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by creator
	"""
	creator
	"""
	groupBy by level
	"""
	level
}
enum tags_aggregate_max_columns {
	"""
	max by name
	"""
	name
	"""
	max by creator
	"""
	creator
	"""
	max by level
	"""
	level
}
enum tags_aggregate_min_columns {
	"""
	min by name
	"""
	name
	"""
	min by creator
	"""
	creator
	"""
	min by level
	"""
	level
}
"""
Boolean filter expression for User
"""
input user_bool_exp {
	"""
	filter by id
	"""
	id: UUIDComparator
	"""
	filter by fetchCycle
	"""
	fetchCycle: IntComparator
	"""
	filter by adapterCount
	"""
	adapterCount: IntComparator
	"""
	filter by adapterNames
	"""
	adapterNames: StringArrayComparator
	"""
	filter by usernames
	"""
	usernames: StringArrayComparator
	"""
	filter by lastSeen
	"""
	lastSeen: EpochComparator
	"""
	filter by adapterUsers
	"""
	adapterUsers: adapter_user_bool_exp
	AND: [user_bool_exp!]
	OR: [user_bool_exp!]
	NOT: [user_bool_exp!]
}
"""
Order for User
"""
enum user_order_by {
	"""
	Order by fetchCycle in an ascending order
	"""
	fetchCycle_ASC
	"""
	Order by fetchCycle in a descending order
	"""
	fetchCycle_DESC
	"""
	Order by adapterCount in an ascending order
	"""
	adapterCount_ASC
	"""
	Order by adapterCount in a descending order
	"""
	adapterCount_DESC
	"""
	Order by lastSeen in an ascending order
	"""
	lastSeen_ASC
	"""
	Order by lastSeen in a descending order
	"""
	lastSeen_DESC
}
type usersAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [users_aggregate_max_columns!]!): Map
	users("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: user_bool_exp): [User]
}
enum users_aggregate_avg_columns {
	"""
	avg by fetchCycle
	"""
	fetchCycle
	"""
	avg by adapterCount
	"""
	adapterCount
	"""
	avg by lastSeen
	"""
	lastSeen
}
enum users_aggregate_columns {
	"""
	groupBy by id
	"""
	id
	"""
	groupBy by fetchCycle
	"""
	fetchCycle
	"""
	groupBy by adapterCount
	"""
	adapterCount
	"""
	groupBy by lastSeen
	"""
	lastSeen
}
enum users_aggregate_max_columns {
	"""
	max by id
	"""
	id
	"""
	max by fetchCycle
	"""
	fetchCycle
	"""
	max by adapterCount
	"""
	adapterCount
	"""
	max by lastSeen
	"""
	lastSeen
}
enum users_aggregate_min_columns {
	"""
	min by id
	"""
	id
	"""
	min by fetchCycle
	"""
	fetchCycle
	"""
	min by adapterCount
	"""
	adapterCount
	"""
	min by lastSeen
	"""
	lastSeen
}
enum users_aggregate_sum_columns {
	"""
	sum by fetchCycle
	"""
	fetchCycle
	"""
	sum by adapterCount
	"""
	adapterCount
	"""
	sum by lastSeen
	"""
	lastSeen
}
type vlansAggregate {
	group: [String!]!
	distinct: [String!]!
	count: Int
	sum("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [vlans_aggregate_sum_columns!]!): Map
	avg("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [vlans_aggregate_avg_columns!]!): Map
	min("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [vlans_aggregate_min_columns!]!): Map
	max("""
	Aggregate functions compute a single result value from a set of input values
	"""
	column: [vlans_aggregate_max_columns!]!): Map
	vlans("""
	limit the number of rows returned.
	"""
	limit: Int = 100, """
	skip the first n rows.
	"""
	offset: Int = 0, """
	filter the rows returned
	"""
	where: network_interface_vlan_bool_exp): [NetworkInterfaceVlan] @relation(name: "network_interfaces_vlan", fkName: ["macAddr","fetch_cycle"], relationFkName: ["macAddr","fetch_cycle"], relType: ONE_TO_MANY)
}
enum vlans_aggregate_avg_columns {
	"""
	avg by tagId
	"""
	tagId
}
enum vlans_aggregate_columns {
	"""
	groupBy by macAddr
	"""
	macAddr
	"""
	groupBy by name
	"""
	name
	"""
	groupBy by tagId
	"""
	tagId
}
enum vlans_aggregate_max_columns {
	"""
	max by macAddr
	"""
	macAddr
	"""
	max by name
	"""
	name
	"""
	max by tagId
	"""
	tagId
}
enum vlans_aggregate_min_columns {
	"""
	min by macAddr
	"""
	macAddr
	"""
	min by name
	"""
	name
	"""
	min by tagId
	"""
	tagId
}
enum vlans_aggregate_sum_columns {
	"""
	sum by tagId
	"""
	tagId
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_generateInputs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	return args, nil
}

func (ec *executionContext) dir_jsonpath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []*string
	if tmp, ok := rawArgs["depends"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["depends"] = arg1
	return args, nil
}

func (ec *executionContext) dir_relation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["fkName"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fkName"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["relationFkName"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["relationFkName"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["relType"]; ok {
		arg3, err = ec.unmarshalNRelationType2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["relType"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["manyToManyTableName"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["manyToManyTableName"] = arg4
	var arg5 []string
	if tmp, ok := rawArgs["joinOn"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["joinOn"] = arg5
	return args, nil
}

func (ec *executionContext) dir_sqlgen_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["skip"]; ok {
		arg0, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg0
	return args, nil
}

func (ec *executionContext) dir_viewFunction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []*string
	if tmp, ok := rawArgs["arguments"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["arguments"] = arg1
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_adapterData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterDataBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_adapter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_deviceUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_firewallRules_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []FirewallRulesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *FirewallRuleBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_firewallRules_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *FirewallRuleBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_installedSoftware_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []InstalledSoftwareAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *InstalledSoftwareBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_installedSoftware_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *InstalledSoftwareBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_interfaces_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_localAdmins_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceAdminBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_os_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *OperatingSystemBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_tags_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []TagsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_AdapterDevice_tags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_AdapterUser_adapterData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterDataBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_AdapterUser_adapter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AdapterBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_groups_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []GroupsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_groups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_preventionPolicy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CsPolicyBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_CrowdStrikeData_sensorUpdatePolicy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Device_adapterDevices_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Device_adapterDevices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_Device_interfaces_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []InterfacesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Device_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_Device_tags_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []TagsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Device_tags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_GCETagsAggregate_GCETags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *GceTagsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_GCETagsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GCETagsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_GCETagsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GCETagsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_GoogleCloudData_GCETags_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GCETagsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []GCETagsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *GceTagsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_GoogleCloudData_GCETags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *GceTagsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_NetworkInterface_vlans_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []VlansAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOvlans_aggregate_columns2bandicootpkggqlVlansAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []VlansAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOvlans_aggregate_columns2bandicootpkggqlVlansAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *NetworkInterfaceVlanBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_NetworkInterface_vlans_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *NetworkInterfaceVlanBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query__wizardFilters_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["type"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["type"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_adapterDevices_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterDevicesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_adapterDevices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []AdapterDeviceOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_adapterUsers_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_adapterUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []AdapterUserOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_devices_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []DevicesAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *DeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_devices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *DeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []DeviceOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_users_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []UsersAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *UserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *UserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	var arg3 []UserOrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg3, err = ec.unmarshalOuser_order_by2bandicootpkggqlUserOrderBy(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg3
	return args, nil
}

func (ec *executionContext) field_User_adapterUsers_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []AdapterUsersAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_User_adapterUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_adapterDevices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterDeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterDevicesAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterDevicesAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_adapterUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *AdapterUserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_adapterUsersAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []AdapterUsersAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_csPolicy_groups_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []GroupsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_csPolicy_groups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_csPolicy_preventionSettings_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []PreventionSettingsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []PreventionSettingsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsPreventionSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_csPolicy_preventionSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsPreventionSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_csPolicy_sensorUpdateSettings_aggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []SensorUpdateSettingsAggregateColumns
	if tmp, ok := rawArgs["groupBy"]; ok {
		arg0, err = ec.unmarshalOsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupBy"] = arg0
	var arg1 []SensorUpdateSettingsAggregateColumns
	if tmp, ok := rawArgs["distinctOn"]; ok {
		arg1, err = ec.unmarshalOsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distinctOn"] = arg1
	var arg2 []AggregateOrdering
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg2, err = ec.unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	var arg5 *CsSensorUpdateSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg5, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_csPolicy_sensorUpdateSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsSensorUpdateSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_csPreventionSettings_settings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsPolicySettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_devices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *DeviceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_devicesAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []DevicesAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_firewallRules_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *FirewallRuleBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_firewallRulesAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []FirewallRulesAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_groups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsGroupBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_groupsAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []GroupsAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_installedSoftware_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *InstalledSoftwareBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_installedSoftwareAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InstalledSoftwareAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_interfacesAggregate_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *NetworkInterfaceBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_interfacesAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_interfacesAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []InterfacesAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_preventionSettingsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []PreventionSettingsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_preventionSettingsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []PreventionSettingsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_preventionSettingsAggregate_preventionSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsPreventionSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_sensorUpdateSettingsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []SensorUpdateSettingsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_sensorUpdateSettingsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []SensorUpdateSettingsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_sensorUpdateSettingsAggregate_sensorUpdateSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *CsSensorUpdateSettingsBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_tagsAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_tagsAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []TagsAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_tagsAggregate_tags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *TagBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_usersAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []UsersAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_usersAggregate_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *UserBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

func (ec *executionContext) field_vlansAggregate_avg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []VlansAggregateAvgColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNvlans_aggregate_avg_columns2bandicootpkggqlVlansAggregateAvgColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_vlansAggregate_max_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []VlansAggregateMaxColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNvlans_aggregate_max_columns2bandicootpkggqlVlansAggregateMaxColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_vlansAggregate_min_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []VlansAggregateMinColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNvlans_aggregate_min_columns2bandicootpkggqlVlansAggregateMinColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_vlansAggregate_sum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []VlansAggregateSumColumns
	if tmp, ok := rawArgs["column"]; ok {
		arg0, err = ec.unmarshalNvlans_aggregate_sum_columns2bandicootpkggqlVlansAggregateSumColumns(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["column"] = arg0
	return args, nil
}

func (ec *executionContext) field_vlansAggregate_vlans_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *NetworkInterfaceVlanBoolExp
	if tmp, ok := rawArgs["where"]; ok {
		arg2, err = ec.unmarshalOnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg2
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ActiveDirectoryData_adCn(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdCn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adSid(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdSid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adGuid(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdGUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adSAMAccountName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdSAMAccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adUserPrincipalName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdUserPrincipalName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adDisplayName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adDistinguishedName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdDistinguishedName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adCanonicalName(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdCanonicalName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adAccountExpires(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdAccountExpires, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adObjectClass(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdObjectClass, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adObjectCategory(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdObjectCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adOrganizationalUnit(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdOrganizationalUnit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adLastLogoff(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdLastLogoff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adLastLogon(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdLastLogon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adLastLogonTimestamp(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdLastLogonTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adBadPasswordTime(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdBadPasswordTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_ad_bad_pwd_count(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdBadPwdCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adManagedBy(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdManagedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPasswordLastSet(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPasswordLastSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPrimaryGroupId(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPrimaryGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPrimaryGroupDn(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPrimaryGroupDn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMemberOf(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMemberOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMemberOfFull(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMemberOfFull, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adUsnChanged(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdUsnChanged, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adUsnCreated(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdUsnCreated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adWhenChanged(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdWhenChanged, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adWhenCreated(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdWhenCreated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adIsCriticalSystemObject(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdIsCriticalSystemObject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMsdsAllowedToDelegateTo(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMsdsAllowedToDelegateTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adPwdMustChange(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdPwdMustChange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ActiveDirectoryData_adMsdsResultantPso(ctx context.Context, field graphql.CollectedField, obj *ActiveDirectoryData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActiveDirectoryData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdMsdsResultantPso, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Adapter_id(ctx context.Context, field graphql.CollectedField, obj *Adapter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Adapter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Adapter_name(ctx context.Context, field graphql.CollectedField, obj *Adapter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Adapter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Adapter_properties(ctx context.Context, field graphql.CollectedField, obj *Adapter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Adapter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_id(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapterId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapter(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_adapter_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Adapter, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapters")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_ONE")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Adapter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bandicoot/pkg/gql.Adapter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Adapter)
	fc.Result = res
	return ec.marshalOAdapter2bandicootpkggqlAdapter(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapterName(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_deviceId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_adapterData(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_adapterData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.AdapterDevice().AdapterData(rctx, obj, args["where"].(*AdapterDataBoolExp))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "data")
			if err != nil {
				return nil, err
			}
			depends, err := ec.unmarshalOString2string(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, depends)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(AdapterData); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bandicoot/pkg/gql.AdapterData`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(AdapterData)
	fc.Result = res
	return ec.marshalOAdapterData2bandicootpkggqlAdapterData(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_data(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_fetchTime(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_hostname(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_name(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_lastSeen(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_osId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OsID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_os(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_os_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Os, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "operating_systems")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"osId"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_ONE")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*OperatingSystem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bandicoot/pkg/gql.OperatingSystem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*OperatingSystem)
	fc.Result = res
	return ec.marshalOOperatingSystem2bandicootpkggqlOperatingSystem(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_prettyId(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrettyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_tags(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_tags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tags, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_tags")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "tags")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalOTag2bandicootpkggqlTag(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_interfaces(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Interfaces, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"deviceId", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]NetworkInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.NetworkInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]NetworkInterface)
	fc.Result = res
	return ec.marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_lastUsedUsers(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUsedUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_domain(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_partOfDomain(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartOfDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_deviceUsers(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_deviceUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DeviceUsers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "deviceUsers")
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AdapterDeviceUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.AdapterDeviceUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterDeviceUser)
	fc.Result = res
	return ec.marshalOAdapterDeviceUser2bandicootpkggqlAdapterDeviceUser(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_localAdmins(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_localAdmins_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LocalAdmins, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "localAdmins")
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AdapterDeviceAdmin); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.AdapterDeviceAdmin`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterDeviceAdmin)
	fc.Result = res
	return ec.marshalOAdapterDeviceAdmin2bandicootpkggqlAdapterDeviceAdmin(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_firewallRules(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_firewallRules_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FirewallRules, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_firewall_rules")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "firewall_rules")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*FirewallRule); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.FirewallRule`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FirewallRule)
	fc.Result = res
	return ec.marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_installedSoftware(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_installedSoftware_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InstalledSoftware, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_installed_software")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "installed_software")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name", "version"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InstalledSoftware); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.InstalledSoftware`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*InstalledSoftware)
	fc.Result = res
	return ec.marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_agentVersion(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_agentStatus(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_agentName(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_model(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_manufacturer(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manufacturer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_serial(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Serial, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_family(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Family, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_biosVersion(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BiosVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_biosSerial(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BiosSerial, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_tags_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_tags_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TagsAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_tags")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "tags")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]TagsAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.TagsAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]TagsAggregate)
	fc.Result = res
	return ec.marshalOtagsAggregate2bandicootpkggqlTagsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_interfaces_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_interfaces_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InterfacesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"deviceId", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]InterfacesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.InterfacesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]InterfacesAggregate)
	fc.Result = res
	return ec.marshalOinterfacesAggregate2bandicootpkggqlInterfacesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_firewallRules_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_firewallRules_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FirewallRulesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_firewall_rules")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "firewall_rules")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]FirewallRulesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.FirewallRulesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]FirewallRulesAggregate)
	fc.Result = res
	return ec.marshalOfirewallRulesAggregate2bandicootpkggqlFirewallRulesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDevice_installedSoftware_aggregate(ctx context.Context, field graphql.CollectedField, obj *AdapterDevice) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDevice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterDevice_installedSoftware_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InstalledSoftwareAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_installed_software")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "installed_software")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name", "version"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]InstalledSoftwareAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.InstalledSoftwareAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]InstalledSoftwareAggregate)
	fc.Result = res
	return ec.marshalOinstalledSoftwareAggregate2bandicootpkggqlInstalledSoftwareAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceAdmin_name(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceAdmin_type(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AdminType)
	fc.Result = res
	return ec.marshalOAdminType2bandicootpkggqlAdminType(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_deviceId(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_sid(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_username(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_lastUseDate(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUseDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_isLocal(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsLocal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_isDisabled(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_isAdmin(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAdmin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_userDepartment(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserDepartment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_passwordMaxAge(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PasswordMaxAge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterDeviceUser_interpreter(ctx context.Context, field graphql.CollectedField, obj *AdapterDeviceUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterDeviceUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interpreter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_id(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapterId(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapter(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterUser_adapter_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Adapter, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapters")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_ONE")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Adapter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bandicoot/pkg/gql.Adapter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Adapter)
	fc.Result = res
	return ec.marshalOAdapter2bandicootpkggqlAdapter(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapterName(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_userId(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_adapterData(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AdapterUser_adapterData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.AdapterUser().AdapterData(rctx, obj, args["where"].(*AdapterDataBoolExp))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "data")
			if err != nil {
				return nil, err
			}
			depends, err := ec.unmarshalOString2string(ctx, []interface{}{"adapterId"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Jsonpath == nil {
				return nil, errors.New("directive jsonpath is not implemented")
			}
			return ec.directives.Jsonpath(ctx, obj, directive0, name, depends)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(AdapterData); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bandicoot/pkg/gql.AdapterData`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(AdapterData)
	fc.Result = res
	return ec.marshalOAdapterData2bandicootpkggqlAdapterData(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_data(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_fetchTime(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_lastSeen(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_username(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_displayName(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_description(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_domain(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_userSid(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserSid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_firstName(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_lastName(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_mail(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_admin(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_local(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Local, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_delegatedAdmin(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DelegatedAdmin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_mfaEnforced(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MfaEnforced, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_mfaEnrolled(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MfaEnrolled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_suspended(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suspended, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_locked(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AdapterUser_disabled(ctx context.Context, field graphql.CollectedField, obj *AdapterUser) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AdapterUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_id(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_name(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_manfacturer(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manfacturer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_bitness(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bitness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_family(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Family, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_cores(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cores, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_coresThreads(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoresThreads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CPU_ghz(ctx context.Context, field graphql.CollectedField, obj *CPU) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CPU",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ghz, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_externalIp(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_groups(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_groups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2bandicootpkggqlCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_preventionPolicy(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_preventionPolicy_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CsPolicy)
	fc.Result = res
	return ec.marshalOcsPolicy2bandicootpkggqlCsPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_sensorUpdatePolicy(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_sensorUpdatePolicy_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdatePolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2bandicootpkggqlCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_csAgentVersion(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CsAgentVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CrowdStrikeData_groups_aggregate(ctx context.Context, field graphql.CollectedField, obj *CrowdStrikeData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CrowdStrikeData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CrowdStrikeData_groups_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]GroupsAggregate)
	fc.Result = res
	return ec.marshalOgroupsAggregate2bandicootpkggqlGroupsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_isSafe(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSafe, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_deviceState(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CylanceDeviceState)
	fc.Result = res
	return ec.marshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_policyId(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PolicyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_policyName(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PolicyName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_policiesDetails(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PoliciesDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_tenantTag(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantTag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_zoneNames(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZoneNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CylanceData_agentVersion(ctx context.Context, field graphql.CollectedField, obj *CylanceData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "CylanceData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_id(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterCount(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterNames(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_hostnames(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostnames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_lastSeen(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterDevices(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_adapterDevices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterDevices, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_devices")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterDevice); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterDevice`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterDevice)
	fc.Result = res
	return ec.marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_interfaces(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Interfaces, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "device_network_interfaces")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]NetworkInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.NetworkInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]NetworkInterface)
	fc.Result = res
	return ec.marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_tags(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_tags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tags, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "device_tags")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Tag)
	fc.Result = res
	return ec.marshalOTag2bandicootpkggqlTag(ctx, field.Selections, res)
}

func (ec *executionContext) _Device__compatibilityAPI(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Device().CompatibilityAPI(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_adapterDevices_aggregate(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_adapterDevices_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterDevicesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_devices")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterDevicesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterDevicesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterDevicesAggregate)
	fc.Result = res
	return ec.marshalOadapterDevicesAggregate2bandicootpkggqlAdapterDevicesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_interfaces_aggregate(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_interfaces_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InterfacesAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "device_network_interfaces")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]InterfacesAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.InterfacesAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]InterfacesAggregate)
	fc.Result = res
	return ec.marshalOinterfacesAggregate2bandicootpkggqlInterfacesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Device_tags_aggregate(ctx context.Context, field graphql.CollectedField, obj *Device) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Device",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Device_tags_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TagsAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "device_tags")
			if err != nil {
				return nil, err
			}
			arguments, err := ec.unmarshalOString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			if ec.directives.ViewFunction == nil {
				return nil, errors.New("directive viewFunction is not implemented")
			}
			return ec.directives.ViewFunction(ctx, obj, directive0, name, arguments)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]TagsAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.TagsAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]TagsAggregate)
	fc.Result = res
	return ec.marshalOtagsAggregate2bandicootpkggqlTagsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_name(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_source(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_type(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AccessType)
	fc.Result = res
	return ec.marshalOAccessType2bandicootpkggqlAccessType(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_direction(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Direction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Direction)
	fc.Result = res
	return ec.marshalODirection2bandicootpkggqlDirection(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_target(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_protocol(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_srcPort(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SrcPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _FirewallRule_dstPort(ctx context.Context, field graphql.CollectedField, obj *FirewallRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "FirewallRule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DstPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GCETagsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GCETagsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _GCETagsAggregate_GCETags(ctx context.Context, field graphql.CollectedField, obj *GCETagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GCETagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GCETagsAggregate_GCETags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCETags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*GceTags)
	fc.Result = res
	return ec.marshalOGceTags2bandicootpkggqlGceTags(ctx, field.Selections, res)
}

func (ec *executionContext) _GceTags_gceKey(ctx context.Context, field graphql.CollectedField, obj *GceTags) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GceTags",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GceKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GceTags_gceValue(ctx context.Context, field graphql.CollectedField, obj *GceTags) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GceTags",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GceValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_Id(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_Size(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_Image(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_GCETags(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GoogleCloudData_GCETags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCETags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*GceTags)
	fc.Result = res
	return ec.marshalOGceTags2bandicootpkggqlGceTags(ctx, field.Selections, res)
}

func (ec *executionContext) _GoogleCloudData_GCETags_aggregate(ctx context.Context, field graphql.CollectedField, obj *GoogleCloudData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GoogleCloudData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_GoogleCloudData_GCETags_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCETagsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]GCETagsAggregate)
	fc.Result = res
	return ec.marshalOGCETagsAggregate2bandicootpkggqlGCETagsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_name(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_version(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_architecture(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Architecture)
	fc.Result = res
	return ec.marshalOArchitecture2bandicootpkggqlArchitecture(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_description(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_vendor(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vendor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_publisher(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Publisher, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_cveCount(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CveCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_swLicense(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SwLicense, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InstalledSoftware_path(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftware) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "InstalledSoftware",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_deviceId(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_macAddr(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MacAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOMac2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_ipAddrs(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddrs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]net.IP)
	fc.Result = res
	return ec.marshalOIP2netIP(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_name(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_manufacturer(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manufacturer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_subnets(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subnets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*net.IPNet)
	fc.Result = res
	return ec.marshalOCIDR2netIPNet(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_operationalStatus(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OperationalStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_adminStatus(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_portType(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PortType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_mtu(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mtu, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_gateway(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gateway, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*net.IP)
	fc.Result = res
	return ec.marshalOIP2netIP(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_port(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_vlans(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_NetworkInterface_vlans_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Vlans, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces_vlan")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"macAddr", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"macAddr", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*NetworkInterfaceVlan); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.NetworkInterfaceVlan`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*NetworkInterfaceVlan)
	fc.Result = res
	return ec.marshalONetworkInterfaceVlan2bandicootpkggqlNetworkInterfaceVlan(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterface_vlans_aggregate(ctx context.Context, field graphql.CollectedField, obj *NetworkInterface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterface",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_NetworkInterface_vlans_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.VlansAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces_vlan")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"macAddr", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"macAddr", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]VlansAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.VlansAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]VlansAggregate)
	fc.Result = res
	return ec.marshalOvlansAggregate2bandicootpkggqlVlansAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterfaceVlan_macAddr(ctx context.Context, field graphql.CollectedField, obj *NetworkInterfaceVlan) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterfaceVlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MacAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOMac2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterfaceVlan_name(ctx context.Context, field graphql.CollectedField, obj *NetworkInterfaceVlan) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterfaceVlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterfaceVlan_tagId(ctx context.Context, field graphql.CollectedField, obj *NetworkInterfaceVlan) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterfaceVlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TagID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkInterfaceVlan_tagged(ctx context.Context, field graphql.CollectedField, obj *NetworkInterfaceVlan) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "NetworkInterfaceVlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tagged, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ObjectFilter_name(ctx context.Context, field graphql.CollectedField, obj *ObjectFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ObjectFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ObjectFilter_displayName(ctx context.Context, field graphql.CollectedField, obj *ObjectFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ObjectFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ObjectFilter_type(ctx context.Context, field graphql.CollectedField, obj *ObjectFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ObjectFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ObjectFilter_description(ctx context.Context, field graphql.CollectedField, obj *ObjectFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ObjectFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ObjectFilter_filters(ctx context.Context, field graphql.CollectedField, obj *ObjectFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ObjectFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Filters, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			skip, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.Sqlgen == nil {
				return nil, errors.New("directive sqlgen is not implemented")
			}
			return ec.directives.Sqlgen(ctx, obj, directive0, skip)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]Filter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.Filter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Filter)
	fc.Result = res
	return ec.marshalOFilter2bandicootpkggqlFilter(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_id(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_type(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_distribution(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distribution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_architecture(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_servicePack(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServicePack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_installDate(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstallDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_kernelVersion(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KernelVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_codeName(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CodeName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_major(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Major, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_minor(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Minor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_build(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OperatingSystem_rawName(ctx context.Context, field graphql.CollectedField, obj *OperatingSystem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OperatingSystem",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Operator_name(ctx context.Context, field graphql.CollectedField, obj *Operator) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Operator",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Operator_type(ctx context.Context, field graphql.CollectedField, obj *Operator) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Operator",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Operator_displayName(ctx context.Context, field graphql.CollectedField, obj *Operator) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Operator",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Operator_description(ctx context.Context, field graphql.CollectedField, obj *Operator) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Operator",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Operator_formatDisplay(ctx context.Context, field graphql.CollectedField, obj *Operator) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Operator",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormatDisplay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterDevices(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterDevices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterDevices(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp), args["orderBy"].([]AdapterDeviceOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]AdapterDevice)
	fc.Result = res
	return ec.marshalNAdapterDevice2bandicootpkggqlAdapterDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_devices(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_devices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Devices(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp), args["orderBy"].([]DeviceOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Device)
	fc.Result = res
	return ec.marshalNDevice2bandicootpkggqlDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterUsers(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp), args["orderBy"].([]AdapterUserOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]AdapterUser)
	fc.Result = res
	return ec.marshalNAdapterUser2bandicootpkggqlAdapterUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_users_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx, args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp), args["orderBy"].([]UserOrderBy))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]User)
	fc.Result = res
	return ec.marshalNUser2bandicootpkggqlUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__wizardFilters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__wizardFilters_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().WizardFilters(rctx, args["type"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			skip, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.Sqlgen == nil {
				return nil, errors.New("directive sqlgen is not implemented")
			}
			return ec.directives.Sqlgen(ctx, nil, directive0, skip)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ObjectFilter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bandicoot/pkg/gql.ObjectFilter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ObjectFilter)
	fc.Result = res
	return ec.marshalOObjectFilter2bandicootpkggqlObjectFilter(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterDevices_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterDevices_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterDevicesAggregate(rctx, args["groupBy"].([]AdapterDevicesAggregateColumns), args["distinctOn"].([]AdapterDevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterDeviceBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterDevicesAggregate)
	fc.Result = res
	return ec.marshalOadapterDevicesAggregate2bandicootpkggqlAdapterDevicesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_devices_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_devices_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DevicesAggregate(rctx, args["groupBy"].([]DevicesAggregateColumns), args["distinctOn"].([]DevicesAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*DeviceBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]DevicesAggregate)
	fc.Result = res
	return ec.marshalOdevicesAggregate2bandicootpkggqlDevicesAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_adapterUsers_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_adapterUsers_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdapterUsersAggregate(rctx, args["groupBy"].([]AdapterUsersAggregateColumns), args["distinctOn"].([]AdapterUsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*AdapterUserBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterUsersAggregate)
	fc.Result = res
	return ec.marshalOadapterUsersAggregate2bandicootpkggqlAdapterUsersAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_users_aggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_users_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UsersAggregate(rctx, args["groupBy"].([]UsersAggregateColumns), args["distinctOn"].([]UsersAggregateColumns), args["orderBy"].([]AggregateOrdering), args["limit"].(*int), args["offset"].(*int), args["where"].(*UserBoolExp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]UsersAggregate)
	fc.Result = res
	return ec.marshalOusersAggregate2bandicootpkggqlUsersAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _ScalarFilter_name(ctx context.Context, field graphql.CollectedField, obj *ScalarFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ScalarFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ScalarFilter_displayName(ctx context.Context, field graphql.CollectedField, obj *ScalarFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ScalarFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ScalarFilter_description(ctx context.Context, field graphql.CollectedField, obj *ScalarFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ScalarFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ScalarFilter_type(ctx context.Context, field graphql.CollectedField, obj *ScalarFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ScalarFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ScalarFilter_operators(ctx context.Context, field graphql.CollectedField, obj *ScalarFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ScalarFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Operators, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			skip, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.Sqlgen == nil {
				return nil, errors.New("directive sqlgen is not implemented")
			}
			return ec.directives.Sqlgen(ctx, obj, directive0, skip)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Operator); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.Operator`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Operator)
	fc.Result = res
	return ec.marshalNOperator2bandicootpkggqlOperator(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_deviceId(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_path(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_name(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_totalSize(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_freeSize(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FreeSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_isEncrypted(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsEncrypted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Storage_description(ctx context.Context, field graphql.CollectedField, obj *Storage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Storage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Tag_name(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Tag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Tag_creator(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Tag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Tag_level(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Tag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UnionFilter_name(ctx context.Context, field graphql.CollectedField, obj *UnionFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UnionFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UnionFilter_displayName(ctx context.Context, field graphql.CollectedField, obj *UnionFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UnionFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UnionFilter_type(ctx context.Context, field graphql.CollectedField, obj *UnionFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UnionFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UnionFilter_description(ctx context.Context, field graphql.CollectedField, obj *UnionFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UnionFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UnionFilter_objects(ctx context.Context, field graphql.CollectedField, obj *UnionFilter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UnionFilter",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Objects, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			skip, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.Sqlgen == nil {
				return nil, errors.New("directive sqlgen is not implemented")
			}
			return ec.directives.Sqlgen(ctx, obj, directive0, skip)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ObjectFilter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.ObjectFilter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ObjectFilter)
	fc.Result = res
	return ec.marshalOObjectFilter2bandicootpkggqlObjectFilter(ctx, field.Selections, res)
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomsatorigouuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) _User_fetchCycle(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchCycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterCount(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterNames(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_usernames(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Usernames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_lastSeen(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterUsers(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_User_adapterUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterUsers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_users")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"user_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterUser)
	fc.Result = res
	return ec.marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx, field.Selections, res)
}

func (ec *executionContext) _User__compatibilityAPI(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().CompatibilityAPI(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adapterUsers_aggregate(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_User_adapterUsers_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterUsersAggregate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_users")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"user_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]AdapterUsersAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []bandicoot/pkg/gql.AdapterUsersAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AdapterUsersAggregate)
	fc.Result = res
	return ec.marshalOadapterUsersAggregate2bandicootpkggqlAdapterUsersAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterDevicesAggregate_adapterDevices(ctx context.Context, field graphql.CollectedField, obj *AdapterDevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterDevicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterDevicesAggregate_adapterDevices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdapterDevices, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterDevice)
	fc.Result = res
	return ec.marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_group(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_count(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_min(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_max(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _adapterUsersAggregate_adapterUsers(ctx context.Context, field graphql.CollectedField, obj *AdapterUsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "adapterUsersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_adapterUsersAggregate_adapterUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdapterUsers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_users")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"user_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AdapterUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.AdapterUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AdapterUser)
	fc.Result = res
	return ec.marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_id(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_name(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_createdBy(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_createdTimestamp(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_description(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_groupType(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_modifiedBy(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csGroup_modifiedTime(ctx context.Context, field graphql.CollectedField, obj *CsGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_name(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_description(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_platformName(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlatformName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_groups(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_groups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2bandicootpkggqlCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_enabled(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_createdBy(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_createdTime(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*internal.Epoch)
	fc.Result = res
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_preventionSettings(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_preventionSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsPreventionSettings)
	fc.Result = res
	return ec.marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_sensorUpdateSettings(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_sensorUpdateSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdateSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsSensorUpdateSettings)
	fc.Result = res
	return ec.marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_groups_aggregate(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_groups_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]GroupsAggregate)
	fc.Result = res
	return ec.marshalOgroupsAggregate2bandicootpkggqlGroupsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_preventionSettings_aggregate(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_preventionSettings_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionSettingsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]PreventionSettingsAggregate)
	fc.Result = res
	return ec.marshalOpreventionSettingsAggregate2bandicootpkggqlPreventionSettingsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicy_sensorUpdateSettings_aggregate(ctx context.Context, field graphql.CollectedField, obj *CsPolicy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPolicy_sensorUpdateSettings_aggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdateSettingsAggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]SensorUpdateSettingsAggregate)
	fc.Result = res
	return ec.marshalOsensorUpdateSettingsAggregate2bandicootpkggqlSensorUpdateSettingsAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) _csPolicySettings_enabled(ctx context.Context, field graphql.CollectedField, obj *CsPolicySettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPolicySettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _csPreventionSettings_name(ctx context.Context, field graphql.CollectedField, obj *CsPreventionSettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPreventionSettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _csPreventionSettings_settings(ctx context.Context, field graphql.CollectedField, obj *CsPreventionSettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csPreventionSettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_csPreventionSettings_settings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Settings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsPolicySettings)
	fc.Result = res
	return ec.marshalOcsPolicySettings2bandicootpkggqlCsPolicySettings(ctx, field.Selections, res)
}

func (ec *executionContext) _csSensorUpdateSettings_build(ctx context.Context, field graphql.CollectedField, obj *CsSensorUpdateSettings) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "csSensorUpdateSettings",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _devicesAggregate_devices(ctx context.Context, field graphql.CollectedField, obj *DevicesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "devicesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_devicesAggregate_devices_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Devices, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Device)
	fc.Result = res
	return ec.marshalODevice2bandicootpkggqlDevice(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _firewallRulesAggregate_firewallRules(ctx context.Context, field graphql.CollectedField, obj *FirewallRulesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "firewallRulesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_firewallRulesAggregate_firewallRules_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FirewallRules, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_firewall_rules")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "firewall_rules")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*FirewallRule); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.FirewallRule`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FirewallRule)
	fc.Result = res
	return ec.marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _groupsAggregate_groups(ctx context.Context, field graphql.CollectedField, obj *GroupsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "groupsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_groupsAggregate_groups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsGroup)
	fc.Result = res
	return ec.marshalOcsGroup2bandicootpkggqlCsGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_group(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_count(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_min(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_max(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _installedSoftwareAggregate_installedSoftware(ctx context.Context, field graphql.CollectedField, obj *InstalledSoftwareAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "installedSoftwareAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_installedSoftwareAggregate_installedSoftware_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InstalledSoftware, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_installed_software")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "installed_software")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name", "version"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InstalledSoftware); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.InstalledSoftware`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*InstalledSoftware)
	fc.Result = res
	return ec.marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_group(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_count(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_min(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_interfacesAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_max(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_interfacesAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _interfacesAggregate_interfaces(ctx context.Context, field graphql.CollectedField, obj *InterfacesAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "interfacesAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_interfacesAggregate_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Interfaces, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"deviceId", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*NetworkInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.NetworkInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*NetworkInterface)
	fc.Result = res
	return ec.marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_preventionSettingsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_preventionSettingsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _preventionSettingsAggregate_preventionSettings(ctx context.Context, field graphql.CollectedField, obj *PreventionSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "preventionSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_preventionSettingsAggregate_preventionSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreventionSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsPreventionSettings)
	fc.Result = res
	return ec.marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_sensorUpdateSettingsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_sensorUpdateSettingsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _sensorUpdateSettingsAggregate_sensorUpdateSettings(ctx context.Context, field graphql.CollectedField, obj *SensorUpdateSettingsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "sensorUpdateSettingsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_sensorUpdateSettingsAggregate_sensorUpdateSettings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SensorUpdateSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*CsSensorUpdateSettings)
	fc.Result = res
	return ec.marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_tagsAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_tagsAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _tagsAggregate_tags(ctx context.Context, field graphql.CollectedField, obj *TagsAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "tagsAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_tagsAggregate_tags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tags, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "adapter_device_tags")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"id"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"adapter_device_id"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "MANY_TO_MANY")
			if err != nil {
				return nil, err
			}
			manyToManyTableName, err := ec.unmarshalOString2string(ctx, "tags")
			if err != nil {
				return nil, err
			}
			joinOn, err := ec.unmarshalOString2string(ctx, []interface{}{"name"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, manyToManyTableName, joinOn)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalOTag2bandicootpkggqlTag(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_group(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_count(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_min(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_max(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _usersAggregate_users(ctx context.Context, field graphql.CollectedField, obj *UsersAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "usersAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_usersAggregate_users_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*User)
	fc.Result = res
	return ec.marshalOUser2bandicootpkggqlUser(ctx, field.Selections, res)
}

func (ec *executionContext) _vlansAggregate_group(ctx context.Context, field graphql.CollectedField, obj *VlansAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "vlansAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _vlansAggregate_distinct(ctx context.Context, field graphql.CollectedField, obj *VlansAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "vlansAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distinct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _vlansAggregate_count(ctx context.Context, field graphql.CollectedField, obj *VlansAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "vlansAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _vlansAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *VlansAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "vlansAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_vlansAggregate_sum_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _vlansAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *VlansAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "vlansAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_vlansAggregate_avg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _vlansAggregate_min(ctx context.Context, field graphql.CollectedField, obj *VlansAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "vlansAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_vlansAggregate_min_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _vlansAggregate_max(ctx context.Context, field graphql.CollectedField, obj *VlansAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "vlansAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_vlansAggregate_max_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _vlansAggregate_vlans(ctx context.Context, field graphql.CollectedField, obj *VlansAggregate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "vlansAggregate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_vlansAggregate_vlans_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Vlans, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "network_interfaces_vlan")
			if err != nil {
				return nil, err
			}
			fkName, err := ec.unmarshalNString2string(ctx, []interface{}{"macAddr", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relationFkName, err := ec.unmarshalNString2string(ctx, []interface{}{"macAddr", "fetch_cycle"})
			if err != nil {
				return nil, err
			}
			relType, err := ec.unmarshalNRelationType2string(ctx, "ONE_TO_MANY")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive0, name, fkName, relationFkName, relType, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*NetworkInterfaceVlan); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*bandicoot/pkg/gql.NetworkInterfaceVlan`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*NetworkInterfaceVlan)
	fc.Result = res
	return ec.marshalONetworkInterfaceVlan2bandicootpkggqlNetworkInterfaceVlan(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAccessTypeComparator(ctx context.Context, obj interface{}) (AccessTypeComparator, error) {
	var it AccessTypeComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error
			it.In, err = ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		case "not_in":
			var err error
			it.NotIn, err = ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAdminTypeComparator(ctx context.Context, obj interface{}) (AdminTypeComparator, error) {
	var it AdminTypeComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error
			it.In, err = ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		case "not_in":
			var err error
			it.NotIn, err = ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArchitectureComparator(ctx context.Context, obj interface{}) (ArchitectureComparator, error) {
	var it ArchitectureComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error
			it.In, err = ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		case "not_in":
			var err error
			it.NotIn, err = ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBooleanComparator(ctx context.Context, obj interface{}) (BooleanComparator, error) {
	var it BooleanComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCIDRComparator(ctx context.Context, obj interface{}) (CIDRComparator, error) {
	var it CIDRComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOCIDR2netIPNet(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOCIDR2netIPNet(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCylanceDeviceStateComparator(ctx context.Context, obj interface{}) (CylanceDeviceStateComparator, error) {
	var it CylanceDeviceStateComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error
			it.In, err = ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		case "not_in":
			var err error
			it.NotIn, err = ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDirectionComparator(ctx context.Context, obj interface{}) (DirectionComparator, error) {
	var it DirectionComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalODirection2bandicootpkggqlDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalODirection2bandicootpkggqlDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error
			it.In, err = ec.unmarshalODirection2bandicootpkggqlDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "not_in":
			var err error
			it.NotIn, err = ec.unmarshalODirection2bandicootpkggqlDirection(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEpochArrayComparator(ctx context.Context, obj interface{}) (EpochArrayComparator, error) {
	var it EpochArrayComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEpochComparator(ctx context.Context, obj interface{}) (EpochComparator, error) {
	var it EpochComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lte":
			var err error
			it.Lte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error
			it.Lt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "gte":
			var err error
			it.Gte, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error
			it.Gt, err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
			if err != nil {
				return it, err
			}
		case "days":
			var err error
			it.Days, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFloatArrayComparator(ctx context.Context, obj interface{}) (FloatArrayComparator, error) {
	var it FloatArrayComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "contains":
			var err error
			it.Contains, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "contained_by":
			var err error
			it.ContainedBy, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "overlap":
			var err error
			it.Overlap, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "size":
			var err error
			it.Size, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFloatComparator(ctx context.Context, obj interface{}) (FloatComparator, error) {
	var it FloatComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lte":
			var err error
			it.Lte, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error
			it.Lt, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "gte":
			var err error
			it.Gte, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error
			it.Gt, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIPArrayComparator(ctx context.Context, obj interface{}) (IPArrayComparator, error) {
	var it IPArrayComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOIP2netIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOIP2netIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "contains":
			var err error
			it.Contains, err = ec.unmarshalOIP2netIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "contained_by":
			var err error
			it.ContainedBy, err = ec.unmarshalOIP2netIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "overlap":
			var err error
			it.Overlap, err = ec.unmarshalOIP2netIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "size":
			var err error
			it.Size, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "in_subnet":
			var err error
			it.InSubnet, err = ec.unmarshalOCIDR2netIPNet(ctx, v)
			if err != nil {
				return it, err
			}
		case "ip_family":
			var err error
			it.IPFamily, err = ec.unmarshalOIPFamily2bandicootpkggqlIPFamily(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIPComparator(ctx context.Context, obj interface{}) (IPComparator, error) {
	var it IPComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOIP2netIP(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOIP2netIP(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntArrayComparator(ctx context.Context, obj interface{}) (IntArrayComparator, error) {
	var it IntArrayComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "contains":
			var err error
			it.Contains, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "contained_by":
			var err error
			it.ContainedBy, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "overlap":
			var err error
			it.Overlap, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "size":
			var err error
			it.Size, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntComparator(ctx context.Context, obj interface{}) (IntComparator, error) {
	var it IntComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "lte":
			var err error
			it.Lte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error
			it.Lt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "gte":
			var err error
			it.Gte, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error
			it.Gt, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error
			it.In, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "not_in":
			var err error
			it.NotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMacArrayComparator(ctx context.Context, obj interface{}) (MacArrayComparator, error) {
	var it MacArrayComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contains":
			var err error
			it.Contains, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contained_by":
			var err error
			it.ContainedBy, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "overlap":
			var err error
			it.Overlap, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "size":
			var err error
			it.Size, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMacComparator(ctx context.Context, obj interface{}) (MacComparator, error) {
	var it MacComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOMac2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringArrayComparator(ctx context.Context, obj interface{}) (StringArrayComparator, error) {
	var it StringArrayComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contains":
			var err error
			it.Contains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contained_by":
			var err error
			it.ContainedBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "overlap":
			var err error
			it.Overlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "no_overlap":
			var err error
			it.NoOverlap, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "size":
			var err error
			it.Size, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "contains_regex":
			var err error
			it.ContainsRegex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringComparator(ctx context.Context, obj interface{}) (StringComparator, error) {
	var it StringComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error
			it.In, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "not_in":
			var err error
			it.NotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "like":
			var err error
			it.Like, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ilike":
			var err error
			it.Ilike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "not_like":
			var err error
			it.NotLike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "not_ilike":
			var err error
			it.NotIlike, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffix":
			var err error
			it.Suffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "prefix":
			var err error
			it.Prefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUUIDArrayComparator(ctx context.Context, obj interface{}) (UUIDArrayComparator, error) {
	var it UUIDArrayComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "contains":
			var err error
			it.Contains, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "contained_by":
			var err error
			it.ContainedBy, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "overlap":
			var err error
			it.Overlap, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "size":
			var err error
			it.Size, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUUIDComparator(ctx context.Context, obj interface{}) (UUIDComparator, error) {
	var it UUIDComparator
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "exists":
			var err error
			it.Exists, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error
			it.Eq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "neq":
			var err error
			it.Neq, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error
			it.In, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "not_in":
			var err error
			it.NotIn, err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_bool_exp(ctx context.Context, obj interface{}) (AdapterBoolExp, error) {
	var it AdapterBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties":
			var err error
			it.Properties, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_data_bool_exp(ctx context.Context, obj interface{}) (AdapterDataBoolExp, error) {
	var it AdapterDataBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "adCn":
			var err error
			it.AdCn, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSid":
			var err error
			it.AdSid, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adGuid":
			var err error
			it.AdGUID, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adName":
			var err error
			it.AdName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adSAMAccountName":
			var err error
			it.AdSAMAccountName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUserPrincipalName":
			var err error
			it.AdUserPrincipalName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDisplayName":
			var err error
			it.AdDisplayName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adDistinguishedName":
			var err error
			it.AdDistinguishedName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adCanonicalName":
			var err error
			it.AdCanonicalName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adAccountExpires":
			var err error
			it.AdAccountExpires, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectClass":
			var err error
			it.AdObjectClass, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adObjectCategory":
			var err error
			it.AdObjectCategory, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adOrganizationalUnit":
			var err error
			it.AdOrganizationalUnit, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "ad_bad_pwd_count":
			var err error
			it.AdBadPwdCount, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adManagedBy":
			var err error
			it.AdManagedBy, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupId":
			var err error
			it.AdPrimaryGroupID, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPrimaryGroupDn":
			var err error
			it.AdPrimaryGroupDn, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOf":
			var err error
			it.AdMemberOf, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMemberOfFull":
			var err error
			it.AdMemberOfFull, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnChanged":
			var err error
			it.AdUsnChanged, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adUsnCreated":
			var err error
			it.AdUsnCreated, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adIsCriticalSystemObject":
			var err error
			it.AdIsCriticalSystemObject, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsAllowedToDelegateTo":
			var err error
			it.AdMsdsAllowedToDelegateTo, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adPwdMustChange":
			var err error
			it.AdPwdMustChange, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adMsdsResultantPso":
			var err error
			it.AdMsdsResultantPso, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "isSafe":
			var err error
			it.IsSafe, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceState":
			var err error
			it.DeviceState, err = ec.unmarshalOCylanceDeviceStateComparator2bandicootpkggqlCylanceDeviceStateComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyId":
			var err error
			it.PolicyID, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "policyName":
			var err error
			it.PolicyName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "policiesDetails":
			var err error
			it.PoliciesDetails, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantTag":
			var err error
			it.TenantTag, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "zoneNames":
			var err error
			it.ZoneNames, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion":
			var err error
			it.AgentVersion, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalIp":
			var err error
			it.ExternalIP, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "groups":
			var err error
			it.Groups, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "preventionPolicy":
			var err error
			it.PreventionPolicy, err = ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "sensorUpdatePolicy":
			var err error
			it.SensorUpdatePolicy, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "csAgentVersion":
			var err error
			it.CsAgentVersion, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_device_admin_bool_exp(ctx context.Context, obj interface{}) (AdapterDeviceAdminBoolExp, error) {
	var it AdapterDeviceAdminBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOAdminTypeComparator2bandicootpkggqlAdminTypeComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_device_bool_exp(ctx context.Context, obj interface{}) (AdapterDeviceBoolExp, error) {
	var it AdapterDeviceBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle":
			var err error
			it.FetchCycle, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId":
			var err error
			it.AdapterID, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapter":
			var err error
			it.Adapter, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName":
			var err error
			it.AdapterName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId":
			var err error
			it.DeviceID, err = ec.unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterData":
			var err error
			it.AdapterData, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime":
			var err error
			it.FetchTime, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostname":
			var err error
			it.Hostname, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen":
			var err error
			it.LastSeen, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "osId":
			var err error
			it.OsID, err = ec.unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "os":
			var err error
			it.Os, err = ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "prettyId":
			var err error
			it.PrettyID, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "interfaces":
			var err error
			it.Interfaces, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUsedUsers":
			var err error
			it.LastUsedUsers, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain":
			var err error
			it.Domain, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "partOfDomain":
			var err error
			it.PartOfDomain, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceUsers":
			var err error
			it.DeviceUsers, err = ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "localAdmins":
			var err error
			it.LocalAdmins, err = ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "firewallRules":
			var err error
			it.FirewallRules, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "installedSoftware":
			var err error
			it.InstalledSoftware, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentVersion":
			var err error
			it.AgentVersion, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentStatus":
			var err error
			it.AgentStatus, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentName":
			var err error
			it.AgentName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "model":
			var err error
			it.Model, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer":
			var err error
			it.Manufacturer, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "serial":
			var err error
			it.Serial, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "family":
			var err error
			it.Family, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosVersion":
			var err error
			it.BiosVersion, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "biosSerial":
			var err error
			it.BiosSerial, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_device_user_bool_exp(ctx context.Context, obj interface{}) (AdapterDeviceUserBoolExp, error) {
	var it AdapterDeviceUserBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "deviceId":
			var err error
			it.DeviceID, err = ec.unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "sid":
			var err error
			it.Sid, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "username":
			var err error
			it.Username, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastUseDate":
			var err error
			it.LastUseDate, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "isLocal":
			var err error
			it.IsLocal, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "isDisabled":
			var err error
			it.IsDisabled, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAdmin":
			var err error
			it.IsAdmin, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "userDepartment":
			var err error
			it.UserDepartment, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordMaxAge":
			var err error
			it.PasswordMaxAge, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "interpreter":
			var err error
			it.Interpreter, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputadapter_user_bool_exp(ctx context.Context, obj interface{}) (AdapterUserBoolExp, error) {
	var it AdapterUserBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle":
			var err error
			it.FetchCycle, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterId":
			var err error
			it.AdapterID, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapter":
			var err error
			it.Adapter, err = ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterName":
			var err error
			it.AdapterName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId":
			var err error
			it.UserID, err = ec.unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterData":
			var err error
			it.AdapterData, err = ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchTime":
			var err error
			it.FetchTime, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen":
			var err error
			it.LastSeen, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "username":
			var err error
			it.Username, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayName":
			var err error
			it.DisplayName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "domain":
			var err error
			it.Domain, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "userSid":
			var err error
			it.UserSid, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstName":
			var err error
			it.FirstName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastName":
			var err error
			it.LastName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "mail":
			var err error
			it.Mail, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "admin":
			var err error
			it.Admin, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "local":
			var err error
			it.Local, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "delegatedAdmin":
			var err error
			it.DelegatedAdmin, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfaEnforced":
			var err error
			it.MfaEnforced, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "mfaEnrolled":
			var err error
			it.MfaEnrolled, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "suspended":
			var err error
			it.Suspended, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "locked":
			var err error
			it.Locked, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "disabled":
			var err error
			it.Disabled, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_group_bool_exp(ctx context.Context, obj interface{}) (CsGroupBoolExp, error) {
	var it CsGroupBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy":
			var err error
			it.CreatedBy, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTimestamp":
			var err error
			it.CreatedTimestamp, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupType":
			var err error
			it.GroupType, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedBy":
			var err error
			it.ModifiedBy, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "modifiedTime":
			var err error
			it.ModifiedTime, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_policy_bool_exp(ctx context.Context, obj interface{}) (CsPolicyBoolExp, error) {
	var it CsPolicyBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName":
			var err error
			it.PlatformName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "groups":
			var err error
			it.Groups, err = ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "enabled":
			var err error
			it.Enabled, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy":
			var err error
			it.CreatedBy, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdTime":
			var err error
			it.CreatedTime, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "preventionSettings":
			var err error
			it.PreventionSettings, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "sensorUpdateSettings":
			var err error
			it.SensorUpdateSettings, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_policy_settings_bool_exp(ctx context.Context, obj interface{}) (CsPolicySettingsBoolExp, error) {
	var it CsPolicySettingsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "enabled":
			var err error
			it.Enabled, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_prevention_settings_bool_exp(ctx context.Context, obj interface{}) (CsPreventionSettingsBoolExp, error) {
	var it CsPreventionSettingsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "settings":
			var err error
			it.Settings, err = ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputcs_sensor_update_settings_bool_exp(ctx context.Context, obj interface{}) (CsSensorUpdateSettingsBoolExp, error) {
	var it CsSensorUpdateSettingsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "build":
			var err error
			it.Build, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputdevice_bool_exp(ctx context.Context, obj interface{}) (DeviceBoolExp, error) {
	var it DeviceBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle":
			var err error
			it.FetchCycle, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount":
			var err error
			it.AdapterCount, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames":
			var err error
			it.AdapterNames, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "hostnames":
			var err error
			it.Hostnames, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen":
			var err error
			it.LastSeen, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterDevices":
			var err error
			it.AdapterDevices, err = ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "interfaces":
			var err error
			it.Interfaces, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			it.Tags, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputfirewall_rule_bool_exp(ctx context.Context, obj interface{}) (FirewallRuleBoolExp, error) {
	var it FirewallRuleBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "source":
			var err error
			it.Source, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOAccessTypeComparator2bandicootpkggqlAccessTypeComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "direction":
			var err error
			it.Direction, err = ec.unmarshalODirectionComparator2bandicootpkggqlDirectionComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "target":
			var err error
			it.Target, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol":
			var err error
			it.Protocol, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "srcPort":
			var err error
			it.SrcPort, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "dstPort":
			var err error
			it.DstPort, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputgce_tags_bool_exp(ctx context.Context, obj interface{}) (GceTagsBoolExp, error) {
	var it GceTagsBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "gceKey":
			var err error
			it.GceKey, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "gceValue":
			var err error
			it.GceValue, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputinstalled_software_bool_exp(ctx context.Context, obj interface{}) (InstalledSoftwareBoolExp, error) {
	var it InstalledSoftwareBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "version":
			var err error
			it.Version, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture":
			var err error
			it.Architecture, err = ec.unmarshalOArchitectureComparator2bandicootpkggqlArchitectureComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "vendor":
			var err error
			it.Vendor, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "publisher":
			var err error
			it.Publisher, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "cveCount":
			var err error
			it.CveCount, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "swLicense":
			var err error
			it.SwLicense, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "path":
			var err error
			it.Path, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputnetwork_interface_bool_exp(ctx context.Context, obj interface{}) (NetworkInterfaceBoolExp, error) {
	var it NetworkInterfaceBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "deviceId":
			var err error
			it.DeviceID, err = ec.unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "macAddr":
			var err error
			it.MacAddr, err = ec.unmarshalOMacComparator2bandicootpkggqlMacComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "ipAddrs":
			var err error
			it.IPAddrs, err = ec.unmarshalOIPArrayComparator2bandicootpkggqlIPArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "manufacturer":
			var err error
			it.Manufacturer, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "operationalStatus":
			var err error
			it.OperationalStatus, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adminStatus":
			var err error
			it.AdminStatus, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "portType":
			var err error
			it.PortType, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "mtu":
			var err error
			it.Mtu, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "gateway":
			var err error
			it.Gateway, err = ec.unmarshalOIPComparator2bandicootpkggqlIPComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "port":
			var err error
			it.Port, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "vlans":
			var err error
			it.Vlans, err = ec.unmarshalOnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputnetwork_interface_vlan_bool_exp(ctx context.Context, obj interface{}) (NetworkInterfaceVlanBoolExp, error) {
	var it NetworkInterfaceVlanBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "macAddr":
			var err error
			it.MacAddr, err = ec.unmarshalOMacComparator2bandicootpkggqlMacComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagId":
			var err error
			it.TagID, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagged":
			var err error
			it.Tagged, err = ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputoperating_system_bool_exp(ctx context.Context, obj interface{}) (OperatingSystemBoolExp, error) {
	var it OperatingSystemBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "distribution":
			var err error
			it.Distribution, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "architecture":
			var err error
			it.Architecture, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "servicePack":
			var err error
			it.ServicePack, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "installDate":
			var err error
			it.InstallDate, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "kernelVersion":
			var err error
			it.KernelVersion, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "codeName":
			var err error
			it.CodeName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "major":
			var err error
			it.Major, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "minor":
			var err error
			it.Minor, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "build":
			var err error
			it.Build, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawName":
			var err error
			it.RawName, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputtag_bool_exp(ctx context.Context, obj interface{}) (TagBoolExp, error) {
	var it TagBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "creator":
			var err error
			it.Creator, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "level":
			var err error
			it.Level, err = ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputuser_bool_exp(ctx context.Context, obj interface{}) (UserBoolExp, error) {
	var it UserBoolExp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetchCycle":
			var err error
			it.FetchCycle, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterCount":
			var err error
			it.AdapterCount, err = ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterNames":
			var err error
			it.AdapterNames, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernames":
			var err error
			it.Usernames, err = ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSeen":
			var err error
			it.LastSeen, err = ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
			if err != nil {
				return it, err
			}
		case "adapterUsers":
			var err error
			it.AdapterUsers, err = ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _AdapterData(ctx context.Context, sel ast.SelectionSet, obj AdapterData) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case ActiveDirectoryData:
		return ec._ActiveDirectoryData(ctx, sel, &obj)
	case *ActiveDirectoryData:
		if obj == nil {
			return graphql.Null
		}
		return ec._ActiveDirectoryData(ctx, sel, obj)
	case CylanceData:
		return ec._CylanceData(ctx, sel, &obj)
	case *CylanceData:
		if obj == nil {
			return graphql.Null
		}
		return ec._CylanceData(ctx, sel, obj)
	case CrowdStrikeData:
		return ec._CrowdStrikeData(ctx, sel, &obj)
	case *CrowdStrikeData:
		if obj == nil {
			return graphql.Null
		}
		return ec._CrowdStrikeData(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Aggregate(ctx context.Context, sel ast.SelectionSet, obj Aggregate) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Filter(ctx context.Context, sel ast.SelectionSet, obj Filter) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case ObjectFilter:
		return ec._ObjectFilter(ctx, sel, &obj)
	case *ObjectFilter:
		if obj == nil {
			return graphql.Null
		}
		return ec._ObjectFilter(ctx, sel, obj)
	case Operator:
		return ec._Operator(ctx, sel, &obj)
	case *Operator:
		if obj == nil {
			return graphql.Null
		}
		return ec._Operator(ctx, sel, obj)
	case ScalarFilter:
		return ec._ScalarFilter(ctx, sel, &obj)
	case *ScalarFilter:
		if obj == nil {
			return graphql.Null
		}
		return ec._ScalarFilter(ctx, sel, obj)
	case UnionFilter:
		return ec._UnionFilter(ctx, sel, &obj)
	case *UnionFilter:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnionFilter(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var activeDirectoryDataImplementors = []string{"ActiveDirectoryData", "AdapterData"}

func (ec *executionContext) _ActiveDirectoryData(ctx context.Context, sel ast.SelectionSet, obj *ActiveDirectoryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, activeDirectoryDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActiveDirectoryData")
		case "adCn":
			out.Values[i] = ec._ActiveDirectoryData_adCn(ctx, field, obj)
		case "adSid":
			out.Values[i] = ec._ActiveDirectoryData_adSid(ctx, field, obj)
		case "adGuid":
			out.Values[i] = ec._ActiveDirectoryData_adGuid(ctx, field, obj)
		case "adName":
			out.Values[i] = ec._ActiveDirectoryData_adName(ctx, field, obj)
		case "adSAMAccountName":
			out.Values[i] = ec._ActiveDirectoryData_adSAMAccountName(ctx, field, obj)
		case "adUserPrincipalName":
			out.Values[i] = ec._ActiveDirectoryData_adUserPrincipalName(ctx, field, obj)
		case "adDisplayName":
			out.Values[i] = ec._ActiveDirectoryData_adDisplayName(ctx, field, obj)
		case "adDistinguishedName":
			out.Values[i] = ec._ActiveDirectoryData_adDistinguishedName(ctx, field, obj)
		case "adCanonicalName":
			out.Values[i] = ec._ActiveDirectoryData_adCanonicalName(ctx, field, obj)
		case "adAccountExpires":
			out.Values[i] = ec._ActiveDirectoryData_adAccountExpires(ctx, field, obj)
		case "adObjectClass":
			out.Values[i] = ec._ActiveDirectoryData_adObjectClass(ctx, field, obj)
		case "adObjectCategory":
			out.Values[i] = ec._ActiveDirectoryData_adObjectCategory(ctx, field, obj)
		case "adOrganizationalUnit":
			out.Values[i] = ec._ActiveDirectoryData_adOrganizationalUnit(ctx, field, obj)
		case "adLastLogoff":
			out.Values[i] = ec._ActiveDirectoryData_adLastLogoff(ctx, field, obj)
		case "adLastLogon":
			out.Values[i] = ec._ActiveDirectoryData_adLastLogon(ctx, field, obj)
		case "adLastLogonTimestamp":
			out.Values[i] = ec._ActiveDirectoryData_adLastLogonTimestamp(ctx, field, obj)
		case "adBadPasswordTime":
			out.Values[i] = ec._ActiveDirectoryData_adBadPasswordTime(ctx, field, obj)
		case "ad_bad_pwd_count":
			out.Values[i] = ec._ActiveDirectoryData_ad_bad_pwd_count(ctx, field, obj)
		case "adManagedBy":
			out.Values[i] = ec._ActiveDirectoryData_adManagedBy(ctx, field, obj)
		case "adPasswordLastSet":
			out.Values[i] = ec._ActiveDirectoryData_adPasswordLastSet(ctx, field, obj)
		case "adPrimaryGroupId":
			out.Values[i] = ec._ActiveDirectoryData_adPrimaryGroupId(ctx, field, obj)
		case "adPrimaryGroupDn":
			out.Values[i] = ec._ActiveDirectoryData_adPrimaryGroupDn(ctx, field, obj)
		case "adMemberOf":
			out.Values[i] = ec._ActiveDirectoryData_adMemberOf(ctx, field, obj)
		case "adMemberOfFull":
			out.Values[i] = ec._ActiveDirectoryData_adMemberOfFull(ctx, field, obj)
		case "adUsnChanged":
			out.Values[i] = ec._ActiveDirectoryData_adUsnChanged(ctx, field, obj)
		case "adUsnCreated":
			out.Values[i] = ec._ActiveDirectoryData_adUsnCreated(ctx, field, obj)
		case "adWhenChanged":
			out.Values[i] = ec._ActiveDirectoryData_adWhenChanged(ctx, field, obj)
		case "adWhenCreated":
			out.Values[i] = ec._ActiveDirectoryData_adWhenCreated(ctx, field, obj)
		case "adIsCriticalSystemObject":
			out.Values[i] = ec._ActiveDirectoryData_adIsCriticalSystemObject(ctx, field, obj)
		case "adMsdsAllowedToDelegateTo":
			out.Values[i] = ec._ActiveDirectoryData_adMsdsAllowedToDelegateTo(ctx, field, obj)
		case "adPwdMustChange":
			out.Values[i] = ec._ActiveDirectoryData_adPwdMustChange(ctx, field, obj)
		case "adMsdsResultantPso":
			out.Values[i] = ec._ActiveDirectoryData_adMsdsResultantPso(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterImplementors = []string{"Adapter"}

func (ec *executionContext) _Adapter(ctx context.Context, sel ast.SelectionSet, obj *Adapter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Adapter")
		case "id":
			out.Values[i] = ec._Adapter_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Adapter_name(ctx, field, obj)
		case "properties":
			out.Values[i] = ec._Adapter_properties(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDeviceImplementors = []string{"AdapterDevice"}

func (ec *executionContext) _AdapterDevice(ctx context.Context, sel ast.SelectionSet, obj *AdapterDevice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDeviceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterDevice")
		case "id":
			out.Values[i] = ec._AdapterDevice_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._AdapterDevice_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterId":
			out.Values[i] = ec._AdapterDevice_adapterId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapter":
			out.Values[i] = ec._AdapterDevice_adapter(ctx, field, obj)
		case "adapterName":
			out.Values[i] = ec._AdapterDevice_adapterName(ctx, field, obj)
		case "deviceId":
			out.Values[i] = ec._AdapterDevice_deviceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdapterDevice_adapterData(ctx, field, obj)
				return res
			})
		case "data":
			out.Values[i] = ec._AdapterDevice_data(ctx, field, obj)
		case "fetchTime":
			out.Values[i] = ec._AdapterDevice_fetchTime(ctx, field, obj)
		case "hostname":
			out.Values[i] = ec._AdapterDevice_hostname(ctx, field, obj)
		case "name":
			out.Values[i] = ec._AdapterDevice_name(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._AdapterDevice_lastSeen(ctx, field, obj)
		case "osId":
			out.Values[i] = ec._AdapterDevice_osId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "os":
			out.Values[i] = ec._AdapterDevice_os(ctx, field, obj)
		case "prettyId":
			out.Values[i] = ec._AdapterDevice_prettyId(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._AdapterDevice_tags(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec._AdapterDevice_interfaces(ctx, field, obj)
		case "lastUsedUsers":
			out.Values[i] = ec._AdapterDevice_lastUsedUsers(ctx, field, obj)
		case "domain":
			out.Values[i] = ec._AdapterDevice_domain(ctx, field, obj)
		case "partOfDomain":
			out.Values[i] = ec._AdapterDevice_partOfDomain(ctx, field, obj)
		case "deviceUsers":
			out.Values[i] = ec._AdapterDevice_deviceUsers(ctx, field, obj)
		case "localAdmins":
			out.Values[i] = ec._AdapterDevice_localAdmins(ctx, field, obj)
		case "firewallRules":
			out.Values[i] = ec._AdapterDevice_firewallRules(ctx, field, obj)
		case "installedSoftware":
			out.Values[i] = ec._AdapterDevice_installedSoftware(ctx, field, obj)
		case "agentVersion":
			out.Values[i] = ec._AdapterDevice_agentVersion(ctx, field, obj)
		case "agentStatus":
			out.Values[i] = ec._AdapterDevice_agentStatus(ctx, field, obj)
		case "agentName":
			out.Values[i] = ec._AdapterDevice_agentName(ctx, field, obj)
		case "model":
			out.Values[i] = ec._AdapterDevice_model(ctx, field, obj)
		case "manufacturer":
			out.Values[i] = ec._AdapterDevice_manufacturer(ctx, field, obj)
		case "serial":
			out.Values[i] = ec._AdapterDevice_serial(ctx, field, obj)
		case "family":
			out.Values[i] = ec._AdapterDevice_family(ctx, field, obj)
		case "biosVersion":
			out.Values[i] = ec._AdapterDevice_biosVersion(ctx, field, obj)
		case "biosSerial":
			out.Values[i] = ec._AdapterDevice_biosSerial(ctx, field, obj)
		case "tags_aggregate":
			out.Values[i] = ec._AdapterDevice_tags_aggregate(ctx, field, obj)
		case "interfaces_aggregate":
			out.Values[i] = ec._AdapterDevice_interfaces_aggregate(ctx, field, obj)
		case "firewallRules_aggregate":
			out.Values[i] = ec._AdapterDevice_firewallRules_aggregate(ctx, field, obj)
		case "installedSoftware_aggregate":
			out.Values[i] = ec._AdapterDevice_installedSoftware_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDeviceAdminImplementors = []string{"AdapterDeviceAdmin"}

func (ec *executionContext) _AdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, obj *AdapterDeviceAdmin) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDeviceAdminImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterDeviceAdmin")
		case "name":
			out.Values[i] = ec._AdapterDeviceAdmin_name(ctx, field, obj)
		case "type":
			out.Values[i] = ec._AdapterDeviceAdmin_type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDeviceUserImplementors = []string{"AdapterDeviceUser"}

func (ec *executionContext) _AdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, obj *AdapterDeviceUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDeviceUserImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterDeviceUser")
		case "deviceId":
			out.Values[i] = ec._AdapterDeviceUser_deviceId(ctx, field, obj)
		case "sid":
			out.Values[i] = ec._AdapterDeviceUser_sid(ctx, field, obj)
		case "username":
			out.Values[i] = ec._AdapterDeviceUser_username(ctx, field, obj)
		case "lastUseDate":
			out.Values[i] = ec._AdapterDeviceUser_lastUseDate(ctx, field, obj)
		case "isLocal":
			out.Values[i] = ec._AdapterDeviceUser_isLocal(ctx, field, obj)
		case "isDisabled":
			out.Values[i] = ec._AdapterDeviceUser_isDisabled(ctx, field, obj)
		case "isAdmin":
			out.Values[i] = ec._AdapterDeviceUser_isAdmin(ctx, field, obj)
		case "userDepartment":
			out.Values[i] = ec._AdapterDeviceUser_userDepartment(ctx, field, obj)
		case "passwordMaxAge":
			out.Values[i] = ec._AdapterDeviceUser_passwordMaxAge(ctx, field, obj)
		case "interpreter":
			out.Values[i] = ec._AdapterDeviceUser_interpreter(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterUserImplementors = []string{"AdapterUser"}

func (ec *executionContext) _AdapterUser(ctx context.Context, sel ast.SelectionSet, obj *AdapterUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterUserImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdapterUser")
		case "id":
			out.Values[i] = ec._AdapterUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._AdapterUser_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterId":
			out.Values[i] = ec._AdapterUser_adapterId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapter":
			out.Values[i] = ec._AdapterUser_adapter(ctx, field, obj)
		case "adapterName":
			out.Values[i] = ec._AdapterUser_adapterName(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._AdapterUser_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdapterUser_adapterData(ctx, field, obj)
				return res
			})
		case "data":
			out.Values[i] = ec._AdapterUser_data(ctx, field, obj)
		case "fetchTime":
			out.Values[i] = ec._AdapterUser_fetchTime(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._AdapterUser_lastSeen(ctx, field, obj)
		case "username":
			out.Values[i] = ec._AdapterUser_username(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._AdapterUser_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._AdapterUser_description(ctx, field, obj)
		case "domain":
			out.Values[i] = ec._AdapterUser_domain(ctx, field, obj)
		case "userSid":
			out.Values[i] = ec._AdapterUser_userSid(ctx, field, obj)
		case "firstName":
			out.Values[i] = ec._AdapterUser_firstName(ctx, field, obj)
		case "lastName":
			out.Values[i] = ec._AdapterUser_lastName(ctx, field, obj)
		case "mail":
			out.Values[i] = ec._AdapterUser_mail(ctx, field, obj)
		case "admin":
			out.Values[i] = ec._AdapterUser_admin(ctx, field, obj)
		case "local":
			out.Values[i] = ec._AdapterUser_local(ctx, field, obj)
		case "delegatedAdmin":
			out.Values[i] = ec._AdapterUser_delegatedAdmin(ctx, field, obj)
		case "mfaEnforced":
			out.Values[i] = ec._AdapterUser_mfaEnforced(ctx, field, obj)
		case "mfaEnrolled":
			out.Values[i] = ec._AdapterUser_mfaEnrolled(ctx, field, obj)
		case "suspended":
			out.Values[i] = ec._AdapterUser_suspended(ctx, field, obj)
		case "locked":
			out.Values[i] = ec._AdapterUser_locked(ctx, field, obj)
		case "disabled":
			out.Values[i] = ec._AdapterUser_disabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cPUImplementors = []string{"CPU"}

func (ec *executionContext) _CPU(ctx context.Context, sel ast.SelectionSet, obj *CPU) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cPUImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CPU")
		case "id":
			out.Values[i] = ec._CPU_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._CPU_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manfacturer":
			out.Values[i] = ec._CPU_manfacturer(ctx, field, obj)
		case "bitness":
			out.Values[i] = ec._CPU_bitness(ctx, field, obj)
		case "family":
			out.Values[i] = ec._CPU_family(ctx, field, obj)
		case "cores":
			out.Values[i] = ec._CPU_cores(ctx, field, obj)
		case "coresThreads":
			out.Values[i] = ec._CPU_coresThreads(ctx, field, obj)
		case "ghz":
			out.Values[i] = ec._CPU_ghz(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var crowdStrikeDataImplementors = []string{"CrowdStrikeData", "AdapterData"}

func (ec *executionContext) _CrowdStrikeData(ctx context.Context, sel ast.SelectionSet, obj *CrowdStrikeData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, crowdStrikeDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CrowdStrikeData")
		case "externalIp":
			out.Values[i] = ec._CrowdStrikeData_externalIp(ctx, field, obj)
		case "groups":
			out.Values[i] = ec._CrowdStrikeData_groups(ctx, field, obj)
		case "preventionPolicy":
			out.Values[i] = ec._CrowdStrikeData_preventionPolicy(ctx, field, obj)
		case "sensorUpdatePolicy":
			out.Values[i] = ec._CrowdStrikeData_sensorUpdatePolicy(ctx, field, obj)
		case "csAgentVersion":
			out.Values[i] = ec._CrowdStrikeData_csAgentVersion(ctx, field, obj)
		case "groups_aggregate":
			out.Values[i] = ec._CrowdStrikeData_groups_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cylanceDataImplementors = []string{"CylanceData", "AdapterData"}

func (ec *executionContext) _CylanceData(ctx context.Context, sel ast.SelectionSet, obj *CylanceData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cylanceDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CylanceData")
		case "isSafe":
			out.Values[i] = ec._CylanceData_isSafe(ctx, field, obj)
		case "deviceState":
			out.Values[i] = ec._CylanceData_deviceState(ctx, field, obj)
		case "policyId":
			out.Values[i] = ec._CylanceData_policyId(ctx, field, obj)
		case "policyName":
			out.Values[i] = ec._CylanceData_policyName(ctx, field, obj)
		case "policiesDetails":
			out.Values[i] = ec._CylanceData_policiesDetails(ctx, field, obj)
		case "tenantTag":
			out.Values[i] = ec._CylanceData_tenantTag(ctx, field, obj)
		case "zoneNames":
			out.Values[i] = ec._CylanceData_zoneNames(ctx, field, obj)
		case "agentVersion":
			out.Values[i] = ec._CylanceData_agentVersion(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deviceImplementors = []string{"Device"}

func (ec *executionContext) _Device(ctx context.Context, sel ast.SelectionSet, obj *Device) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deviceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Device")
		case "id":
			out.Values[i] = ec._Device_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._Device_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterCount":
			out.Values[i] = ec._Device_adapterCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterNames":
			out.Values[i] = ec._Device_adapterNames(ctx, field, obj)
		case "hostnames":
			out.Values[i] = ec._Device_hostnames(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._Device_lastSeen(ctx, field, obj)
		case "adapterDevices":
			out.Values[i] = ec._Device_adapterDevices(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec._Device_interfaces(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._Device_tags(ctx, field, obj)
		case "_compatibilityAPI":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Device__compatibilityAPI(ctx, field, obj)
				return res
			})
		case "adapterDevices_aggregate":
			out.Values[i] = ec._Device_adapterDevices_aggregate(ctx, field, obj)
		case "interfaces_aggregate":
			out.Values[i] = ec._Device_interfaces_aggregate(ctx, field, obj)
		case "tags_aggregate":
			out.Values[i] = ec._Device_tags_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var firewallRuleImplementors = []string{"FirewallRule"}

func (ec *executionContext) _FirewallRule(ctx context.Context, sel ast.SelectionSet, obj *FirewallRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, firewallRuleImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FirewallRule")
		case "name":
			out.Values[i] = ec._FirewallRule_name(ctx, field, obj)
		case "source":
			out.Values[i] = ec._FirewallRule_source(ctx, field, obj)
		case "type":
			out.Values[i] = ec._FirewallRule_type(ctx, field, obj)
		case "direction":
			out.Values[i] = ec._FirewallRule_direction(ctx, field, obj)
		case "target":
			out.Values[i] = ec._FirewallRule_target(ctx, field, obj)
		case "protocol":
			out.Values[i] = ec._FirewallRule_protocol(ctx, field, obj)
		case "srcPort":
			out.Values[i] = ec._FirewallRule_srcPort(ctx, field, obj)
		case "dstPort":
			out.Values[i] = ec._FirewallRule_dstPort(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gCETagsAggregateImplementors = []string{"GCETagsAggregate"}

func (ec *executionContext) _GCETagsAggregate(ctx context.Context, sel ast.SelectionSet, obj *GCETagsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gCETagsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GCETagsAggregate")
		case "group":
			out.Values[i] = ec._GCETagsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._GCETagsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._GCETagsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._GCETagsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._GCETagsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._GCETagsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._GCETagsAggregate_max(ctx, field, obj)
		case "GCETags":
			out.Values[i] = ec._GCETagsAggregate_GCETags(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gceTagsImplementors = []string{"GceTags"}

func (ec *executionContext) _GceTags(ctx context.Context, sel ast.SelectionSet, obj *GceTags) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gceTagsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GceTags")
		case "gceKey":
			out.Values[i] = ec._GceTags_gceKey(ctx, field, obj)
		case "gceValue":
			out.Values[i] = ec._GceTags_gceValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var googleCloudDataImplementors = []string{"GoogleCloudData"}

func (ec *executionContext) _GoogleCloudData(ctx context.Context, sel ast.SelectionSet, obj *GoogleCloudData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, googleCloudDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GoogleCloudData")
		case "Id":
			out.Values[i] = ec._GoogleCloudData_Id(ctx, field, obj)
		case "Size":
			out.Values[i] = ec._GoogleCloudData_Size(ctx, field, obj)
		case "Image":
			out.Values[i] = ec._GoogleCloudData_Image(ctx, field, obj)
		case "GCETags":
			out.Values[i] = ec._GoogleCloudData_GCETags(ctx, field, obj)
		case "GCETags_aggregate":
			out.Values[i] = ec._GoogleCloudData_GCETags_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var installedSoftwareImplementors = []string{"InstalledSoftware"}

func (ec *executionContext) _InstalledSoftware(ctx context.Context, sel ast.SelectionSet, obj *InstalledSoftware) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, installedSoftwareImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InstalledSoftware")
		case "name":
			out.Values[i] = ec._InstalledSoftware_name(ctx, field, obj)
		case "version":
			out.Values[i] = ec._InstalledSoftware_version(ctx, field, obj)
		case "architecture":
			out.Values[i] = ec._InstalledSoftware_architecture(ctx, field, obj)
		case "description":
			out.Values[i] = ec._InstalledSoftware_description(ctx, field, obj)
		case "vendor":
			out.Values[i] = ec._InstalledSoftware_vendor(ctx, field, obj)
		case "publisher":
			out.Values[i] = ec._InstalledSoftware_publisher(ctx, field, obj)
		case "cveCount":
			out.Values[i] = ec._InstalledSoftware_cveCount(ctx, field, obj)
		case "swLicense":
			out.Values[i] = ec._InstalledSoftware_swLicense(ctx, field, obj)
		case "path":
			out.Values[i] = ec._InstalledSoftware_path(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var networkInterfaceImplementors = []string{"NetworkInterface"}

func (ec *executionContext) _NetworkInterface(ctx context.Context, sel ast.SelectionSet, obj *NetworkInterface) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkInterfaceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkInterface")
		case "deviceId":
			out.Values[i] = ec._NetworkInterface_deviceId(ctx, field, obj)
		case "macAddr":
			out.Values[i] = ec._NetworkInterface_macAddr(ctx, field, obj)
		case "ipAddrs":
			out.Values[i] = ec._NetworkInterface_ipAddrs(ctx, field, obj)
		case "name":
			out.Values[i] = ec._NetworkInterface_name(ctx, field, obj)
		case "manufacturer":
			out.Values[i] = ec._NetworkInterface_manufacturer(ctx, field, obj)
		case "subnets":
			out.Values[i] = ec._NetworkInterface_subnets(ctx, field, obj)
		case "operationalStatus":
			out.Values[i] = ec._NetworkInterface_operationalStatus(ctx, field, obj)
		case "adminStatus":
			out.Values[i] = ec._NetworkInterface_adminStatus(ctx, field, obj)
		case "portType":
			out.Values[i] = ec._NetworkInterface_portType(ctx, field, obj)
		case "mtu":
			out.Values[i] = ec._NetworkInterface_mtu(ctx, field, obj)
		case "gateway":
			out.Values[i] = ec._NetworkInterface_gateway(ctx, field, obj)
		case "port":
			out.Values[i] = ec._NetworkInterface_port(ctx, field, obj)
		case "vlans":
			out.Values[i] = ec._NetworkInterface_vlans(ctx, field, obj)
		case "vlans_aggregate":
			out.Values[i] = ec._NetworkInterface_vlans_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var networkInterfaceVlanImplementors = []string{"NetworkInterfaceVlan"}

func (ec *executionContext) _NetworkInterfaceVlan(ctx context.Context, sel ast.SelectionSet, obj *NetworkInterfaceVlan) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkInterfaceVlanImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkInterfaceVlan")
		case "macAddr":
			out.Values[i] = ec._NetworkInterfaceVlan_macAddr(ctx, field, obj)
		case "name":
			out.Values[i] = ec._NetworkInterfaceVlan_name(ctx, field, obj)
		case "tagId":
			out.Values[i] = ec._NetworkInterfaceVlan_tagId(ctx, field, obj)
		case "tagged":
			out.Values[i] = ec._NetworkInterfaceVlan_tagged(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var objectFilterImplementors = []string{"ObjectFilter", "Filter"}

func (ec *executionContext) _ObjectFilter(ctx context.Context, sel ast.SelectionSet, obj *ObjectFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, objectFilterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObjectFilter")
		case "name":
			out.Values[i] = ec._ObjectFilter_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "displayName":
			out.Values[i] = ec._ObjectFilter_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec._ObjectFilter_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._ObjectFilter_description(ctx, field, obj)
		case "filters":
			out.Values[i] = ec._ObjectFilter_filters(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var operatingSystemImplementors = []string{"OperatingSystem"}

func (ec *executionContext) _OperatingSystem(ctx context.Context, sel ast.SelectionSet, obj *OperatingSystem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, operatingSystemImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperatingSystem")
		case "id":
			out.Values[i] = ec._OperatingSystem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec._OperatingSystem_type(ctx, field, obj)
		case "distribution":
			out.Values[i] = ec._OperatingSystem_distribution(ctx, field, obj)
		case "architecture":
			out.Values[i] = ec._OperatingSystem_architecture(ctx, field, obj)
		case "servicePack":
			out.Values[i] = ec._OperatingSystem_servicePack(ctx, field, obj)
		case "installDate":
			out.Values[i] = ec._OperatingSystem_installDate(ctx, field, obj)
		case "kernelVersion":
			out.Values[i] = ec._OperatingSystem_kernelVersion(ctx, field, obj)
		case "codeName":
			out.Values[i] = ec._OperatingSystem_codeName(ctx, field, obj)
		case "major":
			out.Values[i] = ec._OperatingSystem_major(ctx, field, obj)
		case "minor":
			out.Values[i] = ec._OperatingSystem_minor(ctx, field, obj)
		case "build":
			out.Values[i] = ec._OperatingSystem_build(ctx, field, obj)
		case "rawName":
			out.Values[i] = ec._OperatingSystem_rawName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var operatorImplementors = []string{"Operator", "Filter"}

func (ec *executionContext) _Operator(ctx context.Context, sel ast.SelectionSet, obj *Operator) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, operatorImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Operator")
		case "name":
			out.Values[i] = ec._Operator_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec._Operator_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "displayName":
			out.Values[i] = ec._Operator_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Operator_description(ctx, field, obj)
		case "formatDisplay":
			out.Values[i] = ec._Operator_formatDisplay(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "adapterDevices":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterDevices(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "devices":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_devices(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "adapterUsers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "users":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_wizardFilters":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__wizardFilters(ctx, field)
				return res
			})
		case "adapterDevices_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterDevices_aggregate(ctx, field)
				return res
			})
		case "devices_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_devices_aggregate(ctx, field)
				return res
			})
		case "adapterUsers_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adapterUsers_aggregate(ctx, field)
				return res
			})
		case "users_aggregate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users_aggregate(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var scalarFilterImplementors = []string{"ScalarFilter", "Filter"}

func (ec *executionContext) _ScalarFilter(ctx context.Context, sel ast.SelectionSet, obj *ScalarFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scalarFilterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScalarFilter")
		case "name":
			out.Values[i] = ec._ScalarFilter_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "displayName":
			out.Values[i] = ec._ScalarFilter_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._ScalarFilter_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec._ScalarFilter_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "operators":
			out.Values[i] = ec._ScalarFilter_operators(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var storageImplementors = []string{"Storage"}

func (ec *executionContext) _Storage(ctx context.Context, sel ast.SelectionSet, obj *Storage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Storage")
		case "deviceId":
			out.Values[i] = ec._Storage_deviceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "path":
			out.Values[i] = ec._Storage_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Storage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalSize":
			out.Values[i] = ec._Storage_totalSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "freeSize":
			out.Values[i] = ec._Storage_freeSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isEncrypted":
			out.Values[i] = ec._Storage_isEncrypted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Storage_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagImplementors = []string{"Tag"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "name":
			out.Values[i] = ec._Tag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "creator":
			out.Values[i] = ec._Tag_creator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "level":
			out.Values[i] = ec._Tag_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var unionFilterImplementors = []string{"UnionFilter", "Filter"}

func (ec *executionContext) _UnionFilter(ctx context.Context, sel ast.SelectionSet, obj *UnionFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unionFilterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnionFilter")
		case "name":
			out.Values[i] = ec._UnionFilter_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "displayName":
			out.Values[i] = ec._UnionFilter_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec._UnionFilter_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._UnionFilter_description(ctx, field, obj)
		case "objects":
			out.Values[i] = ec._UnionFilter_objects(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetchCycle":
			out.Values[i] = ec._User_fetchCycle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterCount":
			out.Values[i] = ec._User_adapterCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adapterNames":
			out.Values[i] = ec._User_adapterNames(ctx, field, obj)
		case "usernames":
			out.Values[i] = ec._User_usernames(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._User_lastSeen(ctx, field, obj)
		case "adapterUsers":
			out.Values[i] = ec._User_adapterUsers(ctx, field, obj)
		case "_compatibilityAPI":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User__compatibilityAPI(ctx, field, obj)
				return res
			})
		case "adapterUsers_aggregate":
			out.Values[i] = ec._User_adapterUsers_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterDevicesAggregateImplementors = []string{"adapterDevicesAggregate"}

func (ec *executionContext) _adapterDevicesAggregate(ctx context.Context, sel ast.SelectionSet, obj *AdapterDevicesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterDevicesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("adapterDevicesAggregate")
		case "group":
			out.Values[i] = ec._adapterDevicesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._adapterDevicesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._adapterDevicesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._adapterDevicesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._adapterDevicesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._adapterDevicesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._adapterDevicesAggregate_max(ctx, field, obj)
		case "adapterDevices":
			out.Values[i] = ec._adapterDevicesAggregate_adapterDevices(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adapterUsersAggregateImplementors = []string{"adapterUsersAggregate"}

func (ec *executionContext) _adapterUsersAggregate(ctx context.Context, sel ast.SelectionSet, obj *AdapterUsersAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adapterUsersAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("adapterUsersAggregate")
		case "group":
			out.Values[i] = ec._adapterUsersAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._adapterUsersAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._adapterUsersAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._adapterUsersAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._adapterUsersAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._adapterUsersAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._adapterUsersAggregate_max(ctx, field, obj)
		case "adapterUsers":
			out.Values[i] = ec._adapterUsersAggregate_adapterUsers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csGroupImplementors = []string{"csGroup"}

func (ec *executionContext) _csGroup(ctx context.Context, sel ast.SelectionSet, obj *CsGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csGroupImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csGroup")
		case "id":
			out.Values[i] = ec._csGroup_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._csGroup_name(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._csGroup_createdBy(ctx, field, obj)
		case "createdTimestamp":
			out.Values[i] = ec._csGroup_createdTimestamp(ctx, field, obj)
		case "description":
			out.Values[i] = ec._csGroup_description(ctx, field, obj)
		case "groupType":
			out.Values[i] = ec._csGroup_groupType(ctx, field, obj)
		case "modifiedBy":
			out.Values[i] = ec._csGroup_modifiedBy(ctx, field, obj)
		case "modifiedTime":
			out.Values[i] = ec._csGroup_modifiedTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csPolicyImplementors = []string{"csPolicy"}

func (ec *executionContext) _csPolicy(ctx context.Context, sel ast.SelectionSet, obj *CsPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csPolicy")
		case "name":
			out.Values[i] = ec._csPolicy_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._csPolicy_description(ctx, field, obj)
		case "platformName":
			out.Values[i] = ec._csPolicy_platformName(ctx, field, obj)
		case "groups":
			out.Values[i] = ec._csPolicy_groups(ctx, field, obj)
		case "enabled":
			out.Values[i] = ec._csPolicy_enabled(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._csPolicy_createdBy(ctx, field, obj)
		case "createdTime":
			out.Values[i] = ec._csPolicy_createdTime(ctx, field, obj)
		case "preventionSettings":
			out.Values[i] = ec._csPolicy_preventionSettings(ctx, field, obj)
		case "sensorUpdateSettings":
			out.Values[i] = ec._csPolicy_sensorUpdateSettings(ctx, field, obj)
		case "groups_aggregate":
			out.Values[i] = ec._csPolicy_groups_aggregate(ctx, field, obj)
		case "preventionSettings_aggregate":
			out.Values[i] = ec._csPolicy_preventionSettings_aggregate(ctx, field, obj)
		case "sensorUpdateSettings_aggregate":
			out.Values[i] = ec._csPolicy_sensorUpdateSettings_aggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csPolicySettingsImplementors = []string{"csPolicySettings"}

func (ec *executionContext) _csPolicySettings(ctx context.Context, sel ast.SelectionSet, obj *CsPolicySettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csPolicySettingsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csPolicySettings")
		case "enabled":
			out.Values[i] = ec._csPolicySettings_enabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csPreventionSettingsImplementors = []string{"csPreventionSettings"}

func (ec *executionContext) _csPreventionSettings(ctx context.Context, sel ast.SelectionSet, obj *CsPreventionSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csPreventionSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csPreventionSettings")
		case "name":
			out.Values[i] = ec._csPreventionSettings_name(ctx, field, obj)
		case "settings":
			out.Values[i] = ec._csPreventionSettings_settings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var csSensorUpdateSettingsImplementors = []string{"csSensorUpdateSettings"}

func (ec *executionContext) _csSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, obj *CsSensorUpdateSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, csSensorUpdateSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("csSensorUpdateSettings")
		case "build":
			out.Values[i] = ec._csSensorUpdateSettings_build(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var devicesAggregateImplementors = []string{"devicesAggregate"}

func (ec *executionContext) _devicesAggregate(ctx context.Context, sel ast.SelectionSet, obj *DevicesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, devicesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("devicesAggregate")
		case "group":
			out.Values[i] = ec._devicesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._devicesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._devicesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._devicesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._devicesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._devicesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._devicesAggregate_max(ctx, field, obj)
		case "devices":
			out.Values[i] = ec._devicesAggregate_devices(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var firewallRulesAggregateImplementors = []string{"firewallRulesAggregate"}

func (ec *executionContext) _firewallRulesAggregate(ctx context.Context, sel ast.SelectionSet, obj *FirewallRulesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, firewallRulesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("firewallRulesAggregate")
		case "group":
			out.Values[i] = ec._firewallRulesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._firewallRulesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._firewallRulesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._firewallRulesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._firewallRulesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._firewallRulesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._firewallRulesAggregate_max(ctx, field, obj)
		case "firewallRules":
			out.Values[i] = ec._firewallRulesAggregate_firewallRules(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var groupsAggregateImplementors = []string{"groupsAggregate"}

func (ec *executionContext) _groupsAggregate(ctx context.Context, sel ast.SelectionSet, obj *GroupsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("groupsAggregate")
		case "group":
			out.Values[i] = ec._groupsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._groupsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._groupsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._groupsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._groupsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._groupsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._groupsAggregate_max(ctx, field, obj)
		case "groups":
			out.Values[i] = ec._groupsAggregate_groups(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var installedSoftwareAggregateImplementors = []string{"installedSoftwareAggregate"}

func (ec *executionContext) _installedSoftwareAggregate(ctx context.Context, sel ast.SelectionSet, obj *InstalledSoftwareAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, installedSoftwareAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("installedSoftwareAggregate")
		case "group":
			out.Values[i] = ec._installedSoftwareAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._installedSoftwareAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._installedSoftwareAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._installedSoftwareAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._installedSoftwareAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._installedSoftwareAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._installedSoftwareAggregate_max(ctx, field, obj)
		case "installedSoftware":
			out.Values[i] = ec._installedSoftwareAggregate_installedSoftware(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfacesAggregateImplementors = []string{"interfacesAggregate"}

func (ec *executionContext) _interfacesAggregate(ctx context.Context, sel ast.SelectionSet, obj *InterfacesAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfacesAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("interfacesAggregate")
		case "group":
			out.Values[i] = ec._interfacesAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._interfacesAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._interfacesAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._interfacesAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._interfacesAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._interfacesAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._interfacesAggregate_max(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec._interfacesAggregate_interfaces(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var preventionSettingsAggregateImplementors = []string{"preventionSettingsAggregate"}

func (ec *executionContext) _preventionSettingsAggregate(ctx context.Context, sel ast.SelectionSet, obj *PreventionSettingsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preventionSettingsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("preventionSettingsAggregate")
		case "group":
			out.Values[i] = ec._preventionSettingsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._preventionSettingsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._preventionSettingsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._preventionSettingsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._preventionSettingsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._preventionSettingsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._preventionSettingsAggregate_max(ctx, field, obj)
		case "preventionSettings":
			out.Values[i] = ec._preventionSettingsAggregate_preventionSettings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sensorUpdateSettingsAggregateImplementors = []string{"sensorUpdateSettingsAggregate"}

func (ec *executionContext) _sensorUpdateSettingsAggregate(ctx context.Context, sel ast.SelectionSet, obj *SensorUpdateSettingsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sensorUpdateSettingsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("sensorUpdateSettingsAggregate")
		case "group":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_max(ctx, field, obj)
		case "sensorUpdateSettings":
			out.Values[i] = ec._sensorUpdateSettingsAggregate_sensorUpdateSettings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagsAggregateImplementors = []string{"tagsAggregate"}

func (ec *executionContext) _tagsAggregate(ctx context.Context, sel ast.SelectionSet, obj *TagsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("tagsAggregate")
		case "group":
			out.Values[i] = ec._tagsAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._tagsAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._tagsAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._tagsAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._tagsAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._tagsAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._tagsAggregate_max(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._tagsAggregate_tags(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var usersAggregateImplementors = []string{"usersAggregate"}

func (ec *executionContext) _usersAggregate(ctx context.Context, sel ast.SelectionSet, obj *UsersAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, usersAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("usersAggregate")
		case "group":
			out.Values[i] = ec._usersAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._usersAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._usersAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._usersAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._usersAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._usersAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._usersAggregate_max(ctx, field, obj)
		case "users":
			out.Values[i] = ec._usersAggregate_users(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var vlansAggregateImplementors = []string{"vlansAggregate"}

func (ec *executionContext) _vlansAggregate(ctx context.Context, sel ast.SelectionSet, obj *VlansAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vlansAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("vlansAggregate")
		case "group":
			out.Values[i] = ec._vlansAggregate_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distinct":
			out.Values[i] = ec._vlansAggregate_distinct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":
			out.Values[i] = ec._vlansAggregate_count(ctx, field, obj)
		case "sum":
			out.Values[i] = ec._vlansAggregate_sum(ctx, field, obj)
		case "avg":
			out.Values[i] = ec._vlansAggregate_avg(ctx, field, obj)
		case "min":
			out.Values[i] = ec._vlansAggregate_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._vlansAggregate_max(ctx, field, obj)
		case "vlans":
			out.Values[i] = ec._vlansAggregate_vlans(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v AdapterDevice) graphql.Marshaler {
	return ec._AdapterDevice(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v []AdapterDevice) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterDevice2bandicootpkggqlAdapterDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v AdapterUser) graphql.Marshaler {
	return ec._AdapterUser(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v []AdapterUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterUser2bandicootpkggqlAdapterUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx context.Context, v interface{}) (AggregateOrdering, error) {
	var res AggregateOrdering
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx context.Context, sel ast.SelectionSet, v AggregateOrdering) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNDevice2bandicootpkggqlDevice(ctx context.Context, sel ast.SelectionSet, v Device) graphql.Marshaler {
	return ec._Device(ctx, sel, &v)
}

func (ec *executionContext) marshalNDevice2bandicootpkggqlDevice(ctx context.Context, sel ast.SelectionSet, v []Device) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDevice2bandicootpkggqlDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNGCETagsAggregate2bandicootpkggqlGCETagsAggregate(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregate) graphql.Marshaler {
	return ec._GCETagsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx context.Context, v interface{}) (GCETagsAggregateColumns, error) {
	var res GCETagsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx context.Context, v interface{}) (GCETagsAggregateMaxColumns, error) {
	var res GCETagsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx context.Context, v interface{}) ([]GCETagsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GCETagsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETags_aggregate_max_columns2bandicootpkggqlGCETagsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx context.Context, v interface{}) (GCETagsAggregateMinColumns, error) {
	var res GCETagsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v GCETagsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx context.Context, v interface{}) ([]GCETagsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GCETagsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETags_aggregate_min_columns2bandicootpkggqlGCETagsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNIP2netIP(ctx context.Context, v interface{}) (net.IP, error) {
	return UnmarshalIPScalar(v)
}

func (ec *executionContext) marshalNIP2netIP(ctx context.Context, sel ast.SelectionSet, v net.IP) graphql.Marshaler {
	res := MarshalIPScalar(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNNetworkInterface2bandicootpkggqlNetworkInterface(ctx context.Context, sel ast.SelectionSet, v NetworkInterface) graphql.Marshaler {
	return ec._NetworkInterface(ctx, sel, &v)
}

func (ec *executionContext) marshalNOperator2bandicootpkggqlOperator(ctx context.Context, sel ast.SelectionSet, v []*Operator) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOperator2bandicootpkggqlOperator(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNRelationType2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNRelationType2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalNTag2bandicootpkggqlTag(ctx context.Context, sel ast.SelectionSet, v Tag) graphql.Marshaler {
	return ec._Tag(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNUUID2githubcomsatorigouuidUUID(ctx context.Context, v interface{}) (uuid.UUID, error) {
	return UnmarshalUUIDScalar(v)
}

func (ec *executionContext) marshalNUUID2githubcomsatorigouuidUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	res := MarshalUUIDScalar(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2bandicootpkggqlUser(ctx context.Context, sel ast.SelectionSet, v User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2bandicootpkggqlUser(ctx context.Context, sel ast.SelectionSet, v []User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2bandicootpkggqlUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNadapterDevicesAggregate2bandicootpkggqlAdapterDevicesAggregate(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregate) graphql.Marshaler {
	return ec._adapterDevicesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateAvgColumns, error) {
	var res AdapterDevicesAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_avg_columns2bandicootpkggqlAdapterDevicesAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateColumns, error) {
	var res AdapterDevicesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateMaxColumns, error) {
	var res AdapterDevicesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_max_columns2bandicootpkggqlAdapterDevicesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateMinColumns, error) {
	var res AdapterDevicesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_min_columns2bandicootpkggqlAdapterDevicesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx context.Context, v interface{}) (AdapterDevicesAggregateSumColumns, error) {
	var res AdapterDevicesAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v AdapterDevicesAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_sum_columns2bandicootpkggqlAdapterDevicesAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNadapterUsersAggregate2bandicootpkggqlAdapterUsersAggregate(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregate) graphql.Marshaler {
	return ec._adapterUsersAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateAvgColumns, error) {
	var res AdapterUsersAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx context.Context, v interface{}) ([]AdapterUsersAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_avg_columns2bandicootpkggqlAdapterUsersAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateColumns, error) {
	var res AdapterUsersAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateMaxColumns, error) {
	var res AdapterUsersAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx context.Context, v interface{}) ([]AdapterUsersAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_max_columns2bandicootpkggqlAdapterUsersAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateMinColumns, error) {
	var res AdapterUsersAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx context.Context, v interface{}) ([]AdapterUsersAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_min_columns2bandicootpkggqlAdapterUsersAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx context.Context, v interface{}) (AdapterUsersAggregateSumColumns, error) {
	var res AdapterUsersAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v AdapterUsersAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx context.Context, v interface{}) ([]AdapterUsersAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_sum_columns2bandicootpkggqlAdapterUsersAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx context.Context, v interface{}) (AdapterBoolExp, error) {
	return ec.unmarshalInputadapter_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx context.Context, v interface{}) (AdapterDataBoolExp, error) {
	return ec.unmarshalInputadapter_data_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx context.Context, v interface{}) (AdapterDeviceAdminBoolExp, error) {
	return ec.unmarshalInputadapter_device_admin_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx context.Context, v interface{}) (AdapterDeviceBoolExp, error) {
	return ec.unmarshalInputadapter_device_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx context.Context, v interface{}) (AdapterDeviceOrderBy, error) {
	var res AdapterDeviceOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx context.Context, sel ast.SelectionSet, v AdapterDeviceOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx context.Context, v interface{}) (AdapterDeviceUserBoolExp, error) {
	return ec.unmarshalInputadapter_device_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx context.Context, v interface{}) (AdapterUserBoolExp, error) {
	return ec.unmarshalInputadapter_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx context.Context, v interface{}) (AdapterUserOrderBy, error) {
	var res AdapterUserOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx context.Context, sel ast.SelectionSet, v AdapterUserOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx context.Context, v interface{}) (CsGroupBoolExp, error) {
	return ec.unmarshalInputcs_group_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx context.Context, v interface{}) (CsPolicyBoolExp, error) {
	return ec.unmarshalInputcs_policy_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx context.Context, v interface{}) (CsPolicySettingsBoolExp, error) {
	return ec.unmarshalInputcs_policy_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx context.Context, v interface{}) (CsPreventionSettingsBoolExp, error) {
	return ec.unmarshalInputcs_prevention_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx context.Context, v interface{}) (CsSensorUpdateSettingsBoolExp, error) {
	return ec.unmarshalInputcs_sensor_update_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx context.Context, v interface{}) (DeviceBoolExp, error) {
	return ec.unmarshalInputdevice_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx context.Context, v interface{}) (DeviceOrderBy, error) {
	var res DeviceOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx context.Context, sel ast.SelectionSet, v DeviceOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNdevicesAggregate2bandicootpkggqlDevicesAggregate(ctx context.Context, sel ast.SelectionSet, v DevicesAggregate) graphql.Marshaler {
	return ec._devicesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx context.Context, v interface{}) (DevicesAggregateAvgColumns, error) {
	var res DevicesAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx context.Context, v interface{}) ([]DevicesAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_avg_columns2bandicootpkggqlDevicesAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx context.Context, v interface{}) (DevicesAggregateColumns, error) {
	var res DevicesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx context.Context, v interface{}) (DevicesAggregateMaxColumns, error) {
	var res DevicesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx context.Context, v interface{}) ([]DevicesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_max_columns2bandicootpkggqlDevicesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx context.Context, v interface{}) (DevicesAggregateMinColumns, error) {
	var res DevicesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx context.Context, v interface{}) ([]DevicesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_min_columns2bandicootpkggqlDevicesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx context.Context, v interface{}) (DevicesAggregateSumColumns, error) {
	var res DevicesAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v DevicesAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx context.Context, v interface{}) ([]DevicesAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_sum_columns2bandicootpkggqlDevicesAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNfirewallRulesAggregate2bandicootpkggqlFirewallRulesAggregate(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregate) graphql.Marshaler {
	return ec._firewallRulesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateAvgColumns, error) {
	var res FirewallRulesAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx context.Context, v interface{}) ([]FirewallRulesAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_avg_columns2bandicootpkggqlFirewallRulesAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateColumns, error) {
	var res FirewallRulesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateMaxColumns, error) {
	var res FirewallRulesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx context.Context, v interface{}) ([]FirewallRulesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_max_columns2bandicootpkggqlFirewallRulesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateMinColumns, error) {
	var res FirewallRulesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx context.Context, v interface{}) ([]FirewallRulesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_min_columns2bandicootpkggqlFirewallRulesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx context.Context, v interface{}) (FirewallRulesAggregateSumColumns, error) {
	var res FirewallRulesAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v FirewallRulesAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx context.Context, v interface{}) ([]FirewallRulesAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_sum_columns2bandicootpkggqlFirewallRulesAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx context.Context, v interface{}) (FirewallRuleBoolExp, error) {
	return ec.unmarshalInputfirewall_rule_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx context.Context, v interface{}) (GceTagsBoolExp, error) {
	return ec.unmarshalInputgce_tags_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNgroupsAggregate2bandicootpkggqlGroupsAggregate(ctx context.Context, sel ast.SelectionSet, v GroupsAggregate) graphql.Marshaler {
	return ec._groupsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx context.Context, v interface{}) (GroupsAggregateAvgColumns, error) {
	var res GroupsAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx context.Context, v interface{}) ([]GroupsAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_avg_columns2bandicootpkggqlGroupsAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx context.Context, v interface{}) (GroupsAggregateColumns, error) {
	var res GroupsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx context.Context, v interface{}) (GroupsAggregateMaxColumns, error) {
	var res GroupsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx context.Context, v interface{}) ([]GroupsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_max_columns2bandicootpkggqlGroupsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx context.Context, v interface{}) (GroupsAggregateMinColumns, error) {
	var res GroupsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx context.Context, v interface{}) ([]GroupsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_min_columns2bandicootpkggqlGroupsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx context.Context, v interface{}) (GroupsAggregateSumColumns, error) {
	var res GroupsAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v GroupsAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx context.Context, v interface{}) ([]GroupsAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_sum_columns2bandicootpkggqlGroupsAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNinstalledSoftwareAggregate2bandicootpkggqlInstalledSoftwareAggregate(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregate) graphql.Marshaler {
	return ec._installedSoftwareAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateAvgColumns, error) {
	var res InstalledSoftwareAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_avg_columns2bandicootpkggqlInstalledSoftwareAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateColumns, error) {
	var res InstalledSoftwareAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateMaxColumns, error) {
	var res InstalledSoftwareAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_max_columns2bandicootpkggqlInstalledSoftwareAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateMinColumns, error) {
	var res InstalledSoftwareAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_min_columns2bandicootpkggqlInstalledSoftwareAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx context.Context, v interface{}) (InstalledSoftwareAggregateSumColumns, error) {
	var res InstalledSoftwareAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v InstalledSoftwareAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_sum_columns2bandicootpkggqlInstalledSoftwareAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx context.Context, v interface{}) (InstalledSoftwareBoolExp, error) {
	return ec.unmarshalInputinstalled_software_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNinterfacesAggregate2bandicootpkggqlInterfacesAggregate(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregate) graphql.Marshaler {
	return ec._interfacesAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx context.Context, v interface{}) (InterfacesAggregateColumns, error) {
	var res InterfacesAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx context.Context, v interface{}) (InterfacesAggregateMaxColumns, error) {
	var res InterfacesAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx context.Context, v interface{}) ([]InterfacesAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InterfacesAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfaces_aggregate_max_columns2bandicootpkggqlInterfacesAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx context.Context, v interface{}) (InterfacesAggregateMinColumns, error) {
	var res InterfacesAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v InterfacesAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx context.Context, v interface{}) ([]InterfacesAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InterfacesAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfaces_aggregate_min_columns2bandicootpkggqlInterfacesAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx context.Context, v interface{}) (NetworkInterfaceBoolExp, error) {
	return ec.unmarshalInputnetwork_interface_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx context.Context, v interface{}) (NetworkInterfaceVlanBoolExp, error) {
	return ec.unmarshalInputnetwork_interface_vlan_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx context.Context, v interface{}) (OperatingSystemBoolExp, error) {
	return ec.unmarshalInputoperating_system_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNpreventionSettingsAggregate2bandicootpkggqlPreventionSettingsAggregate(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregate) graphql.Marshaler {
	return ec._preventionSettingsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx context.Context, v interface{}) (PreventionSettingsAggregateColumns, error) {
	var res PreventionSettingsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx context.Context, v interface{}) (PreventionSettingsAggregateMaxColumns, error) {
	var res PreventionSettingsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx context.Context, v interface{}) ([]PreventionSettingsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]PreventionSettingsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettings_aggregate_max_columns2bandicootpkggqlPreventionSettingsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx context.Context, v interface{}) (PreventionSettingsAggregateMinColumns, error) {
	var res PreventionSettingsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v PreventionSettingsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx context.Context, v interface{}) ([]PreventionSettingsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]PreventionSettingsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettings_aggregate_min_columns2bandicootpkggqlPreventionSettingsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNsensorUpdateSettingsAggregate2bandicootpkggqlSensorUpdateSettingsAggregate(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregate) graphql.Marshaler {
	return ec._sensorUpdateSettingsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx context.Context, v interface{}) (SensorUpdateSettingsAggregateColumns, error) {
	var res SensorUpdateSettingsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx context.Context, v interface{}) (SensorUpdateSettingsAggregateMaxColumns, error) {
	var res SensorUpdateSettingsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx context.Context, v interface{}) ([]SensorUpdateSettingsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]SensorUpdateSettingsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettings_aggregate_max_columns2bandicootpkggqlSensorUpdateSettingsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx context.Context, v interface{}) (SensorUpdateSettingsAggregateMinColumns, error) {
	var res SensorUpdateSettingsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v SensorUpdateSettingsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx context.Context, v interface{}) ([]SensorUpdateSettingsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]SensorUpdateSettingsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettings_aggregate_min_columns2bandicootpkggqlSensorUpdateSettingsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNtag_bool_exp2bandicootpkggqlTagBoolExp(ctx context.Context, v interface{}) (TagBoolExp, error) {
	return ec.unmarshalInputtag_bool_exp(ctx, v)
}

func (ec *executionContext) marshalNtagsAggregate2bandicootpkggqlTagsAggregate(ctx context.Context, sel ast.SelectionSet, v TagsAggregate) graphql.Marshaler {
	return ec._tagsAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx context.Context, v interface{}) (TagsAggregateColumns, error) {
	var res TagsAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v TagsAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx context.Context, v interface{}) (TagsAggregateMaxColumns, error) {
	var res TagsAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v TagsAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx context.Context, v interface{}) ([]TagsAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagsAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []TagsAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtags_aggregate_max_columns2bandicootpkggqlTagsAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx context.Context, v interface{}) (TagsAggregateMinColumns, error) {
	var res TagsAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v TagsAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx context.Context, v interface{}) ([]TagsAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagsAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []TagsAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtags_aggregate_min_columns2bandicootpkggqlTagsAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNuser_bool_exp2bandicootpkggqlUserBoolExp(ctx context.Context, v interface{}) (UserBoolExp, error) {
	return ec.unmarshalInputuser_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalNuser_order_by2bandicootpkggqlUserOrderBy(ctx context.Context, v interface{}) (UserOrderBy, error) {
	var res UserOrderBy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNuser_order_by2bandicootpkggqlUserOrderBy(ctx context.Context, sel ast.SelectionSet, v UserOrderBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNusersAggregate2bandicootpkggqlUsersAggregate(ctx context.Context, sel ast.SelectionSet, v UsersAggregate) graphql.Marshaler {
	return ec._usersAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx context.Context, v interface{}) (UsersAggregateAvgColumns, error) {
	var res UsersAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx context.Context, v interface{}) ([]UsersAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_avg_columns2bandicootpkggqlUsersAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx context.Context, v interface{}) (UsersAggregateColumns, error) {
	var res UsersAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx context.Context, v interface{}) (UsersAggregateMaxColumns, error) {
	var res UsersAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx context.Context, v interface{}) ([]UsersAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_max_columns2bandicootpkggqlUsersAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx context.Context, v interface{}) (UsersAggregateMinColumns, error) {
	var res UsersAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx context.Context, v interface{}) ([]UsersAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_min_columns2bandicootpkggqlUsersAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx context.Context, v interface{}) (UsersAggregateSumColumns, error) {
	var res UsersAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v UsersAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx context.Context, v interface{}) ([]UsersAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_sum_columns2bandicootpkggqlUsersAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNvlansAggregate2bandicootpkggqlVlansAggregate(ctx context.Context, sel ast.SelectionSet, v VlansAggregate) graphql.Marshaler {
	return ec._vlansAggregate(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNvlans_aggregate_avg_columns2bandicootpkggqlVlansAggregateAvgColumns(ctx context.Context, v interface{}) (VlansAggregateAvgColumns, error) {
	var res VlansAggregateAvgColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNvlans_aggregate_avg_columns2bandicootpkggqlVlansAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v VlansAggregateAvgColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNvlans_aggregate_avg_columns2bandicootpkggqlVlansAggregateAvgColumns(ctx context.Context, v interface{}) ([]VlansAggregateAvgColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]VlansAggregateAvgColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNvlans_aggregate_avg_columns2bandicootpkggqlVlansAggregateAvgColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNvlans_aggregate_avg_columns2bandicootpkggqlVlansAggregateAvgColumns(ctx context.Context, sel ast.SelectionSet, v []VlansAggregateAvgColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNvlans_aggregate_avg_columns2bandicootpkggqlVlansAggregateAvgColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNvlans_aggregate_columns2bandicootpkggqlVlansAggregateColumns(ctx context.Context, v interface{}) (VlansAggregateColumns, error) {
	var res VlansAggregateColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNvlans_aggregate_columns2bandicootpkggqlVlansAggregateColumns(ctx context.Context, sel ast.SelectionSet, v VlansAggregateColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNvlans_aggregate_max_columns2bandicootpkggqlVlansAggregateMaxColumns(ctx context.Context, v interface{}) (VlansAggregateMaxColumns, error) {
	var res VlansAggregateMaxColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNvlans_aggregate_max_columns2bandicootpkggqlVlansAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v VlansAggregateMaxColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNvlans_aggregate_max_columns2bandicootpkggqlVlansAggregateMaxColumns(ctx context.Context, v interface{}) ([]VlansAggregateMaxColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]VlansAggregateMaxColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNvlans_aggregate_max_columns2bandicootpkggqlVlansAggregateMaxColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNvlans_aggregate_max_columns2bandicootpkggqlVlansAggregateMaxColumns(ctx context.Context, sel ast.SelectionSet, v []VlansAggregateMaxColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNvlans_aggregate_max_columns2bandicootpkggqlVlansAggregateMaxColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNvlans_aggregate_min_columns2bandicootpkggqlVlansAggregateMinColumns(ctx context.Context, v interface{}) (VlansAggregateMinColumns, error) {
	var res VlansAggregateMinColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNvlans_aggregate_min_columns2bandicootpkggqlVlansAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v VlansAggregateMinColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNvlans_aggregate_min_columns2bandicootpkggqlVlansAggregateMinColumns(ctx context.Context, v interface{}) ([]VlansAggregateMinColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]VlansAggregateMinColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNvlans_aggregate_min_columns2bandicootpkggqlVlansAggregateMinColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNvlans_aggregate_min_columns2bandicootpkggqlVlansAggregateMinColumns(ctx context.Context, sel ast.SelectionSet, v []VlansAggregateMinColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNvlans_aggregate_min_columns2bandicootpkggqlVlansAggregateMinColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNvlans_aggregate_sum_columns2bandicootpkggqlVlansAggregateSumColumns(ctx context.Context, v interface{}) (VlansAggregateSumColumns, error) {
	var res VlansAggregateSumColumns
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNvlans_aggregate_sum_columns2bandicootpkggqlVlansAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v VlansAggregateSumColumns) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNvlans_aggregate_sum_columns2bandicootpkggqlVlansAggregateSumColumns(ctx context.Context, v interface{}) ([]VlansAggregateSumColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]VlansAggregateSumColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNvlans_aggregate_sum_columns2bandicootpkggqlVlansAggregateSumColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNvlans_aggregate_sum_columns2bandicootpkggqlVlansAggregateSumColumns(ctx context.Context, sel ast.SelectionSet, v []VlansAggregateSumColumns) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNvlans_aggregate_sum_columns2bandicootpkggqlVlansAggregateSumColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, v interface{}) (AccessType, error) {
	var res AccessType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, sel ast.SelectionSet, v AccessType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, v interface{}) ([]*AccessType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*AccessType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, sel ast.SelectionSet, v []*AccessType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAccessType2bandicootpkggqlAccessType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, v interface{}) (*AccessType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAccessType2bandicootpkggqlAccessType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAccessType2bandicootpkggqlAccessType(ctx context.Context, sel ast.SelectionSet, v *AccessType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOAccessTypeComparator2bandicootpkggqlAccessTypeComparator(ctx context.Context, v interface{}) (AccessTypeComparator, error) {
	return ec.unmarshalInputAccessTypeComparator(ctx, v)
}

func (ec *executionContext) unmarshalOAccessTypeComparator2bandicootpkggqlAccessTypeComparator(ctx context.Context, v interface{}) (*AccessTypeComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAccessTypeComparator2bandicootpkggqlAccessTypeComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAdapter2bandicootpkggqlAdapter(ctx context.Context, sel ast.SelectionSet, v Adapter) graphql.Marshaler {
	return ec._Adapter(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapter2bandicootpkggqlAdapter(ctx context.Context, sel ast.SelectionSet, v *Adapter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Adapter(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterData2bandicootpkggqlAdapterData(ctx context.Context, sel ast.SelectionSet, v AdapterData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterData(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v AdapterDevice) graphql.Marshaler {
	return ec._AdapterDevice(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v []AdapterDevice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterDevice2bandicootpkggqlAdapterDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v []*AdapterDevice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDevice2bandicootpkggqlAdapterDevice(ctx context.Context, sel ast.SelectionSet, v *AdapterDevice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterDevice(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterDeviceAdmin2bandicootpkggqlAdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, v AdapterDeviceAdmin) graphql.Marshaler {
	return ec._AdapterDeviceAdmin(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterDeviceAdmin2bandicootpkggqlAdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, v []*AdapterDeviceAdmin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterDeviceAdmin2bandicootpkggqlAdapterDeviceAdmin(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDeviceAdmin2bandicootpkggqlAdapterDeviceAdmin(ctx context.Context, sel ast.SelectionSet, v *AdapterDeviceAdmin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterDeviceAdmin(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterDeviceUser2bandicootpkggqlAdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, v AdapterDeviceUser) graphql.Marshaler {
	return ec._AdapterDeviceUser(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterDeviceUser2bandicootpkggqlAdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, v []*AdapterDeviceUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterDeviceUser2bandicootpkggqlAdapterDeviceUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterDeviceUser2bandicootpkggqlAdapterDeviceUser(ctx context.Context, sel ast.SelectionSet, v *AdapterDeviceUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterDeviceUser(ctx, sel, v)
}

func (ec *executionContext) marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v AdapterUser) graphql.Marshaler {
	return ec._AdapterUser(ctx, sel, &v)
}

func (ec *executionContext) marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v []AdapterUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdapterUser2bandicootpkggqlAdapterUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v []*AdapterUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAdapterUser2bandicootpkggqlAdapterUser(ctx context.Context, sel ast.SelectionSet, v *AdapterUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdapterUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, v interface{}) (AdminType, error) {
	var res AdminType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, sel ast.SelectionSet, v AdminType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, v interface{}) ([]*AdminType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*AdminType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, sel ast.SelectionSet, v []*AdminType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdminType2bandicootpkggqlAdminType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, v interface{}) (*AdminType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAdminType2bandicootpkggqlAdminType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAdminType2bandicootpkggqlAdminType(ctx context.Context, sel ast.SelectionSet, v *AdminType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOAdminTypeComparator2bandicootpkggqlAdminTypeComparator(ctx context.Context, v interface{}) (AdminTypeComparator, error) {
	return ec.unmarshalInputAdminTypeComparator(ctx, v)
}

func (ec *executionContext) unmarshalOAdminTypeComparator2bandicootpkggqlAdminTypeComparator(ctx context.Context, v interface{}) (*AdminTypeComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAdminTypeComparator2bandicootpkggqlAdminTypeComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx context.Context, v interface{}) ([]AggregateOrdering, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AggregateOrdering, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx context.Context, sel ast.SelectionSet, v []AggregateOrdering) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAggregateOrdering2bandicootpkggqlAggregateOrdering(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, v interface{}) (Architecture, error) {
	var res Architecture
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, sel ast.SelectionSet, v Architecture) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, v interface{}) ([]*Architecture, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*Architecture, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, sel ast.SelectionSet, v []*Architecture) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOArchitecture2bandicootpkggqlArchitecture(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, v interface{}) (*Architecture, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOArchitecture2bandicootpkggqlArchitecture(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOArchitecture2bandicootpkggqlArchitecture(ctx context.Context, sel ast.SelectionSet, v *Architecture) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOArchitectureComparator2bandicootpkggqlArchitectureComparator(ctx context.Context, v interface{}) (ArchitectureComparator, error) {
	return ec.unmarshalInputArchitectureComparator(ctx, v)
}

func (ec *executionContext) unmarshalOArchitectureComparator2bandicootpkggqlArchitectureComparator(ctx context.Context, v interface{}) (*ArchitectureComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOArchitectureComparator2bandicootpkggqlArchitectureComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx context.Context, v interface{}) (BooleanComparator, error) {
	return ec.unmarshalInputBooleanComparator(ctx, v)
}

func (ec *executionContext) unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx context.Context, v interface{}) (*BooleanComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBooleanComparator2bandicootpkggqlBooleanComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOCIDR2netIPNet(ctx context.Context, v interface{}) (net.IPNet, error) {
	return UnmarshalCIDRScalar(v)
}

func (ec *executionContext) marshalOCIDR2netIPNet(ctx context.Context, sel ast.SelectionSet, v net.IPNet) graphql.Marshaler {
	return MarshalCIDRScalar(v)
}

func (ec *executionContext) unmarshalOCIDR2netIPNet(ctx context.Context, v interface{}) ([]*net.IPNet, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*net.IPNet, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOCIDR2netIPNet(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOCIDR2netIPNet(ctx context.Context, sel ast.SelectionSet, v []*net.IPNet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOCIDR2netIPNet(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOCIDR2netIPNet(ctx context.Context, v interface{}) (*net.IPNet, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCIDR2netIPNet(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOCIDR2netIPNet(ctx context.Context, sel ast.SelectionSet, v *net.IPNet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOCIDR2netIPNet(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, v interface{}) (CylanceDeviceState, error) {
	var res CylanceDeviceState
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, sel ast.SelectionSet, v CylanceDeviceState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, v interface{}) ([]*CylanceDeviceState, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*CylanceDeviceState, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, sel ast.SelectionSet, v []*CylanceDeviceState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, v interface{}) (*CylanceDeviceState, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOCylanceDeviceState2bandicootpkggqlCylanceDeviceState(ctx context.Context, sel ast.SelectionSet, v *CylanceDeviceState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOCylanceDeviceStateComparator2bandicootpkggqlCylanceDeviceStateComparator(ctx context.Context, v interface{}) (CylanceDeviceStateComparator, error) {
	return ec.unmarshalInputCylanceDeviceStateComparator(ctx, v)
}

func (ec *executionContext) unmarshalOCylanceDeviceStateComparator2bandicootpkggqlCylanceDeviceStateComparator(ctx context.Context, v interface{}) (*CylanceDeviceStateComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCylanceDeviceStateComparator2bandicootpkggqlCylanceDeviceStateComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODevice2bandicootpkggqlDevice(ctx context.Context, sel ast.SelectionSet, v Device) graphql.Marshaler {
	return ec._Device(ctx, sel, &v)
}

func (ec *executionContext) marshalODevice2bandicootpkggqlDevice(ctx context.Context, sel ast.SelectionSet, v []*Device) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODevice2bandicootpkggqlDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalODevice2bandicootpkggqlDevice(ctx context.Context, sel ast.SelectionSet, v *Device) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Device(ctx, sel, v)
}

func (ec *executionContext) unmarshalODirection2bandicootpkggqlDirection(ctx context.Context, v interface{}) (Direction, error) {
	var res Direction
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalODirection2bandicootpkggqlDirection(ctx context.Context, sel ast.SelectionSet, v Direction) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalODirection2bandicootpkggqlDirection(ctx context.Context, v interface{}) ([]*Direction, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*Direction, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalODirection2bandicootpkggqlDirection(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODirection2bandicootpkggqlDirection(ctx context.Context, sel ast.SelectionSet, v []*Direction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODirection2bandicootpkggqlDirection(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalODirection2bandicootpkggqlDirection(ctx context.Context, v interface{}) (*Direction, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODirection2bandicootpkggqlDirection(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODirection2bandicootpkggqlDirection(ctx context.Context, sel ast.SelectionSet, v *Direction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalODirectionComparator2bandicootpkggqlDirectionComparator(ctx context.Context, v interface{}) (DirectionComparator, error) {
	return ec.unmarshalInputDirectionComparator(ctx, v)
}

func (ec *executionContext) unmarshalODirectionComparator2bandicootpkggqlDirectionComparator(ctx context.Context, v interface{}) (*DirectionComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODirectionComparator2bandicootpkggqlDirectionComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOEpoch2bandicootinternalEpoch(ctx context.Context, v interface{}) (internal.Epoch, error) {
	return UnmarshalEpochScalar(v)
}

func (ec *executionContext) marshalOEpoch2bandicootinternalEpoch(ctx context.Context, sel ast.SelectionSet, v internal.Epoch) graphql.Marshaler {
	return MarshalEpochScalar(v)
}

func (ec *executionContext) unmarshalOEpoch2bandicootinternalEpoch(ctx context.Context, v interface{}) ([]*internal.Epoch, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*internal.Epoch, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEpoch2bandicootinternalEpoch(ctx context.Context, sel ast.SelectionSet, v []*internal.Epoch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOEpoch2bandicootinternalEpoch(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOEpoch2bandicootinternalEpoch(ctx context.Context, v interface{}) (*internal.Epoch, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEpoch2bandicootinternalEpoch(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOEpoch2bandicootinternalEpoch(ctx context.Context, sel ast.SelectionSet, v *internal.Epoch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOEpoch2bandicootinternalEpoch(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx context.Context, v interface{}) (EpochComparator, error) {
	return ec.unmarshalInputEpochComparator(ctx, v)
}

func (ec *executionContext) unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx context.Context, v interface{}) (*EpochComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEpochComparator2bandicootpkggqlEpochComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOFilter2bandicootpkggqlFilter(ctx context.Context, sel ast.SelectionSet, v Filter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Filter(ctx, sel, v)
}

func (ec *executionContext) marshalOFilter2bandicootpkggqlFilter(ctx context.Context, sel ast.SelectionSet, v []Filter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFilter2bandicootpkggqlFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx context.Context, sel ast.SelectionSet, v FirewallRule) graphql.Marshaler {
	return ec._FirewallRule(ctx, sel, &v)
}

func (ec *executionContext) marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx context.Context, sel ast.SelectionSet, v []*FirewallRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOFirewallRule2bandicootpkggqlFirewallRule(ctx context.Context, sel ast.SelectionSet, v *FirewallRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FirewallRule(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) ([]*float64, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*float64, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOFloat2float64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v []*float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOFloat2float64(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFloat2float64(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOFloat2float64(ctx, sel, *v)
}

func (ec *executionContext) marshalOGCETagsAggregate2bandicootpkggqlGCETagsAggregate(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETagsAggregate2bandicootpkggqlGCETagsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx context.Context, v interface{}) ([]GCETagsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GCETagsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []GCETagsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGCETags_aggregate_columns2bandicootpkggqlGCETagsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOGceTags2bandicootpkggqlGceTags(ctx context.Context, sel ast.SelectionSet, v GceTags) graphql.Marshaler {
	return ec._GceTags(ctx, sel, &v)
}

func (ec *executionContext) marshalOGceTags2bandicootpkggqlGceTags(ctx context.Context, sel ast.SelectionSet, v []*GceTags) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGceTags2bandicootpkggqlGceTags(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOGceTags2bandicootpkggqlGceTags(ctx context.Context, sel ast.SelectionSet, v *GceTags) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GceTags(ctx, sel, v)
}

func (ec *executionContext) unmarshalOIP2netIP(ctx context.Context, v interface{}) (net.IP, error) {
	return UnmarshalIPScalar(v)
}

func (ec *executionContext) marshalOIP2netIP(ctx context.Context, sel ast.SelectionSet, v net.IP) graphql.Marshaler {
	return MarshalIPScalar(v)
}

func (ec *executionContext) unmarshalOIP2netIP(ctx context.Context, v interface{}) ([]net.IP, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]net.IP, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNIP2netIP(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOIP2netIP(ctx context.Context, sel ast.SelectionSet, v []net.IP) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNIP2netIP(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOIP2netIP(ctx context.Context, v interface{}) ([]*net.IP, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*net.IP, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOIP2netIP(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOIP2netIP(ctx context.Context, sel ast.SelectionSet, v []*net.IP) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOIP2netIP(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOIP2netIP(ctx context.Context, v interface{}) (*net.IP, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOIP2netIP(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOIP2netIP(ctx context.Context, sel ast.SelectionSet, v *net.IP) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOIP2netIP(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOIPArrayComparator2bandicootpkggqlIPArrayComparator(ctx context.Context, v interface{}) (IPArrayComparator, error) {
	return ec.unmarshalInputIPArrayComparator(ctx, v)
}

func (ec *executionContext) unmarshalOIPArrayComparator2bandicootpkggqlIPArrayComparator(ctx context.Context, v interface{}) (*IPArrayComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOIPArrayComparator2bandicootpkggqlIPArrayComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOIPComparator2bandicootpkggqlIPComparator(ctx context.Context, v interface{}) (IPComparator, error) {
	return ec.unmarshalInputIPComparator(ctx, v)
}

func (ec *executionContext) unmarshalOIPComparator2bandicootpkggqlIPComparator(ctx context.Context, v interface{}) (*IPComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOIPComparator2bandicootpkggqlIPComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOIPFamily2bandicootpkggqlIPFamily(ctx context.Context, v interface{}) (IPFamily, error) {
	var res IPFamily
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOIPFamily2bandicootpkggqlIPFamily(ctx context.Context, sel ast.SelectionSet, v IPFamily) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOIPFamily2bandicootpkggqlIPFamily(ctx context.Context, v interface{}) (*IPFamily, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOIPFamily2bandicootpkggqlIPFamily(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOIPFamily2bandicootpkggqlIPFamily(ctx context.Context, sel ast.SelectionSet, v *IPFamily) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx context.Context, sel ast.SelectionSet, v InstalledSoftware) graphql.Marshaler {
	return ec._InstalledSoftware(ctx, sel, &v)
}

func (ec *executionContext) marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx context.Context, sel ast.SelectionSet, v []*InstalledSoftware) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOInstalledSoftware2bandicootpkggqlInstalledSoftware(ctx context.Context, sel ast.SelectionSet, v *InstalledSoftware) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InstalledSoftware(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]*int, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*int, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []*int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOInt2int(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx context.Context, v interface{}) (IntComparator, error) {
	return ec.unmarshalInputIntComparator(ctx, v)
}

func (ec *executionContext) unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx context.Context, v interface{}) (*IntComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOIntComparator2bandicootpkggqlIntComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOMac2string(ctx context.Context, v interface{}) (string, error) {
	return UnmarshalMacScalar(v)
}

func (ec *executionContext) marshalOMac2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return MarshalMacScalar(v)
}

func (ec *executionContext) unmarshalOMac2string(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOMac2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMac2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOMac2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOMac2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMac2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOMac2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOMac2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOMacComparator2bandicootpkggqlMacComparator(ctx context.Context, v interface{}) (MacComparator, error) {
	return ec.unmarshalInputMacComparator(ctx, v)
}

func (ec *executionContext) unmarshalOMacComparator2bandicootpkggqlMacComparator(ctx context.Context, v interface{}) (*MacComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMacComparator2bandicootpkggqlMacComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return graphql.UnmarshalMap(v)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalMap(v)
}

func (ec *executionContext) marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx context.Context, sel ast.SelectionSet, v NetworkInterface) graphql.Marshaler {
	return ec._NetworkInterface(ctx, sel, &v)
}

func (ec *executionContext) marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx context.Context, sel ast.SelectionSet, v []NetworkInterface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNetworkInterface2bandicootpkggqlNetworkInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx context.Context, sel ast.SelectionSet, v []*NetworkInterface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalONetworkInterface2bandicootpkggqlNetworkInterface(ctx context.Context, sel ast.SelectionSet, v *NetworkInterface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NetworkInterface(ctx, sel, v)
}

func (ec *executionContext) marshalONetworkInterfaceVlan2bandicootpkggqlNetworkInterfaceVlan(ctx context.Context, sel ast.SelectionSet, v NetworkInterfaceVlan) graphql.Marshaler {
	return ec._NetworkInterfaceVlan(ctx, sel, &v)
}

func (ec *executionContext) marshalONetworkInterfaceVlan2bandicootpkggqlNetworkInterfaceVlan(ctx context.Context, sel ast.SelectionSet, v []*NetworkInterfaceVlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONetworkInterfaceVlan2bandicootpkggqlNetworkInterfaceVlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalONetworkInterfaceVlan2bandicootpkggqlNetworkInterfaceVlan(ctx context.Context, sel ast.SelectionSet, v *NetworkInterfaceVlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NetworkInterfaceVlan(ctx, sel, v)
}

func (ec *executionContext) marshalOObjectFilter2bandicootpkggqlObjectFilter(ctx context.Context, sel ast.SelectionSet, v ObjectFilter) graphql.Marshaler {
	return ec._ObjectFilter(ctx, sel, &v)
}

func (ec *executionContext) marshalOObjectFilter2bandicootpkggqlObjectFilter(ctx context.Context, sel ast.SelectionSet, v []*ObjectFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOObjectFilter2bandicootpkggqlObjectFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOObjectFilter2bandicootpkggqlObjectFilter(ctx context.Context, sel ast.SelectionSet, v *ObjectFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ObjectFilter(ctx, sel, v)
}

func (ec *executionContext) marshalOOperatingSystem2bandicootpkggqlOperatingSystem(ctx context.Context, sel ast.SelectionSet, v OperatingSystem) graphql.Marshaler {
	return ec._OperatingSystem(ctx, sel, &v)
}

func (ec *executionContext) marshalOOperatingSystem2bandicootpkggqlOperatingSystem(ctx context.Context, sel ast.SelectionSet, v *OperatingSystem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OperatingSystem(ctx, sel, v)
}

func (ec *executionContext) marshalOOperator2bandicootpkggqlOperator(ctx context.Context, sel ast.SelectionSet, v Operator) graphql.Marshaler {
	return ec._Operator(ctx, sel, &v)
}

func (ec *executionContext) marshalOOperator2bandicootpkggqlOperator(ctx context.Context, sel ast.SelectionSet, v *Operator) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Operator(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx context.Context, v interface{}) (StringArrayComparator, error) {
	return ec.unmarshalInputStringArrayComparator(ctx, v)
}

func (ec *executionContext) unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx context.Context, v interface{}) (*StringArrayComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOStringArrayComparator2bandicootpkggqlStringArrayComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx context.Context, v interface{}) (StringComparator, error) {
	return ec.unmarshalInputStringComparator(ctx, v)
}

func (ec *executionContext) unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx context.Context, v interface{}) (*StringComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOStringComparator2bandicootpkggqlStringComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTag2bandicootpkggqlTag(ctx context.Context, sel ast.SelectionSet, v Tag) graphql.Marshaler {
	return ec._Tag(ctx, sel, &v)
}

func (ec *executionContext) marshalOTag2bandicootpkggqlTag(ctx context.Context, sel ast.SelectionSet, v []Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2bandicootpkggqlTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTag2bandicootpkggqlTag(ctx context.Context, sel ast.SelectionSet, v []*Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTag2bandicootpkggqlTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTag2bandicootpkggqlTag(ctx context.Context, sel ast.SelectionSet, v *Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return graphql.MarshalTime(v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTime2timeTime(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTime2timeTime(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, v interface{}) (uuid.UUID, error) {
	return UnmarshalUUIDScalar(v)
}

func (ec *executionContext) marshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	return MarshalUUIDScalar(v)
}

func (ec *executionContext) unmarshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, v interface{}) ([]*uuid.UUID, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*uuid.UUID, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, sel ast.SelectionSet, v []*uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOUUID2githubcomsatorigouuidUUID(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, v interface{}) (*uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUUID2githubcomsatorigouuidUUID(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUUID2githubcomsatorigouuidUUID(ctx context.Context, sel ast.SelectionSet, v *uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOUUID2githubcomsatorigouuidUUID(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx context.Context, v interface{}) (UUIDComparator, error) {
	return ec.unmarshalInputUUIDComparator(ctx, v)
}

func (ec *executionContext) unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx context.Context, v interface{}) (*UUIDComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUUIDComparator2bandicootpkggqlUUIDComparator(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUser2bandicootpkggqlUser(ctx context.Context, sel ast.SelectionSet, v User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2bandicootpkggqlUser(ctx context.Context, sel ast.SelectionSet, v []*User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2bandicootpkggqlUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOUser2bandicootpkggqlUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) marshalOadapterDevicesAggregate2bandicootpkggqlAdapterDevicesAggregate(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevicesAggregate2bandicootpkggqlAdapterDevicesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx context.Context, v interface{}) ([]AdapterDevicesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDevicesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterDevicesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterDevices_aggregate_columns2bandicootpkggqlAdapterDevicesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOadapterUsersAggregate2bandicootpkggqlAdapterUsersAggregate(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsersAggregate2bandicootpkggqlAdapterUsersAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx context.Context, v interface{}) ([]AdapterUsersAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUsersAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []AdapterUsersAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapterUsers_aggregate_columns2bandicootpkggqlAdapterUsersAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx context.Context, v interface{}) (AdapterBoolExp, error) {
	return ec.unmarshalInputadapter_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx context.Context, v interface{}) ([]AdapterBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx context.Context, v interface{}) (*AdapterBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_bool_exp2bandicootpkggqlAdapterBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx context.Context, v interface{}) (AdapterDataBoolExp, error) {
	return ec.unmarshalInputadapter_data_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx context.Context, v interface{}) ([]AdapterDataBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDataBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx context.Context, v interface{}) (*AdapterDataBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_data_bool_exp2bandicootpkggqlAdapterDataBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx context.Context, v interface{}) (AdapterDeviceAdminBoolExp, error) {
	return ec.unmarshalInputadapter_device_admin_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx context.Context, v interface{}) ([]AdapterDeviceAdminBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceAdminBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx context.Context, v interface{}) (*AdapterDeviceAdminBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_device_admin_bool_exp2bandicootpkggqlAdapterDeviceAdminBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx context.Context, v interface{}) (AdapterDeviceBoolExp, error) {
	return ec.unmarshalInputadapter_device_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx context.Context, v interface{}) ([]AdapterDeviceBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx context.Context, v interface{}) (*AdapterDeviceBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_device_bool_exp2bandicootpkggqlAdapterDeviceBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx context.Context, v interface{}) ([]AdapterDeviceOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx context.Context, sel ast.SelectionSet, v []AdapterDeviceOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapter_device_order_by2bandicootpkggqlAdapterDeviceOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx context.Context, v interface{}) (AdapterDeviceUserBoolExp, error) {
	return ec.unmarshalInputadapter_device_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx context.Context, v interface{}) ([]AdapterDeviceUserBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterDeviceUserBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx context.Context, v interface{}) (*AdapterDeviceUserBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_device_user_bool_exp2bandicootpkggqlAdapterDeviceUserBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx context.Context, v interface{}) (AdapterUserBoolExp, error) {
	return ec.unmarshalInputadapter_user_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx context.Context, v interface{}) ([]AdapterUserBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUserBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx context.Context, v interface{}) (*AdapterUserBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOadapter_user_bool_exp2bandicootpkggqlAdapterUserBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx context.Context, v interface{}) ([]AdapterUserOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]AdapterUserOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx context.Context, sel ast.SelectionSet, v []AdapterUserOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNadapter_user_order_by2bandicootpkggqlAdapterUserOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsGroup2bandicootpkggqlCsGroup(ctx context.Context, sel ast.SelectionSet, v CsGroup) graphql.Marshaler {
	return ec._csGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsGroup2bandicootpkggqlCsGroup(ctx context.Context, sel ast.SelectionSet, v []*CsGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsGroup2bandicootpkggqlCsGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsGroup2bandicootpkggqlCsGroup(ctx context.Context, sel ast.SelectionSet, v *CsGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csGroup(ctx, sel, v)
}

func (ec *executionContext) marshalOcsPolicy2bandicootpkggqlCsPolicy(ctx context.Context, sel ast.SelectionSet, v CsPolicy) graphql.Marshaler {
	return ec._csPolicy(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsPolicy2bandicootpkggqlCsPolicy(ctx context.Context, sel ast.SelectionSet, v *CsPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csPolicy(ctx, sel, v)
}

func (ec *executionContext) marshalOcsPolicySettings2bandicootpkggqlCsPolicySettings(ctx context.Context, sel ast.SelectionSet, v CsPolicySettings) graphql.Marshaler {
	return ec._csPolicySettings(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsPolicySettings2bandicootpkggqlCsPolicySettings(ctx context.Context, sel ast.SelectionSet, v []*CsPolicySettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsPolicySettings2bandicootpkggqlCsPolicySettings(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsPolicySettings2bandicootpkggqlCsPolicySettings(ctx context.Context, sel ast.SelectionSet, v *CsPolicySettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csPolicySettings(ctx, sel, v)
}

func (ec *executionContext) marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx context.Context, sel ast.SelectionSet, v CsPreventionSettings) graphql.Marshaler {
	return ec._csPreventionSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx context.Context, sel ast.SelectionSet, v []*CsPreventionSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsPreventionSettings2bandicootpkggqlCsPreventionSettings(ctx context.Context, sel ast.SelectionSet, v *CsPreventionSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csPreventionSettings(ctx, sel, v)
}

func (ec *executionContext) marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, v CsSensorUpdateSettings) graphql.Marshaler {
	return ec._csSensorUpdateSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, v []*CsSensorUpdateSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOcsSensorUpdateSettings2bandicootpkggqlCsSensorUpdateSettings(ctx context.Context, sel ast.SelectionSet, v *CsSensorUpdateSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._csSensorUpdateSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx context.Context, v interface{}) (CsGroupBoolExp, error) {
	return ec.unmarshalInputcs_group_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx context.Context, v interface{}) ([]CsGroupBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsGroupBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx context.Context, v interface{}) (*CsGroupBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_group_bool_exp2bandicootpkggqlCsGroupBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx context.Context, v interface{}) (CsPolicyBoolExp, error) {
	return ec.unmarshalInputcs_policy_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx context.Context, v interface{}) ([]CsPolicyBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsPolicyBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx context.Context, v interface{}) (*CsPolicyBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_policy_bool_exp2bandicootpkggqlCsPolicyBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx context.Context, v interface{}) (CsPolicySettingsBoolExp, error) {
	return ec.unmarshalInputcs_policy_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx context.Context, v interface{}) ([]CsPolicySettingsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsPolicySettingsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx context.Context, v interface{}) (*CsPolicySettingsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_policy_settings_bool_exp2bandicootpkggqlCsPolicySettingsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx context.Context, v interface{}) (CsPreventionSettingsBoolExp, error) {
	return ec.unmarshalInputcs_prevention_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx context.Context, v interface{}) ([]CsPreventionSettingsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsPreventionSettingsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx context.Context, v interface{}) (*CsPreventionSettingsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_prevention_settings_bool_exp2bandicootpkggqlCsPreventionSettingsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx context.Context, v interface{}) (CsSensorUpdateSettingsBoolExp, error) {
	return ec.unmarshalInputcs_sensor_update_settings_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx context.Context, v interface{}) ([]CsSensorUpdateSettingsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]CsSensorUpdateSettingsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx context.Context, v interface{}) (*CsSensorUpdateSettingsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOcs_sensor_update_settings_bool_exp2bandicootpkggqlCsSensorUpdateSettingsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx context.Context, v interface{}) (DeviceBoolExp, error) {
	return ec.unmarshalInputdevice_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx context.Context, v interface{}) ([]DeviceBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DeviceBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx context.Context, v interface{}) (*DeviceBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOdevice_bool_exp2bandicootpkggqlDeviceBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx context.Context, v interface{}) ([]DeviceOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DeviceOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx context.Context, sel ast.SelectionSet, v []DeviceOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevice_order_by2bandicootpkggqlDeviceOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOdevicesAggregate2bandicootpkggqlDevicesAggregate(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevicesAggregate2bandicootpkggqlDevicesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx context.Context, v interface{}) ([]DevicesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]DevicesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []DevicesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNdevices_aggregate_columns2bandicootpkggqlDevicesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOfirewallRulesAggregate2bandicootpkggqlFirewallRulesAggregate(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRulesAggregate2bandicootpkggqlFirewallRulesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx context.Context, v interface{}) ([]FirewallRulesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRulesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []FirewallRulesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNfirewallRules_aggregate_columns2bandicootpkggqlFirewallRulesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx context.Context, v interface{}) (FirewallRuleBoolExp, error) {
	return ec.unmarshalInputfirewall_rule_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx context.Context, v interface{}) ([]FirewallRuleBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]FirewallRuleBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx context.Context, v interface{}) (*FirewallRuleBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOfirewall_rule_bool_exp2bandicootpkggqlFirewallRuleBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx context.Context, v interface{}) (GceTagsBoolExp, error) {
	return ec.unmarshalInputgce_tags_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx context.Context, v interface{}) ([]GceTagsBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GceTagsBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx context.Context, v interface{}) (*GceTagsBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOgce_tags_bool_exp2bandicootpkggqlGceTagsBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOgroupsAggregate2bandicootpkggqlGroupsAggregate(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroupsAggregate2bandicootpkggqlGroupsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx context.Context, v interface{}) ([]GroupsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]GroupsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []GroupsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNgroups_aggregate_columns2bandicootpkggqlGroupsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOinstalledSoftwareAggregate2bandicootpkggqlInstalledSoftwareAggregate(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftwareAggregate2bandicootpkggqlInstalledSoftwareAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx context.Context, v interface{}) ([]InstalledSoftwareAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []InstalledSoftwareAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinstalledSoftware_aggregate_columns2bandicootpkggqlInstalledSoftwareAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx context.Context, v interface{}) (InstalledSoftwareBoolExp, error) {
	return ec.unmarshalInputinstalled_software_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx context.Context, v interface{}) ([]InstalledSoftwareBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InstalledSoftwareBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx context.Context, v interface{}) (*InstalledSoftwareBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOinstalled_software_bool_exp2bandicootpkggqlInstalledSoftwareBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOinterfacesAggregate2bandicootpkggqlInterfacesAggregate(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfacesAggregate2bandicootpkggqlInterfacesAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx context.Context, v interface{}) ([]InterfacesAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]InterfacesAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []InterfacesAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNinterfaces_aggregate_columns2bandicootpkggqlInterfacesAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx context.Context, v interface{}) (NetworkInterfaceBoolExp, error) {
	return ec.unmarshalInputnetwork_interface_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx context.Context, v interface{}) ([]NetworkInterfaceBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]NetworkInterfaceBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx context.Context, v interface{}) (*NetworkInterfaceBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOnetwork_interface_bool_exp2bandicootpkggqlNetworkInterfaceBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx context.Context, v interface{}) (NetworkInterfaceVlanBoolExp, error) {
	return ec.unmarshalInputnetwork_interface_vlan_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx context.Context, v interface{}) ([]NetworkInterfaceVlanBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]NetworkInterfaceVlanBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx context.Context, v interface{}) (*NetworkInterfaceVlanBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOnetwork_interface_vlan_bool_exp2bandicootpkggqlNetworkInterfaceVlanBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx context.Context, v interface{}) (OperatingSystemBoolExp, error) {
	return ec.unmarshalInputoperating_system_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx context.Context, v interface{}) ([]OperatingSystemBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]OperatingSystemBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx context.Context, v interface{}) (*OperatingSystemBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOoperating_system_bool_exp2bandicootpkggqlOperatingSystemBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOpreventionSettingsAggregate2bandicootpkggqlPreventionSettingsAggregate(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettingsAggregate2bandicootpkggqlPreventionSettingsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx context.Context, v interface{}) ([]PreventionSettingsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]PreventionSettingsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []PreventionSettingsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNpreventionSettings_aggregate_columns2bandicootpkggqlPreventionSettingsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOsensorUpdateSettingsAggregate2bandicootpkggqlSensorUpdateSettingsAggregate(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettingsAggregate2bandicootpkggqlSensorUpdateSettingsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx context.Context, v interface{}) ([]SensorUpdateSettingsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]SensorUpdateSettingsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []SensorUpdateSettingsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNsensorUpdateSettings_aggregate_columns2bandicootpkggqlSensorUpdateSettingsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx context.Context, v interface{}) (TagBoolExp, error) {
	return ec.unmarshalInputtag_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx context.Context, v interface{}) ([]TagBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx context.Context, v interface{}) (*TagBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOtag_bool_exp2bandicootpkggqlTagBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOtagsAggregate2bandicootpkggqlTagsAggregate(ctx context.Context, sel ast.SelectionSet, v []TagsAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtagsAggregate2bandicootpkggqlTagsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx context.Context, v interface{}) ([]TagsAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TagsAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []TagsAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNtags_aggregate_columns2bandicootpkggqlTagsAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx context.Context, v interface{}) (UserBoolExp, error) {
	return ec.unmarshalInputuser_bool_exp(ctx, v)
}

func (ec *executionContext) unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx context.Context, v interface{}) ([]UserBoolExp, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UserBoolExp, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx context.Context, v interface{}) (*UserBoolExp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOuser_bool_exp2bandicootpkggqlUserBoolExp(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOuser_order_by2bandicootpkggqlUserOrderBy(ctx context.Context, v interface{}) ([]UserOrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UserOrderBy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNuser_order_by2bandicootpkggqlUserOrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOuser_order_by2bandicootpkggqlUserOrderBy(ctx context.Context, sel ast.SelectionSet, v []UserOrderBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNuser_order_by2bandicootpkggqlUserOrderBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOusersAggregate2bandicootpkggqlUsersAggregate(ctx context.Context, sel ast.SelectionSet, v []UsersAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusersAggregate2bandicootpkggqlUsersAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx context.Context, v interface{}) ([]UsersAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]UsersAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []UsersAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNusers_aggregate_columns2bandicootpkggqlUsersAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOvlansAggregate2bandicootpkggqlVlansAggregate(ctx context.Context, sel ast.SelectionSet, v []VlansAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNvlansAggregate2bandicootpkggqlVlansAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOvlans_aggregate_columns2bandicootpkggqlVlansAggregateColumns(ctx context.Context, v interface{}) ([]VlansAggregateColumns, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]VlansAggregateColumns, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNvlans_aggregate_columns2bandicootpkggqlVlansAggregateColumns(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOvlans_aggregate_columns2bandicootpkggqlVlansAggregateColumns(ctx context.Context, sel ast.SelectionSet, v []VlansAggregateColumns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNvlans_aggregate_columns2bandicootpkggqlVlansAggregateColumns(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

// endregion ***************************** type.gotpl *****************************
